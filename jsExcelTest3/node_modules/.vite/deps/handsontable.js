import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/core-js/internals/global.js
var require_global = __commonJS({
  "node_modules/core-js/internals/global.js"(exports, module2) {
    "use strict";
    var check = function(it) {
      return it && it.Math === Math && it;
    };
    module2.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js/internals/fails.js"(exports, module2) {
    "use strict";
    module2.exports = function(exec2) {
      try {
        return !!exec2();
      } catch (error2) {
        return true;
      }
    };
  }
});

// node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/internals/descriptors.js"(exports, module2) {
    "use strict";
    var fails3 = require_fails();
    module2.exports = !fails3(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js/internals/function-bind-native.js"(exports, module2) {
    "use strict";
    var fails3 = require_fails();
    module2.exports = !fails3(function() {
      var test = (function() {
      }).bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js/internals/function-call.js"(exports, module2) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call2 = Function.prototype.call;
    module2.exports = NATIVE_BIND ? call2.bind(call2) : function() {
      return call2.apply(call2, arguments);
    };
  }
});

// node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor2(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js/internals/create-property-descriptor.js"(exports, module2) {
    "use strict";
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this.js"(exports, module2) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call2 = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call2, call2);
    module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call2.apply(fn, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js/internals/classof-raw.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var toString2 = uncurryThis2({}.toString);
    var stringSlice = uncurryThis2("".slice);
    module2.exports = function(it) {
      return stringSlice(toString2(it), 8, -1);
    };
  }
});

// node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js/internals/indexed-object.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var fails3 = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis2("".split);
    module2.exports = fails3(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) === "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js/internals/is-null-or-undefined.js"(exports, module2) {
    "use strict";
    module2.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js/internals/require-object-coercible.js"(exports, module2) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module2.exports = function(it) {
      if (isNullOrUndefined(it))
        throw new $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js/internals/to-indexed-object.js"(exports, module2) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module2.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// node_modules/core-js/internals/document-all.js
var require_document_all = __commonJS({
  "node_modules/core-js/internals/document-all.js"(exports, module2) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
    module2.exports = {
      all: documentAll,
      IS_HTMLDDA
    };
  }
});

// node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js/internals/is-callable.js"(exports, module2) {
    "use strict";
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module2.exports = $documentAll.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/internals/is-object.js"(exports, module2) {
    "use strict";
    var isCallable2 = require_is_callable();
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module2.exports = $documentAll.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable2(it) || it === documentAll;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable2(it);
    };
  }
});

// node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js/internals/get-built-in.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var isCallable2 = require_is_callable();
    var aFunction = function(argument) {
      return isCallable2(argument) ? argument : void 0;
    };
    module2.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(global3[namespace]) : global3[namespace] && global3[namespace][method];
    };
  }
});

// node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    module2.exports = uncurryThis2({}.isPrototypeOf);
  }
});

// node_modules/core-js/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
  "node_modules/core-js/internals/engine-user-agent.js"(exports, module2) {
    "use strict";
    module2.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
  }
});

// node_modules/core-js/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
  "node_modules/core-js/internals/engine-v8-version.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var userAgent = require_engine_user_agent();
    var process2 = global3.process;
    var Deno = global3.Deno;
    var versions = process2 && process2.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match)
          version = +match[1];
      }
    }
    module2.exports = version;
  }
});

// node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module2) {
    "use strict";
    var V8_VERSION = require_engine_v8_version();
    var fails3 = require_fails();
    var global3 = require_global();
    var $String2 = global3.String;
    module2.exports = !!Object.getOwnPropertySymbols && !fails3(function() {
      var symbol = Symbol("symbol detection");
      return !$String2(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module2) {
    "use strict";
    var NATIVE_SYMBOL2 = require_symbol_constructor_detection();
    module2.exports = NATIVE_SYMBOL2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js/internals/is-symbol.js"(exports, module2) {
    "use strict";
    var getBuiltIn2 = require_get_built_in();
    var isCallable2 = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module2.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn2("Symbol");
      return isCallable2($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js/internals/try-to-string.js"(exports, module2) {
    "use strict";
    var $String2 = String;
    module2.exports = function(argument) {
      try {
        return $String2(argument);
      } catch (error2) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js/internals/a-callable.js"(exports, module2) {
    "use strict";
    var isCallable2 = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isCallable2(argument))
        return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js/internals/get-method.js"(exports, module2) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module2.exports = function(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module2) {
    "use strict";
    var call2 = require_function_call();
    var isCallable2 = require_is_callable();
    var isObject3 = require_is_object();
    var $TypeError = TypeError;
    module2.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable2(fn = input.toString) && !isObject3(val = call2(fn, input)))
        return val;
      if (isCallable2(fn = input.valueOf) && !isObject3(val = call2(fn, input)))
        return val;
      if (pref !== "string" && isCallable2(fn = input.toString) && !isObject3(val = call2(fn, input)))
        return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js/internals/is-pure.js"(exports, module2) {
    "use strict";
    module2.exports = false;
  }
});

// node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js/internals/define-global-property.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var defineProperty = Object.defineProperty;
    module2.exports = function(key, value) {
      try {
        defineProperty(global3, key, { value, configurable: true, writable: true });
      } catch (error2) {
        global3[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js/internals/shared-store.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = global3[SHARED] || defineGlobalProperty(SHARED, {});
    module2.exports = store;
  }
});

// node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js/internals/shared.js"(exports, module2) {
    "use strict";
    var IS_PURE = require_is_pure();
    var store = require_shared_store();
    (module2.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.33.3",
      mode: IS_PURE ? "pure" : "global",
      copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.33.3/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/internals/to-object.js"(exports, module2) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module2.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js/internals/has-own-property.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var toObject5 = require_to_object();
    var hasOwnProperty3 = uncurryThis2({}.hasOwnProperty);
    module2.exports = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty3(toObject5(it), key);
    };
  }
});

// node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js/internals/uid.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString2 = uncurryThis2(1 .toString);
    module2.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
    };
  }
});

// node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js/internals/well-known-symbol.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL2 = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = global3.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module2.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL2 && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/internals/to-primitive.js"(exports, module2) {
    "use strict";
    var call2 = require_function_call();
    var isObject3 = require_is_object();
    var isSymbol2 = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module2.exports = function(input, pref) {
      if (!isObject3(input) || isSymbol2(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call2(exoticToPrim, input, pref);
        if (!isObject3(result) || isSymbol2(result))
          return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js/internals/to-property-key.js"(exports, module2) {
    "use strict";
    var toPrimitive = require_to_primitive();
    var isSymbol2 = require_is_symbol();
    module2.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol2(key) ? key : key + "";
    };
  }
});

// node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js/internals/document-create-element.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var isObject3 = require_is_object();
    var document2 = global3.document;
    var EXISTS = isObject3(document2) && isObject3(document2.createElement);
    module2.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/internals/ie8-dom-define.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails3 = require_fails();
    var createElement2 = require_document_create_element();
    module2.exports = !DESCRIPTORS && !fails3(function() {
      return Object.defineProperty(createElement2("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call2 = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error2) {
        }
      if (hasOwn(O, P))
        return createPropertyDescriptor(!call2(propertyIsEnumerableModule.f, O, P), O[P]);
    };
  }
});

// node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails3 = require_fails();
    module2.exports = DESCRIPTORS && fails3(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/internals/an-object.js"(exports, module2) {
    "use strict";
    var isObject3 = require_is_object();
    var $String2 = String;
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isObject3(argument))
        return argument;
      throw new $TypeError($String2(argument) + " is not an object");
    };
  }
});

// node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js/internals/object-define-property.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error2) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw new $TypeError("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
  }
});

// node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js/internals/function-name.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && (function something() {
    }).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module2.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js/internals/inspect-source.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var isCallable2 = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis2(Function.toString);
    if (!isCallable2(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module2.exports = store.inspectSource;
  }
});

// node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var isCallable2 = require_is_callable();
    var WeakMap2 = global3.WeakMap;
    module2.exports = isCallable2(WeakMap2) && /native code/.test(String(WeakMap2));
  }
});

// node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/internals/shared-key.js"(exports, module2) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys2 = shared("keys");
    module2.exports = function(key) {
      return keys2[key] || (keys2[key] = uid(key));
    };
  }
});

// node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js/internals/hidden-keys.js"(exports, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js/internals/internal-state.js"(exports, module2) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var global3 = require_global();
    var isObject3 = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = global3.TypeError;
    var WeakMap2 = global3.WeakMap;
    var set2;
    var get2;
    var has;
    var enforce = function(it) {
      return has(it) ? get2(it) : set2(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject3(it) || (state = get2(it)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set2 = function(it, metadata) {
        if (store.has(it))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get2 = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set2 = function(it, metadata) {
        if (hasOwn(it, STATE))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get2 = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn(it, STATE);
      };
    }
    var store;
    var STATE;
    module2.exports = {
      set: set2,
      get: get2,
      has,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "node_modules/core-js/internals/make-built-in.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var fails3 = require_fails();
    var isCallable2 = require_is_callable();
    var hasOwn = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String2 = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis2("".slice);
    var replace2 = uncurryThis2("".replace);
    var join = uncurryThis2([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails3(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module2.exports = function(value, name, options) {
      if (stringSlice($String2(name), 0, 7) === "Symbol(") {
        name = "[" + replace2($String2(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
      }
      if (options && options.getter)
        name = "get " + name;
      if (options && options.setter)
        name = "set " + name;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS)
          defineProperty(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
          if (DESCRIPTORS)
            defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error2) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(function toString2() {
      return isCallable2(this) && getInternalState(this).source || inspectSource(this);
    }, "toString");
  }
});

// node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "node_modules/core-js/internals/define-built-in.js"(exports, module2) {
    "use strict";
    var isCallable2 = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module2.exports = function(O, key, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable2(value))
        makeBuiltIn(value, name, options);
      if (options.global) {
        if (simple)
          O[key] = value;
        else
          defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe)
            delete O[key];
          else if (O[key])
            simple = true;
        } catch (error2) {
        }
        if (simple)
          O[key] = value;
        else
          definePropertyModule.f(O, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O;
    };
  }
});

// node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "node_modules/core-js/internals/math-trunc.js"(exports, module2) {
    "use strict";
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = Math.trunc || function trunc(x) {
      var n = +x;
      return (n > 0 ? floor : ceil)(n);
    };
  }
});

// node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module2) {
    "use strict";
    var trunc = require_math_trunc();
    module2.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/internals/to-absolute-index.js"(exports, module2) {
    "use strict";
    var toIntegerOrInfinity2 = require_to_integer_or_infinity();
    var max2 = Math.max;
    var min2 = Math.min;
    module2.exports = function(index2, length) {
      var integer = toIntegerOrInfinity2(index2);
      return integer < 0 ? max2(integer + length, 0) : min2(integer, length);
    };
  }
});

// node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/internals/to-length.js"(exports, module2) {
    "use strict";
    var toIntegerOrInfinity2 = require_to_integer_or_infinity();
    var min2 = Math.min;
    module2.exports = function(argument) {
      return argument > 0 ? min2(toIntegerOrInfinity2(argument), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js/internals/length-of-array-like.js"(exports, module2) {
    "use strict";
    var toLength = require_to_length();
    module2.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/internals/array-includes.js"(exports, module2) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike4 = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike4(O);
        var index2 = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el !== el)
          while (length > index2) {
            value = O[index2++];
            if (value !== value)
              return true;
          }
        else
          for (; length > index2; index2++) {
            if ((IS_INCLUDES || index2 in O) && O[index2] === el)
              return IS_INCLUDES || index2 || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    module2.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/internals/object-keys-internal.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf2 = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push2 = uncurryThis2([].push);
    module2.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push2(result, key);
      while (names.length > i)
        if (hasOwn(O, key = names[i++])) {
          ~indexOf2(result, key) || push2(result, key);
        }
      return result;
    };
  }
});

// node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/internals/enum-bug-keys.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js/internals/own-keys.js"(exports, module2) {
    "use strict";
    var getBuiltIn2 = require_get_built_in();
    var uncurryThis2 = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis2([].concat);
    module2.exports = getBuiltIn2("Reflect", "ownKeys") || function ownKeys(it) {
      var keys2 = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
    };
  }
});

// node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module2) {
    "use strict";
    var hasOwn = require_has_own_property();
    var ownKeys = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module2.exports = function(target, source, exceptions) {
      var keys2 = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor2(source, key));
        }
      }
    };
  }
});

// node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js/internals/is-forced.js"(exports, module2) {
    "use strict";
    var fails3 = require_fails();
    var isCallable2 = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable2(detection) ? fails3(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module2.exports = isForced;
  }
});

// node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js/internals/export.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var getOwnPropertyDescriptor2 = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module2.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED4, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global3;
      } else if (STATIC) {
        target = global3[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = (global3[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor2(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED4 = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED4 && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key, sourceProperty, options);
        }
    };
  }
});

// node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/internals/is-array.js"(exports, module2) {
    "use strict";
    var classof = require_classof_raw();
    module2.exports = Array.isArray || function isArray2(argument) {
      return classof(argument) === "Array";
    };
  }
});

// node_modules/core-js/internals/array-set-length.js
var require_array_set_length = __commonJS({
  "node_modules/core-js/internals/array-set-length.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var isArray2 = require_is_array();
    var $TypeError = TypeError;
    var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
    var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {
      if (this !== void 0)
        return true;
      try {
        Object.defineProperty([], "length", { writable: false }).length = 1;
      } catch (error2) {
        return error2 instanceof TypeError;
      }
    }();
    module2.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
      if (isArray2(O) && !getOwnPropertyDescriptor2(O, "length").writable) {
        throw new $TypeError("Cannot set read only .length");
      }
      return O.length = length;
    } : function(O, length) {
      return O.length = length;
    };
  }
});

// node_modules/core-js/internals/does-not-exceed-safe-integer.js
var require_does_not_exceed_safe_integer = __commonJS({
  "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports, module2) {
    "use strict";
    var $TypeError = TypeError;
    var MAX_SAFE_INTEGER = 9007199254740991;
    module2.exports = function(it) {
      if (it > MAX_SAFE_INTEGER)
        throw $TypeError("Maximum allowed index exceeded");
      return it;
    };
  }
});

// node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js/internals/function-apply.js"(exports, module2) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply4 = FunctionPrototype.apply;
    var call2 = FunctionPrototype.call;
    module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call2.bind(apply4) : function() {
      return call2.apply(apply4, arguments);
    });
  }
});

// node_modules/core-js/internals/function-uncurry-this-accessor.js
var require_function_uncurry_this_accessor = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var aCallable = require_a_callable();
    module2.exports = function(object, key, method) {
      try {
        return uncurryThis2(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error2) {
      }
    };
  }
});

// node_modules/core-js/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js/internals/a-possible-prototype.js"(exports, module2) {
    "use strict";
    var isCallable2 = require_is_callable();
    var $String2 = String;
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (typeof argument == "object" || isCallable2(argument))
        return argument;
      throw new $TypeError("Can't set " + $String2(argument) + " as a prototype");
    };
  }
});

// node_modules/core-js/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module2) {
    "use strict";
    var uncurryThisAccessor = require_function_uncurry_this_accessor();
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error2) {
      }
      return function setPrototypeOf2(O, proto2) {
        anObject(O);
        aPossiblePrototype(proto2);
        if (CORRECT_SETTER)
          setter(O, proto2);
        else
          O.__proto__ = proto2;
        return O;
      };
    }() : void 0);
  }
});

// node_modules/core-js/internals/proxy-accessor.js
var require_proxy_accessor = __commonJS({
  "node_modules/core-js/internals/proxy-accessor.js"(exports, module2) {
    "use strict";
    var defineProperty = require_object_define_property().f;
    module2.exports = function(Target, Source, key) {
      key in Target || defineProperty(Target, key, {
        configurable: true,
        get: function() {
          return Source[key];
        },
        set: function(it) {
          Source[key] = it;
        }
      });
    };
  }
});

// node_modules/core-js/internals/inherit-if-required.js
var require_inherit_if_required = __commonJS({
  "node_modules/core-js/internals/inherit-if-required.js"(exports, module2) {
    "use strict";
    var isCallable2 = require_is_callable();
    var isObject3 = require_is_object();
    var setPrototypeOf2 = require_object_set_prototype_of();
    module2.exports = function($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (
        // it can work only with native `setPrototypeOf`
        setPrototypeOf2 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        isCallable2(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject3(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
      )
        setPrototypeOf2($this, NewTargetPrototype);
      return $this;
    };
  }
});

// node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js/internals/to-string-tag-support.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module2.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js/internals/classof.js"(exports, module2) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable2 = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error2) {
      }
    };
    module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable2(O.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js/internals/to-string.js"(exports, module2) {
    "use strict";
    var classof = require_classof();
    var $String2 = String;
    module2.exports = function(argument) {
      if (classof(argument) === "Symbol")
        throw new TypeError("Cannot convert a Symbol value to a string");
      return $String2(argument);
    };
  }
});

// node_modules/core-js/internals/normalize-string-argument.js
var require_normalize_string_argument = __commonJS({
  "node_modules/core-js/internals/normalize-string-argument.js"(exports, module2) {
    "use strict";
    var toString2 = require_to_string();
    module2.exports = function(argument, $default) {
      return argument === void 0 ? arguments.length < 2 ? "" : $default : toString2(argument);
    };
  }
});

// node_modules/core-js/internals/install-error-cause.js
var require_install_error_cause = __commonJS({
  "node_modules/core-js/internals/install-error-cause.js"(exports, module2) {
    "use strict";
    var isObject3 = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    module2.exports = function(O, options) {
      if (isObject3(options) && "cause" in options) {
        createNonEnumerableProperty(O, "cause", options.cause);
      }
    };
  }
});

// node_modules/core-js/internals/error-stack-clear.js
var require_error_stack_clear = __commonJS({
  "node_modules/core-js/internals/error-stack-clear.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var $Error = Error;
    var replace2 = uncurryThis2("".replace);
    var TEST = function(arg) {
      return String(new $Error(arg).stack);
    }("zxcasd");
    var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
    var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
    module2.exports = function(stack, dropEntries) {
      if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
        while (dropEntries--)
          stack = replace2(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
      }
      return stack;
    };
  }
});

// node_modules/core-js/internals/error-stack-installable.js
var require_error_stack_installable = __commonJS({
  "node_modules/core-js/internals/error-stack-installable.js"(exports, module2) {
    "use strict";
    var fails3 = require_fails();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = !fails3(function() {
      var error2 = new Error("a");
      if (!("stack" in error2))
        return true;
      Object.defineProperty(error2, "stack", createPropertyDescriptor(1, 7));
      return error2.stack !== 7;
    });
  }
});

// node_modules/core-js/internals/error-stack-install.js
var require_error_stack_install = __commonJS({
  "node_modules/core-js/internals/error-stack-install.js"(exports, module2) {
    "use strict";
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var clearErrorStack = require_error_stack_clear();
    var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
    var captureStackTrace = Error.captureStackTrace;
    module2.exports = function(error2, C, stack, dropEntries) {
      if (ERROR_STACK_INSTALLABLE) {
        if (captureStackTrace)
          captureStackTrace(error2, C);
        else
          createNonEnumerableProperty(error2, "stack", clearErrorStack(stack, dropEntries));
      }
    };
  }
});

// node_modules/core-js/internals/wrap-error-constructor-with-cause.js
var require_wrap_error_constructor_with_cause = __commonJS({
  "node_modules/core-js/internals/wrap-error-constructor-with-cause.js"(exports, module2) {
    "use strict";
    var getBuiltIn2 = require_get_built_in();
    var hasOwn = require_has_own_property();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var setPrototypeOf2 = require_object_set_prototype_of();
    var copyConstructorProperties = require_copy_constructor_properties();
    var proxyAccessor = require_proxy_accessor();
    var inheritIfRequired = require_inherit_if_required();
    var normalizeStringArgument = require_normalize_string_argument();
    var installErrorCause = require_install_error_cause();
    var installErrorStack = require_error_stack_install();
    var DESCRIPTORS = require_descriptors();
    var IS_PURE = require_is_pure();
    module2.exports = function(FULL_NAME, wrapper, FORCED4, IS_AGGREGATE_ERROR) {
      var STACK_TRACE_LIMIT = "stackTraceLimit";
      var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
      var path = FULL_NAME.split(".");
      var ERROR_NAME = path[path.length - 1];
      var OriginalError = getBuiltIn2.apply(null, path);
      if (!OriginalError)
        return;
      var OriginalErrorPrototype = OriginalError.prototype;
      if (!IS_PURE && hasOwn(OriginalErrorPrototype, "cause"))
        delete OriginalErrorPrototype.cause;
      if (!FORCED4)
        return OriginalError;
      var BaseError = getBuiltIn2("Error");
      var WrappedError = wrapper(function(a, b) {
        var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, void 0);
        var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
        if (message !== void 0)
          createNonEnumerableProperty(result, "message", message);
        installErrorStack(result, WrappedError, result.stack, 2);
        if (this && isPrototypeOf(OriginalErrorPrototype, this))
          inheritIfRequired(result, this, WrappedError);
        if (arguments.length > OPTIONS_POSITION)
          installErrorCause(result, arguments[OPTIONS_POSITION]);
        return result;
      });
      WrappedError.prototype = OriginalErrorPrototype;
      if (ERROR_NAME !== "Error") {
        if (setPrototypeOf2)
          setPrototypeOf2(WrappedError, BaseError);
        else
          copyConstructorProperties(WrappedError, BaseError, { name: true });
      } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
        proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
        proxyAccessor(WrappedError, OriginalError, "prepareStackTrace");
      }
      copyConstructorProperties(WrappedError, OriginalError);
      if (!IS_PURE)
        try {
          if (OriginalErrorPrototype.name !== ERROR_NAME) {
            createNonEnumerableProperty(OriginalErrorPrototype, "name", ERROR_NAME);
          }
          OriginalErrorPrototype.constructor = WrappedError;
        } catch (error2) {
        }
      return WrappedError;
    };
  }
});

// node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module2) {
    "use strict";
    var classofRaw = require_classof_raw();
    var uncurryThis2 = require_function_uncurry_this();
    module2.exports = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis2(fn);
    };
  }
});

// node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js/internals/function-bind-context.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis2(uncurryThis2.bind);
    module2.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js/internals/html.js"(exports, module2) {
    "use strict";
    var getBuiltIn2 = require_get_built_in();
    module2.exports = getBuiltIn2("document", "documentElement");
  }
});

// node_modules/core-js/internals/array-slice.js
var require_array_slice = __commonJS({
  "node_modules/core-js/internals/array-slice.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    module2.exports = uncurryThis2([].slice);
  }
});

// node_modules/core-js/internals/validate-arguments-length.js
var require_validate_arguments_length = __commonJS({
  "node_modules/core-js/internals/validate-arguments-length.js"(exports, module2) {
    "use strict";
    var $TypeError = TypeError;
    module2.exports = function(passed, required) {
      if (passed < required)
        throw new $TypeError("Not enough arguments");
      return passed;
    };
  }
});

// node_modules/core-js/internals/engine-is-ios.js
var require_engine_is_ios = __commonJS({
  "node_modules/core-js/internals/engine-is-ios.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});

// node_modules/core-js/internals/engine-is-node.js
var require_engine_is_node = __commonJS({
  "node_modules/core-js/internals/engine-is-node.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var classof = require_classof_raw();
    module2.exports = classof(global3.process) === "process";
  }
});

// node_modules/core-js/internals/task.js
var require_task = __commonJS({
  "node_modules/core-js/internals/task.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var apply4 = require_function_apply();
    var bind = require_function_bind_context();
    var isCallable2 = require_is_callable();
    var hasOwn = require_has_own_property();
    var fails3 = require_fails();
    var html2 = require_html();
    var arraySlice2 = require_array_slice();
    var createElement2 = require_document_create_element();
    var validateArgumentsLength = require_validate_arguments_length();
    var IS_IOS = require_engine_is_ios();
    var IS_NODE = require_engine_is_node();
    var set2 = global3.setImmediate;
    var clear = global3.clearImmediate;
    var process2 = global3.process;
    var Dispatch = global3.Dispatch;
    var Function2 = global3.Function;
    var MessageChannel = global3.MessageChannel;
    var String2 = global3.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location;
    var defer;
    var channel;
    var port;
    fails3(function() {
      $location = global3.location;
    });
    var run = function(id) {
      if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run(id);
      };
    };
    var eventListener = function(event2) {
      run(event2.data);
    };
    var globalPostMessageDefer = function(id) {
      global3.postMessage(String2(id), $location.protocol + "//" + $location.host);
    };
    if (!set2 || !clear) {
      set2 = function setImmediate2(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable2(handler) ? handler : Function2(handler);
        var args = arraySlice2(arguments, 1);
        queue[++counter] = function() {
          apply4(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate2(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process2.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
      } else if (global3.addEventListener && isCallable2(global3.postMessage) && !global3.importScripts && $location && $location.protocol !== "file:" && !fails3(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        global3.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement2("script")) {
        defer = function(id) {
          html2.appendChild(createElement2("script"))[ONREADYSTATECHANGE] = function() {
            html2.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    module2.exports = {
      set: set2,
      clear
    };
  }
});

// node_modules/core-js/modules/web.clear-immediate.js
var require_web_clear_immediate = __commonJS({
  "node_modules/core-js/modules/web.clear-immediate.js"() {
    "use strict";
    var $6 = require_export();
    var global3 = require_global();
    var clearImmediate2 = require_task().clear;
    $6({ global: true, bind: true, enumerable: true, forced: global3.clearImmediate !== clearImmediate2 }, {
      clearImmediate: clearImmediate2
    });
  }
});

// node_modules/core-js/internals/engine-is-bun.js
var require_engine_is_bun = __commonJS({
  "node_modules/core-js/internals/engine-is-bun.js"(exports, module2) {
    "use strict";
    module2.exports = typeof Bun == "function" && Bun && typeof Bun.version == "string";
  }
});

// node_modules/core-js/internals/schedulers-fix.js
var require_schedulers_fix = __commonJS({
  "node_modules/core-js/internals/schedulers-fix.js"(exports, module2) {
    "use strict";
    var global3 = require_global();
    var apply4 = require_function_apply();
    var isCallable2 = require_is_callable();
    var ENGINE_IS_BUN = require_engine_is_bun();
    var USER_AGENT = require_engine_user_agent();
    var arraySlice2 = require_array_slice();
    var validateArgumentsLength = require_validate_arguments_length();
    var Function2 = global3.Function;
    var WRAP = /MSIE .\./.test(USER_AGENT) || ENGINE_IS_BUN && function() {
      var version = global3.Bun.version.split(".");
      return version.length < 3 || version[0] === "0" && (version[1] < 3 || version[1] === "3" && version[2] === "0");
    }();
    module2.exports = function(scheduler, hasTimeArg) {
      var firstParamIndex = hasTimeArg ? 2 : 1;
      return WRAP ? function(handler, timeout) {
        var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
        var fn = isCallable2(handler) ? handler : Function2(handler);
        var params = boundArgs ? arraySlice2(arguments, firstParamIndex) : [];
        var callback = boundArgs ? function() {
          apply4(fn, this, params);
        } : fn;
        return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
      } : scheduler;
    };
  }
});

// node_modules/core-js/modules/web.set-immediate.js
var require_web_set_immediate = __commonJS({
  "node_modules/core-js/modules/web.set-immediate.js"() {
    "use strict";
    var $6 = require_export();
    var global3 = require_global();
    var setTask = require_task().set;
    var schedulersFix = require_schedulers_fix();
    var setImmediate2 = global3.setImmediate ? schedulersFix(setTask, false) : setTask;
    $6({ global: true, bind: true, enumerable: true, forced: global3.setImmediate !== setImmediate2 }, {
      setImmediate: setImmediate2
    });
  }
});

// node_modules/moment/dist/moment.js
var moment_exports = {};
__export(moment_exports, {
  default: () => moment_default
});
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0; i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}
function isValid(m) {
  if (m._isValid == null) {
    var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m)) {
      m._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m._isValid;
}
function createInvalid(flags) {
  var m = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}
function copyConfig(to2, from2) {
  var i, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0; i < momentPropertiesLen; i++) {
      prop = momentProperties[i];
      val = from2[prop];
      if (!isUndefined(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0; i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config) {
  var prop, i;
  for (i in config) {
    if (hasOwnProp(config, i)) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i, length;
  for (i = 0, length = array.length; i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
    }
    return output;
  };
}
function formatMoment(m, format2) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m);
}
function expandFormat(format2, locale2) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format2;
}
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
function invalidDate() {
  return this._invalidDate;
}
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
}
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
        value,
        mom.month(),
        daysInMonth(value, mom.month())
      );
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0; i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s) {
  return regexEscape(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function addParseToken(token2, callback) {
  var i, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i = 0; i < tokenLen; i++) {
    tokens[token2[i]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array, config, token3) {
    config._w = config._w || {};
    callback(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
function mod(n, x) {
  return (n % x + x) % x;
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
function localeMonths(m, format2) {
  if (!m) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort(m, format2) {
  if (!m) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i = 0; i < 12; i++) {
    shortPieces[i] = regexEscape(shortPieces[i]);
    longPieces[i] = regexEscape(longPieces[i]);
  }
  for (i = 0; i < 24; i++) {
    mixedPieces[i] = regexEscape(mixedPieces[i]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y, m, d, h, M, s, ms) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m, d, h, M, s, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m, d, h, M, s, ms);
  }
  return date;
}
function createUTCDate(y) {
  var date, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n) {
  return ws.slice(n, 7).concat(ws.slice(0, n));
}
function localeWeekdays(m, format2) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j, next, locale2, split;
  while (i < names.length) {
    split = normalizeLocale(names[i]).split("-");
    j = split.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return name.match("^[^/\\\\]*$") != null;
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m) {
  var overflow, a = m._a;
  if (a && getParsingFlags(m).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}
function configFromISO(config) {
  var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config).iso = true;
    for (i = 0, l = isoDatesLen; i < l; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l = isoTimesLen; i < l; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
    return h * 60 + m;
  }
}
function configFromRFC2822(config) {
  var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
function defaults(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i = 0; i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(
      w.GG,
      config._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults(w.W, 1);
    weekday = defaults(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
    week = defaults(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0; i < tokenLen; i++) {
    token2 = tokens2[i];
    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(
    config._locale,
    config._a[HOUR],
    config._meridiem
  );
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i = 0; i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config._a = map(
    [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format2 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config._d = input;
  } else if (isArray(format2)) {
    configFromStringAndArray(config);
  } else if (format2) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray(input)) {
    config._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale2;
  c._i = input;
  c._f = format2;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
function isDurationValid(m) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m) {
    if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i = 0; i < orderLen; ++i) {
    if (m[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset3 = this.utcOffset(), sign2 = "+";
    if (offset3 < 0) {
      offset3 = -offset3;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset3 / 60), 2) + separator + zeroFill(~~offset3 % 60, 2);
  });
}
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset3 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset3 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset3, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset3 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
function createDuration(input, key) {
  var duration = input, match = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign2,
      h: toInt(match[HOUR]) * sign2,
      m: toInt(match[MINUTE]) * sign2,
      s: toInt(match[SECOND]) * sign2,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match[2], sign2),
      M: parseIso(match[3], sign2),
      w: parseIso(match[4], sign2),
      d: parseIso(match[5], sign2),
      h: parseIso(match[6], sign2),
      m: parseIso(match[7], sign2),
      s: parseIso(match[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property, propertyLen = properties.length;
  for (i = 0; i < propertyLen; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property;
  for (i = 0; i < properties.length; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone2() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
function toString() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(
      m,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(
    m,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
function localeData() {
  return this._locale;
}
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject2() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
function localeEras(m, format2) {
  var i, l, date, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l = eras.length; i < l; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date = hooks(eras[i].since).startOf("day");
        eras[i].since = date.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l = eras.length; i < l; ++i) {
    name = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l, dir, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    namePieces.push(regexEscape(eras[i].name));
    abbrPieces.push(regexEscape(eras[i].abbr));
    narrowPieces.push(regexEscape(eras[i].narrow));
    mixedPieces.push(regexEscape(eras[i].name));
    mixedPieces.push(regexEscape(eras[i].abbr));
    mixedPieces.push(regexEscape(eras[i].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
function get$1(format2, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index2, field) {
  if (isNumber(format2)) {
    index2 = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index2 != null) {
    return get$1(format2, index2, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index2 = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index2 != null) {
    return get$1(format2, (index2 + shift) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1(format2, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index2) {
  return listMonthsImpl(format2, index2, "months");
}
function listMonthsShort(format2, index2) {
  return listMonthsImpl(format2, index2, "monthsShort");
}
function listWeekdays(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
}
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
function weeks() {
  return absFloor(this.days() / 7);
}
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var hookCallback, some, momentProperties, updateInProgress, deprecations, keys, defaultCalendar, formattingTokens, localFormattingTokens, formatFunctions, formatTokenFunctions, defaultLongDateFormat, defaultInvalidDate, defaultOrdinal, defaultDayOfMonthOrdinalParse, defaultRelativeTime, aliases, priorities, match1, match2, match3, match4, match6, match1to2, match3to4, match5to6, match1to3, match1to4, match1to6, matchUnsigned, matchSigned, matchOffset, matchShortOffset, matchTimestamp, matchWord, regexes, tokens, YEAR, MONTH, DATE, HOUR, MINUTE, SECOND, MILLISECOND, WEEK, WEEKDAY, indexOf, defaultLocaleMonths, defaultLocaleMonthsShort, MONTHS_IN_FORMAT, defaultMonthsShortRegex, defaultMonthsRegex, getSetYear, defaultLocaleWeek, defaultLocaleWeekdays, defaultLocaleWeekdaysShort, defaultLocaleWeekdaysMin, defaultWeekdaysRegex, defaultWeekdaysShortRegex, defaultWeekdaysMinRegex, defaultLocaleMeridiemParse, getSetHour, baseConfig, locales, localeFamilies, globalLocale, extendedIsoRegex, basicIsoRegex, tzRegex, isoDates, isoTimes, aspNetJsonRegex, rfc2822, obsOffsets, prototypeMin, prototypeMax, now, ordering, chunkOffset, aspNetRegex, isoRegex, add, subtract, lang, MS_PER_SECOND, MS_PER_MINUTE, MS_PER_HOUR, MS_PER_400_YEARS, getSetDayOfMonth, getSetMinute, getSetSecond, token, getSetMillisecond, proto, proto$1, mathAbs, asMilliseconds, asSeconds, asMinutes, asHours, asDays, asWeeks, asMonths, asQuarters, asYears, milliseconds, seconds, minutes, hours, days, months, years, round, thresholds, abs$1, proto$2, moment_default;
var init_moment = __esm({
  "node_modules/moment/dist/moment.js"() {
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t = Object(this), len = t.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }
        return false;
      };
    }
    momentProperties = hooks.momentProperties = [];
    updateInProgress = false;
    deprecations = {};
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    formatFunctions = {};
    formatTokenFunctions = {};
    defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    defaultInvalidDate = "Invalid date";
    defaultOrdinal = "%d";
    defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    aliases = {};
    priorities = {};
    match1 = /\d/;
    match2 = /\d\d/;
    match3 = /\d{3}/;
    match4 = /\d{4}/;
    match6 = /[+-]?\d{6}/;
    match1to2 = /\d\d?/;
    match3to4 = /\d\d\d\d?/;
    match5to6 = /\d\d\d\d\d\d?/;
    match1to3 = /\d{1,3}/;
    match1to4 = /\d{1,4}/;
    match1to6 = /[+-]?\d{1,6}/;
    matchUnsigned = /\d+/;
    matchSigned = /[+-]?\d+/;
    matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
    matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    regexes = {};
    tokens = {};
    YEAR = 0;
    MONTH = 1;
    DATE = 2;
    HOUR = 3;
    MINUTE = 4;
    SECOND = 5;
    MILLISECOND = 6;
    WEEK = 7;
    WEEKDAY = 8;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    );
    defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
    MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    defaultMonthsShortRegex = matchWord;
    defaultMonthsRegex = matchWord;
    addFormatToken("Y", 0, 0, function() {
      var y = this.year();
      return y <= 9999 ? zeroFill(y, 4) : "+" + y;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    getSetYear = makeGetSet("FullYear", true);
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    defaultWeekdaysRegex = matchWord;
    defaultWeekdaysShortRegex = matchWord;
    defaultWeekdaysMinRegex = matchWord;
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("k", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    getSetHour = makeGetSet("Hours", true);
    baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    locales = {};
    localeFamilies = {};
    extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ];
    isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ];
    aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
    rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
    obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    now = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    chunkOffset = /([\+\-]|\d\d)/gi;
    hooks.updateOffset = function() {
    };
    aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
    isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    add = createAdder(1, "add");
    subtract = createAdder(-1, "subtract");
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    MS_PER_SECOND = 1e3;
    MS_PER_MINUTE = 60 * MS_PER_SECOND;
    MS_PER_HOUR = 60 * MS_PER_MINUTE;
    MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    addFormatToken("D", ["DD", 2], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    addFormatToken("m", ["mm", 2], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone2;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject2;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    mathAbs = Math.abs;
    asMilliseconds = makeAs("ms");
    asSeconds = makeAs("s");
    asMinutes = makeAs("m");
    asHours = makeAs("h");
    asDays = makeAs("d");
    asWeeks = makeAs("w");
    asMonths = makeAs("M");
    asQuarters = makeAs("Q");
    asYears = makeAs("y");
    milliseconds = makeGetter("milliseconds");
    seconds = makeGetter("seconds");
    minutes = makeGetter("minutes");
    hours = makeGetter("hours");
    days = makeGetter("days");
    months = makeGetter("months");
    years = makeGetter("years");
    round = Math.round;
    thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    abs$1 = Math.abs;
    proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    hooks.version = "2.29.4";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    moment_default = hooks;
  }
});

// node_modules/core-js/internals/get-json-replacer-function.js
var require_get_json_replacer_function = __commonJS({
  "node_modules/core-js/internals/get-json-replacer-function.js"(exports, module2) {
    "use strict";
    var uncurryThis2 = require_function_uncurry_this();
    var isArray2 = require_is_array();
    var isCallable2 = require_is_callable();
    var classof = require_classof_raw();
    var toString2 = require_to_string();
    var push2 = uncurryThis2([].push);
    module2.exports = function(replacer) {
      if (isCallable2(replacer))
        return replacer;
      if (!isArray2(replacer))
        return;
      var rawLength = replacer.length;
      var keys2 = [];
      for (var i = 0; i < rawLength; i++) {
        var element = replacer[i];
        if (typeof element == "string")
          push2(keys2, element);
        else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String")
          push2(keys2, toString2(element));
      }
      var keysLength = keys2.length;
      var root = true;
      return function(key, value) {
        if (root) {
          root = false;
          return value;
        }
        if (isArray2(this))
          return value;
        for (var j = 0; j < keysLength; j++)
          if (keys2[j] === key)
            return value;
      };
    };
  }
});

// node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/internals/object-keys.js"(exports, module2) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module2.exports = Object.keys || function keys2(O) {
      return internalObjectKeys(O, enumBugKeys);
    };
  }
});

// node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js/internals/object-define-properties.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var props = toIndexedObject(Properties);
      var keys2 = objectKeys(Properties);
      var length = keys2.length;
      var index2 = 0;
      var key;
      while (length > index2)
        definePropertyModule.f(O, key = keys2[index2++], props[key]);
      return O;
    };
  }
});

// node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/internals/object-create.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html2 = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html2.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error2) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module2.exports = Object.create || function create2(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/internals/add-to-unscopables.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var create2 = require_object_create();
    var defineProperty = require_object_define_property().f;
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === void 0) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create2(null)
      });
    }
    module2.exports = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/pikaday/pikaday.js
var require_pikaday = __commonJS({
  "node_modules/pikaday/pikaday.js"(exports, module2) {
    (function(root, factory) {
      "use strict";
      var moment;
      if (typeof exports === "object") {
        try {
          moment = (init_moment(), __toCommonJS(moment_exports));
        } catch (e) {
        }
        module2.exports = factory(moment);
      } else if (typeof define === "function" && define.amd) {
        define(function(req) {
          var id = "moment";
          try {
            moment = req(id);
          } catch (e) {
          }
          return factory(moment);
        });
      } else {
        root.Pikaday = factory(root.moment);
      }
    })(exports, function(moment) {
      "use strict";
      var hasMoment = typeof moment === "function", hasEventListeners = !!window.addEventListener, document2 = window.document, sto = window.setTimeout, addEvent2 = function(el, e, callback, capture) {
        if (hasEventListeners) {
          el.addEventListener(e, callback, !!capture);
        } else {
          el.attachEvent("on" + e, callback);
        }
      }, removeEvent2 = function(el, e, callback, capture) {
        if (hasEventListeners) {
          el.removeEventListener(e, callback, !!capture);
        } else {
          el.detachEvent("on" + e, callback);
        }
      }, trim = function(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }, hasClass2 = function(el, cn) {
        return (" " + el.className + " ").indexOf(" " + cn + " ") !== -1;
      }, addClass2 = function(el, cn) {
        if (!hasClass2(el, cn)) {
          el.className = el.className === "" ? cn : el.className + " " + cn;
        }
      }, removeClass2 = function(el, cn) {
        el.className = trim((" " + el.className + " ").replace(" " + cn + " ", " "));
      }, isArray2 = function(obj) {
        return /Array/.test(Object.prototype.toString.call(obj));
      }, isDate3 = function(obj) {
        return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
      }, isWeekend = function(date) {
        var day = date.getDay();
        return day === 0 || day === 6;
      }, isLeapYear2 = function(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }, getDaysInMonth2 = function(year, month) {
        return [31, isLeapYear2(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
      }, setToStartOfDay = function(date) {
        if (isDate3(date))
          date.setHours(0, 0, 0, 0);
      }, compareDates = function(a, b) {
        return a.getTime() === b.getTime();
      }, extend3 = function(to2, from2, overwrite) {
        var prop, hasProp;
        for (prop in from2) {
          hasProp = to2[prop] !== void 0;
          if (hasProp && typeof from2[prop] === "object" && from2[prop] !== null && from2[prop].nodeName === void 0) {
            if (isDate3(from2[prop])) {
              if (overwrite) {
                to2[prop] = new Date(from2[prop].getTime());
              }
            } else if (isArray2(from2[prop])) {
              if (overwrite) {
                to2[prop] = from2[prop].slice(0);
              }
            } else {
              to2[prop] = extend3({}, from2[prop], overwrite);
            }
          } else if (overwrite || !hasProp) {
            to2[prop] = from2[prop];
          }
        }
        return to2;
      }, fireEvent = function(el, eventName, data) {
        var ev;
        if (document2.createEvent) {
          ev = document2.createEvent("HTMLEvents");
          ev.initEvent(eventName, true, false);
          ev = extend3(ev, data);
          el.dispatchEvent(ev);
        } else if (document2.createEventObject) {
          ev = document2.createEventObject();
          ev = extend3(ev, data);
          el.fireEvent("on" + eventName, ev);
        }
      }, adjustCalendar = function(calendar2) {
        if (calendar2.month < 0) {
          calendar2.year -= Math.ceil(Math.abs(calendar2.month) / 12);
          calendar2.month += 12;
        }
        if (calendar2.month > 11) {
          calendar2.year += Math.floor(Math.abs(calendar2.month) / 12);
          calendar2.month -= 12;
        }
        return calendar2;
      }, defaults2 = {
        // bind the picker to a form field
        field: null,
        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
        bound: void 0,
        // data-attribute on the input field with an aria assistance text (only applied when `bound` is set)
        ariaLabel: "Use the arrow keys to pick a date",
        // position of the datepicker, relative to the field (default to bottom & left)
        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
        position: "bottom left",
        // automatically fit in the viewport even if it means repositioning from the position option
        reposition: true,
        // the default output format for `.toString()` and `field` value
        format: "YYYY-MM-DD",
        // the toString function which gets passed a current date object and format
        // and returns a string
        toString: null,
        // used to create date object from current input string
        parse: null,
        // the initial date to view when first opened
        defaultDate: null,
        // make the `defaultDate` the initial selected value
        setDefaultDate: false,
        // first day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,
        // minimum number of days in the week that gets week number one
        // default ISO 8601, week 01 is the week with the first Thursday (4)
        firstWeekOfYearMinDays: 4,
        // the default flag for moment's strict date parsing
        formatStrict: false,
        // the minimum/earliest date that can be selected
        minDate: null,
        // the maximum/latest date that can be selected
        maxDate: null,
        // number of years either side, or array of upper/lower range
        yearRange: 10,
        // show week numbers at head of row
        showWeekNumber: false,
        // Week picker mode
        pickWholeWeek: false,
        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: void 0,
        maxMonth: void 0,
        startRange: null,
        endRange: null,
        isRTL: false,
        // Additional text to append to the year in the calendar title
        yearSuffix: "",
        // Render the month after year in the calendar title
        showMonthAfterYear: false,
        // Render days of the calendar grid that fall in the next or previous month
        showDaysInNextAndPreviousMonths: false,
        // Allows user to select days that fall in the next or previous month
        enableSelectionDaysInNextAndPreviousMonths: false,
        // how many months are visible
        numberOfMonths: 1,
        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
        // only used for the first display or when a selected date is not visible
        mainCalendar: "left",
        // Specify a DOM element to render the calendar in
        container: void 0,
        // Blur field when date is selected
        blurFieldOnSelect: true,
        // internationalization
        i18n: {
          previousMonth: "Previous Month",
          nextMonth: "Next Month",
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        },
        // Theme Classname
        theme: null,
        // events array
        events: [],
        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null,
        // Enable keyboard input
        keyboardInput: true
      }, renderDayName = function(opts, day, abbr) {
        day += opts.firstDay;
        while (day >= 7) {
          day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
      }, renderDay = function(opts) {
        var arr = [];
        var ariaSelected = "false";
        if (opts.isEmpty) {
          if (opts.showDaysInNextAndPreviousMonths) {
            arr.push("is-outside-current-month");
            if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
              arr.push("is-selection-disabled");
            }
          } else {
            return '<td class="is-empty"></td>';
          }
        }
        if (opts.isDisabled) {
          arr.push("is-disabled");
        }
        if (opts.isToday) {
          arr.push("is-today");
        }
        if (opts.isSelected) {
          arr.push("is-selected");
          ariaSelected = "true";
        }
        if (opts.hasEvent) {
          arr.push("has-event");
        }
        if (opts.isInRange) {
          arr.push("is-inrange");
        }
        if (opts.isStartRange) {
          arr.push("is-startrange");
        }
        if (opts.isEndRange) {
          arr.push("is-endrange");
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(" ") + '" aria-selected="' + ariaSelected + '"><button class="pika-button pika-day" type="button" data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' + opts.day + "</button></td>";
      }, isoWeek = function(date, firstWeekOfYearMinDays) {
        date.setHours(0, 0, 0, 0);
        var yearDay = date.getDate(), weekDay = date.getDay(), dayInFirstWeek = firstWeekOfYearMinDays, dayShift = dayInFirstWeek - 1, daysPerWeek = 7, prevWeekDay = function(day) {
          return (day + daysPerWeek - 1) % daysPerWeek;
        };
        date.setDate(yearDay + dayShift - prevWeekDay(weekDay));
        var jan4th = new Date(date.getFullYear(), 0, dayInFirstWeek), msPerDay = 24 * 60 * 60 * 1e3, daysBetween = (date.getTime() - jan4th.getTime()) / msPerDay, weekNum = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / daysPerWeek);
        return weekNum;
      }, renderWeek = function(d, m, y, firstWeekOfYearMinDays) {
        var date = new Date(y, m, d), week = hasMoment ? moment(date).isoWeek() : isoWeek(date, firstWeekOfYearMinDays);
        return '<td class="pika-week">' + week + "</td>";
      }, renderRow = function(days2, isRTL, pickWholeWeek, isRowSelected) {
        return '<tr class="pika-row' + (pickWholeWeek ? " pick-whole-week" : "") + (isRowSelected ? " is-selected" : "") + '">' + (isRTL ? days2.reverse() : days2).join("") + "</tr>";
      }, renderBody = function(rows) {
        return "<tbody>" + rows.join("") + "</tbody>";
      }, renderHead = function(opts) {
        var i, arr = [];
        if (opts.showWeekNumber) {
          arr.push("<th></th>");
        }
        for (i = 0; i < 7; i++) {
          arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + "</abbr></th>");
        }
        return "<thead><tr>" + (opts.isRTL ? arr.reverse() : arr).join("") + "</tr></thead>";
      }, renderTitle = function(instance, c, year, month, refYear, randId) {
        var i, j, arr, opts = instance._o, isMinYear = year === opts.minYear, isMaxYear = year === opts.maxYear, html2 = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">', monthHtml, yearHtml, prev = true, next = true;
        for (arr = [], i = 0; i < 12; i++) {
          arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? ' selected="selected"' : "") + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? ' disabled="disabled"' : "") + ">" + opts.i18n.months[i] + "</option>");
        }
        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join("") + "</select></div>";
        if (isArray2(opts.yearRange)) {
          i = opts.yearRange[0];
          j = opts.yearRange[1] + 1;
        } else {
          i = year - opts.yearRange;
          j = 1 + year + opts.yearRange;
        }
        for (arr = []; i < j && i <= opts.maxYear; i++) {
          if (i >= opts.minYear) {
            arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"' : "") + ">" + i + "</option>");
          }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join("") + "</select></div>";
        if (opts.showMonthAfterYear) {
          html2 += yearHtml + monthHtml;
        } else {
          html2 += monthHtml + yearHtml;
        }
        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
          prev = false;
        }
        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
          next = false;
        }
        if (c === 0) {
          html2 += '<button class="pika-prev' + (prev ? "" : " is-disabled") + '" type="button">' + opts.i18n.previousMonth + "</button>";
        }
        if (c === instance._o.numberOfMonths - 1) {
          html2 += '<button class="pika-next' + (next ? "" : " is-disabled") + '" type="button">' + opts.i18n.nextMonth + "</button>";
        }
        return html2 += "</div>";
      }, renderTable = function(opts, data, randId) {
        return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + "</table>";
      }, Pikaday2 = function(options) {
        var self2 = this, opts = self2.config(options);
        self2._onMouseDown = function(e) {
          if (!self2._v) {
            return;
          }
          e = e || window.event;
          var target = e.target || e.srcElement;
          if (!target) {
            return;
          }
          if (!hasClass2(target, "is-disabled")) {
            if (hasClass2(target, "pika-button") && !hasClass2(target, "is-empty") && !hasClass2(target.parentNode, "is-disabled")) {
              self2.setDate(new Date(target.getAttribute("data-pika-year"), target.getAttribute("data-pika-month"), target.getAttribute("data-pika-day")));
              if (opts.bound) {
                sto(function() {
                  self2.hide();
                  if (opts.blurFieldOnSelect && opts.field) {
                    opts.field.blur();
                  }
                }, 100);
              }
            } else if (hasClass2(target, "pika-prev")) {
              self2.prevMonth();
            } else if (hasClass2(target, "pika-next")) {
              self2.nextMonth();
            }
          }
          if (!hasClass2(target, "pika-select")) {
            if (e.preventDefault) {
              e.preventDefault();
            } else {
              e.returnValue = false;
              return false;
            }
          } else {
            self2._c = true;
          }
        };
        self2._onChange = function(e) {
          e = e || window.event;
          var target = e.target || e.srcElement;
          if (!target) {
            return;
          }
          if (hasClass2(target, "pika-select-month")) {
            self2.gotoMonth(target.value);
          } else if (hasClass2(target, "pika-select-year")) {
            self2.gotoYear(target.value);
          }
        };
        self2._onKeyChange = function(e) {
          e = e || window.event;
          if (self2.isVisible()) {
            switch (e.keyCode) {
              case 13:
              case 27:
                if (opts.field) {
                  opts.field.blur();
                }
                break;
              case 37:
                self2.adjustDate("subtract", 1);
                break;
              case 38:
                self2.adjustDate("subtract", 7);
                break;
              case 39:
                self2.adjustDate("add", 1);
                break;
              case 40:
                self2.adjustDate("add", 7);
                break;
              case 8:
              case 46:
                self2.setDate(null);
                break;
            }
          }
        };
        self2._parseFieldValue = function() {
          if (opts.parse) {
            return opts.parse(opts.field.value, opts.format);
          } else if (hasMoment) {
            var date = moment(opts.field.value, opts.format, opts.formatStrict);
            return date && date.isValid() ? date.toDate() : null;
          } else {
            return new Date(Date.parse(opts.field.value));
          }
        };
        self2._onInputChange = function(e) {
          var date;
          if (e.firedBy === self2) {
            return;
          }
          date = self2._parseFieldValue();
          if (isDate3(date)) {
            self2.setDate(date);
          }
          if (!self2._v) {
            self2.show();
          }
        };
        self2._onInputFocus = function() {
          self2.show();
        };
        self2._onInputClick = function() {
          self2.show();
        };
        self2._onInputBlur = function() {
          var pEl = document2.activeElement;
          do {
            if (hasClass2(pEl, "pika-single")) {
              return;
            }
          } while (pEl = pEl.parentNode);
          if (!self2._c) {
            self2._b = sto(function() {
              self2.hide();
            }, 50);
          }
          self2._c = false;
        };
        self2._onClick = function(e) {
          e = e || window.event;
          var target = e.target || e.srcElement, pEl = target;
          if (!target) {
            return;
          }
          if (!hasEventListeners && hasClass2(target, "pika-select")) {
            if (!target.onchange) {
              target.setAttribute("onchange", "return;");
              addEvent2(target, "change", self2._onChange);
            }
          }
          do {
            if (hasClass2(pEl, "pika-single") || pEl === opts.trigger) {
              return;
            }
          } while (pEl = pEl.parentNode);
          if (self2._v && target !== opts.trigger && pEl !== opts.trigger) {
            self2.hide();
          }
        };
        self2.el = document2.createElement("div");
        self2.el.className = "pika-single" + (opts.isRTL ? " is-rtl" : "") + (opts.theme ? " " + opts.theme : "");
        addEvent2(self2.el, "mousedown", self2._onMouseDown, true);
        addEvent2(self2.el, "touchend", self2._onMouseDown, true);
        addEvent2(self2.el, "change", self2._onChange);
        if (opts.keyboardInput) {
          addEvent2(document2, "keydown", self2._onKeyChange);
        }
        if (opts.field) {
          if (opts.container) {
            opts.container.appendChild(self2.el);
          } else if (opts.bound) {
            document2.body.appendChild(self2.el);
          } else {
            opts.field.parentNode.insertBefore(self2.el, opts.field.nextSibling);
          }
          addEvent2(opts.field, "change", self2._onInputChange);
          if (!opts.defaultDate) {
            opts.defaultDate = self2._parseFieldValue();
            opts.setDefaultDate = true;
          }
        }
        var defDate = opts.defaultDate;
        if (isDate3(defDate)) {
          if (opts.setDefaultDate) {
            self2.setDate(defDate, true);
          } else {
            self2.gotoDate(defDate);
          }
        } else {
          self2.gotoDate(/* @__PURE__ */ new Date());
        }
        if (opts.bound) {
          this.hide();
          self2.el.className += " is-bound";
          addEvent2(opts.trigger, "click", self2._onInputClick);
          addEvent2(opts.trigger, "focus", self2._onInputFocus);
          addEvent2(opts.trigger, "blur", self2._onInputBlur);
        } else {
          this.show();
        }
      };
      Pikaday2.prototype = {
        /**
         * configure functionality
         */
        config: function(options) {
          if (!this._o) {
            this._o = extend3({}, defaults2, true);
          }
          var opts = extend3(this._o, options, true);
          opts.isRTL = !!opts.isRTL;
          opts.field = opts.field && opts.field.nodeName ? opts.field : null;
          opts.theme = typeof opts.theme === "string" && opts.theme ? opts.theme : null;
          opts.bound = !!(opts.bound !== void 0 ? opts.field && opts.bound : opts.field);
          opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
          opts.disableWeekends = !!opts.disableWeekends;
          opts.disableDayFn = typeof opts.disableDayFn === "function" ? opts.disableDayFn : null;
          var nom = parseInt(opts.numberOfMonths, 10) || 1;
          opts.numberOfMonths = nom > 4 ? 4 : nom;
          if (!isDate3(opts.minDate)) {
            opts.minDate = false;
          }
          if (!isDate3(opts.maxDate)) {
            opts.maxDate = false;
          }
          if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) {
            opts.maxDate = opts.minDate = false;
          }
          if (opts.minDate) {
            this.setMinDate(opts.minDate);
          }
          if (opts.maxDate) {
            this.setMaxDate(opts.maxDate);
          }
          if (isArray2(opts.yearRange)) {
            var fallback = (/* @__PURE__ */ new Date()).getFullYear() - 10;
            opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
            opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
          } else {
            opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults2.yearRange;
            if (opts.yearRange > 100) {
              opts.yearRange = 100;
            }
          }
          return opts;
        },
        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format2) {
          format2 = format2 || this._o.format;
          if (!isDate3(this._d)) {
            return "";
          }
          if (this._o.toString) {
            return this._o.toString(this._d, format2);
          }
          if (hasMoment) {
            return moment(this._d).format(format2);
          }
          return this._d.toDateString();
        },
        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function() {
          return hasMoment ? moment(this._d) : null;
        },
        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect) {
          if (hasMoment && moment.isMoment(date)) {
            this.setDate(date.toDate(), preventOnSelect);
          }
        },
        /**
         * return a Date object of the current selection
         */
        getDate: function() {
          return isDate3(this._d) ? new Date(this._d.getTime()) : null;
        },
        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect) {
          if (!date) {
            this._d = null;
            if (this._o.field) {
              this._o.field.value = "";
              fireEvent(this._o.field, "change", { firedBy: this });
            }
            return this.draw();
          }
          if (typeof date === "string") {
            date = new Date(Date.parse(date));
          }
          if (!isDate3(date)) {
            return;
          }
          var min2 = this._o.minDate, max2 = this._o.maxDate;
          if (isDate3(min2) && date < min2) {
            date = min2;
          } else if (isDate3(max2) && date > max2) {
            date = max2;
          }
          this._d = new Date(date.getTime());
          setToStartOfDay(this._d);
          this.gotoDate(this._d);
          if (this._o.field) {
            this._o.field.value = this.toString();
            fireEvent(this._o.field, "change", { firedBy: this });
          }
          if (!preventOnSelect && typeof this._o.onSelect === "function") {
            this._o.onSelect.call(this, this.getDate());
          }
        },
        /**
         * clear and reset the date
         */
        clear: function() {
          this.setDate(null);
        },
        /**
         * change view to a specific date
         */
        gotoDate: function(date) {
          var newCalendar = true;
          if (!isDate3(date)) {
            return;
          }
          if (this.calendars) {
            var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1), lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1), visibleDate = date.getTime();
            lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
            lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
            newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
          }
          if (newCalendar) {
            this.calendars = [{
              month: date.getMonth(),
              year: date.getFullYear()
            }];
            if (this._o.mainCalendar === "right") {
              this.calendars[0].month += 1 - this._o.numberOfMonths;
            }
          }
          this.adjustCalendars();
        },
        adjustDate: function(sign2, days2) {
          var day = this.getDate() || /* @__PURE__ */ new Date();
          var difference = parseInt(days2) * 24 * 60 * 60 * 1e3;
          var newDay;
          if (sign2 === "add") {
            newDay = new Date(day.valueOf() + difference);
          } else if (sign2 === "subtract") {
            newDay = new Date(day.valueOf() - difference);
          }
          this.setDate(newDay);
        },
        adjustCalendars: function() {
          this.calendars[0] = adjustCalendar(this.calendars[0]);
          for (var c = 1; c < this._o.numberOfMonths; c++) {
            this.calendars[c] = adjustCalendar({
              month: this.calendars[0].month + c,
              year: this.calendars[0].year
            });
          }
          this.draw();
        },
        gotoToday: function() {
          this.gotoDate(/* @__PURE__ */ new Date());
        },
        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month) {
          if (!isNaN(month)) {
            this.calendars[0].month = parseInt(month, 10);
            this.adjustCalendars();
          }
        },
        nextMonth: function() {
          this.calendars[0].month++;
          this.adjustCalendars();
        },
        prevMonth: function() {
          this.calendars[0].month--;
          this.adjustCalendars();
        },
        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year) {
          if (!isNaN(year)) {
            this.calendars[0].year = parseInt(year, 10);
            this.adjustCalendars();
          }
        },
        /**
         * change the minDate
         */
        setMinDate: function(value) {
          if (value instanceof Date) {
            setToStartOfDay(value);
            this._o.minDate = value;
            this._o.minYear = value.getFullYear();
            this._o.minMonth = value.getMonth();
          } else {
            this._o.minDate = defaults2.minDate;
            this._o.minYear = defaults2.minYear;
            this._o.minMonth = defaults2.minMonth;
            this._o.startRange = defaults2.startRange;
          }
          this.draw();
        },
        /**
         * change the maxDate
         */
        setMaxDate: function(value) {
          if (value instanceof Date) {
            setToStartOfDay(value);
            this._o.maxDate = value;
            this._o.maxYear = value.getFullYear();
            this._o.maxMonth = value.getMonth();
          } else {
            this._o.maxDate = defaults2.maxDate;
            this._o.maxYear = defaults2.maxYear;
            this._o.maxMonth = defaults2.maxMonth;
            this._o.endRange = defaults2.endRange;
          }
          this.draw();
        },
        setStartRange: function(value) {
          this._o.startRange = value;
        },
        setEndRange: function(value) {
          this._o.endRange = value;
        },
        /**
         * refresh the HTML
         */
        draw: function(force) {
          if (!this._v && !force) {
            return;
          }
          var opts = this._o, minYear = opts.minYear, maxYear = opts.maxYear, minMonth = opts.minMonth, maxMonth = opts.maxMonth, html2 = "", randId;
          if (this._y <= minYear) {
            this._y = minYear;
            if (!isNaN(minMonth) && this._m < minMonth) {
              this._m = minMonth;
            }
          }
          if (this._y >= maxYear) {
            this._y = maxYear;
            if (!isNaN(maxMonth) && this._m > maxMonth) {
              this._m = maxMonth;
            }
          }
          for (var c = 0; c < opts.numberOfMonths; c++) {
            randId = "pika-title-" + Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 2);
            html2 += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + "</div>";
          }
          this.el.innerHTML = html2;
          if (opts.bound) {
            if (opts.field.type !== "hidden") {
              sto(function() {
                opts.trigger.focus();
              }, 1);
            }
          }
          if (typeof this._o.onDraw === "function") {
            this._o.onDraw(this);
          }
          if (opts.bound) {
            opts.field.setAttribute("aria-label", opts.ariaLabel);
          }
        },
        adjustPosition: function() {
          var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left2, top2, clientRect, leftAligned, bottomAligned;
          if (this._o.container)
            return;
          this.el.style.position = "absolute";
          field = this._o.trigger;
          pEl = field;
          width = this.el.offsetWidth;
          height = this.el.offsetHeight;
          viewportWidth = window.innerWidth || document2.documentElement.clientWidth;
          viewportHeight = window.innerHeight || document2.documentElement.clientHeight;
          scrollTop = window.pageYOffset || document2.body.scrollTop || document2.documentElement.scrollTop;
          leftAligned = true;
          bottomAligned = true;
          if (typeof field.getBoundingClientRect === "function") {
            clientRect = field.getBoundingClientRect();
            left2 = clientRect.left + window.pageXOffset;
            top2 = clientRect.bottom + window.pageYOffset;
          } else {
            left2 = pEl.offsetLeft;
            top2 = pEl.offsetTop + pEl.offsetHeight;
            while (pEl = pEl.offsetParent) {
              left2 += pEl.offsetLeft;
              top2 += pEl.offsetTop;
            }
          }
          if (this._o.reposition && left2 + width > viewportWidth || this._o.position.indexOf("right") > -1 && left2 - width + field.offsetWidth > 0) {
            left2 = left2 - width + field.offsetWidth;
            leftAligned = false;
          }
          if (this._o.reposition && top2 + height > viewportHeight + scrollTop || this._o.position.indexOf("top") > -1 && top2 - height - field.offsetHeight > 0) {
            top2 = top2 - height - field.offsetHeight;
            bottomAligned = false;
          }
          this.el.style.left = left2 + "px";
          this.el.style.top = top2 + "px";
          addClass2(this.el, leftAligned ? "left-aligned" : "right-aligned");
          addClass2(this.el, bottomAligned ? "bottom-aligned" : "top-aligned");
          removeClass2(this.el, !leftAligned ? "left-aligned" : "right-aligned");
          removeClass2(this.el, !bottomAligned ? "bottom-aligned" : "top-aligned");
        },
        /**
         * render HTML for a particular month
         */
        render: function(year, month, randId) {
          var opts = this._o, now2 = /* @__PURE__ */ new Date(), days2 = getDaysInMonth2(year, month), before = new Date(year, month, 1).getDay(), data = [], row = [];
          setToStartOfDay(now2);
          if (opts.firstDay > 0) {
            before -= opts.firstDay;
            if (before < 0) {
              before += 7;
            }
          }
          var previousMonth = month === 0 ? 11 : month - 1, nextMonth = month === 11 ? 0 : month + 1, yearOfPreviousMonth = month === 0 ? year - 1 : year, yearOfNextMonth = month === 11 ? year + 1 : year, daysInPreviousMonth = getDaysInMonth2(yearOfPreviousMonth, previousMonth);
          var cells = days2 + before, after = cells;
          while (after > 7) {
            after -= 7;
          }
          cells += 7 - after;
          var isWeekSelected = false;
          for (var i = 0, r = 0; i < cells; i++) {
            var day = new Date(year, month, 1 + (i - before)), isSelected = isDate3(this._d) ? compareDates(day, this._d) : false, isToday = compareDates(day, now2), hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false, isEmpty2 = i < before || i >= days2 + before, dayNumber = 1 + (i - before), monthNumber = month, yearNumber = year, isStartRange = opts.startRange && compareDates(opts.startRange, day), isEndRange = opts.endRange && compareDates(opts.endRange, day), isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange, isDisabled2 = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);
            if (isEmpty2) {
              if (i < before) {
                dayNumber = daysInPreviousMonth + dayNumber;
                monthNumber = previousMonth;
                yearNumber = yearOfPreviousMonth;
              } else {
                dayNumber = dayNumber - days2;
                monthNumber = nextMonth;
                yearNumber = yearOfNextMonth;
              }
            }
            var dayConfig = {
              day: dayNumber,
              month: monthNumber,
              year: yearNumber,
              hasEvent,
              isSelected,
              isToday,
              isDisabled: isDisabled2,
              isEmpty: isEmpty2,
              isStartRange,
              isEndRange,
              isInRange,
              showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
              enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
            };
            if (opts.pickWholeWeek && isSelected) {
              isWeekSelected = true;
            }
            row.push(renderDay(dayConfig));
            if (++r === 7) {
              if (opts.showWeekNumber) {
                row.unshift(renderWeek(i - before, month, year, opts.firstWeekOfYearMinDays));
              }
              data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
              row = [];
              r = 0;
              isWeekSelected = false;
            }
          }
          return renderTable(opts, data, randId);
        },
        isVisible: function() {
          return this._v;
        },
        show: function() {
          if (!this.isVisible()) {
            this._v = true;
            this.draw();
            removeClass2(this.el, "is-hidden");
            if (this._o.bound) {
              addEvent2(document2, "click", this._onClick);
              this.adjustPosition();
            }
            if (typeof this._o.onOpen === "function") {
              this._o.onOpen.call(this);
            }
          }
        },
        hide: function() {
          var v = this._v;
          if (v !== false) {
            if (this._o.bound) {
              removeEvent2(document2, "click", this._onClick);
            }
            if (!this._o.container) {
              this.el.style.position = "static";
              this.el.style.left = "auto";
              this.el.style.top = "auto";
            }
            addClass2(this.el, "is-hidden");
            this._v = false;
            if (v !== void 0 && typeof this._o.onClose === "function") {
              this._o.onClose.call(this);
            }
          }
        },
        /**
         * GAME OVER
         */
        destroy: function() {
          var opts = this._o;
          this.hide();
          removeEvent2(this.el, "mousedown", this._onMouseDown, true);
          removeEvent2(this.el, "touchend", this._onMouseDown, true);
          removeEvent2(this.el, "change", this._onChange);
          if (opts.keyboardInput) {
            removeEvent2(document2, "keydown", this._onKeyChange);
          }
          if (opts.field) {
            removeEvent2(opts.field, "change", this._onInputChange);
            if (opts.bound) {
              removeEvent2(opts.trigger, "click", this._onInputClick);
              removeEvent2(opts.trigger, "focus", this._onInputFocus);
              removeEvent2(opts.trigger, "blur", this._onInputBlur);
            }
          }
          if (this.el.parentNode) {
            this.el.parentNode.removeChild(this.el);
          }
        }
      };
      return Pikaday2;
    });
  }
});

// node_modules/numbro/dist/numbro.min.js
var require_numbro_min = __commonJS({
  "node_modules/numbro/dist/numbro.min.js"(exports, module2) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).numbro = e();
      }
    }(function() {
      return function a(o, u, c) {
        function s(t, e2) {
          if (!u[t]) {
            if (!o[t]) {
              var r = "function" == typeof __require && __require;
              if (!e2 && r)
                return r(t, true);
              if (l)
                return l(t, true);
              var n = new Error("Cannot find module '" + t + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = u[t] = { exports: {} };
            o[t][0].call(i.exports, function(e3) {
              return s(o[t][1][e3] || e3);
            }, i, i.exports, a, o, u, c);
          }
          return u[t].exports;
        }
        for (var l = "function" == typeof __require && __require, e = 0; e < c.length; e++)
          s(c[e]);
        return s;
      }({ 1: [function(e, r, t) {
        !function(e2) {
          "use strict";
          var t2, k = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, _ = Math.ceil, L = Math.floor, T = "[BigNumber Error] ", P = T + "Number primitive has more than 15 significant digits: ", U = 1e14, j = 14, C = 9007199254740991, R = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], I = 1e7, $6 = 1e9;
          function G(e3) {
            var t3 = 0 | e3;
            return 0 < e3 || e3 === t3 ? t3 : t3 - 1;
          }
          function V(e3) {
            for (var t3, r2, n = 1, i = e3.length, a = e3[0] + ""; n < i; ) {
              for (t3 = e3[n++] + "", r2 = j - t3.length; r2--; t3 = "0" + t3)
                ;
              a += t3;
            }
            for (i = a.length; 48 === a.charCodeAt(--i); )
              ;
            return a.slice(0, i + 1 || 1);
          }
          function q(e3, t3) {
            var r2, n, i = e3.c, a = t3.c, o = e3.s, u = t3.s, c = e3.e, s = t3.e;
            if (!o || !u)
              return null;
            if (r2 = i && !i[0], n = a && !a[0], r2 || n)
              return r2 ? n ? 0 : -u : o;
            if (o != u)
              return o;
            if (r2 = o < 0, n = c == s, !i || !a)
              return n ? 0 : !i ^ r2 ? 1 : -1;
            if (!n)
              return s < c ^ r2 ? 1 : -1;
            for (u = (c = i.length) < (s = a.length) ? c : s, o = 0; o < u; o++)
              if (i[o] != a[o])
                return i[o] > a[o] ^ r2 ? 1 : -1;
            return c == s ? 0 : s < c ^ r2 ? 1 : -1;
          }
          function Z(e3, t3, r2, n) {
            if (e3 < t3 || r2 < e3 || e3 !== (e3 < 0 ? _(e3) : L(e3)))
              throw Error(T + (n || "Argument") + ("number" == typeof e3 ? e3 < t3 || r2 < e3 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e3));
          }
          function z(e3) {
            var t3 = e3.c.length - 1;
            return G(e3.e / j) == t3 && e3.c[t3] % 2 != 0;
          }
          function W(e3, t3) {
            return (1 < e3.length ? e3.charAt(0) + "." + e3.slice(1) : e3) + (t3 < 0 ? "e" : "e+") + t3;
          }
          function H(e3, t3, r2) {
            var n, i;
            if (t3 < 0) {
              for (i = r2 + "."; ++t3; i += r2)
                ;
              e3 = i + e3;
            } else if (++t3 > (n = e3.length)) {
              for (i = r2, t3 -= n; --t3; i += r2)
                ;
              e3 += i;
            } else
              t3 < n && (e3 = e3.slice(0, t3) + "." + e3.slice(t3));
            return e3;
          }
          (t2 = function e3(t3) {
            var y, f, p, r2, s, o, u, c, l, g, n = A.prototype = { constructor: A, toString: null, valueOf: null }, d = new A(1), b = 20, w = 4, h = -7, v = 21, m = -1e7, O = 1e7, x = false, a = 1, S = 0, N = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: " ", suffix: "" }, M = "0123456789abcdefghijklmnopqrstuvwxyz";
            function A(e4, t4) {
              var r3, n2, i2, a2, o2, u2, c2, s2, l2 = this;
              if (!(l2 instanceof A))
                return new A(e4, t4);
              if (null == t4) {
                if (e4 instanceof A)
                  return l2.s = e4.s, l2.e = e4.e, void (l2.c = (e4 = e4.c) ? e4.slice() : e4);
                if ((u2 = "number" == typeof e4) && 0 * e4 == 0) {
                  if (l2.s = 1 / e4 < 0 ? (e4 = -e4, -1) : 1, e4 === ~~e4) {
                    for (a2 = 0, o2 = e4; 10 <= o2; o2 /= 10, a2++)
                      ;
                    return l2.e = a2, void (l2.c = [e4]);
                  }
                  s2 = String(e4);
                } else {
                  if (s2 = String(e4), !k.test(s2))
                    return p(l2, s2, u2);
                  l2.s = 45 == s2.charCodeAt(0) ? (s2 = s2.slice(1), -1) : 1;
                }
                -1 < (a2 = s2.indexOf(".")) && (s2 = s2.replace(".", "")), 0 < (o2 = s2.search(/e/i)) ? (a2 < 0 && (a2 = o2), a2 += +s2.slice(o2 + 1), s2 = s2.substring(0, o2)) : a2 < 0 && (a2 = s2.length);
              } else {
                if (Z(t4, 2, M.length, "Base"), s2 = String(e4), 10 == t4)
                  return E(l2 = new A(e4 instanceof A ? e4 : s2), b + l2.e + 1, w);
                if (u2 = "number" == typeof e4) {
                  if (0 * e4 != 0)
                    return p(l2, s2, u2, t4);
                  if (l2.s = 1 / e4 < 0 ? (s2 = s2.slice(1), -1) : 1, A.DEBUG && 15 < s2.replace(/^0\.0*|\./, "").length)
                    throw Error(P + e4);
                  u2 = false;
                } else
                  l2.s = 45 === s2.charCodeAt(0) ? (s2 = s2.slice(1), -1) : 1;
                for (r3 = M.slice(0, t4), a2 = o2 = 0, c2 = s2.length; o2 < c2; o2++)
                  if (r3.indexOf(n2 = s2.charAt(o2)) < 0) {
                    if ("." == n2) {
                      if (a2 < o2) {
                        a2 = c2;
                        continue;
                      }
                    } else if (!i2 && (s2 == s2.toUpperCase() && (s2 = s2.toLowerCase()) || s2 == s2.toLowerCase() && (s2 = s2.toUpperCase()))) {
                      i2 = true, o2 = -1, a2 = 0;
                      continue;
                    }
                    return p(l2, String(e4), u2, t4);
                  }
                -1 < (a2 = (s2 = f(s2, t4, 10, l2.s)).indexOf(".")) ? s2 = s2.replace(".", "") : a2 = s2.length;
              }
              for (o2 = 0; 48 === s2.charCodeAt(o2); o2++)
                ;
              for (c2 = s2.length; 48 === s2.charCodeAt(--c2); )
                ;
              if (s2 = s2.slice(o2, ++c2)) {
                if (c2 -= o2, u2 && A.DEBUG && 15 < c2 && (C < e4 || e4 !== L(e4)))
                  throw Error(P + l2.s * e4);
                if (O < (a2 = a2 - o2 - 1))
                  l2.c = l2.e = null;
                else if (a2 < m)
                  l2.c = [l2.e = 0];
                else {
                  if (l2.e = a2, l2.c = [], o2 = (a2 + 1) % j, a2 < 0 && (o2 += j), o2 < c2) {
                    for (o2 && l2.c.push(+s2.slice(0, o2)), c2 -= j; o2 < c2; )
                      l2.c.push(+s2.slice(o2, o2 += j));
                    s2 = s2.slice(o2), o2 = j - s2.length;
                  } else
                    o2 -= c2;
                  for (; o2--; s2 += "0")
                    ;
                  l2.c.push(+s2);
                }
              } else
                l2.c = [l2.e = 0];
            }
            function i(e4, t4, r3, n2) {
              var i2, a2, o2, u2, c2;
              if (null == r3 ? r3 = w : Z(r3, 0, 8), !e4.c)
                return e4.toString();
              if (i2 = e4.c[0], o2 = e4.e, null == t4)
                c2 = V(e4.c), c2 = 1 == n2 || 2 == n2 && (o2 <= h || v <= o2) ? W(c2, o2) : H(c2, o2, "0");
              else if (a2 = (e4 = E(new A(e4), t4, r3)).e, u2 = (c2 = V(e4.c)).length, 1 == n2 || 2 == n2 && (t4 <= a2 || a2 <= h)) {
                for (; u2 < t4; c2 += "0", u2++)
                  ;
                c2 = W(c2, a2);
              } else if (t4 -= o2, c2 = H(c2, a2, "0"), u2 < a2 + 1) {
                if (0 < --t4)
                  for (c2 += "."; t4--; c2 += "0")
                    ;
              } else if (0 < (t4 += a2 - u2))
                for (a2 + 1 == u2 && (c2 += "."); t4--; c2 += "0")
                  ;
              return e4.s < 0 && i2 ? "-" + c2 : c2;
            }
            function B(e4, t4) {
              for (var r3, n2 = 1, i2 = new A(e4[0]); n2 < e4.length; n2++) {
                if (!(r3 = new A(e4[n2])).s) {
                  i2 = r3;
                  break;
                }
                t4.call(i2, r3) && (i2 = r3);
              }
              return i2;
            }
            function D(e4, t4, r3) {
              for (var n2 = 1, i2 = t4.length; !t4[--i2]; t4.pop())
                ;
              for (i2 = t4[0]; 10 <= i2; i2 /= 10, n2++)
                ;
              return (r3 = n2 + r3 * j - 1) > O ? e4.c = e4.e = null : e4.c = r3 < m ? [e4.e = 0] : (e4.e = r3, t4), e4;
            }
            function E(e4, t4, r3, n2) {
              var i2, a2, o2, u2, c2, s2, l2, f2 = e4.c, p2 = R;
              if (f2) {
                e: {
                  for (i2 = 1, u2 = f2[0]; 10 <= u2; u2 /= 10, i2++)
                    ;
                  if ((a2 = t4 - i2) < 0)
                    a2 += j, o2 = t4, l2 = (c2 = f2[s2 = 0]) / p2[i2 - o2 - 1] % 10 | 0;
                  else if ((s2 = _((a2 + 1) / j)) >= f2.length) {
                    if (!n2)
                      break e;
                    for (; f2.length <= s2; f2.push(0))
                      ;
                    c2 = l2 = 0, o2 = (a2 %= j) - j + (i2 = 1);
                  } else {
                    for (c2 = u2 = f2[s2], i2 = 1; 10 <= u2; u2 /= 10, i2++)
                      ;
                    l2 = (o2 = (a2 %= j) - j + i2) < 0 ? 0 : c2 / p2[i2 - o2 - 1] % 10 | 0;
                  }
                  if (n2 = n2 || t4 < 0 || null != f2[s2 + 1] || (o2 < 0 ? c2 : c2 % p2[i2 - o2 - 1]), n2 = r3 < 4 ? (l2 || n2) && (0 == r3 || r3 == (e4.s < 0 ? 3 : 2)) : 5 < l2 || 5 == l2 && (4 == r3 || n2 || 6 == r3 && (0 < a2 ? 0 < o2 ? c2 / p2[i2 - o2] : 0 : f2[s2 - 1]) % 10 & 1 || r3 == (e4.s < 0 ? 8 : 7)), t4 < 1 || !f2[0])
                    return f2.length = 0, n2 ? (t4 -= e4.e + 1, f2[0] = p2[(j - t4 % j) % j], e4.e = -t4 || 0) : f2[0] = e4.e = 0, e4;
                  if (0 == a2 ? (f2.length = s2, u2 = 1, s2--) : (f2.length = s2 + 1, u2 = p2[j - a2], f2[s2] = 0 < o2 ? L(c2 / p2[i2 - o2] % p2[o2]) * u2 : 0), n2)
                    for (; ; ) {
                      if (0 == s2) {
                        for (a2 = 1, o2 = f2[0]; 10 <= o2; o2 /= 10, a2++)
                          ;
                        for (o2 = f2[0] += u2, u2 = 1; 10 <= o2; o2 /= 10, u2++)
                          ;
                        a2 != u2 && (e4.e++, f2[0] == U && (f2[0] = 1));
                        break;
                      }
                      if (f2[s2] += u2, f2[s2] != U)
                        break;
                      f2[s2--] = 0, u2 = 1;
                    }
                  for (a2 = f2.length; 0 === f2[--a2]; f2.pop())
                    ;
                }
                e4.e > O ? e4.c = e4.e = null : e4.e < m && (e4.c = [e4.e = 0]);
              }
              return e4;
            }
            function F(e4) {
              var t4, r3 = e4.e;
              return null === r3 ? e4.toString() : (t4 = V(e4.c), t4 = r3 <= h || v <= r3 ? W(t4, r3) : H(t4, r3, "0"), e4.s < 0 ? "-" + t4 : t4);
            }
            return A.clone = e3, A.ROUND_UP = 0, A.ROUND_DOWN = 1, A.ROUND_CEIL = 2, A.ROUND_FLOOR = 3, A.ROUND_HALF_UP = 4, A.ROUND_HALF_DOWN = 5, A.ROUND_HALF_EVEN = 6, A.ROUND_HALF_CEIL = 7, A.ROUND_HALF_FLOOR = 8, A.EUCLID = 9, A.config = A.set = function(e4) {
              var t4, r3;
              if (null != e4) {
                if ("object" != typeof e4)
                  throw Error(T + "Object expected: " + e4);
                if (e4.hasOwnProperty(t4 = "DECIMAL_PLACES") && (Z(r3 = e4[t4], 0, $6, t4), b = r3), e4.hasOwnProperty(t4 = "ROUNDING_MODE") && (Z(r3 = e4[t4], 0, 8, t4), w = r3), e4.hasOwnProperty(t4 = "EXPONENTIAL_AT") && ((r3 = e4[t4]) && r3.pop ? (Z(r3[0], -$6, 0, t4), Z(r3[1], 0, $6, t4), h = r3[0], v = r3[1]) : (Z(r3, -$6, $6, t4), h = -(v = r3 < 0 ? -r3 : r3))), e4.hasOwnProperty(t4 = "RANGE"))
                  if ((r3 = e4[t4]) && r3.pop)
                    Z(r3[0], -$6, -1, t4), Z(r3[1], 1, $6, t4), m = r3[0], O = r3[1];
                  else {
                    if (Z(r3, -$6, $6, t4), !r3)
                      throw Error(T + t4 + " cannot be zero: " + r3);
                    m = -(O = r3 < 0 ? -r3 : r3);
                  }
                if (e4.hasOwnProperty(t4 = "CRYPTO")) {
                  if ((r3 = e4[t4]) !== !!r3)
                    throw Error(T + t4 + " not true or false: " + r3);
                  if (r3) {
                    if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                      throw x = !r3, Error(T + "crypto unavailable");
                    x = r3;
                  } else
                    x = r3;
                }
                if (e4.hasOwnProperty(t4 = "MODULO_MODE") && (Z(r3 = e4[t4], 0, 9, t4), a = r3), e4.hasOwnProperty(t4 = "POW_PRECISION") && (Z(r3 = e4[t4], 0, $6, t4), S = r3), e4.hasOwnProperty(t4 = "FORMAT")) {
                  if ("object" != typeof (r3 = e4[t4]))
                    throw Error(T + t4 + " not an object: " + r3);
                  N = r3;
                }
                if (e4.hasOwnProperty(t4 = "ALPHABET")) {
                  if ("string" != typeof (r3 = e4[t4]) || /^.$|[+-.\s]|(.).*\1/.test(r3))
                    throw Error(T + t4 + " invalid: " + r3);
                  M = r3;
                }
              }
              return { DECIMAL_PLACES: b, ROUNDING_MODE: w, EXPONENTIAL_AT: [h, v], RANGE: [m, O], CRYPTO: x, MODULO_MODE: a, POW_PRECISION: S, FORMAT: N, ALPHABET: M };
            }, A.isBigNumber = function(e4) {
              return e4 instanceof A || e4 && true === e4._isBigNumber || false;
            }, A.maximum = A.max = function() {
              return B(arguments, n.lt);
            }, A.minimum = A.min = function() {
              return B(arguments, n.gt);
            }, A.random = (r2 = 9007199254740992, s = Math.random() * r2 & 2097151 ? function() {
              return L(Math.random() * r2);
            } : function() {
              return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
            }, function(e4) {
              var t4, r3, n2, i2, a2, o2 = 0, u2 = [], c2 = new A(d);
              if (null == e4 ? e4 = b : Z(e4, 0, $6), i2 = _(e4 / j), x)
                if (crypto.getRandomValues) {
                  for (t4 = crypto.getRandomValues(new Uint32Array(i2 *= 2)); o2 < i2; )
                    9e15 <= (a2 = 131072 * t4[o2] + (t4[o2 + 1] >>> 11)) ? (r3 = crypto.getRandomValues(new Uint32Array(2)), t4[o2] = r3[0], t4[o2 + 1] = r3[1]) : (u2.push(a2 % 1e14), o2 += 2);
                  o2 = i2 / 2;
                } else {
                  if (!crypto.randomBytes)
                    throw x = false, Error(T + "crypto unavailable");
                  for (t4 = crypto.randomBytes(i2 *= 7); o2 < i2; )
                    9e15 <= (a2 = 281474976710656 * (31 & t4[o2]) + 1099511627776 * t4[o2 + 1] + 4294967296 * t4[o2 + 2] + 16777216 * t4[o2 + 3] + (t4[o2 + 4] << 16) + (t4[o2 + 5] << 8) + t4[o2 + 6]) ? crypto.randomBytes(7).copy(t4, o2) : (u2.push(a2 % 1e14), o2 += 7);
                  o2 = i2 / 7;
                }
              if (!x)
                for (; o2 < i2; )
                  (a2 = s()) < 9e15 && (u2[o2++] = a2 % 1e14);
              for (i2 = u2[--o2], e4 %= j, i2 && e4 && (a2 = R[j - e4], u2[o2] = L(i2 / a2) * a2); 0 === u2[o2]; u2.pop(), o2--)
                ;
              if (o2 < 0)
                u2 = [n2 = 0];
              else {
                for (n2 = -1; 0 === u2[0]; u2.splice(0, 1), n2 -= j)
                  ;
                for (o2 = 1, a2 = u2[0]; 10 <= a2; a2 /= 10, o2++)
                  ;
                o2 < j && (n2 -= j - o2);
              }
              return c2.e = n2, c2.c = u2, c2;
            }), A.sum = function() {
              for (var e4 = 1, t4 = arguments, r3 = new A(t4[0]); e4 < t4.length; )
                r3 = r3.plus(t4[e4++]);
              return r3;
            }, f = function() {
              var v2 = "0123456789";
              function m2(e4, t4, r3, n2) {
                for (var i2, a2, o2 = [0], u2 = 0, c2 = e4.length; u2 < c2; ) {
                  for (a2 = o2.length; a2--; o2[a2] *= t4)
                    ;
                  for (o2[0] += n2.indexOf(e4.charAt(u2++)), i2 = 0; i2 < o2.length; i2++)
                    o2[i2] > r3 - 1 && (null == o2[i2 + 1] && (o2[i2 + 1] = 0), o2[i2 + 1] += o2[i2] / r3 | 0, o2[i2] %= r3);
                }
                return o2.reverse();
              }
              return function(e4, t4, r3, n2, i2) {
                var a2, o2, u2, c2, s2, l2, f2, p2, g2 = e4.indexOf("."), h2 = b, d2 = w;
                for (0 <= g2 && (c2 = S, S = 0, e4 = e4.replace(".", ""), l2 = (p2 = new A(t4)).pow(e4.length - g2), S = c2, p2.c = m2(H(V(l2.c), l2.e, "0"), 10, r3, v2), p2.e = p2.c.length), u2 = c2 = (f2 = m2(e4, t4, r3, i2 ? (a2 = M, v2) : (a2 = v2, M))).length; 0 == f2[--c2]; f2.pop())
                  ;
                if (!f2[0])
                  return a2.charAt(0);
                if (g2 < 0 ? --u2 : (l2.c = f2, l2.e = u2, l2.s = n2, f2 = (l2 = y(l2, p2, h2, d2, r3)).c, s2 = l2.r, u2 = l2.e), g2 = f2[o2 = u2 + h2 + 1], c2 = r3 / 2, s2 = s2 || o2 < 0 || null != f2[o2 + 1], s2 = d2 < 4 ? (null != g2 || s2) && (0 == d2 || d2 == (l2.s < 0 ? 3 : 2)) : c2 < g2 || g2 == c2 && (4 == d2 || s2 || 6 == d2 && 1 & f2[o2 - 1] || d2 == (l2.s < 0 ? 8 : 7)), o2 < 1 || !f2[0])
                  e4 = s2 ? H(a2.charAt(1), -h2, a2.charAt(0)) : a2.charAt(0);
                else {
                  if (f2.length = o2, s2)
                    for (--r3; ++f2[--o2] > r3; )
                      f2[o2] = 0, o2 || (++u2, f2 = [1].concat(f2));
                  for (c2 = f2.length; !f2[--c2]; )
                    ;
                  for (g2 = 0, e4 = ""; g2 <= c2; e4 += a2.charAt(f2[g2++]))
                    ;
                  e4 = H(e4, u2, a2.charAt(0));
                }
                return e4;
              };
            }(), y = function() {
              function M2(e4, t4, r3) {
                var n2, i2, a2, o2, u2 = 0, c2 = e4.length, s2 = t4 % I, l2 = t4 / I | 0;
                for (e4 = e4.slice(); c2--; )
                  u2 = ((i2 = s2 * (a2 = e4[c2] % I) + (n2 = l2 * a2 + (o2 = e4[c2] / I | 0) * s2) % I * I + u2) / r3 | 0) + (n2 / I | 0) + l2 * o2, e4[c2] = i2 % r3;
                return u2 && (e4 = [u2].concat(e4)), e4;
              }
              function B2(e4, t4, r3, n2) {
                var i2, a2;
                if (r3 != n2)
                  a2 = n2 < r3 ? 1 : -1;
                else
                  for (i2 = a2 = 0; i2 < r3; i2++)
                    if (e4[i2] != t4[i2]) {
                      a2 = e4[i2] > t4[i2] ? 1 : -1;
                      break;
                    }
                return a2;
              }
              function D2(e4, t4, r3, n2) {
                for (var i2 = 0; r3--; )
                  e4[r3] -= i2, i2 = e4[r3] < t4[r3] ? 1 : 0, e4[r3] = i2 * n2 + e4[r3] - t4[r3];
                for (; !e4[0] && 1 < e4.length; e4.splice(0, 1))
                  ;
              }
              return function(e4, t4, r3, n2, i2) {
                var a2, o2, u2, c2, s2, l2, f2, p2, g2, h2, d2, v2, m2, y2, b2, w2, O2, x2 = e4.s == t4.s ? 1 : -1, S2 = e4.c, N2 = t4.c;
                if (!(S2 && S2[0] && N2 && N2[0]))
                  return new A(e4.s && t4.s && (S2 ? !N2 || S2[0] != N2[0] : N2) ? S2 && 0 == S2[0] || !N2 ? 0 * x2 : x2 / 0 : NaN);
                for (g2 = (p2 = new A(x2)).c = [], x2 = r3 + (o2 = e4.e - t4.e) + 1, i2 || (i2 = U, o2 = G(e4.e / j) - G(t4.e / j), x2 = x2 / j | 0), u2 = 0; N2[u2] == (S2[u2] || 0); u2++)
                  ;
                if (N2[u2] > (S2[u2] || 0) && o2--, x2 < 0)
                  g2.push(1), c2 = true;
                else {
                  for (y2 = S2.length, w2 = N2.length, x2 += 2, 1 < (s2 = L(i2 / (N2[u2 = 0] + 1))) && (N2 = M2(N2, s2, i2), S2 = M2(S2, s2, i2), w2 = N2.length, y2 = S2.length), m2 = w2, d2 = (h2 = S2.slice(0, w2)).length; d2 < w2; h2[d2++] = 0)
                    ;
                  O2 = N2.slice(), O2 = [0].concat(O2), b2 = N2[0], N2[1] >= i2 / 2 && b2++;
                  do {
                    if (s2 = 0, (a2 = B2(N2, h2, w2, d2)) < 0) {
                      if (v2 = h2[0], w2 != d2 && (v2 = v2 * i2 + (h2[1] || 0)), 1 < (s2 = L(v2 / b2)))
                        for (i2 <= s2 && (s2 = i2 - 1), f2 = (l2 = M2(N2, s2, i2)).length, d2 = h2.length; 1 == B2(l2, h2, f2, d2); )
                          s2--, D2(l2, w2 < f2 ? O2 : N2, f2, i2), f2 = l2.length, a2 = 1;
                      else
                        0 == s2 && (a2 = s2 = 1), f2 = (l2 = N2.slice()).length;
                      if (f2 < d2 && (l2 = [0].concat(l2)), D2(h2, l2, d2, i2), d2 = h2.length, -1 == a2)
                        for (; B2(N2, h2, w2, d2) < 1; )
                          s2++, D2(h2, w2 < d2 ? O2 : N2, d2, i2), d2 = h2.length;
                    } else
                      0 === a2 && (s2++, h2 = [0]);
                    g2[u2++] = s2, h2[0] ? h2[d2++] = S2[m2] || 0 : (h2 = [S2[m2]], d2 = 1);
                  } while ((m2++ < y2 || null != h2[0]) && x2--);
                  c2 = null != h2[0], g2[0] || g2.splice(0, 1);
                }
                if (i2 == U) {
                  for (u2 = 1, x2 = g2[0]; 10 <= x2; x2 /= 10, u2++)
                    ;
                  E(p2, r3 + (p2.e = u2 + o2 * j - 1) + 1, n2, c2);
                } else
                  p2.e = o2, p2.r = +c2;
                return p2;
              };
            }(), o = /^(-?)0([xbo])(?=\w[\w.]*$)/i, u = /^([^.]+)\.$/, c = /^\.([^.]+)$/, l = /^-?(Infinity|NaN)$/, g = /^\s*\+(?=[\w.])|^\s+|\s+$/g, p = function(e4, t4, r3, n2) {
              var i2, a2 = r3 ? t4 : t4.replace(g, "");
              if (l.test(a2))
                e4.s = isNaN(a2) ? null : a2 < 0 ? -1 : 1, e4.c = e4.e = null;
              else {
                if (!r3 && (a2 = a2.replace(o, function(e5, t5, r4) {
                  return i2 = "x" == (r4 = r4.toLowerCase()) ? 16 : "b" == r4 ? 2 : 8, n2 && n2 != i2 ? e5 : t5;
                }), n2 && (i2 = n2, a2 = a2.replace(u, "$1").replace(c, "0.$1")), t4 != a2))
                  return new A(a2, i2);
                if (A.DEBUG)
                  throw Error(T + "Not a" + (n2 ? " base " + n2 : "") + " number: " + t4);
                e4.c = e4.e = e4.s = null;
              }
            }, n.absoluteValue = n.abs = function() {
              var e4 = new A(this);
              return e4.s < 0 && (e4.s = 1), e4;
            }, n.comparedTo = function(e4, t4) {
              return q(this, new A(e4, t4));
            }, n.decimalPlaces = n.dp = function(e4, t4) {
              var r3, n2, i2;
              if (null != e4)
                return Z(e4, 0, $6), null == t4 ? t4 = w : Z(t4, 0, 8), E(new A(this), e4 + this.e + 1, t4);
              if (!(r3 = this.c))
                return null;
              if (n2 = ((i2 = r3.length - 1) - G(this.e / j)) * j, i2 = r3[i2])
                for (; i2 % 10 == 0; i2 /= 10, n2--)
                  ;
              return n2 < 0 && (n2 = 0), n2;
            }, n.dividedBy = n.div = function(e4, t4) {
              return y(this, new A(e4, t4), b, w);
            }, n.dividedToIntegerBy = n.idiv = function(e4, t4) {
              return y(this, new A(e4, t4), 0, 1);
            }, n.exponentiatedBy = n.pow = function(e4, t4) {
              var r3, n2, i2, a2, o2, u2, c2, s2, l2 = this;
              if ((e4 = new A(e4)).c && !e4.isInteger())
                throw Error(T + "Exponent not an integer: " + F(e4));
              if (null != t4 && (t4 = new A(t4)), o2 = 14 < e4.e, !l2.c || !l2.c[0] || 1 == l2.c[0] && !l2.e && 1 == l2.c.length || !e4.c || !e4.c[0])
                return s2 = new A(Math.pow(+F(l2), o2 ? 2 - z(e4) : +F(e4))), t4 ? s2.mod(t4) : s2;
              if (u2 = e4.s < 0, t4) {
                if (t4.c ? !t4.c[0] : !t4.s)
                  return new A(NaN);
                (n2 = !u2 && l2.isInteger() && t4.isInteger()) && (l2 = l2.mod(t4));
              } else {
                if (9 < e4.e && (0 < l2.e || l2.e < -1 || (0 == l2.e ? 1 < l2.c[0] || o2 && 24e7 <= l2.c[1] : l2.c[0] < 8e13 || o2 && l2.c[0] <= 9999975e7)))
                  return a2 = l2.s < 0 && z(e4) ? -0 : 0, -1 < l2.e && (a2 = 1 / a2), new A(u2 ? 1 / a2 : a2);
                S && (a2 = _(S / j + 2));
              }
              for (c2 = o2 ? (r3 = new A(0.5), u2 && (e4.s = 1), z(e4)) : (i2 = Math.abs(+F(e4))) % 2, s2 = new A(d); ; ) {
                if (c2) {
                  if (!(s2 = s2.times(l2)).c)
                    break;
                  a2 ? s2.c.length > a2 && (s2.c.length = a2) : n2 && (s2 = s2.mod(t4));
                }
                if (i2) {
                  if (0 === (i2 = L(i2 / 2)))
                    break;
                  c2 = i2 % 2;
                } else if (E(e4 = e4.times(r3), e4.e + 1, 1), 14 < e4.e)
                  c2 = z(e4);
                else {
                  if (0 == (i2 = +F(e4)))
                    break;
                  c2 = i2 % 2;
                }
                l2 = l2.times(l2), a2 ? l2.c && l2.c.length > a2 && (l2.c.length = a2) : n2 && (l2 = l2.mod(t4));
              }
              return n2 ? s2 : (u2 && (s2 = d.div(s2)), t4 ? s2.mod(t4) : a2 ? E(s2, S, w, void 0) : s2);
            }, n.integerValue = function(e4) {
              var t4 = new A(this);
              return null == e4 ? e4 = w : Z(e4, 0, 8), E(t4, t4.e + 1, e4);
            }, n.isEqualTo = n.eq = function(e4, t4) {
              return 0 === q(this, new A(e4, t4));
            }, n.isFinite = function() {
              return !!this.c;
            }, n.isGreaterThan = n.gt = function(e4, t4) {
              return 0 < q(this, new A(e4, t4));
            }, n.isGreaterThanOrEqualTo = n.gte = function(e4, t4) {
              return 1 === (t4 = q(this, new A(e4, t4))) || 0 === t4;
            }, n.isInteger = function() {
              return !!this.c && G(this.e / j) > this.c.length - 2;
            }, n.isLessThan = n.lt = function(e4, t4) {
              return q(this, new A(e4, t4)) < 0;
            }, n.isLessThanOrEqualTo = n.lte = function(e4, t4) {
              return -1 === (t4 = q(this, new A(e4, t4))) || 0 === t4;
            }, n.isNaN = function() {
              return !this.s;
            }, n.isNegative = function() {
              return this.s < 0;
            }, n.isPositive = function() {
              return 0 < this.s;
            }, n.isZero = function() {
              return !!this.c && 0 == this.c[0];
            }, n.minus = function(e4, t4) {
              var r3, n2, i2, a2, o2 = this, u2 = o2.s;
              if (t4 = (e4 = new A(e4, t4)).s, !u2 || !t4)
                return new A(NaN);
              if (u2 != t4)
                return e4.s = -t4, o2.plus(e4);
              var c2 = o2.e / j, s2 = e4.e / j, l2 = o2.c, f2 = e4.c;
              if (!c2 || !s2) {
                if (!l2 || !f2)
                  return l2 ? (e4.s = -t4, e4) : new A(f2 ? o2 : NaN);
                if (!l2[0] || !f2[0])
                  return f2[0] ? (e4.s = -t4, e4) : new A(l2[0] ? o2 : 3 == w ? -0 : 0);
              }
              if (c2 = G(c2), s2 = G(s2), l2 = l2.slice(), u2 = c2 - s2) {
                for ((i2 = (a2 = u2 < 0) ? (u2 = -u2, l2) : (s2 = c2, f2)).reverse(), t4 = u2; t4--; i2.push(0))
                  ;
                i2.reverse();
              } else
                for (n2 = (a2 = (u2 = l2.length) < (t4 = f2.length)) ? u2 : t4, u2 = t4 = 0; t4 < n2; t4++)
                  if (l2[t4] != f2[t4]) {
                    a2 = l2[t4] < f2[t4];
                    break;
                  }
              if (a2 && (i2 = l2, l2 = f2, f2 = i2, e4.s = -e4.s), 0 < (t4 = (n2 = f2.length) - (r3 = l2.length)))
                for (; t4--; l2[r3++] = 0)
                  ;
              for (t4 = U - 1; u2 < n2; ) {
                if (l2[--n2] < f2[n2]) {
                  for (r3 = n2; r3 && !l2[--r3]; l2[r3] = t4)
                    ;
                  --l2[r3], l2[n2] += U;
                }
                l2[n2] -= f2[n2];
              }
              for (; 0 == l2[0]; l2.splice(0, 1), --s2)
                ;
              return l2[0] ? D(e4, l2, s2) : (e4.s = 3 == w ? -1 : 1, e4.c = [e4.e = 0], e4);
            }, n.modulo = n.mod = function(e4, t4) {
              var r3, n2, i2 = this;
              return e4 = new A(e4, t4), !i2.c || !e4.s || e4.c && !e4.c[0] ? new A(NaN) : !e4.c || i2.c && !i2.c[0] ? new A(i2) : (9 == a ? (n2 = e4.s, e4.s = 1, r3 = y(i2, e4, 0, 3), e4.s = n2, r3.s *= n2) : r3 = y(i2, e4, 0, a), (e4 = i2.minus(r3.times(e4))).c[0] || 1 != a || (e4.s = i2.s), e4);
            }, n.multipliedBy = n.times = function(e4, t4) {
              var r3, n2, i2, a2, o2, u2, c2, s2, l2, f2, p2, g2, h2, d2, v2, m2 = this, y2 = m2.c, b2 = (e4 = new A(e4, t4)).c;
              if (!(y2 && b2 && y2[0] && b2[0]))
                return !m2.s || !e4.s || y2 && !y2[0] && !b2 || b2 && !b2[0] && !y2 ? e4.c = e4.e = e4.s = null : (e4.s *= m2.s, y2 && b2 ? (e4.c = [0], e4.e = 0) : e4.c = e4.e = null), e4;
              for (n2 = G(m2.e / j) + G(e4.e / j), e4.s *= m2.s, (c2 = y2.length) < (f2 = b2.length) && (h2 = y2, y2 = b2, b2 = h2, i2 = c2, c2 = f2, f2 = i2), i2 = c2 + f2, h2 = []; i2--; h2.push(0))
                ;
              for (d2 = U, v2 = I, i2 = f2; 0 <= --i2; ) {
                for (r3 = 0, p2 = b2[i2] % v2, g2 = b2[i2] / v2 | 0, a2 = i2 + (o2 = c2); i2 < a2; )
                  r3 = ((s2 = p2 * (s2 = y2[--o2] % v2) + (u2 = g2 * s2 + (l2 = y2[o2] / v2 | 0) * p2) % v2 * v2 + h2[a2] + r3) / d2 | 0) + (u2 / v2 | 0) + g2 * l2, h2[a2--] = s2 % d2;
                h2[a2] = r3;
              }
              return r3 ? ++n2 : h2.splice(0, 1), D(e4, h2, n2);
            }, n.negated = function() {
              var e4 = new A(this);
              return e4.s = -e4.s || null, e4;
            }, n.plus = function(e4, t4) {
              var r3, n2 = this, i2 = n2.s;
              if (t4 = (e4 = new A(e4, t4)).s, !i2 || !t4)
                return new A(NaN);
              if (i2 != t4)
                return e4.s = -t4, n2.minus(e4);
              var a2 = n2.e / j, o2 = e4.e / j, u2 = n2.c, c2 = e4.c;
              if (!a2 || !o2) {
                if (!u2 || !c2)
                  return new A(i2 / 0);
                if (!u2[0] || !c2[0])
                  return c2[0] ? e4 : new A(u2[0] ? n2 : 0 * i2);
              }
              if (a2 = G(a2), o2 = G(o2), u2 = u2.slice(), i2 = a2 - o2) {
                for ((r3 = 0 < i2 ? (o2 = a2, c2) : (i2 = -i2, u2)).reverse(); i2--; r3.push(0))
                  ;
                r3.reverse();
              }
              for ((i2 = u2.length) - (t4 = c2.length) < 0 && (r3 = c2, c2 = u2, u2 = r3, t4 = i2), i2 = 0; t4; )
                i2 = (u2[--t4] = u2[t4] + c2[t4] + i2) / U | 0, u2[t4] = U === u2[t4] ? 0 : u2[t4] % U;
              return i2 && (u2 = [i2].concat(u2), ++o2), D(e4, u2, o2);
            }, n.precision = n.sd = function(e4, t4) {
              var r3, n2, i2;
              if (null != e4 && e4 !== !!e4)
                return Z(e4, 1, $6), null == t4 ? t4 = w : Z(t4, 0, 8), E(new A(this), e4, t4);
              if (!(r3 = this.c))
                return null;
              if (n2 = (i2 = r3.length - 1) * j + 1, i2 = r3[i2]) {
                for (; i2 % 10 == 0; i2 /= 10, n2--)
                  ;
                for (i2 = r3[0]; 10 <= i2; i2 /= 10, n2++)
                  ;
              }
              return e4 && this.e + 1 > n2 && (n2 = this.e + 1), n2;
            }, n.shiftedBy = function(e4) {
              return Z(e4, -C, C), this.times("1e" + e4);
            }, n.squareRoot = n.sqrt = function() {
              var e4, t4, r3, n2, i2, a2 = this, o2 = a2.c, u2 = a2.s, c2 = a2.e, s2 = b + 4, l2 = new A("0.5");
              if (1 !== u2 || !o2 || !o2[0])
                return new A(!u2 || u2 < 0 && (!o2 || o2[0]) ? NaN : o2 ? a2 : 1 / 0);
              if ((r3 = 0 == (u2 = Math.sqrt(+F(a2))) || u2 == 1 / 0 ? (((t4 = V(o2)).length + c2) % 2 == 0 && (t4 += "0"), u2 = Math.sqrt(+t4), c2 = G((c2 + 1) / 2) - (c2 < 0 || c2 % 2), new A(t4 = u2 == 1 / 0 ? "1e" + c2 : (t4 = u2.toExponential()).slice(0, t4.indexOf("e") + 1) + c2)) : new A(u2 + "")).c[0]) {
                for ((u2 = (c2 = r3.e) + s2) < 3 && (u2 = 0); ; )
                  if (i2 = r3, r3 = l2.times(i2.plus(y(a2, i2, s2, 1))), V(i2.c).slice(0, u2) === (t4 = V(r3.c)).slice(0, u2)) {
                    if (r3.e < c2 && --u2, "9999" != (t4 = t4.slice(u2 - 3, u2 + 1)) && (n2 || "4999" != t4)) {
                      +t4 && (+t4.slice(1) || "5" != t4.charAt(0)) || (E(r3, r3.e + b + 2, 1), e4 = !r3.times(r3).eq(a2));
                      break;
                    }
                    if (!n2 && (E(i2, i2.e + b + 2, 0), i2.times(i2).eq(a2))) {
                      r3 = i2;
                      break;
                    }
                    s2 += 4, u2 += 4, n2 = 1;
                  }
              }
              return E(r3, r3.e + b + 1, w, e4);
            }, n.toExponential = function(e4, t4) {
              return null != e4 && (Z(e4, 0, $6), e4++), i(this, e4, t4, 1);
            }, n.toFixed = function(e4, t4) {
              return null != e4 && (Z(e4, 0, $6), e4 = e4 + this.e + 1), i(this, e4, t4);
            }, n.toFormat = function(e4, t4, r3) {
              var n2;
              if (null == r3)
                null != e4 && t4 && "object" == typeof t4 ? (r3 = t4, t4 = null) : e4 && "object" == typeof e4 ? (r3 = e4, e4 = t4 = null) : r3 = N;
              else if ("object" != typeof r3)
                throw Error(T + "Argument not an object: " + r3);
              if (n2 = this.toFixed(e4, t4), this.c) {
                var i2, a2 = n2.split("."), o2 = +r3.groupSize, u2 = +r3.secondaryGroupSize, c2 = r3.groupSeparator || "", s2 = a2[0], l2 = a2[1], f2 = this.s < 0, p2 = f2 ? s2.slice(1) : s2, g2 = p2.length;
                if (u2 && (i2 = o2, o2 = u2, g2 -= u2 = i2), 0 < o2 && 0 < g2) {
                  for (i2 = g2 % o2 || o2, s2 = p2.substr(0, i2); i2 < g2; i2 += o2)
                    s2 += c2 + p2.substr(i2, o2);
                  0 < u2 && (s2 += c2 + p2.slice(i2)), f2 && (s2 = "-" + s2);
                }
                n2 = l2 ? s2 + (r3.decimalSeparator || "") + ((u2 = +r3.fractionGroupSize) ? l2.replace(new RegExp("\\d{" + u2 + "}\\B", "g"), "$&" + (r3.fractionGroupSeparator || "")) : l2) : s2;
              }
              return (r3.prefix || "") + n2 + (r3.suffix || "");
            }, n.toFraction = function(e4) {
              var t4, r3, n2, i2, a2, o2, u2, c2, s2, l2, f2, p2, g2 = this, h2 = g2.c;
              if (null != e4 && (!(u2 = new A(e4)).isInteger() && (u2.c || 1 !== u2.s) || u2.lt(d)))
                throw Error(T + "Argument " + (u2.isInteger() ? "out of range: " : "not an integer: ") + F(u2));
              if (!h2)
                return new A(g2);
              for (t4 = new A(d), s2 = r3 = new A(d), n2 = c2 = new A(d), p2 = V(h2), a2 = t4.e = p2.length - g2.e - 1, t4.c[0] = R[(o2 = a2 % j) < 0 ? j + o2 : o2], e4 = !e4 || 0 < u2.comparedTo(t4) ? 0 < a2 ? t4 : s2 : u2, o2 = O, O = 1 / 0, u2 = new A(p2), c2.c[0] = 0; l2 = y(u2, t4, 0, 1), 1 != (i2 = r3.plus(l2.times(n2))).comparedTo(e4); )
                r3 = n2, n2 = i2, s2 = c2.plus(l2.times(i2 = s2)), c2 = i2, t4 = u2.minus(l2.times(i2 = t4)), u2 = i2;
              return i2 = y(e4.minus(r3), n2, 0, 1), c2 = c2.plus(i2.times(s2)), r3 = r3.plus(i2.times(n2)), c2.s = s2.s = g2.s, f2 = y(s2, n2, a2 *= 2, w).minus(g2).abs().comparedTo(y(c2, r3, a2, w).minus(g2).abs()) < 1 ? [s2, n2] : [c2, r3], O = o2, f2;
            }, n.toNumber = function() {
              return +F(this);
            }, n.toPrecision = function(e4, t4) {
              return null != e4 && Z(e4, 1, $6), i(this, e4, t4, 2);
            }, n.toString = function(e4) {
              var t4, r3 = this, n2 = r3.s, i2 = r3.e;
              return null === i2 ? n2 ? (t4 = "Infinity", n2 < 0 && (t4 = "-" + t4)) : t4 = "NaN" : (t4 = null == e4 ? i2 <= h || v <= i2 ? W(V(r3.c), i2) : H(V(r3.c), i2, "0") : 10 === e4 ? H(V((r3 = E(new A(r3), b + i2 + 1, w)).c), r3.e, "0") : (Z(e4, 2, M.length, "Base"), f(H(V(r3.c), i2, "0"), 10, e4, n2, true)), n2 < 0 && r3.c[0] && (t4 = "-" + t4)), t4;
            }, n.valueOf = n.toJSON = function() {
              return F(this);
            }, n._isBigNumber = true, "function" == typeof Symbol && "symbol" == typeof Symbol.iterator && (n[Symbol.toStringTag] = "BigNumber", n[Symbol.for("nodejs.util.inspect.custom")] = n.valueOf), null != t3 && A.set(t3), A;
          }()).default = t2.BigNumber = t2, void 0 !== r && r.exports ? r.exports = t2 : (e2 || (e2 = "undefined" != typeof self && self ? self : window), e2.BigNumber = t2);
        }(this);
      }, {}], 2: [function(e, t, r) {
        "use strict";
        t.exports = { languageTag: "en-US", delimiters: { thousands: ",", decimal: "." }, abbreviations: { thousand: "k", million: "m", billion: "b", trillion: "t" }, spaceSeparated: false, ordinal: function(e2) {
          var t2 = e2 % 10;
          return 1 == ~~(e2 % 100 / 10) ? "th" : 1 === t2 ? "st" : 2 === t2 ? "nd" : 3 === t2 ? "rd" : "th";
        }, currency: { symbol: "$", position: "prefix", code: "USD" }, currencyFormat: { thousandSeparated: true, totalLength: 4, spaceSeparated: true }, formats: { fourDigits: { totalLength: 4, spaceSeparated: true }, fullWithTwoDecimals: { output: "currency", thousandSeparated: true, mantissa: 2 }, fullWithTwoDecimalsNoCurrency: { thousandSeparated: true, mantissa: 2 }, fullWithNoDecimals: { output: "currency", thousandSeparated: true, mantissa: 0 } } };
      }, {}], 3: [function(e, t, r) {
        "use strict";
        function C(e2, t2) {
          return function(e3) {
            if (Array.isArray(e3))
              return e3;
          }(e2) || function(e3, t3) {
            var r2 = [], n2 = true, i2 = false, a = void 0;
            try {
              for (var o2, u2 = e3[Symbol.iterator](); !(n2 = (o2 = u2.next()).done) && (r2.push(o2.value), !t3 || r2.length !== t3); n2 = true)
                ;
            } catch (e4) {
              i2 = true, a = e4;
            } finally {
              try {
                n2 || null == u2.return || u2.return();
              } finally {
                if (i2)
                  throw a;
              }
            }
            return r2;
          }(e2, t2) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }();
        }
        var R = e("./globalState"), o = e("./validating"), u = e("./parsing"), n = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], M = { general: { scale: 1024, suffixes: n, marker: "bd" }, binary: { scale: 1024, suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], marker: "b" }, decimal: { scale: 1e3, suffixes: n, marker: "d" } }, I = { totalLength: 0, characteristic: 0, forceAverage: false, average: false, mantissa: -1, optionalMantissa: true, thousandSeparated: false, spaceSeparated: false, negative: "sign", forceSign: false };
        function i(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, r2 = 2 < arguments.length ? arguments[2] : void 0;
          if ("string" == typeof t2 && (t2 = u.parseFormat(t2)), !o.validateFormat(t2))
            return "ERROR: invalid format";
          var n2 = t2.prefix || "", i2 = t2.postfix || "", a = function(e3, t3, r3) {
            switch (t3.output) {
              case "currency":
                return t3 = A(t3, R.currentCurrencyDefaultFormat()), function(e4, t4, r4) {
                  var n4 = r4.currentCurrency(), i4 = Object.assign({}, I, t4), a3 = void 0, o3 = "", u3 = !!i4.totalLength || !!i4.forceAverage || i4.average, c2 = t4.currencyPosition || n4.position, s2 = t4.currencySymbol || n4.symbol;
                  i4.spaceSeparated && (o3 = " ");
                  "infix" === c2 && (a3 = o3 + s2 + o3);
                  var l2 = D({ instance: e4, providedFormat: t4, state: r4, decimalSeparator: a3 });
                  "prefix" === c2 && (l2 = e4._value < 0 && "sign" === i4.negative ? "-".concat(o3).concat(s2).concat(l2.slice(1)) : s2 + o3 + l2);
                  c2 && "postfix" !== c2 || (l2 = l2 + (o3 = u3 ? "" : o3) + s2);
                  return l2;
                }(e3, t3, R);
              case "percent":
                return t3 = A(t3, R.currentPercentageDefaultFormat()), function(e4, t4, r4, n4) {
                  var i4 = t4.prefixSymbol, a3 = D({ instance: n4(100 * e4._value), providedFormat: t4, state: r4 }), o3 = Object.assign({}, I, t4);
                  if (i4)
                    return "%".concat(o3.spaceSeparated ? " " : "").concat(a3);
                  return "".concat(a3).concat(o3.spaceSeparated ? " " : "", "%");
                }(e3, t3, R, r3);
              case "byte":
                return t3 = A(t3, R.currentByteDefaultFormat()), h = e3, v = R, m = r3, y = (d = t3).base || "binary", b = M[y], w = B(h._value, b.suffixes, b.scale), O = w.value, x = w.suffix, S = D({ instance: m(O), providedFormat: d, state: v, defaults: v.currentByteDefaultFormat() }), N = v.currentAbbreviations(), "".concat(S).concat(N.spaced ? " " : "").concat(x);
              case "time":
                return t3 = A(t3, R.currentTimeDefaultFormat()), l = e3, f = Math.floor(l._value / 60 / 60), p2 = Math.floor((l._value - 60 * f * 60) / 60), g = Math.round(l._value - 60 * f * 60 - 60 * p2), "".concat(f, ":").concat(p2 < 10 ? "0" : "").concat(p2, ":").concat(g < 10 ? "0" : "").concat(g);
              case "ordinal":
                return t3 = A(t3, R.currentOrdinalDefaultFormat()), n3 = e3, i3 = t3, o2 = (a2 = R).currentOrdinal(), u2 = Object.assign({}, I, i3), c = D({ instance: n3, providedFormat: i3, state: a2 }), s = o2(n3._value), "".concat(c).concat(u2.spaceSeparated ? " " : "").concat(s);
              case "number":
              default:
                return D({ instance: e3, providedFormat: t3, numbro: r3 });
            }
            var n3, i3, a2, o2, u2, c, s;
            var l, f, p2, g;
            var h, d, v, m, y, b, w, O, x, S, N;
          }(e2, t2, r2);
          return a = (a = n2 + a) + i2;
        }
        function B(e2, t2, r2) {
          var n2 = t2[0], i2 = Math.abs(e2);
          if (r2 <= i2) {
            for (var a = 1; a < t2.length; ++a) {
              var o2 = Math.pow(r2, a), u2 = Math.pow(r2, a + 1);
              if (o2 <= i2 && i2 < u2) {
                n2 = t2[a], e2 /= o2;
                break;
              }
            }
            n2 === t2[0] && (e2 /= Math.pow(r2, t2.length - 1), n2 = t2[t2.length - 1]);
          }
          return { value: e2, suffix: n2 };
        }
        function p(e2) {
          for (var t2 = "", r2 = 0; r2 < e2; r2++)
            t2 += "0";
          return t2;
        }
        function $6(e2, t2) {
          return -1 !== e2.toString().indexOf("e") ? function(e3, t3) {
            var r2 = e3.toString(), n2 = C(r2.split("e"), 2), i2 = n2[0], a = n2[1], o2 = C(i2.split("."), 2), u2 = o2[0], c = o2[1], s = void 0 === c ? "" : c;
            if (0 < +a)
              r2 = u2 + s + p(a - s.length);
            else {
              var l = ".";
              l = +u2 < 0 ? "-0".concat(l) : "0".concat(l);
              var f = (p(-a - 1) + Math.abs(u2) + s).substr(0, t3);
              f.length < t3 && (f += p(t3 - f.length)), r2 = l + f;
            }
            return 0 < +a && 0 < t3 && (r2 += ".".concat(p(t3))), r2;
          }(e2, t2) : (Math.round(+"".concat(e2, "e+").concat(t2)) / Math.pow(10, t2)).toFixed(t2);
        }
        function D(e2) {
          var t2 = e2.instance, r2 = e2.providedFormat, n2 = e2.state, i2 = void 0 === n2 ? R : n2, a = e2.decimalSeparator, o2 = e2.defaults, u2 = void 0 === o2 ? i2.currentDefaults() : o2, c = t2._value;
          if (0 === c && i2.hasZeroFormat())
            return i2.getZeroFormat();
          if (!isFinite(c))
            return c.toString();
          var s, l, f, p2, g, h, d, v, m = Object.assign({}, I, u2, r2), y = m.totalLength, b = y ? 0 : m.characteristic, w = m.optionalCharacteristic, O = m.forceAverage, x = !!y || !!O || m.average, S = y ? -1 : x && void 0 === r2.mantissa ? 0 : m.mantissa, N = !y && (void 0 === r2.optionalMantissa ? -1 === S : m.optionalMantissa), M2 = m.trimMantissa, B2 = m.thousandSeparated, D2 = m.spaceSeparated, A2 = m.negative, E = m.forceSign, F = m.exponential, k = "";
          if (x) {
            var _ = function(e3) {
              var t3 = e3.value, r3 = e3.forceAverage, n3 = e3.abbreviations, i3 = e3.spaceSeparated, a2 = void 0 !== i3 && i3, o3 = e3.totalLength, u3 = void 0 === o3 ? 0 : o3, c2 = "", s2 = Math.abs(t3), l2 = -1;
              if (s2 >= Math.pow(10, 12) && !r3 || "trillion" === r3 ? (c2 = n3.trillion, t3 /= Math.pow(10, 12)) : s2 < Math.pow(10, 12) && s2 >= Math.pow(10, 9) && !r3 || "billion" === r3 ? (c2 = n3.billion, t3 /= Math.pow(10, 9)) : s2 < Math.pow(10, 9) && s2 >= Math.pow(10, 6) && !r3 || "million" === r3 ? (c2 = n3.million, t3 /= Math.pow(10, 6)) : (s2 < Math.pow(10, 6) && s2 >= Math.pow(10, 3) && !r3 || "thousand" === r3) && (c2 = n3.thousand, t3 /= Math.pow(10, 3)), c2 && (c2 = (a2 ? " " : "") + c2), u3) {
                var f2 = t3.toString().split(".")[0];
                l2 = Math.max(u3 - f2.length, 0);
              }
              return { value: t3, abbreviation: c2, mantissaPrecision: l2 };
            }({ value: c, forceAverage: O, abbreviations: i2.currentAbbreviations(), spaceSeparated: D2, totalLength: y });
            c = _.value, k += _.abbreviation, y && (S = _.mantissaPrecision);
          }
          if (F) {
            var L = (l = (s = { value: c, characteristicPrecision: b }).value, f = s.characteristicPrecision, p2 = void 0 === f ? 0 : f, g = C(l.toExponential().split("e"), 2), h = g[0], d = g[1], v = +h, p2 && 1 < p2 && (v *= Math.pow(10, p2 - 1), d = 0 <= (d = +d - (p2 - 1)) ? "+".concat(d) : d), { value: v, abbreviation: "e".concat(d) });
            c = L.value, k = L.abbreviation + k;
          }
          var T, P, U, j = function(e3, t3, r3, n3, i3) {
            if (-1 === n3)
              return e3;
            var a2 = $6(t3, n3), o3 = C(a2.toString().split("."), 2), u3 = o3[0], c2 = o3[1], s2 = void 0 === c2 ? "" : c2;
            if (s2.match(/^0+$/) && (r3 || i3))
              return u3;
            var l2 = s2.match(/0+$/);
            return i3 && l2 ? "".concat(u3, ".").concat(s2.toString().slice(0, l2.index)) : a2.toString();
          }(c.toString(), c, N, S, M2);
          return j = function(e3, t3, r3, n3, i3) {
            var a2 = n3.currentDelimiters(), o3 = a2.thousands;
            i3 = i3 || a2.decimal;
            var u3 = a2.thousandsSize || 3, c2 = e3.toString(), s2 = c2.split(".")[0], l2 = c2.split(".")[1];
            return r3 && (t3 < 0 && (s2 = s2.slice(1)), function(e4, t4) {
              for (var r4 = [], n4 = 0, i4 = e4; 0 < i4; i4--)
                n4 === t4 && (r4.unshift(i4), n4 = 0), n4++;
              return r4;
            }(s2.length, u3).forEach(function(e4, t4) {
              s2 = s2.slice(0, e4 + t4) + o3 + s2.slice(e4 + t4);
            }), t3 < 0 && (s2 = "-".concat(s2))), c2 = l2 ? s2 + i3 + l2 : s2;
          }(j = function(e3, t3, r3, n3) {
            var i3 = e3, a2 = C(i3.toString().split("."), 2), o3 = a2[0], u3 = a2[1];
            if (o3.match(/^-?0$/) && r3)
              return u3 ? "".concat(o3.replace("0", ""), ".").concat(u3) : o3.replace("0", "");
            if (o3.length < n3)
              for (var c2 = n3 - o3.length, s2 = 0; s2 < c2; s2++)
                i3 = "0".concat(i3);
            return i3.toString();
          }(j, 0, w, b), c, B2, i2, a), (x || F) && (j = j + k), (E || c < 0) && (T = j, U = A2, j = 0 === (P = c) ? T : 0 == +T ? T.replace("-", "") : 0 < P ? "+".concat(T) : "sign" === U ? T : "(".concat(T.replace("-", ""), ")")), j;
        }
        function A(e2, t2) {
          if (!e2)
            return t2;
          var r2 = Object.keys(e2);
          return 1 === r2.length && "output" === r2[0] ? t2 : e2;
        }
        t.exports = function(n2) {
          return { format: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return i.apply(void 0, t2.concat([n2]));
          }, getByteUnit: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return (function(e3) {
              var t3 = M.general;
              return B(e3._value, t3.suffixes, t3.scale).suffix;
            }).apply(void 0, t2.concat([n2]));
          }, getBinaryByteUnit: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return (function(e3) {
              var t3 = M.binary;
              return B(e3._value, t3.suffixes, t3.scale).suffix;
            }).apply(void 0, t2.concat([n2]));
          }, getDecimalByteUnit: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return (function(e3) {
              var t3 = M.decimal;
              return B(e3._value, t3.suffixes, t3.scale).suffix;
            }).apply(void 0, t2.concat([n2]));
          }, formatOrDefault: A };
        };
      }, { "./globalState": 4, "./parsing": 8, "./validating": 10 }], 4: [function(e, t, r) {
        "use strict";
        var i = e("./en-US"), n = e("./validating"), a = e("./parsing"), o = {}, u = void 0, c = {}, s = null, l = {};
        function f(e2) {
          u = e2;
        }
        function p() {
          return c[u];
        }
        o.languages = function() {
          return Object.assign({}, c);
        }, o.currentLanguage = function() {
          return u;
        }, o.currentCurrency = function() {
          return p().currency;
        }, o.currentAbbreviations = function() {
          return p().abbreviations;
        }, o.currentDelimiters = function() {
          return p().delimiters;
        }, o.currentOrdinal = function() {
          return p().ordinal;
        }, o.currentDefaults = function() {
          return Object.assign({}, p().defaults, l);
        }, o.currentOrdinalDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().ordinalFormat);
        }, o.currentByteDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().byteFormat);
        }, o.currentPercentageDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().percentageFormat);
        }, o.currentCurrencyDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().currencyFormat);
        }, o.currentTimeDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().timeFormat);
        }, o.setDefaults = function(e2) {
          e2 = a.parseFormat(e2), n.validateFormat(e2) && (l = e2);
        }, o.getZeroFormat = function() {
          return s;
        }, o.setZeroFormat = function(e2) {
          return s = "string" == typeof e2 ? e2 : null;
        }, o.hasZeroFormat = function() {
          return null !== s;
        }, o.languageData = function(e2) {
          if (e2) {
            if (c[e2])
              return c[e2];
            throw new Error('Unknown tag "'.concat(e2, '"'));
          }
          return p();
        }, o.registerLanguage = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
          if (!n.validateLanguage(e2))
            throw new Error("Invalid language data");
          c[e2.languageTag] = e2, t2 && f(e2.languageTag);
        }, o.setLanguage = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : i.languageTag;
          if (!c[e2]) {
            var r2 = e2.split("-")[0], n2 = Object.keys(c).find(function(e3) {
              return e3.split("-")[0] === r2;
            });
            return c[n2] ? void f(n2) : void f(t2);
          }
          f(e2);
        }, o.registerLanguage(i), u = i.languageTag, t.exports = o;
      }, { "./en-US": 2, "./parsing": 8, "./validating": 10 }], 5: [function(n, e, t) {
        "use strict";
        e.exports = function(t2) {
          return { loadLanguagesInNode: function(e2) {
            return r = t2, void e2.forEach(function(t3) {
              var e3 = void 0;
              try {
                e3 = n("../languages/".concat(t3));
              } catch (e4) {
                console.error('Unable to load "'.concat(t3, '". No matching language file found.'));
              }
              e3 && r.registerLanguage(e3);
            });
            var r;
          } };
        };
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var c = e("bignumber.js");
        function a(e2, t2, r2) {
          var n = new c(e2._value), i = t2;
          return r2.isNumbro(t2) && (i = t2._value), i = new c(i), e2._value = n.minus(i).toNumber(), e2;
        }
        t.exports = function(u) {
          return { add: function(e2, t2) {
            return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) && (o = n._value), o = new c(o), r2._value = a2.plus(o).toNumber(), r2;
            var r2, n, i, a2, o;
          }, subtract: function(e2, t2) {
            return a(e2, t2, u);
          }, multiply: function(e2, t2) {
            return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) && (o = n._value), o = new c(o), r2._value = a2.times(o).toNumber(), r2;
            var r2, n, i, a2, o;
          }, divide: function(e2, t2) {
            return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) && (o = n._value), o = new c(o), r2._value = a2.dividedBy(o).toNumber(), r2;
            var r2, n, i, a2, o;
          }, set: function(e2, t2) {
            return r2 = e2, i = n = t2, u.isNumbro(n) && (i = n._value), r2._value = i, r2;
            var r2, n, i;
          }, difference: function(e2, t2) {
            return r2 = t2, a(i = (n = u)(e2._value), r2, n), Math.abs(i._value);
            var r2, n, i;
          } };
        };
      }, { "bignumber.js": 1 }], 7: [function(e, t, r) {
        "use strict";
        function i(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
          }
        }
        var a = e("./globalState"), n = e("./validating"), o = e("./loading")(g), u = e("./unformatting"), c = e("./formatting")(g), s = e("./manipulating")(g), l = e("./parsing"), f = function() {
          function t2(e3) {
            !function(e4, t3) {
              if (!(e4 instanceof t3))
                throw new TypeError("Cannot call a class as a function");
            }(this, t2), this._value = e3;
          }
          var e2, r2, n2;
          return e2 = t2, (r2 = [{ key: "clone", value: function() {
            return g(this._value);
          } }, { key: "format", value: function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            return c.format(this, e3);
          } }, { key: "formatCurrency", value: function(e3) {
            return "string" == typeof e3 && (e3 = l.parseFormat(e3)), (e3 = c.formatOrDefault(e3, a.currentCurrencyDefaultFormat())).output = "currency", c.format(this, e3);
          } }, { key: "formatTime", value: function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            return e3.output = "time", c.format(this, e3);
          } }, { key: "binaryByteUnits", value: function() {
            return c.getBinaryByteUnit(this);
          } }, { key: "decimalByteUnits", value: function() {
            return c.getDecimalByteUnit(this);
          } }, { key: "byteUnits", value: function() {
            return c.getByteUnit(this);
          } }, { key: "difference", value: function(e3) {
            return s.difference(this, e3);
          } }, { key: "add", value: function(e3) {
            return s.add(this, e3);
          } }, { key: "subtract", value: function(e3) {
            return s.subtract(this, e3);
          } }, { key: "multiply", value: function(e3) {
            return s.multiply(this, e3);
          } }, { key: "divide", value: function(e3) {
            return s.divide(this, e3);
          } }, { key: "set", value: function(e3) {
            return s.set(this, p(e3));
          } }, { key: "value", value: function() {
            return this._value;
          } }, { key: "valueOf", value: function() {
            return this._value;
          } }]) && i(e2.prototype, r2), n2 && i(e2, n2), t2;
        }();
        function p(e2) {
          var t2 = e2;
          return g.isNumbro(e2) ? t2 = e2._value : "string" == typeof e2 ? t2 = g.unformat(e2) : isNaN(e2) && (t2 = NaN), t2;
        }
        function g(e2) {
          return new f(p(e2));
        }
        g.version = "2.1.2", g.isNumbro = function(e2) {
          return e2 instanceof f;
        }, g.language = a.currentLanguage, g.registerLanguage = a.registerLanguage, g.setLanguage = a.setLanguage, g.languages = a.languages, g.languageData = a.languageData, g.zeroFormat = a.setZeroFormat, g.defaultFormat = a.currentDefaults, g.setDefaults = a.setDefaults, g.defaultCurrencyFormat = a.currentCurrencyDefaultFormat, g.validate = n.validate, g.loadLanguagesInNode = o.loadLanguagesInNode, g.unformat = u.unformat, t.exports = g;
      }, { "./formatting": 3, "./globalState": 4, "./loading": 5, "./manipulating": 6, "./parsing": 8, "./unformatting": 9, "./validating": 10 }], 8: [function(e, t, r) {
        "use strict";
        t.exports = { parseFormat: function(e2) {
          var t2, r2, n, i, a, o, u, c, s, l, f, p, g, h, d, v, m, y, b, w, O = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
          return "string" != typeof e2 ? e2 : (r2 = O, e2 = (n = (t2 = e2).match(/^{([^}]*)}/)) ? (r2.prefix = n[1], t2.slice(n[0].length)) : t2, a = O, function(e3, t3) {
            if (-1 === e3.indexOf("$")) {
              if (-1 === e3.indexOf("%"))
                return -1 !== e3.indexOf("bd") ? (t3.output = "byte", t3.base = "general") : -1 !== e3.indexOf("b") ? (t3.output = "byte", t3.base = "binary") : -1 !== e3.indexOf("d") ? (t3.output = "byte", t3.base = "decimal") : -1 === e3.indexOf(":") ? -1 !== e3.indexOf("o") && (t3.output = "ordinal") : t3.output = "time";
              t3.output = "percent";
            } else
              t3.output = "currency";
          }(e2 = (o = (i = e2).match(/{([^}]*)}$/)) ? (a.postfix = o[1], i.slice(0, -o[0].length)) : i, O), u = O, (c = e2.match(/[1-9]+[0-9]*/)) && (u.totalLength = +c[0]), s = O, (l = e2.split(".")[0].match(/0+/)) && (s.characteristic = l[0].length), function(e3, t3) {
            if (-1 !== e3.indexOf(".")) {
              var r3 = e3.split(".")[0];
              t3.optionalCharacteristic = -1 === r3.indexOf("0");
            }
          }(e2, O), f = O, -1 !== e2.indexOf("a") && (f.average = true), g = O, -1 !== (p = e2).indexOf("K") ? g.forceAverage = "thousand" : -1 !== p.indexOf("M") ? g.forceAverage = "million" : -1 !== p.indexOf("B") ? g.forceAverage = "billion" : -1 !== p.indexOf("T") && (g.forceAverage = "trillion"), function(e3, t3) {
            var r3 = e3.split(".")[1];
            if (r3) {
              var n2 = r3.match(/0+/);
              n2 && (t3.mantissa = n2[0].length);
            }
          }(e2, O), d = O, (h = e2).match(/\[\.]/) ? d.optionalMantissa = true : h.match(/\./) && (d.optionalMantissa = false), v = O, -1 !== e2.indexOf(",") && (v.thousandSeparated = true), m = O, -1 !== e2.indexOf(" ") && (m.spaceSeparated = true), b = O, (y = e2).match(/^\+?\([^)]*\)$/) && (b.negative = "parenthesis"), y.match(/^\+?-/) && (b.negative = "sign"), w = O, e2.match(/^\+/) && (w.forceSign = true), O);
        } };
      }, {}], 9: [function(p, e, t) {
        "use strict";
        var O = [{ key: "ZiB", factor: Math.pow(1024, 7) }, { key: "ZB", factor: Math.pow(1e3, 7) }, { key: "YiB", factor: Math.pow(1024, 8) }, { key: "YB", factor: Math.pow(1e3, 8) }, { key: "TiB", factor: Math.pow(1024, 4) }, { key: "TB", factor: Math.pow(1e3, 4) }, { key: "PiB", factor: Math.pow(1024, 5) }, { key: "PB", factor: Math.pow(1e3, 5) }, { key: "MiB", factor: Math.pow(1024, 2) }, { key: "MB", factor: Math.pow(1e3, 2) }, { key: "KiB", factor: Math.pow(1024, 1) }, { key: "KB", factor: Math.pow(1e3, 1) }, { key: "GiB", factor: Math.pow(1024, 3) }, { key: "GB", factor: Math.pow(1e3, 3) }, { key: "EiB", factor: Math.pow(1024, 6) }, { key: "EB", factor: Math.pow(1e3, 6) }, { key: "B", factor: 1 }];
        function x(e2) {
          return e2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function g(e2, t2) {
          var r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "", n = 3 < arguments.length ? arguments[3] : void 0, i = 4 < arguments.length ? arguments[4] : void 0, a = 5 < arguments.length ? arguments[5] : void 0, o = 6 < arguments.length ? arguments[6] : void 0;
          if ("" !== e2)
            return e2 === i ? 0 : function e3(t3, r2) {
              var n2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "", i2 = 3 < arguments.length ? arguments[3] : void 0, a2 = 4 < arguments.length ? arguments[4] : void 0, o2 = 5 < arguments.length ? arguments[5] : void 0, u = 6 < arguments.length ? arguments[6] : void 0;
              if (!isNaN(+t3))
                return +t3;
              var c = "", s = t3.replace(/(^[^(]*)\((.*)\)([^)]*$)/, "$1$2$3");
              if (s !== t3)
                return -1 * e3(s, r2, n2, i2, a2, o2, u);
              for (var l = 0; l < O.length; l++) {
                var f = O[l];
                if ((c = t3.replace(f.key, "")) !== t3)
                  return e3(c, r2, n2, i2, a2, o2, u) * f.factor;
              }
              if ((c = t3.replace("%", "")) !== t3)
                return e3(c, r2, n2, i2, a2, o2, u) / 100;
              var p2 = parseFloat(t3);
              if (!isNaN(p2)) {
                var g2 = i2(p2);
                if (g2 && "." !== g2 && (c = t3.replace(new RegExp("".concat(x(g2), "$")), "")) !== t3)
                  return e3(c, r2, n2, i2, a2, o2, u);
                var h = {};
                Object.keys(o2).forEach(function(e4) {
                  h[o2[e4]] = e4;
                });
                for (var d = Object.keys(h).sort().reverse(), v = d.length, m = 0; m < v; m++) {
                  var y = d[m], b = h[y];
                  if ((c = t3.replace(y, "")) !== t3) {
                    var w = void 0;
                    switch (b) {
                      case "thousand":
                        w = Math.pow(10, 3);
                        break;
                      case "million":
                        w = Math.pow(10, 6);
                        break;
                      case "billion":
                        w = Math.pow(10, 9);
                        break;
                      case "trillion":
                        w = Math.pow(10, 12);
                    }
                    return e3(c, r2, n2, i2, a2, o2, u) * w;
                  }
                }
              }
            }(function(e3, t3) {
              var r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "", n2 = e3.replace(r2, "");
              return n2 = (n2 = n2.replace(new RegExp("([0-9])".concat(x(t3.thousands), "([0-9])"), "g"), "$1$2")).replace(t3.decimal, ".");
            }(e2, t2, r), t2, r, n, i, a, o);
        }
        e.exports = { unformat: function(e2, t2) {
          var r, n, i, a = p("./globalState"), o = a.currentDelimiters(), u = a.currentCurrency().symbol, c = a.currentOrdinal(), s = a.getZeroFormat(), l = a.currentAbbreviations(), f = void 0;
          if ("string" == typeof e2)
            f = function(e3, t3) {
              if (!e3.indexOf(":") || ":" === t3.thousands)
                return false;
              var r2 = e3.split(":");
              if (3 !== r2.length)
                return false;
              var n2 = +r2[0], i2 = +r2[1], a2 = +r2[2];
              return !isNaN(n2) && !isNaN(i2) && !isNaN(a2);
            }(e2, o) ? (r = e2.split(":"), n = +r[0], i = +r[1], +r[2] + 60 * i + 3600 * n) : g(e2, o, u, c, s, l, t2);
          else {
            if ("number" != typeof e2)
              return;
            f = e2;
          }
          if (void 0 !== f)
            return f;
        } };
      }, { "./globalState": 4 }], 10: [function(e, t, r) {
        "use strict";
        function n(e2) {
          return function(e3) {
            if (Array.isArray(e3)) {
              for (var t2 = 0, r2 = new Array(e3.length); t2 < e3.length; t2++)
                r2[t2] = e3[t2];
              return r2;
            }
          }(e2) || function(e3) {
            if (Symbol.iterator in Object(e3) || "[object Arguments]" === Object.prototype.toString.call(e3))
              return Array.from(e3);
          }(e2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance");
          }();
        }
        function f(e2) {
          return (f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        var i = e("./unformatting"), a = /^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/, p = { output: { type: "string", validValues: ["currency", "percent", "byte", "time", "ordinal", "number"] }, base: { type: "string", validValues: ["decimal", "binary", "general"], restriction: function(e2, t2) {
          return "byte" === t2.output;
        }, message: "`base` must be provided only when the output is `byte`", mandatory: function(e2) {
          return "byte" === e2.output;
        } }, characteristic: { type: "number", restriction: function(e2) {
          return 0 <= e2;
        }, message: "value must be positive" }, prefix: "string", postfix: "string", forceAverage: { type: "string", validValues: ["trillion", "billion", "million", "thousand"] }, average: "boolean", currencyPosition: { type: "string", validValues: ["prefix", "infix", "postfix"] }, currencySymbol: "string", totalLength: { type: "number", restrictions: [{ restriction: function(e2) {
          return 0 <= e2;
        }, message: "value must be positive" }, { restriction: function(e2, t2) {
          return !t2.exponential;
        }, message: "`totalLength` is incompatible with `exponential`" }] }, mantissa: { type: "number", restriction: function(e2) {
          return 0 <= e2;
        }, message: "value must be positive" }, optionalMantissa: "boolean", trimMantissa: "boolean", optionalCharacteristic: "boolean", thousandSeparated: "boolean", spaceSeparated: "boolean", abbreviations: { type: "object", children: { thousand: "string", million: "string", billion: "string", trillion: "string" } }, negative: { type: "string", validValues: ["sign", "parenthesis"] }, forceSign: "boolean", exponential: { type: "boolean" }, prefixSymbol: { type: "boolean", restriction: function(e2, t2) {
          return "percent" === t2.output;
        }, message: "`prefixSymbol` can be provided only when the output is `percent`" } }, o = { languageTag: { type: "string", mandatory: true, restriction: function(e2) {
          return e2.match(a);
        }, message: "the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)" }, delimiters: { type: "object", children: { thousands: "string", decimal: "string", thousandsSize: "number" }, mandatory: true }, abbreviations: { type: "object", children: { thousand: { type: "string", mandatory: true }, million: { type: "string", mandatory: true }, billion: { type: "string", mandatory: true }, trillion: { type: "string", mandatory: true } }, mandatory: true }, spaceSeparated: "boolean", ordinal: { type: "function", mandatory: true }, currency: { type: "object", children: { symbol: "string", position: "string", code: "string" }, mandatory: true }, defaults: "format", ordinalFormat: "format", byteFormat: "format", percentageFormat: "format", currencyFormat: "format", timeDefaults: "format", formats: { type: "object", children: { fourDigits: { type: "format", mandatory: true }, fullWithTwoDecimals: { type: "format", mandatory: true }, fullWithTwoDecimalsNoCurrency: { type: "format", mandatory: true }, fullWithNoDecimals: { type: "format", mandatory: true } } } };
        function u(e2) {
          return !!i.unformat(e2);
        }
        function g(c2, s, l) {
          var e2 = 3 < arguments.length && void 0 !== arguments[3] && arguments[3], t2 = Object.keys(c2).map(function(e3) {
            if (!s[e3])
              return console.error("".concat(l, " Invalid key: ").concat(e3)), false;
            var t3 = c2[e3], r2 = s[e3];
            if ("string" == typeof r2 && (r2 = { type: r2 }), "format" === r2.type) {
              if (!g(t3, p, "[Validate ".concat(e3, "]"), true))
                return false;
            } else if (f(t3) !== r2.type)
              return console.error("".concat(l, " ").concat(e3, ' type mismatched: "').concat(r2.type, '" expected, "').concat(f(t3), '" provided')), false;
            if (r2.restrictions && r2.restrictions.length)
              for (var n2 = r2.restrictions.length, i2 = 0; i2 < n2; i2++) {
                var a2 = r2.restrictions[i2], o2 = a2.restriction, u2 = a2.message;
                if (!o2(t3, c2))
                  return console.error("".concat(l, " ").concat(e3, " invalid value: ").concat(u2)), false;
              }
            if (r2.restriction && !r2.restriction(t3, c2))
              return console.error("".concat(l, " ").concat(e3, " invalid value: ").concat(r2.message)), false;
            if (r2.validValues && -1 === r2.validValues.indexOf(t3))
              return console.error("".concat(l, " ").concat(e3, " invalid value: must be among ").concat(JSON.stringify(r2.validValues), ', "').concat(t3, '" provided')), false;
            if (r2.children && !g(t3, r2.children, "[Validate ".concat(e3, "]")))
              return false;
            return true;
          });
          return e2 || t2.push.apply(t2, n(Object.keys(s).map(function(e3) {
            var t3 = s[e3];
            if ("string" == typeof t3 && (t3 = { type: t3 }), t3.mandatory) {
              var r2 = t3.mandatory;
              if ("function" == typeof r2 && (r2 = r2(c2)), r2 && void 0 === c2[e3])
                return console.error("".concat(l, ' Missing mandatory key "').concat(e3, '"')), false;
            }
            return true;
          }))), t2.reduce(function(e3, t3) {
            return e3 && t3;
          }, true);
        }
        function c(e2) {
          return g(e2, p, "[Validate format]");
        }
        t.exports = { validate: function(e2, t2) {
          var r2 = u(e2), n2 = c(t2);
          return r2 && n2;
        }, validateFormat: c, validateInput: u, validateLanguage: function(e2) {
          return g(e2, o, "[Validate language]");
        } };
      }, { "./unformatting": 9 }] }, {}, [7])(7);
    });
  }
});

// node_modules/core-js/internals/delete-property-or-throw.js
var require_delete_property_or_throw = __commonJS({
  "node_modules/core-js/internals/delete-property-or-throw.js"(exports, module2) {
    "use strict";
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module2.exports = function(O, P) {
      if (!delete O[P])
        throw new $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
    };
  }
});

// node_modules/core-js/modules/es.array.push.js
var $ = require_export();
var toObject = require_to_object();
var lengthOfArrayLike = require_length_of_array_like();
var setArrayLength = require_array_set_length();
var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
var fails = require_fails();
var INCORRECT_TO_LENGTH = fails(function() {
  return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
});
var properErrorOnNonWritableLength = function() {
  try {
    Object.defineProperty([], "length", { writable: false }).push();
  } catch (error2) {
    return error2 instanceof TypeError;
  }
};
var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
$({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});

// node_modules/core-js/modules/es.error.cause.js
var $2 = require_export();
var global2 = require_global();
var apply = require_function_apply();
var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
var WEB_ASSEMBLY = "WebAssembly";
var WebAssembly = global2[WEB_ASSEMBLY];
var FORCED2 = new Error("e", { cause: 7 }).cause !== 7;
var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
  var O = {};
  O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED2);
  $2({ global: true, constructor: true, arity: 1, forced: FORCED2 }, O);
};
var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
  if (WebAssembly && WebAssembly[ERROR_NAME]) {
    var O = {};
    O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED2);
    $2({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED2 }, O);
  }
};
exportGlobalErrorCauseWrapper("Error", function(init) {
  return function Error2(message) {
    return apply(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("EvalError", function(init) {
  return function EvalError(message) {
    return apply(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("RangeError", function(init) {
  return function RangeError(message) {
    return apply(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("ReferenceError", function(init) {
  return function ReferenceError(message) {
    return apply(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("SyntaxError", function(init) {
  return function SyntaxError(message) {
    return apply(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("TypeError", function(init) {
  return function TypeError2(message) {
    return apply(init, this, arguments);
  };
});
exportGlobalErrorCauseWrapper("URIError", function(init) {
  return function URIError(message) {
    return apply(init, this, arguments);
  };
});
exportWebAssemblyErrorCauseWrapper("CompileError", function(init) {
  return function CompileError(message) {
    return apply(init, this, arguments);
  };
});
exportWebAssemblyErrorCauseWrapper("LinkError", function(init) {
  return function LinkError(message) {
    return apply(init, this, arguments);
  };
});
exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init) {
  return function RuntimeError(message) {
    return apply(init, this, arguments);
  };
});

// node_modules/core-js/modules/web.immediate.js
require_web_clear_immediate();
require_web_set_immediate();

// node_modules/handsontable/helpers/dom/element.mjs
var element_exports = {};
__export(element_exports, {
  HTML_CHARACTERS: () => HTML_CHARACTERS,
  addClass: () => addClass,
  addEvent: () => addEvent,
  clearTextSelection: () => clearTextSelection,
  closest: () => closest,
  closestDown: () => closestDown,
  empty: () => empty,
  fastInnerHTML: () => fastInnerHTML,
  fastInnerText: () => fastInnerText,
  getCaretPosition: () => getCaretPosition,
  getComputedStyle: () => getComputedStyle,
  getCssTransform: () => getCssTransform,
  getFrameElement: () => getFrameElement,
  getParent: () => getParent,
  getParentWindow: () => getParentWindow,
  getScrollLeft: () => getScrollLeft,
  getScrollTop: () => getScrollTop,
  getScrollableElement: () => getScrollableElement,
  getScrollbarWidth: () => getScrollbarWidth,
  getSelectionEndPosition: () => getSelectionEndPosition,
  getSelectionText: () => getSelectionText,
  getStyle: () => getStyle,
  getTrimmingContainer: () => getTrimmingContainer,
  getWindowScrollLeft: () => getWindowScrollLeft,
  getWindowScrollTop: () => getWindowScrollTop,
  hasAccessToParentWindow: () => hasAccessToParentWindow,
  hasClass: () => hasClass,
  hasHorizontalScrollbar: () => hasHorizontalScrollbar,
  hasVerticalScrollbar: () => hasVerticalScrollbar,
  index: () => index,
  innerHeight: () => innerHeight,
  innerWidth: () => innerWidth,
  isChildOf: () => isChildOf,
  isDetached: () => isDetached,
  isInput: () => isInput,
  isOutsideInput: () => isOutsideInput,
  isVisible: () => isVisible,
  matchesCSSRules: () => matchesCSSRules,
  observeVisibilityChangeOnce: () => observeVisibilityChangeOnce,
  offset: () => offset2,
  outerHeight: () => outerHeight,
  outerWidth: () => outerWidth,
  overlayContainsElement: () => overlayContainsElement,
  removeClass: () => removeClass,
  removeEvent: () => removeEvent,
  removeTextNodes: () => removeTextNodes,
  resetCssTransform: () => resetCssTransform,
  selectElementIfAllowed: () => selectElementIfAllowed,
  setCaretPosition: () => setCaretPosition,
  setOverlayPosition: () => setOverlayPosition
});

// node_modules/handsontable/helpers/string.mjs
var string_exports = {};
__export(string_exports, {
  equalsIgnoreCase: () => equalsIgnoreCase,
  isPercentValue: () => isPercentValue,
  randomString: () => randomString,
  sanitize: () => sanitize,
  stripTags: () => stripTags,
  substitute: () => substitute,
  toUpperCaseFirst: () => toUpperCaseFirst
});

// node_modules/dompurify/dist/purify.es.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var hasOwnProperty = Object.hasOwnProperty;
var setPrototypeOf = Object.setPrototypeOf;
var isFrozen = Object.isFrozen;
var getPrototypeOf = Object.getPrototypeOf;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze;
var seal = Object.seal;
var create = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect;
var apply2 = _ref.apply;
var construct = _ref.construct;
if (!apply2) {
  apply2 = function apply4(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return _construct(Func, _toConsumableArray(args));
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringToString = unapply(String.prototype.toString);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply2(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set2, array, transformCaseFunc) {
  var _transformCaseFunc;
  transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set2, null);
  }
  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === "string") {
      var lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function clone(object) {
  var newObject = create(null);
  var property;
  for (property in object) {
    if (apply2(hasOwnProperty, object, [property]) === true) {
      newObject[property] = object[property];
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html2) {
        return html2;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root) {
    return createDOMPurify(root);
  };
  DOMPurify.version = "2.4.7";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement2 = window2.HTMLTemplateElement, Node2 = window2.Node, Element = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement2 === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone(document2).documentMode ? document2.documentMode : {};
  } catch (_) {
  }
  var hooks2 = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0 && documentMode !== 9;
  var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var ALLOW_SELF_CLOSE_IN_ATTR = true;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var ALLOWED_NAMESPACES = null;
  var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  var PARSER_MEDIA_TYPE;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || _typeof(cfg) !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone(DEFAULT_URI_SAFE_ATTRIBUTES),
      // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone(DEFAULT_DATA_URI_TAGS),
      // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  var ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_2) {
        node.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {
        }
      } else {
        try {
          node.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc;
    var leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
      }
    }
    var body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  var _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
      null,
      false
    );
  };
  var _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
  };
  var _isNode = function _isNode2(object) {
    return _typeof(Node2) === "object" ? object instanceof Node2 : object && _typeof(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks2[entryPoint]) {
      return;
    }
    arrayForEach(hooks2[entryPoint], function(hook2) {
      hook2.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$1, " ");
      content = stringReplace(content, ERB_EXPR$1, " ");
      content = stringReplace(content, TMPLIT_EXPR$1, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      )
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if (value) {
      return false;
    } else
      ;
    return true;
  };
  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr;
    var value;
    var lcName;
    var l;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    while (l--) {
      attr = attributes[l];
      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value = name === "value" ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$1, " ");
        value = stringReplace(value, ERB_EXPR$1, " ");
        value = stringReplace(value, TMPLIT_EXPR$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && _typeof(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI)
          ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var body;
    var importedNode;
    var currentNode;
    var oldNode;
    var returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
      serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks2[entryPoint] = hooks2[entryPoint] || [];
    arrayPush(hooks2[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks2[entryPoint]) {
      return arrayPop(hooks2[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks2[entryPoint]) {
      hooks2[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks2 = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();

// node_modules/handsontable/helpers/mixed.mjs
var mixed_exports = {};
__export(mixed_exports, {
  _injectProductInfo: () => _injectProductInfo,
  isDefined: () => isDefined,
  isEmpty: () => isEmpty,
  isRegExp: () => isRegExp,
  isUndefined: () => isUndefined2,
  stringify: () => stringify
});
init_moment();

// node_modules/handsontable/helpers/array.mjs
var array_exports = {};
__export(array_exports, {
  arrayAvg: () => arrayAvg,
  arrayEach: () => arrayEach,
  arrayFilter: () => arrayFilter,
  arrayFlatten: () => arrayFlatten,
  arrayMap: () => arrayMap,
  arrayMax: () => arrayMax,
  arrayMin: () => arrayMin,
  arrayReduce: () => arrayReduce,
  arraySum: () => arraySum,
  arrayUnique: () => arrayUnique,
  extendArray: () => extendArray,
  getDifferenceOfArrays: () => getDifferenceOfArrays,
  getIntersectionOfArrays: () => getIntersectionOfArrays,
  getUnionOfArrays: () => getUnionOfArrays,
  pivot: () => pivot,
  stringToArray: () => stringToArray,
  to2dArray: () => to2dArray
});
function to2dArray(arr) {
  const ilen = arr.length;
  let i = 0;
  while (i < ilen) {
    arr[i] = [arr[i]];
    i += 1;
  }
}
function extendArray(arr, extension) {
  const ilen = extension.length;
  let i = 0;
  while (i < ilen) {
    arr.push(extension[i]);
    i += 1;
  }
}
function pivot(arr) {
  const pivotedArr = [];
  if (!arr || arr.length === 0 || !arr[0] || arr[0].length === 0) {
    return pivotedArr;
  }
  const rowCount = arr.length;
  const colCount = arr[0].length;
  for (let i = 0; i < rowCount; i++) {
    for (let j = 0; j < colCount; j++) {
      if (!pivotedArr[j]) {
        pivotedArr[j] = [];
      }
      pivotedArr[j][i] = arr[i][j];
    }
  }
  return pivotedArr;
}
function arrayReduce(array, iteratee, accumulator, initFromArray) {
  let index2 = -1;
  let iterable = array;
  let result = accumulator;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  const length = iterable.length;
  if (initFromArray && length) {
    index2 += 1;
    result = iterable[index2];
  }
  index2 += 1;
  while (index2 < length) {
    result = iteratee(result, iterable[index2], index2, iterable);
    index2 += 1;
  }
  return result;
}
function arrayFilter(array, predicate) {
  let index2 = 0;
  let iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  const length = iterable.length;
  const result = [];
  let resIndex = -1;
  while (index2 < length) {
    const value = iterable[index2];
    if (predicate(value, index2, iterable)) {
      resIndex += 1;
      result[resIndex] = value;
    }
    index2 += 1;
  }
  return result;
}
function arrayMap(array, iteratee) {
  let index2 = 0;
  let iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  const length = iterable.length;
  const result = [];
  let resIndex = -1;
  while (index2 < length) {
    const value = iterable[index2];
    resIndex += 1;
    result[resIndex] = iteratee(value, index2, iterable);
    index2 += 1;
  }
  return result;
}
function arrayEach(array, iteratee) {
  let index2 = 0;
  let iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  const length = iterable.length;
  while (index2 < length) {
    if (iteratee(iterable[index2], index2, iterable) === false) {
      break;
    }
    index2 += 1;
  }
  return array;
}
function arraySum(array) {
  return arrayReduce(array, (a, b) => a + b, 0);
}
function arrayMax(array) {
  return arrayReduce(array, (a, b) => a > b ? a : b, Array.isArray(array) ? array[0] : void 0);
}
function arrayMin(array) {
  return arrayReduce(array, (a, b) => a < b ? a : b, Array.isArray(array) ? array[0] : void 0);
}
function arrayAvg(array) {
  if (!array.length) {
    return 0;
  }
  return arraySum(array) / array.length;
}
function arrayFlatten(array) {
  return arrayReduce(array, (initial, value) => initial.concat(Array.isArray(value) ? arrayFlatten(value) : value), []);
}
function arrayUnique(array) {
  const unique = [];
  arrayEach(array, (value) => {
    if (unique.indexOf(value) === -1) {
      unique.push(value);
    }
  });
  return unique;
}
function getDifferenceOfArrays() {
  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
    arrays[_key] = arguments[_key];
  }
  const [first, ...rest] = [...arrays];
  let filteredFirstArray = first;
  arrayEach(rest, (array) => {
    filteredFirstArray = filteredFirstArray.filter((value) => !array.includes(value));
  });
  return filteredFirstArray;
}
function getIntersectionOfArrays() {
  for (var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    arrays[_key2] = arguments[_key2];
  }
  const [first, ...rest] = [...arrays];
  let filteredFirstArray = first;
  arrayEach(rest, (array) => {
    filteredFirstArray = filteredFirstArray.filter((value) => array.includes(value));
  });
  return filteredFirstArray;
}
function getUnionOfArrays() {
  for (var _len3 = arguments.length, arrays = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    arrays[_key3] = arguments[_key3];
  }
  const [first, ...rest] = [...arrays];
  const set2 = new Set(first);
  arrayEach(rest, (array) => {
    arrayEach(array, (value) => {
      if (!set2.has(value)) {
        set2.add(value);
      }
    });
  });
  return Array.from(set2);
}
function stringToArray(value) {
  let delimiter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
  return value.split(delimiter);
}

// node_modules/handsontable/helpers/templateLiteralTag.mjs
function toSingleLine(strings) {
  for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    expressions[_key - 1] = arguments[_key];
  }
  const result = arrayReduce(strings, (previousValue, currentValue, index2) => {
    const valueWithoutWhiteSpaces = currentValue.replace(/\r?\n\s*/g, "");
    const expressionForIndex = expressions[index2] ? expressions[index2] : "";
    return previousValue + valueWithoutWhiteSpaces + expressionForIndex;
  }, "");
  return result.trim();
}

// node_modules/handsontable/helpers/mixed.mjs
function stringify(value) {
  let result;
  switch (typeof value) {
    case "string":
    case "number":
      result = `${value}`;
      break;
    case "object":
      result = value === null ? "" : value.toString();
      break;
    case "undefined":
      result = "";
      break;
    default:
      result = value.toString();
      break;
  }
  return result;
}
function isDefined(variable) {
  return typeof variable !== "undefined";
}
function isUndefined2(variable) {
  return typeof variable === "undefined";
}
function isEmpty(variable) {
  return variable === null || variable === "" || isUndefined2(variable);
}
function isRegExp(variable) {
  return Object.prototype.toString.call(variable) === "[object RegExp]";
}
var _m = "length";
var _hd = (v) => parseInt(v, 16);
var _pi = (v) => parseInt(v, 10);
var _ss = (v, s, l) => v["substr"](s, l);
var _cp = (v) => v["codePointAt"](0) - 65;
var _norm = (v) => `${v}`.replace(/\-/g, "");
var _extractTime = (v) => _hd(_ss(_norm(v), _hd("12"), _cp("F"))) / (_hd(_ss(_norm(v), _cp("B"), ~~![][_m])) || 9);
var _ignored = () => typeof location !== "undefined" && /^([a-z0-9\-]+\.)?\x68\x61\x6E\x64\x73\x6F\x6E\x74\x61\x62\x6C\x65\x2E\x63\x6F\x6D$/i.test(location.host);
var _notified = false;
var consoleMessages = {
  invalid: () => toSingleLine`
    The license key for Handsontable is invalid.\x20
    If you need any help, contact us at support@handsontable.com.`,
  expired: (_ref2) => {
    let {
      keyValidityDate,
      hotVersion
    } = _ref2;
    return toSingleLine`
    The license key for Handsontable expired on ${keyValidityDate}, and is not valid for the installed\x20
    version ${hotVersion}. Renew your license key at handsontable.com or downgrade to a version released prior\x20
    to ${keyValidityDate}. If you need any help, contact us at sales@handsontable.com.`;
  },
  missing: () => toSingleLine`
    The license key for Handsontable is missing. Use your purchased key to activate the product.\x20
    Alternatively, you can activate Handsontable to use for non-commercial purposes by\x20
    passing the key: 'non-commercial-and-evaluation'. If you need any help, contact\x20
    us at support@handsontable.com.`,
  non_commercial: () => ""
};
var domMessages = {
  invalid: () => toSingleLine`
    The license key for Handsontable is invalid.\x20
    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> on how to\x20
    install it properly or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.`,
  expired: (_ref2) => {
    let {
      keyValidityDate,
      hotVersion
    } = _ref2;
    return toSingleLine`
    The license key for Handsontable expired on ${keyValidityDate}, and is not valid for the installed\x20
    version ${hotVersion}. <a href="https://handsontable.com/pricing" target="_blank">Renew</a> your\x20
    license key or downgrade to a version released prior to ${keyValidityDate}. If you need any\x20
    help, contact us at <a href="mailto:sales@handsontable.com">sales@handsontable.com</a>.`;
  },
  missing: () => toSingleLine`
    The license key for Handsontable is missing. Use your purchased key to activate the product.\x20
    Alternatively, you can activate Handsontable to use for non-commercial purposes by\x20
    passing the key: 'non-commercial-and-evaluation'.\x20
    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> about it in\x20
    the documentation or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.`,
  non_commercial: () => ""
};
function _injectProductInfo(key, element) {
  const hasValidType = !isEmpty(key);
  const isNonCommercial = typeof key === "string" && key.toLowerCase() === "non-commercial-and-evaluation";
  const hotVersion = "13.1.0";
  let keyValidityDate;
  let consoleMessageState = "invalid";
  let domMessageState = "invalid";
  key = _norm(key || "");
  const schemaValidity = _checkKeySchema(key);
  if (hasValidType || isNonCommercial || schemaValidity) {
    if (schemaValidity) {
      const releaseDate = moment_default("31/08/2023", "DD/MM/YYYY");
      const releaseDays = Math.floor(releaseDate.toDate().getTime() / 864e5);
      const keyValidityDays = _extractTime(key);
      keyValidityDate = moment_default((keyValidityDays + 1) * 864e5, "x").format("MMMM DD, YYYY");
      if (releaseDays > keyValidityDays) {
        consoleMessageState = "expired";
        domMessageState = "expired";
      } else {
        consoleMessageState = "valid";
        domMessageState = "valid";
      }
    } else if (isNonCommercial) {
      consoleMessageState = "non_commercial";
      domMessageState = "valid";
    } else {
      consoleMessageState = "invalid";
      domMessageState = "invalid";
    }
  } else {
    consoleMessageState = "missing";
    domMessageState = "missing";
  }
  if (_ignored()) {
    consoleMessageState = "valid";
    domMessageState = "valid";
  }
  if (!_notified && consoleMessageState !== "valid") {
    const message = consoleMessages[consoleMessageState]({
      keyValidityDate,
      hotVersion
    });
    if (message) {
      console[consoleMessageState === "non_commercial" ? "info" : "warn"](consoleMessages[consoleMessageState]({
        keyValidityDate,
        hotVersion
      }));
    }
    _notified = true;
  }
  if (domMessageState !== "valid" && element.parentNode) {
    const message = domMessages[domMessageState]({
      keyValidityDate,
      hotVersion
    });
    if (message) {
      const messageNode = document.createElement("div");
      messageNode.className = "hot-display-license-info";
      messageNode.innerHTML = domMessages[domMessageState]({
        keyValidityDate,
        hotVersion
      });
      element.parentNode.insertBefore(messageNode, element.nextSibling);
    }
  }
}
function _checkKeySchema(v) {
  let z = [][_m];
  let p = z;
  if (v[_m] !== _cp("Z")) {
    return false;
  }
  for (let c = "", i = "B<H4P+".split(""), j = _cp(i.shift()); j; j = _cp(i.shift() || "A")) {
    --j < ""[_m] ? p = p | (_pi(`${_pi(_hd(c) + (_hd(_ss(v, Math.abs(j), 2)) + []).padStart(2, "0"))}`) % 97 || 2) >> 1 : c = _ss(v, j, !j ? 6 : i[_m] === 1 ? 9 : 8);
  }
  return p === z;
}

// node_modules/handsontable/helpers/string.mjs
function toUpperCaseFirst(string) {
  return string[0].toUpperCase() + string.substr(1);
}
function equalsIgnoreCase() {
  const unique = [];
  for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
    strings[_key] = arguments[_key];
  }
  let length = strings.length;
  while (length) {
    length -= 1;
    const string = stringify(strings[length]).toLowerCase();
    if (unique.indexOf(string) === -1) {
      unique.push(string);
    }
  }
  return unique.length === 1;
}
function randomString() {
  function s4() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return s4() + s4() + s4() + s4();
}
function isPercentValue(value) {
  return /^([0-9][0-9]?%$)|(^100%$)/.test(value);
}
function substitute(template) {
  let variables = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return `${template}`.replace(/(?:\\)?\[([^[\]]+)]/g, (match, name) => {
    if (match.charAt(0) === "\\") {
      return match.substr(1, match.length - 1);
    }
    return variables[name] === void 0 ? "" : variables[name];
  });
}
function stripTags(string) {
  return sanitize(`${string}`, {
    ALLOWED_TAGS: []
  });
}
function sanitize(string, options) {
  return purify.sanitize(string, options);
}

// node_modules/handsontable/helpers/dom/element.mjs
function getParent(element) {
  let level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let iteration = -1;
  let parent = null;
  let elementToCheck = element;
  while (elementToCheck !== null) {
    if (iteration === level) {
      parent = elementToCheck;
      break;
    }
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      iteration += 1;
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return parent;
}
function getFrameElement(frame) {
  return Object.getPrototypeOf(frame.parent) && frame.frameElement;
}
function getParentWindow(frame) {
  return getFrameElement(frame) && frame.parent;
}
function hasAccessToParentWindow(frame) {
  return !!Object.getPrototypeOf(frame.parent);
}
function closest(element) {
  let nodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let until = arguments.length > 2 ? arguments[2] : void 0;
  const {
    ELEMENT_NODE,
    DOCUMENT_FRAGMENT_NODE
  } = Node;
  let elementToCheck = element;
  while (elementToCheck !== null && elementToCheck !== void 0 && elementToCheck !== until) {
    const {
      nodeType,
      nodeName
    } = elementToCheck;
    if (nodeType === ELEMENT_NODE && (nodes.includes(nodeName) || nodes.includes(elementToCheck))) {
      return elementToCheck;
    }
    const {
      host
    } = elementToCheck;
    if (host && nodeType === DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return null;
}
function closestDown(element, nodes, until) {
  const matched = [];
  let elementToCheck = element;
  while (elementToCheck) {
    elementToCheck = closest(elementToCheck, nodes, until);
    if (!elementToCheck || until && !until.contains(elementToCheck)) {
      break;
    }
    matched.push(elementToCheck);
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  const length = matched.length;
  return length ? matched[length - 1] : null;
}
function isChildOf(child, parent) {
  let node = child.parentNode;
  let queriedParents = [];
  if (typeof parent === "string") {
    if (child.defaultView) {
      queriedParents = Array.prototype.slice.call(child.querySelectorAll(parent), 0);
    } else {
      queriedParents = Array.prototype.slice.call(child.ownerDocument.querySelectorAll(parent), 0);
    }
  } else {
    queriedParents.push(parent);
  }
  while (node !== null) {
    if (queriedParents.indexOf(node) > -1) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
function index(element) {
  let i = 0;
  let elementToCheck = element;
  if (elementToCheck.previousSibling) {
    while (elementToCheck = elementToCheck.previousSibling) {
      i += 1;
    }
  }
  return i;
}
function overlayContainsElement(overlayType, element, root) {
  const overlayElement = root.parentElement.querySelector(`.ht_clone_${overlayType}`);
  return overlayElement ? overlayElement.contains(element) : null;
}
function filterEmptyClassNames(classNames) {
  if (!classNames || !classNames.length) {
    return [];
  }
  return classNames.filter((x) => !!x);
}
function hasClass(element, className) {
  if (element.classList === void 0 || typeof className !== "string" || className === "") {
    return false;
  }
  return element.classList.contains(className);
}
function addClass(element, className) {
  if (typeof className === "string") {
    className = className.split(" ");
  }
  className = filterEmptyClassNames(className);
  if (className.length > 0) {
    element.classList.add(...className);
  }
}
function removeClass(element, className) {
  if (typeof className === "string") {
    className = className.split(" ");
  }
  className = filterEmptyClassNames(className);
  if (className.length > 0) {
    element.classList.remove(...className);
  }
}
function removeTextNodes(element) {
  if (element.nodeType === 3) {
    element.parentNode.removeChild(element);
  } else if (["TABLE", "THEAD", "TBODY", "TFOOT", "TR"].indexOf(element.nodeName) > -1) {
    const childs = element.childNodes;
    for (let i = childs.length - 1; i >= 0; i--) {
      removeTextNodes(childs[i]);
    }
  }
}
function empty(element) {
  let child;
  while (child = element.lastChild) {
    element.removeChild(child);
  }
}
var HTML_CHARACTERS = /(<(.*)>|&(.*);)/;
function fastInnerHTML(element, content) {
  let sanitizeContent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (HTML_CHARACTERS.test(content)) {
    element.innerHTML = sanitizeContent ? sanitize(content) : content;
  } else {
    fastInnerText(element, content);
  }
}
function fastInnerText(element, content) {
  const child = element.firstChild;
  if (child && child.nodeType === 3 && child.nextSibling === null) {
    child.textContent = content;
  } else {
    empty(element);
    element.appendChild(element.ownerDocument.createTextNode(content));
  }
}
function isVisible(element) {
  const documentElement = element.ownerDocument.documentElement;
  let next = element;
  while (next !== documentElement) {
    if (next === null) {
      return false;
    } else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      if (next.host) {
        if (next.host.impl) {
          return isVisible(next.host.impl);
        } else if (next.host) {
          return isVisible(next.host);
        }
        throw new Error("Lost in Web Components world");
      } else {
        return false;
      }
    } else if (next.style && next.style.display === "none") {
      return false;
    }
    next = next.parentNode;
  }
  return true;
}
function offset2(element) {
  const rootDocument = element.ownerDocument;
  const rootWindow = rootDocument.defaultView;
  const documentElement = rootDocument.documentElement;
  let elementToCheck = element;
  let offsetLeft;
  let offsetTop;
  let lastElem;
  offsetLeft = elementToCheck.offsetLeft;
  offsetTop = elementToCheck.offsetTop;
  lastElem = elementToCheck;
  while (elementToCheck = elementToCheck.offsetParent) {
    if (elementToCheck === rootDocument.body) {
      break;
    }
    offsetLeft += elementToCheck.offsetLeft;
    offsetTop += elementToCheck.offsetTop;
    lastElem = elementToCheck;
  }
  if (lastElem && lastElem.style.position === "fixed") {
    offsetLeft += rootWindow.pageXOffset || documentElement.scrollLeft;
    offsetTop += rootWindow.pageYOffset || documentElement.scrollTop;
  }
  return {
    left: offsetLeft,
    top: offsetTop
  };
}
function getWindowScrollTop() {
  let rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  return rootWindow.scrollY;
}
function getWindowScrollLeft() {
  let rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  return rootWindow.scrollX;
}
function getScrollTop(element) {
  let rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
  if (element === rootWindow) {
    return getWindowScrollTop(rootWindow);
  }
  return element.scrollTop;
}
function getScrollLeft(element) {
  let rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
  if (element === rootWindow) {
    return getWindowScrollLeft(rootWindow);
  }
  return element.scrollLeft;
}
function getScrollableElement(element) {
  let rootDocument = element.ownerDocument;
  let rootWindow = rootDocument ? rootDocument.defaultView : void 0;
  if (!rootDocument) {
    rootDocument = element.document ? element.document : element;
    rootWindow = rootDocument.defaultView;
  }
  const props = ["auto", "scroll"];
  let el = element.parentNode;
  while (el && el.style && rootDocument.body !== el) {
    let {
      overflow,
      overflowX,
      overflowY
    } = el.style;
    if ([overflow, overflowX, overflowY].includes("scroll")) {
      return el;
    } else {
      ({
        overflow,
        overflowX,
        overflowY
      } = rootWindow.getComputedStyle(el));
      if (props.includes(overflow) || props.includes(overflowX) || props.includes(overflowY)) {
        return el;
      }
    }
    if (el.clientHeight <= el.scrollHeight + 1 && (props.includes(overflowY) || props.includes(overflow))) {
      return el;
    }
    if (el.clientWidth <= el.scrollWidth + 1 && (props.includes(overflowX) || props.includes(overflow))) {
      return el;
    }
    el = el.parentNode;
  }
  return rootWindow;
}
function getTrimmingContainer(base) {
  const rootDocument = base.ownerDocument;
  const rootWindow = rootDocument.defaultView;
  let el = base.parentNode;
  while (el && el.style && rootDocument.body !== el) {
    if (el.style.overflow !== "visible" && el.style.overflow !== "") {
      return el;
    }
    const computedStyle = getComputedStyle(el, rootWindow);
    const allowedProperties = ["scroll", "hidden", "auto"];
    const property = computedStyle.getPropertyValue("overflow");
    const propertyY = computedStyle.getPropertyValue("overflow-y");
    const propertyX = computedStyle.getPropertyValue("overflow-x");
    if (allowedProperties.includes(property) || allowedProperties.includes(propertyY) || allowedProperties.includes(propertyX)) {
      return el;
    }
    el = el.parentNode;
  }
  return rootWindow;
}
function getStyle(element, prop) {
  let rootWindow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : window;
  if (!element) {
    return;
  } else if (element === rootWindow) {
    if (prop === "width") {
      return `${rootWindow.innerWidth}px`;
    } else if (prop === "height") {
      return `${rootWindow.innerHeight}px`;
    }
    return;
  }
  const styleProp = element.style[prop];
  if (styleProp !== "" && styleProp !== void 0) {
    return styleProp;
  }
  const computedStyle = getComputedStyle(element, rootWindow);
  if (computedStyle[prop] !== "" && computedStyle[prop] !== void 0) {
    return computedStyle[prop];
  }
}
function matchesCSSRules(element, rule) {
  const {
    selectorText
  } = rule;
  let result = false;
  if (rule.type === CSSRule.STYLE_RULE && selectorText) {
    if (element.msMatchesSelector) {
      result = element.msMatchesSelector(selectorText);
    } else if (element.matches) {
      result = element.matches(selectorText);
    }
  }
  return result;
}
function getComputedStyle(element) {
  let rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
  return element.currentStyle || rootWindow.getComputedStyle(element);
}
function outerWidth(element) {
  return element.offsetWidth;
}
function outerHeight(element) {
  return element.offsetHeight;
}
function innerHeight(element) {
  return element.clientHeight || element.innerHeight;
}
function innerWidth(element) {
  return element.clientWidth || element.innerWidth;
}
function addEvent(element, event2, callback) {
  element.addEventListener(event2, callback, false);
}
function removeEvent(element, event2, callback) {
  element.removeEventListener(event2, callback, false);
}
function getCaretPosition(el) {
  if (el.selectionStart) {
    return el.selectionStart;
  }
  return 0;
}
function getSelectionEndPosition(el) {
  if (el.selectionEnd) {
    return el.selectionEnd;
  }
  return 0;
}
function getSelectionText() {
  let rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  const rootDocument = rootWindow.document;
  let text2 = "";
  if (rootWindow.getSelection) {
    text2 = rootWindow.getSelection().toString();
  } else if (rootDocument.selection && rootDocument.selection.type !== "Control") {
    text2 = rootDocument.selection.createRange().text;
  }
  return text2;
}
function clearTextSelection() {
  let rootWindow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window;
  if (rootWindow.getSelection) {
    if (rootWindow.getSelection().empty) {
      rootWindow.getSelection().empty();
    } else if (rootWindow.getSelection().removeAllRanges) {
      rootWindow.getSelection().removeAllRanges();
    }
  }
}
function setCaretPosition(element, pos, endPos) {
  if (endPos === void 0) {
    endPos = pos;
  }
  if (element.setSelectionRange) {
    element.focus();
    try {
      element.setSelectionRange(pos, endPos);
    } catch (err) {
      const elementParent = element.parentNode;
      const parentDisplayValue = elementParent.style.display;
      elementParent.style.display = "block";
      element.setSelectionRange(pos, endPos);
      elementParent.style.display = parentDisplayValue;
    }
  }
}
var cachedScrollbarWidth;
function walkontableCalculateScrollbarWidth() {
  let rootDocument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
  const inner = rootDocument.createElement("div");
  inner.style.height = "200px";
  inner.style.width = "100%";
  const outer = rootDocument.createElement("div");
  outer.style.boxSizing = "content-box";
  outer.style.height = "150px";
  outer.style.left = "0px";
  outer.style.overflow = "hidden";
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.width = "200px";
  outer.style.visibility = "hidden";
  outer.appendChild(inner);
  (rootDocument.body || rootDocument.documentElement).appendChild(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;
  if (w1 === w2) {
    w2 = outer.clientWidth;
  }
  (rootDocument.body || rootDocument.documentElement).removeChild(outer);
  return w1 - w2;
}
function getScrollbarWidth() {
  let rootDocument = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
  if (cachedScrollbarWidth === void 0) {
    cachedScrollbarWidth = walkontableCalculateScrollbarWidth(rootDocument);
  }
  return cachedScrollbarWidth;
}
function hasVerticalScrollbar(element) {
  return element.offsetWidth !== element.clientWidth;
}
function hasHorizontalScrollbar(element) {
  return element.offsetHeight !== element.clientHeight;
}
function setOverlayPosition(overlayElem, left2, top2) {
  overlayElem.style.transform = `translate3d(${left2},${top2},0)`;
}
function getCssTransform(element) {
  let transform;
  if (element.style.transform && (transform = element.style.transform) !== "") {
    return ["transform", transform];
  }
  return -1;
}
function resetCssTransform(element) {
  if (element.style.transform && element.style.transform !== "") {
    element.style.transform = "";
  }
}
function isInput(element) {
  const inputs = ["INPUT", "SELECT", "TEXTAREA"];
  return element && (inputs.indexOf(element.nodeName) > -1 || element.contentEditable === "true");
}
function isOutsideInput(element) {
  return isInput(element) && element.hasAttribute("data-hot-input") === false;
}
function selectElementIfAllowed(element) {
  const activeElement = element.ownerDocument.activeElement;
  if (!isOutsideInput(activeElement)) {
    element.select();
  }
}
function isDetached(element) {
  return !element.parentNode;
}
function observeVisibilityChangeOnce(elementToBeObserved, callback) {
  const visibilityObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting && elementToBeObserved.offsetParent !== null) {
        callback();
        observer.unobserve(elementToBeObserved);
      }
    });
  }, {
    root: elementToBeObserved.ownerDocument.body
  });
  visibilityObserver.observe(elementToBeObserved);
}

// node_modules/handsontable/helpers/function.mjs
var function_exports = {};
__export(function_exports, {
  curry: () => curry,
  curryRight: () => curryRight,
  debounce: () => debounce,
  fastCall: () => fastCall,
  isFunction: () => isFunction2,
  partial: () => partial,
  pipe: () => pipe,
  throttle: () => throttle,
  throttleAfterHits: () => throttleAfterHits
});
function isFunction2(func) {
  return typeof func === "function";
}
function throttle(func) {
  let wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  let lastCalled = 0;
  const result = {
    lastCallThrottled: true
  };
  let lastTimer = null;
  function _throttle() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const stamp = Date.now();
    let needCall = false;
    result.lastCallThrottled = true;
    if (!lastCalled) {
      lastCalled = stamp;
      needCall = true;
    }
    const remaining = wait - (stamp - lastCalled);
    if (needCall) {
      result.lastCallThrottled = false;
      func.apply(this, args);
    } else {
      if (lastTimer) {
        clearTimeout(lastTimer);
      }
      lastTimer = setTimeout(() => {
        result.lastCallThrottled = false;
        func.apply(this, args);
        lastCalled = 0;
        lastTimer = void 0;
      }, remaining);
    }
    return result;
  }
  return _throttle;
}
function throttleAfterHits(func) {
  let wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  let hits = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
  const funcThrottle = throttle(func, wait);
  let remainHits = hits;
  function _clearHits() {
    remainHits = hits;
  }
  function _throttleAfterHits() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (remainHits) {
      remainHits -= 1;
      return func.apply(this, args);
    }
    return funcThrottle.apply(this, args);
  }
  _throttleAfterHits.clearHits = _clearHits;
  return _throttleAfterHits;
}
function debounce(func) {
  let wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  let lastTimer = null;
  let result;
  function _debounce() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    if (lastTimer) {
      clearTimeout(lastTimer);
    }
    lastTimer = setTimeout(() => {
      result = func.apply(this, args);
    }, wait);
    return result;
  }
  return _debounce;
}
function pipe() {
  for (var _len4 = arguments.length, functions = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    functions[_key4] = arguments[_key4];
  }
  const [firstFunc, ...restFunc] = functions;
  return function _pipe() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return arrayReduce(restFunc, (acc, fn) => fn(acc), firstFunc.apply(this, args));
  };
}
function partial(func) {
  for (var _len6 = arguments.length, params = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    params[_key6 - 1] = arguments[_key6];
  }
  return function _partial() {
    for (var _len7 = arguments.length, restParams = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      restParams[_key7] = arguments[_key7];
    }
    return func.apply(this, params.concat(restParams));
  };
}
function curry(func) {
  const argsLength = func.length;
  function given(argsSoFar) {
    return function _curry() {
      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        params[_key8] = arguments[_key8];
      }
      const passedArgsSoFar = argsSoFar.concat(params);
      let result;
      if (passedArgsSoFar.length >= argsLength) {
        result = func.apply(this, passedArgsSoFar);
      } else {
        result = given(passedArgsSoFar);
      }
      return result;
    };
  }
  return given([]);
}
function curryRight(func) {
  const argsLength = func.length;
  function given(argsSoFar) {
    return function _curry() {
      for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        params[_key9] = arguments[_key9];
      }
      const passedArgsSoFar = argsSoFar.concat(params.reverse());
      let result;
      if (passedArgsSoFar.length >= argsLength) {
        result = func.apply(this, passedArgsSoFar);
      } else {
        result = given(passedArgsSoFar);
      }
      return result;
    };
  }
  return given([]);
}
function fastCall(func, context, arg1, arg2, arg3, arg4, arg5, arg6) {
  if (isDefined(arg6)) {
    return func.call(context, arg1, arg2, arg3, arg4, arg5, arg6);
  } else if (isDefined(arg5)) {
    return func.call(context, arg1, arg2, arg3, arg4, arg5);
  } else if (isDefined(arg4)) {
    return func.call(context, arg1, arg2, arg3, arg4);
  } else if (isDefined(arg3)) {
    return func.call(context, arg1, arg2, arg3);
  } else if (isDefined(arg2)) {
    return func.call(context, arg1, arg2);
  } else if (isDefined(arg1)) {
    return func.call(context, arg1);
  }
  return func.call(context);
}

// node_modules/handsontable/helpers/browser.mjs
var browser_exports = {};
__export(browser_exports, {
  isChrome: () => isChrome,
  isChromeWebKit: () => isChromeWebKit,
  isEdge: () => isEdge,
  isEdgeWebKit: () => isEdgeWebKit,
  isFirefox: () => isFirefox,
  isFirefoxWebKit: () => isFirefoxWebKit,
  isIOS: () => isIOS,
  isIpadOS: () => isIpadOS,
  isLinuxOS: () => isLinuxOS,
  isMacOS: () => isMacOS,
  isMobileBrowser: () => isMobileBrowser,
  isSafari: () => isSafari,
  isWindowsOS: () => isWindowsOS,
  setBrowserMeta: () => setBrowserMeta,
  setPlatformMeta: () => setPlatformMeta
});

// node_modules/handsontable/helpers/object.mjs
var object_exports = {};
__export(object_exports, {
  clone: () => clone3,
  createObjectPropListener: () => createObjectPropListener,
  deepClone: () => deepClone,
  deepExtend: () => deepExtend,
  deepObjectSize: () => deepObjectSize,
  defineGetter: () => defineGetter,
  duckSchema: () => duckSchema,
  extend: () => extend2,
  getProperty: () => getProperty,
  hasOwnProperty: () => hasOwnProperty2,
  inherit: () => inherit,
  isObject: () => isObject2,
  isObjectEqual: () => isObjectEqual,
  mixin: () => mixin,
  objectEach: () => objectEach,
  setProperty: () => setProperty
});

// node_modules/core-js/modules/es.json.stringify.js
var $3 = require_export();
var getBuiltIn = require_get_built_in();
var apply3 = require_function_apply();
var call = require_function_call();
var uncurryThis = require_function_uncurry_this();
var fails2 = require_fails();
var isCallable = require_is_callable();
var isSymbol = require_is_symbol();
var arraySlice = require_array_slice();
var getReplacerFunction = require_get_json_replacer_function();
var NATIVE_SYMBOL = require_symbol_constructor_detection();
var $String = String;
var $stringify = getBuiltIn("JSON", "stringify");
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis("".charAt);
var charCodeAt = uncurryThis("".charCodeAt);
var replace = uncurryThis("".replace);
var numberToString = uncurryThis(1 .toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;
var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails2(function() {
  var symbol = getBuiltIn("Symbol")("stringify detection");
  return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
});
var ILL_FORMED_UNICODE = fails2(function() {
  return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
});
var stringifyWithSymbolsFix = function(it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === void 0 || isSymbol(it)))
    return;
  args[1] = function(key, value) {
    if (isCallable($replacer))
      value = call($replacer, this, $String(key), value);
    if (!isSymbol(value))
      return value;
  };
  return apply3($stringify, null, args);
};
var fixIllFormed = function(match, offset3, string) {
  var prev = charAt(string, offset3 - 1);
  var next = charAt(string, offset3 + 1);
  if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
    return "\\u" + numberToString(charCodeAt(match, 0), 16);
  }
  return match;
};
if ($stringify) {
  $3({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify3(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply3(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
    }
  });
}

// node_modules/handsontable/helpers/object.mjs
function duckSchema(object) {
  let schema;
  if (Array.isArray(object)) {
    schema = object.length ? new Array(object.length).fill(null) : [];
  } else {
    schema = {};
    objectEach(object, (value, key) => {
      if (key === "__children") {
        return;
      }
      if (value && typeof value === "object" && !Array.isArray(value)) {
        schema[key] = duckSchema(value);
      } else if (Array.isArray(value)) {
        if (value.length && typeof value[0] === "object" && !Array.isArray(value[0])) {
          schema[key] = [duckSchema(value[0])];
        } else {
          schema[key] = [];
        }
      } else {
        schema[key] = null;
      }
    });
  }
  return schema;
}
function inherit(Child, Parent) {
  Parent.prototype.constructor = Parent;
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;
  return Child;
}
function extend2(target, extension, writableKeys) {
  const hasWritableKeys = Array.isArray(writableKeys);
  objectEach(extension, (value, key) => {
    if (hasWritableKeys === false || writableKeys.includes(key)) {
      target[key] = value;
    }
  });
  return target;
}
function deepExtend(target, extension) {
  objectEach(extension, (value, key) => {
    if (extension[key] && typeof extension[key] === "object") {
      if (!target[key]) {
        if (Array.isArray(extension[key])) {
          target[key] = [];
        } else if (Object.prototype.toString.call(extension[key]) === "[object Date]") {
          target[key] = extension[key];
        } else {
          target[key] = {};
        }
      }
      deepExtend(target[key], extension[key]);
    } else {
      target[key] = extension[key];
    }
  });
}
function deepClone(obj) {
  if (typeof obj === "object") {
    return JSON.parse(JSON.stringify(obj));
  }
  return obj;
}
function clone3(object) {
  const result = {};
  objectEach(object, (value, key) => {
    result[key] = value;
  });
  return result;
}
function mixin(Base) {
  if (!Base.MIXINS) {
    Base.MIXINS = [];
  }
  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    mixins[_key - 1] = arguments[_key];
  }
  arrayEach(mixins, (mixinItem) => {
    Base.MIXINS.push(mixinItem.MIXIN_NAME);
    objectEach(mixinItem, (value, key) => {
      if (Base.prototype[key] !== void 0) {
        throw new Error(`Mixin conflict. Property '${key}' already exist and cannot be overwritten.`);
      }
      if (typeof value === "function") {
        Base.prototype[key] = value;
      } else {
        const getter = function _getter(property, initialValue) {
          const propertyName = `_${property}`;
          const initValue = (newValue) => {
            let result = newValue;
            if (Array.isArray(result) || isObject2(result)) {
              result = deepClone(result);
            }
            return result;
          };
          return function() {
            if (this[propertyName] === void 0) {
              this[propertyName] = initValue(initialValue);
            }
            return this[propertyName];
          };
        };
        const setter = function _setter(property) {
          const propertyName = `_${property}`;
          return function(newValue) {
            this[propertyName] = newValue;
          };
        };
        Object.defineProperty(Base.prototype, key, {
          get: getter(key, value),
          set: setter(key),
          configurable: true
        });
      }
    });
  });
  return Base;
}
function isObjectEqual(object1, object2) {
  return JSON.stringify(object1) === JSON.stringify(object2);
}
function isObject2(object) {
  return Object.prototype.toString.call(object) === "[object Object]";
}
function defineGetter(object, property, value, options) {
  options.value = value;
  options.writable = options.writable !== false;
  options.enumerable = options.enumerable !== false;
  options.configurable = options.configurable !== false;
  Object.defineProperty(object, property, options);
}
function objectEach(object, iteratee) {
  for (const key in object) {
    if (!object.hasOwnProperty || object.hasOwnProperty && Object.prototype.hasOwnProperty.call(object, key)) {
      if (iteratee(object[key], key, object) === false) {
        break;
      }
    }
  }
  return object;
}
function getProperty(object, name) {
  const names = name.split(".");
  let result = object;
  objectEach(names, (nameItem) => {
    result = result[nameItem];
    if (result === void 0) {
      result = void 0;
      return false;
    }
  });
  return result;
}
function setProperty(object, name, value) {
  const names = name.split(".");
  let workingObject = object;
  names.forEach((propName, index2) => {
    if (index2 !== names.length - 1) {
      if (!hasOwnProperty2(workingObject, propName)) {
        workingObject[propName] = {};
      }
      workingObject = workingObject[propName];
    } else {
      workingObject[propName] = value;
    }
  });
}
function deepObjectSize(object) {
  if (!isObject2(object)) {
    return 0;
  }
  const recursObjLen = function(obj) {
    let result = 0;
    if (isObject2(obj)) {
      objectEach(obj, (value, key) => {
        if (key === "__children") {
          return;
        }
        result += recursObjLen(value);
      });
    } else {
      result += 1;
    }
    return result;
  };
  return recursObjLen(object);
}
function createObjectPropListener(defaultValue) {
  let propertyToListen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "value";
  const privateProperty = `_${propertyToListen}`;
  const holder2 = {
    _touched: false,
    [privateProperty]: defaultValue,
    isTouched() {
      return this._touched;
    }
  };
  Object.defineProperty(holder2, propertyToListen, {
    get() {
      return this[privateProperty];
    },
    set(value) {
      this._touched = true;
      this[privateProperty] = value;
    },
    enumerable: true,
    configurable: true
  });
  return holder2;
}
function hasOwnProperty2(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}

// node_modules/handsontable/helpers/browser.mjs
var tester2 = (testerFunc) => {
  const result = {
    value: false
  };
  result.test = (ua, vendor) => {
    result.value = testerFunc(ua, vendor);
  };
  return result;
};
var browsers = {
  chrome: tester2((ua, vendor) => /Chrome/.test(ua) && /Google/.test(vendor)),
  chromeWebKit: tester2((ua) => /CriOS/.test(ua)),
  edge: tester2((ua) => /Edge/.test(ua)),
  edgeWebKit: tester2((ua) => /EdgiOS/.test(ua)),
  firefox: tester2((ua) => /Firefox/.test(ua)),
  firefoxWebKit: tester2((ua) => /FxiOS/.test(ua)),
  mobile: tester2((ua) => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua)),
  safari: tester2((ua, vendor) => /Safari/.test(ua) && /Apple Computer/.test(vendor))
};
var platforms = {
  mac: tester2((platform) => /^Mac/.test(platform)),
  win: tester2((platform) => /^Win/.test(platform)),
  linux: tester2((platform) => /^Linux/.test(platform)),
  ios: tester2((ua) => /iPhone|iPad|iPod/i.test(ua))
};
function setBrowserMeta() {
  let {
    userAgent = navigator.userAgent,
    vendor = navigator.vendor
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  objectEach(browsers, (_ref2) => {
    let {
      test
    } = _ref2;
    return void test(userAgent, vendor);
  });
}
function setPlatformMeta() {
  let {
    platform = navigator.platform
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  objectEach(platforms, (_ref2) => {
    let {
      test
    } = _ref2;
    return void test(platform);
  });
}
setBrowserMeta();
setPlatformMeta();
function isChrome() {
  return browsers.chrome.value;
}
function isChromeWebKit() {
  return browsers.chromeWebKit.value;
}
function isFirefox() {
  return browsers.firefox.value;
}
function isFirefoxWebKit() {
  return browsers.firefoxWebKit.value;
}
function isSafari() {
  return browsers.safari.value;
}
function isEdge() {
  return browsers.edge.value;
}
function isEdgeWebKit() {
  return browsers.edgeWebKit.value;
}
function isMobileBrowser() {
  return browsers.mobile.value;
}
function isIOS() {
  return platforms.ios.value;
}
function isIpadOS() {
  let {
    maxTouchPoints
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : navigator;
  return maxTouchPoints > 2 && platforms.mac.value;
}
function isWindowsOS() {
  return platforms.win.value;
}
function isMacOS() {
  return platforms.mac.value;
}
function isLinuxOS() {
  return platforms.linux.value;
}

// node_modules/handsontable/helpers/unicode.mjs
var unicode_exports = {};
__export(unicode_exports, {
  KEY_CODES: () => KEY_CODES,
  isCtrlKey: () => isCtrlKey,
  isCtrlMetaKey: () => isCtrlMetaKey,
  isFunctionKey: () => isFunctionKey,
  isKey: () => isKey,
  isPrintableChar: () => isPrintableChar
});
var KEY_CODES = {
  ALT: 18,
  ARROW_DOWN: 40,
  ARROW_LEFT: 37,
  ARROW_RIGHT: 39,
  ARROW_UP: 38,
  AUDIO_DOWN: isFirefox() ? 182 : 174,
  AUDIO_MUTE: isFirefox() ? 181 : 173,
  AUDIO_UP: isFirefox() ? 183 : 175,
  BACKSPACE: 8,
  CAPS_LOCK: 20,
  COMMA: 188,
  COMMAND_LEFT: 91,
  COMMAND_RIGHT: 93,
  COMMAND_FIREFOX: 224,
  CONTROL: 17,
  DELETE: 46,
  END: 35,
  ENTER: 13,
  ESCAPE: 27,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  F13: 124,
  F14: 125,
  F15: 126,
  F16: 127,
  F17: 128,
  F18: 129,
  F19: 130,
  HOME: 36,
  INSERT: 45,
  MEDIA_NEXT: 176,
  MEDIA_PLAY_PAUSE: 179,
  MEDIA_PREV: 177,
  MEDIA_STOP: 178,
  NULL: 0,
  NUM_LOCK: 144,
  PAGE_DOWN: 34,
  PAGE_UP: 33,
  PAUSE: 19,
  PERIOD: 190,
  SCROLL_LOCK: 145,
  SHIFT: 16,
  SPACE: 32,
  TAB: 9,
  A: 65,
  C: 67,
  D: 68,
  F: 70,
  L: 76,
  O: 79,
  P: 80,
  S: 83,
  V: 86,
  X: 88,
  Y: 89,
  Z: 90
};
var FUNCTION_KEYS = [KEY_CODES.ALT, KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_UP, KEY_CODES.AUDIO_DOWN, KEY_CODES.AUDIO_MUTE, KEY_CODES.AUDIO_UP, KEY_CODES.BACKSPACE, KEY_CODES.CAPS_LOCK, KEY_CODES.DELETE, KEY_CODES.END, KEY_CODES.ENTER, KEY_CODES.ESCAPE, KEY_CODES.F1, KEY_CODES.F2, KEY_CODES.F3, KEY_CODES.F4, KEY_CODES.F5, KEY_CODES.F6, KEY_CODES.F7, KEY_CODES.F8, KEY_CODES.F9, KEY_CODES.F10, KEY_CODES.F11, KEY_CODES.F12, KEY_CODES.F13, KEY_CODES.F14, KEY_CODES.F15, KEY_CODES.F16, KEY_CODES.F17, KEY_CODES.F18, KEY_CODES.F19, KEY_CODES.HOME, KEY_CODES.INSERT, KEY_CODES.MEDIA_NEXT, KEY_CODES.MEDIA_PLAY_PAUSE, KEY_CODES.MEDIA_PREV, KEY_CODES.MEDIA_STOP, KEY_CODES.NULL, KEY_CODES.NUM_LOCK, KEY_CODES.PAGE_DOWN, KEY_CODES.PAGE_UP, KEY_CODES.PAUSE, KEY_CODES.SCROLL_LOCK, KEY_CODES.SHIFT, KEY_CODES.TAB];
function isPrintableChar(keyCode) {
  return keyCode === 32 || // space
  keyCode >= 48 && keyCode <= 57 || // 0-9
  keyCode >= 96 && keyCode <= 111 || // numpad
  keyCode >= 186 && keyCode <= 192 || // ;=,-./`
  keyCode >= 219 && keyCode <= 222 || // []{}\|"'
  keyCode >= 226 || // special chars (229 for Asian chars)
  keyCode >= 65 && keyCode <= 90;
}
function isFunctionKey(keyCode) {
  return FUNCTION_KEYS.includes(keyCode);
}
function isCtrlKey(keyCode) {
  const keys2 = [];
  if (isMacOS()) {
    keys2.push(KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX);
  } else {
    keys2.push(KEY_CODES.CONTROL);
  }
  return keys2.includes(keyCode);
}
function isCtrlMetaKey(keyCode) {
  return [KEY_CODES.CONTROL, KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX].includes(keyCode);
}
function isKey(keyCode, baseCode) {
  const keys2 = baseCode.split("|");
  let result = false;
  arrayEach(keys2, (key) => {
    if (keyCode === KEY_CODES[key]) {
      result = true;
      return false;
    }
  });
  return result;
}

// node_modules/handsontable/helpers/dom/event.mjs
var event_exports = {};
__export(event_exports, {
  isImmediatePropagationStopped: () => isImmediatePropagationStopped,
  isLeftClick: () => isLeftClick,
  isRightClick: () => isRightClick,
  stopImmediatePropagation: () => stopImmediatePropagation
});
function stopImmediatePropagation(event2) {
  event2.isImmediatePropagationEnabled = false;
  event2.cancelBubble = true;
}
function isImmediatePropagationStopped(event2) {
  return event2.isImmediatePropagationEnabled === false;
}
function isRightClick(event2) {
  return event2.button === 2;
}
function isLeftClick(event2) {
  return event2.button === 0;
}

// node_modules/handsontable/helpers/console.mjs
function warn2() {
  if (isDefined(console)) {
    console.warn(...arguments);
  }
}
function error() {
  if (isDefined(console)) {
    console.error(...arguments);
  }
}

// node_modules/handsontable/pluginHooks.mjs
var REGISTERED_HOOKS = [
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Fired after resetting a cell's meta. This happens when the {@link Core#updateSettings} method is called.
   *
   * @event Hooks#afterCellMetaReset
   */
  "afterCellMetaReset",
  /**
   * Fired after one or more cells has been changed. The changes are triggered in any situation when the
   * value is entered using an editor or changed using API (e.q setDataAtCell).
   *
   * __Note:__ For performance reasons, the `changes` array is null for `"loadData"` source.
   *
   * @event Hooks#afterChange
   * @param {Array[]} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`. `row` is a visual row index.
   * @param {string} [source] String that identifies source of hook call ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @example
   * ::: only-for javascript
   * ```js
   * new Handsontable(element, {
   *   afterChange: (changes) => {
   *     changes?.forEach(([row, prop, oldValue, newValue]) => {
   *       // Some logic...
   *     });
   *   }
   * })
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * <HotTable
   *   afterChange={(changes, source) => {
   *     changes?.forEach(([row, prop, oldValue, newValue]) => {
   *       // Some logic...
   *     });
   *   }}
   * />
   * ```
   * :::
   */
  "afterChange",
  /**
   * Fired each time user opens {@link ContextMenu} and after setting up the Context Menu's default options. These options are a collection
   * which user can select by setting an array of keys or an array of objects in {@link Options#contextMenu} option.
   *
   * @event Hooks#afterContextMenuDefaultOptions
   * @param {Array} predefinedItems An array of objects containing information about the pre-defined Context Menu items.
   */
  "afterContextMenuDefaultOptions",
  /**
   * Fired each time user opens {@link ContextMenu} plugin before setting up the Context Menu's items but after filtering these options by
   * user (`contextMenu` option). This hook can by helpful to determine if user use specified menu item or to set up
   * one of the menu item to by always visible.
   *
   * @event Hooks#beforeContextMenuSetItems
   * @param {object[]} menuItems An array of objects containing information about to generated Context Menu items.
   */
  "beforeContextMenuSetItems",
  /**
   * Fired by {@link DropdownMenu} plugin after setting up the Dropdown Menu's default options. These options are a
   * collection which user can select by setting an array of keys or an array of objects in {@link Options#dropdownMenu}
   * option.
   *
   * @event Hooks#afterDropdownMenuDefaultOptions
   * @param {object[]} predefinedItems An array of objects containing information about the pre-defined Context Menu items.
   */
  "afterDropdownMenuDefaultOptions",
  /**
   * Fired by {@link DropdownMenu} plugin before setting up the Dropdown Menu's items but after filtering these options
   * by user (`dropdownMenu` option). This hook can by helpful to determine if user use specified menu item or to set
   * up one of the menu item to by always visible.
   *
   * @event Hooks#beforeDropdownMenuSetItems
   * @param {object[]} menuItems An array of objects containing information about to generated Dropdown Menu items.
   */
  "beforeDropdownMenuSetItems",
  /**
   * Fired by {@link ContextMenu} plugin after hiding the Context Menu. This hook is fired when {@link Options#contextMenu}
   * option is enabled.
   *
   * @event Hooks#afterContextMenuHide
   * @param {object} context The Context Menu plugin instance.
   */
  "afterContextMenuHide",
  /**
   * Fired by {@link ContextMenu} plugin before opening the Context Menu. This hook is fired when {@link Options#contextMenu}
   * option is enabled.
   *
   * @event Hooks#beforeContextMenuShow
   * @param {object} context The Context Menu instance.
   */
  "beforeContextMenuShow",
  /**
   * Fired by {@link ContextMenu} plugin after opening the Context Menu. This hook is fired when {@link Options#contextMenu}
   * option is enabled.
   *
   * @event Hooks#afterContextMenuShow
   * @param {object} context The Context Menu plugin instance.
   */
  "afterContextMenuShow",
  /**
   * Fired by {@link CopyPaste} plugin after reaching the copy limit while copying data. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#afterCopyLimit
   * @param {number} selectedRows Count of selected copyable rows.
   * @param {number} selectedColumns Count of selected copyable columns.
   * @param {number} copyRowsLimit Current copy rows limit.
   * @param {number} copyColumnsLimit Current copy columns limit.
   */
  "afterCopyLimit",
  /**
   * Fired before created a new column.
   *
   * @event Hooks#beforeCreateCol
   * @param {number} index Represents the visual index of first newly created column in the data source array.
   * @param {number} amount Number of newly created columns in the data source array.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*} If `false` then creating columns is cancelled.
   * @example
   * ::: only-for javascript
   * ```js
   * // Return `false` to cancel column inserting.
   * new Handsontable(element, {
   *   beforeCreateCol: function(data, coords) {
   *     return false;
   *   }
   * });
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * // Return `false` to cancel column inserting.
   * <HotTable
   *   beforeCreateCol={(data, coords) => {
   *     return false;
   *   }}
   * />
   * ```
   * :::
   */
  "beforeCreateCol",
  /**
   * Fired after the order of columns has changed.
   * This hook is fired by changing column indexes of any type supported by the {@link IndexMapper}.
   *
   * @event Hooks#afterColumnSequenceChange
   * @param {'init'|'remove'|'insert'|'move'|'update'} [source] A string that indicates what caused the change to the order of columns.
   */
  "afterColumnSequenceChange",
  /**
   * Fired after created a new column.
   *
   * @event Hooks#afterCreateCol
   * @param {number} index Represents the visual index of first newly created column in the data source.
   * @param {number} amount Number of newly created columns in the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterCreateCol",
  /**
   * Fired before created a new row.
   *
   * @event Hooks#beforeCreateRow
   * @param {number} index Represents the visual index of first newly created row in the data source array.
   * @param {number} amount Number of newly created rows in the data source array.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeCreateRow",
  /**
   * Fired after created a new row.
   *
   * @event Hooks#afterCreateRow
   * @param {number} index Represents the visual index of first newly created row in the data source array.
   * @param {number} amount Number of newly created rows in the data source array.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterCreateRow",
  /**
   * Fired after all selected cells are deselected.
   *
   * @event Hooks#afterDeselect
   */
  "afterDeselect",
  /**
   * Fired after destroying the Handsontable instance.
   *
   * @event Hooks#afterDestroy
   */
  "afterDestroy",
  /**
   * Hook fired after keydown event is handled.
   *
   * @event Hooks#afterDocumentKeyDown
   * @param {Event} event A native `keydown` event object.
   */
  "afterDocumentKeyDown",
  /**
   * Fired inside the Walkontable's selection `draw` method. Can be used to add additional class names to cells, depending on the current selection.
   *
   * @event Hooks#afterDrawSelection
   * @param {number} currentRow Row index of the currently processed cell.
   * @param {number} currentColumn Column index of the currently cell.
   * @param {number[]} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
   * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.
   * @since 0.38.1
   * @returns {string|undefined} Can return a `String`, which will act as an additional `className` to be added to the currently processed cell.
   */
  "afterDrawSelection",
  /**
   * Fired inside the Walkontable's `refreshSelections` method. Can be used to remove additional class names from all cells in the table.
   *
   * @event Hooks#beforeRemoveCellClassNames
   * @since 0.38.1
   * @returns {string[]|undefined} Can return an `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
   */
  "beforeRemoveCellClassNames",
  /**
   * Fired after getting the cell settings.
   *
   * @event Hooks#afterGetCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} cellProperties Object containing the cell properties.
   */
  "afterGetCellMeta",
  /**
   * Fired after retrieving information about a column header and appending it to the table header.
   *
   * @event Hooks#afterGetColHeader
   * @param {number} column Visual column index.
   * @param {HTMLTableCellElement} TH Header's TH element.
   * @param {number} [headerLevel=0] (Since 12.2.0) Header level index. Accepts positive (0 to n)
   *                                 and negative (-1 to -n) values. For positive values, 0 points to the
   *                                 topmost header. For negative values, -1 points to the bottom-most
   *                                 header (the header closest to the cells).
   */
  "afterGetColHeader",
  /**
   * Fired after retrieving information about a row header and appending it to the table header.
   *
   * @event Hooks#afterGetRowHeader
   * @param {number} row Visual row index.
   * @param {HTMLTableCellElement} TH Header's TH element.
   */
  "afterGetRowHeader",
  /**
   * Fired after the Handsontable instance is initiated.
   *
   * @event Hooks#afterInit
   */
  "afterInit",
  /**
   * Fired after Handsontable's [`data`](@/api/options.md#data)
   * gets modified by the [`loadData()`](@/api/core.md#loaddata) method
   * or the [`updateSettings()`](@/api/core.md#updatesettings) method.
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data.md)
   *
   * @event Hooks#afterLoadData
   * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
   * @param {string} source The source of the call
   */
  "afterLoadData",
  /**
   * Fired after the [`updateData()`](@/api/core.md#updatedata) method
   * modifies Handsontable's [`data`](@/api/options.md#data).
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data.md)
   *
   * @event Hooks#afterUpdateData
   * @since 11.1.0
   * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
   * @param {string} source The source of the call
   */
  "afterUpdateData",
  /**
   * Fired after a scroll event, which is identified as a momentum scroll (e.g. On an iPad).
   *
   * @event Hooks#afterMomentumScroll
   */
  "afterMomentumScroll",
  /**
   * Fired after a `mousedown` event is triggered on the cell corner (the drag handle).
   *
   * @event Hooks#afterOnCellCornerMouseDown
   * @param {Event} event `mousedown` event object.
   */
  "afterOnCellCornerMouseDown",
  /**
   * Fired after a `dblclick` event is triggered on the cell corner (the drag handle).
   *
   * @event Hooks#afterOnCellCornerDblClick
   * @param {Event} event `dblclick` event object.
   */
  "afterOnCellCornerDblClick",
  /**
   * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate
   * indexes are negative.
   *
   * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseDown` called
   * with coordinates `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellMouseDown
   * @param {Event} event `mousedown` event object.
   * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseDown",
  /**
   * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate
   * indexes are negative.
   *
   * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseUp` called
   * with coordinates `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellMouseUp
   * @param {Event} event `mouseup` event object.
   * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseUp",
  /**
   * Fired after clicking right mouse button on a cell or row/column header.
   *
   * For example clicking on the row header of cell (0, 0) results with `afterOnCellContextMenu` called
   * with coordinates `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellContextMenu
   * @since 4.1.0
   * @param {Event} event `contextmenu` event object.
   * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellContextMenu",
  /**
   * Fired after hovering a cell or row/column header with the mouse cursor. In case the row/column header was
   * hovered, the index is negative.
   *
   * For example, hovering over the row header of cell (0, 0) results with `afterOnCellMouseOver` called
   * with coords `{row: 0, col: -1}`.
   *
   * @event Hooks#afterOnCellMouseOver
   * @param {Event} event `mouseover` event object.
   * @param {CellCoords} coords Hovered cell's visual coordinate object.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseOver",
  /**
   * Fired after leaving a cell or row/column header with the mouse cursor.
   *
   * @event Hooks#afterOnCellMouseOut
   * @param {Event} event `mouseout` event object.
   * @param {CellCoords} coords Leaved cell's visual coordinate object.
   * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
   */
  "afterOnCellMouseOut",
  /**
   * Fired after one or more columns are removed.
   *
   * @event Hooks#afterRemoveCol
   * @param {number} index Visual index of starter column.
   * @param {number} amount An amount of removed columns.
   * @param {number[]} physicalColumns An array of physical columns removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterRemoveCol",
  /**
   * Fired after one or more rows are removed.
   *
   * @event Hooks#afterRemoveRow
   * @param {number} index Visual index of starter row.
   * @param {number} amount An amount of removed rows.
   * @param {number[]} physicalRows An array of physical rows removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterRemoveRow",
  /**
   * Fired before starting rendering the cell.
   *
   * @event Hooks#beforeRenderer
   * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.
   * @param {*} value Value of the rendered cell.
   * @param {object} cellProperties Object containing the cell's properties.
   */
  "beforeRenderer",
  /**
   * Fired after finishing rendering the cell (after the renderer finishes).
   *
   * @event Hooks#afterRenderer
   * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.
   * @param {*} value Value of the rendered cell.
   * @param {object} cellProperties Object containing the cell's properties.
   */
  "afterRenderer",
  /**
   * Fired after the order of rows has changed.
   * This hook is fired by changing row indexes of any type supported by the {@link IndexMapper}.
   *
   * @event Hooks#afterRowSequenceChange
   * @param {'init'|'remove'|'insert'|'move'|'update'} [source] A string that indicates what caused the change to the order of rows.
   */
  "afterRowSequenceChange",
  /**
   * Fired after the horizontal scroll event.
   *
   * @event Hooks#afterScrollHorizontally
   */
  "afterScrollHorizontally",
  /**
   * Fired after the vertical scroll event.
   *
   * @event Hooks#afterScrollVertically
   */
  "afterScrollVertically",
  /**
   * Fired after one or more cells are selected (e.g. During mouse move).
   *
   * @event Hooks#afterSelection
   * @param {number} row Selection start visual row index.
   * @param {number} column Selection start visual column index.
   * @param {number} row2 Selection end visual row index.
   * @param {number} column2 Selection end visual column index.
   * @param {object} preventScrolling A reference to the observable object with the `value` property.
   *                                  Property `preventScrolling.value` expects a boolean value that
   *                                  Handsontable uses to control scroll behavior after selection.
   * @param {object} preventScrolling Object with `value` property where its value change will be observed.
   * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   * @example
   * ::: only-for javascript
   * ```js
   * new Handsontable(element, {
   *   afterSelection: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
   *     // If set to `false` (default): when cell selection is outside the viewport,
   *     // Handsontable scrolls the viewport to cell selection's end corner.
   *     // If set to `true`: when cell selection is outside the viewport,
   *     // Handsontable doesn't scroll to cell selection's end corner.
   *     preventScrolling.value = true;
   *   }
   * })
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * <HotTable
   *   afterSelection={(row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
   *     // If set to `false` (default): when cell selection is outside the viewport,
   *     // Handsontable scrolls the viewport to cell selection's end corner.
   *     // If set to `true`: when cell selection is outside the viewport,
   *     // Handsontable doesn't scroll to cell selection's end corner.
   *     preventScrolling.value = true;
   *   }}
   * />
   * ```
   * :::
   */
  "afterSelection",
  /**
   * Fired after one or more cells are selected.
   *
   * The `prop` and `prop2` arguments represent the source object property name instead of the column number.
   *
   * @event Hooks#afterSelectionByProp
   * @param {number} row Selection start visual row index.
   * @param {string} prop Selection start data source object property name.
   * @param {number} row2 Selection end visual row index.
   * @param {string} prop2 Selection end data source object property name.
   * @param {object} preventScrolling Object with `value` property where its value change will be observed.
   * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   * @example
   * ```js
   * ::: only-for javascript
   * new Handsontable(element, {
   *   afterSelectionByProp: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
   *     // setting if prevent scrolling after selection
   *     preventScrolling.value = true;
   *   }
   * })
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * <HotTable
   *   afterSelectionByProp={(row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
   *     // setting if prevent scrolling after selection
   *     preventScrolling.value = true;
   *   }}
   * />
   * ```
   * :::
   */
  "afterSelectionByProp",
  /**
   * Fired after one or more cells are selected (e.g. On mouse up).
   *
   * @event Hooks#afterSelectionEnd
   * @param {number} row Selection start visual row index.
   * @param {number} column Selection start visual column index.
   * @param {number} row2 Selection end visual row index.
   * @param {number} column2 Selection end visual column index.
   * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   */
  "afterSelectionEnd",
  /**
   * Fired after one or more cells are selected (e.g. On mouse up).
   *
   * The `prop` and `prop2` arguments represent the source object property name instead of the column number.
   *
   * @event Hooks#afterSelectionEndByProp
   * @param {number} row Selection start visual row index.
   * @param {string} prop Selection start data source object property index.
   * @param {number} row2 Selection end visual row index.
   * @param {string} prop2 Selection end data source object property index.
   * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
   */
  "afterSelectionEndByProp",
  /**
   * Fired after cell meta is changed.
   *
   * @event Hooks#afterSetCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key The updated meta key.
   * @param {*} value The updated meta value.
   */
  "afterSetCellMeta",
  /**
   * Fired after cell meta is removed.
   *
   * @event Hooks#afterRemoveCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key The removed meta key.
   * @param {*} value Value which was under removed key of cell meta.
   */
  "afterRemoveCellMeta",
  /**
   * Fired after cell data was changed.
   *
   * @event Hooks#afterSetDataAtCell
   * @param {Array} changes An array of changes in format `[[row, column, oldValue, value], ...]`.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterSetDataAtCell",
  /**
   * Fired after cell data was changed.
   * Called only when `setDataAtRowProp` was executed.
   *
   * @event Hooks#afterSetDataAtRowProp
   * @param {Array} changes An array of changes in format `[[row, prop, oldValue, value], ...]`.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "afterSetDataAtRowProp",
  /**
   * Fired after cell source data was changed.
   *
   * @event Hooks#afterSetSourceDataAtCell
   * @since 8.0.0
   * @param {Array} changes An array of changes in format `[[row, column, oldValue, value], ...]`.
   * @param {string} [source] String that identifies source of hook call.
   */
  "afterSetSourceDataAtCell",
  /**
   * Fired after calling the `updateSettings` method.
   *
   * @event Hooks#afterUpdateSettings
   * @param {object} newSettings New settings object.
   */
  "afterUpdateSettings",
  /**
   * @description
   * A plugin hook executed after validator function, only if validator function is defined.
   * Validation result is the first parameter. This can be used to determinate if validation passed successfully or not.
   *
   * __Returning false from the callback will mark the cell as invalid__.
   *
   * @event Hooks#afterValidate
   * @param {boolean} isValid `true` if valid, `false` if not.
   * @param {*} value The value in question.
   * @param {number} row Visual row index.
   * @param {string|number} prop Property name / visual column index.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {undefined | boolean} If `false` the cell will be marked as invalid, `true` otherwise.
   */
  "afterValidate",
  /**
   * Fired before successful change of language (when proper language code was set).
   *
   * @event Hooks#beforeLanguageChange
   * @since 0.35.0
   * @param {string} languageCode New language code.
   */
  "beforeLanguageChange",
  /**
   * Fired after successful change of language (when proper language code was set).
   *
   * @event Hooks#afterLanguageChange
   * @since 0.35.0
   * @param {string} languageCode New language code.
   */
  "afterLanguageChange",
  /**
   * Fired by {@link Autofill} plugin before populating the data in the autofill feature. This hook is fired when
   * {@link Options#fillHandle} option is enabled.
   *
   * @event Hooks#beforeAutofill
   * @param {Array[]} selectionData Data the autofill operation will start from.
   * @param {CellRange} sourceRange The range values will be filled from.
   * @param {CellRange} targetRange The range new values will be filled into.
   * @param {string} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.
   *
   * @returns {boolean|Array[]} If false, the operation is cancelled. If array of arrays, the returned data
   *                              will be passed into `populateFromArray` instead of the default autofill
   *                              algorithm's result.
   */
  "beforeAutofill",
  /**
   * Fired by {@link Autofill} plugin after populating the data in the autofill feature. This hook is fired when
   * {@link Options#fillHandle} option is enabled.
   *
   * @event Hooks#afterAutofill
   * @since 8.0.0
   * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used
   *                            and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.
   * @param {CellRange} sourceRange The range values will be filled from.
   * @param {CellRange} targetRange The range new values will be filled into.
   * @param {string} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.
   */
  "afterAutofill",
  /**
   * Fired before aligning the cell contents.
   *
   * @event Hooks#beforeCellAlignment
   * @param {object} stateBefore An object with class names defining the cell alignment.
   * @param {CellRange[]} range An array of CellRange coordinates where the alignment will be applied.
   * @param {string} type Type of the alignment - either `horizontal` or `vertical`.
   * @param {string} alignmentClass String defining the alignment class added to the cell.
   * Possible values:
   * * `htLeft`
   * * `htCenter`
   * * `htRight`
   * * `htJustify`
   * * `htTop`
   * * `htMiddle`
   * * `htBottom`.
   */
  "beforeCellAlignment",
  /**
   * Fired before one or more cells are changed.
   *
   * Use this hook to silently alter the user's changes before Handsontable re-renders.
   *
   * To ignore the user's changes, use a nullified array or return `false`.
   *
   * @event Hooks#beforeChange
   * @param {Array[]} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`. `row` is a visual row index.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {undefined | boolean} If `false` all changes were cancelled, `true` otherwise.
   * @example
   * ::: only-for javascript
   * ```js
   * // to alter a single change, overwrite the value with `changes[i][3]`
   * new Handsontable(element, {
   *   beforeChange: (changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     changes[0][3] = 10;
   *   }
   * });
   *
   * // to ignore a single change, set `changes[i]` to `null`
   * // or remove `changes[i]` from the array, by using `changes.splice(i, 1)`
   * new Handsontable(element, {
   *   beforeChange: (changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     changes[0] = null;
   *   }
   * });
   *
   * // to ignore all changes, return `false`
   * // or set the array's length to 0, by using `changes.length = 0`
   * new Handsontable(element, {
   *   beforeChange: (changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     return false;
   *   }
   * });
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * // to alter a single change, overwrite the desired value with `changes[i][3]`
   * <HotTable
   *   beforeChange={(changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     changes[0][3] = 10;
   *   }}
   * />
   *
   * // to ignore a single change, set `changes[i]` to `null`
   * // or remove `changes[i]` from the array, by using changes.splice(i, 1).
   * <HotTable
   *   beforeChange={(changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     changes[0] = null;
   *   }}
   * />
   *
   * // to ignore all changes, return `false`
   * // or set the array's length to 0 (`changes.length = 0`)
   * <HotTable
   *   beforeChange={(changes, source) => {
   *     // [[row, prop, oldVal, newVal], ...]
   *     return false;
   *   }}
   * />
   * ```
   * :::
   */
  "beforeChange",
  /**
   * Fired right before rendering the changes.
   *
   * @event Hooks#beforeChangeRender
   * @param {Array[]} changes Array in form of `[row, prop, oldValue, newValue]`.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "beforeChangeRender",
  /**
   * Fired before drawing the borders.
   *
   * @event Hooks#beforeDrawBorders
   * @param {Array} corners Array specifying the current selection borders.
   * @param {string} borderClassName Specifies the border class name.
   */
  "beforeDrawBorders",
  /**
   * Fired before getting cell settings.
   *
   * @event Hooks#beforeGetCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} cellProperties Object containing the cell's properties.
   */
  "beforeGetCellMeta",
  /**
   * Fired before cell meta is removed.
   *
   * @event Hooks#beforeRemoveCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key The removed meta key.
   * @param {*} value Value which is under removed key of cell meta.
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRemoveCellMeta",
  /**
   * Fired before the Handsontable instance is initiated.
   *
   * @event Hooks#beforeInit
   */
  "beforeInit",
  /**
   * Fired before the Walkontable instance is initiated.
   *
   * @event Hooks#beforeInitWalkontable
   * @param {object} walkontableConfig Walkontable configuration object.
   */
  "beforeInitWalkontable",
  /**
   * Fired before Handsontable's [`data`](@/api/options.md#data)
   * gets modified by the [`loadData()`](@/api/core.md#loaddata) method
   * or the [`updateSettings()`](@/api/core.md#updatesettings) method.
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data.md)
   *
   * @event Hooks#beforeLoadData
   * @since 8.0.0
   * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
   * @param {string} source The source of the call
   * @returns {Array} The returned array will be used as Handsontable's new dataset.
   */
  "beforeLoadData",
  /**
   * Fired before the [`updateData()`](@/api/core.md#updatedata) method
   * modifies Handsontable's [`data`](@/api/options.md#data).
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data.md)
   *
   * @event Hooks#beforeUpdateData
   * @since 11.1.0
   * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
   * @param {string} source The source of the call
   * @returns {Array} The returned array will be used as Handsontable's new dataset.
   */
  "beforeUpdateData",
  /**
   * Hook fired before keydown event is handled. It can be used to stop default key bindings.
   *
   * __Note__: To prevent default behavior you need to call `false` in your `beforeKeyDown` handler.
   *
   * @event Hooks#beforeKeyDown
   * @param {Event} event Original DOM event.
   */
  "beforeKeyDown",
  /**
   * Fired after the user clicked a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellMouseDown
   * @param {Event} event The `mousedown` event object.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  "beforeOnCellMouseDown",
  /**
   * Fired after the user clicked a cell.
   *
   * @event Hooks#beforeOnCellMouseUp
   * @param {Event} event The `mouseup` event object.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   */
  "beforeOnCellMouseUp",
  /**
   * Fired after the user clicked a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellContextMenu
   * @since 4.1.0
   * @param {Event} event The `contextmenu` event object.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   */
  "beforeOnCellContextMenu",
  /**
   * Fired after the user moved cursor over a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellMouseOver
   * @param {Event} event The `mouseover` event object.
   * @param {CellCoords} coords CellCoords object containing the visual coordinates of the clicked cell.
   * @param {HTMLTableCellElement} TD TD element.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  "beforeOnCellMouseOver",
  /**
   * Fired after the user moved cursor out from a cell, but before all the calculations related with it.
   *
   * @event Hooks#beforeOnCellMouseOut
   * @param {Event} event The `mouseout` event object.
   * @param {CellCoords} coords CellCoords object containing the visual coordinates of the leaved cell.
   * @param {HTMLTableCellElement} TD TD element.
   */
  "beforeOnCellMouseOut",
  /**
   * Fired before one or more columns are about to be removed.
   *
   * @event Hooks#beforeRemoveCol
   * @param {number} index Visual index of starter column.
   * @param {number} amount Amount of columns to be removed.
   * @param {number[]} physicalColumns An array of physical columns removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRemoveCol",
  /**
   * Fired when one or more rows are about to be removed.
   *
   * @event Hooks#beforeRemoveRow
   * @param {number} index Visual index of starter row.
   * @param {number} amount Amount of rows to be removed.
   * @param {number[]} physicalRows An array of physical rows removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRemoveRow",
  /**
   * Fired before Handsontable's view-rendering engine is rendered.
   *
   * __Note:__ In Handsontable 9.x and earlier, the `beforeViewRender` hook was named `beforeRender`.
   *
   * @event Hooks#beforeViewRender
   * @since 10.0.0
   * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
   *                           data, or a logic that needs a full Handsontable render cycle.
   *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
   * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering cycle will be skipped.
   */
  "beforeViewRender",
  /**
   * Fired after Handsontable's view-rendering engine is rendered,
   * but before redrawing the selection borders and before scroll syncing.
   *
   * __Note:__ In Handsontable 9.x and earlier, the `afterViewRender` hook was named `afterRender`.
   *
   * @event Hooks#afterViewRender
   * @since 10.0.0
   * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
   *                           data, or a logic that needs a full Handsontable render cycle.
   *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
   */
  "afterViewRender",
  /**
   * Fired before Handsontable's view-rendering engine updates the view.
   *
   * The `beforeRender` event is fired right after the Handsontable
   * business logic is executed and right before the rendering engine starts calling
   * the Core logic, renderers, cell meta objects etc. to update the view.
   *
   * @event Hooks#beforeRender
   * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
   *                           data, or a logic that needs a full Handsontable render cycle.
   *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
   */
  "beforeRender",
  /**
   * Fired after Handsontable's view-rendering engine updates the view.
   *
   * @event Hooks#afterRender
   * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
   *                           data, or a logic that needs a full Handsontable render cycle.
   *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
   */
  "afterRender",
  /**
   * Fired before cell meta is changed.
   *
   * @event Hooks#beforeSetCellMeta
   * @since 8.0.0
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key The updated meta key.
   * @param {*} value The updated meta value.
   * @returns {boolean|undefined} If false is returned the action is canceled.
   */
  "beforeSetCellMeta",
  /**
   * Fired before setting range is started but not finished yet.
   *
   * @event Hooks#beforeSetRangeStartOnly
   * @param {CellCoords} coords CellCoords instance.
   */
  "beforeSetRangeStartOnly",
  /**
   * Fired before setting range is started.
   *
   * @event Hooks#beforeSetRangeStart
   * @param {CellCoords} coords CellCoords instance.
   */
  "beforeSetRangeStart",
  /**
   * Fired before setting range is ended.
   *
   * @event Hooks#beforeSetRangeEnd
   * @param {CellCoords} coords CellCoords instance.
   */
  "beforeSetRangeEnd",
  /**
   * Fired before the logic of handling a touch scroll, when user started scrolling on a touch-enabled device.
   *
   * @event Hooks#beforeTouchScroll
   */
  "beforeTouchScroll",
  /**
   * Fired before cell validation, only if validator function is defined. This can be used to manipulate the value
   * of changed cell before it is applied to the validator function.
   *
   * __Note:__ this will not affect values of changes. This will change value *ONLY* for validation.
   *
   * @event Hooks#beforeValidate
   * @param {*} value Value of the cell.
   * @param {number} row Visual row index.
   * @param {string|number} prop Property name / column index.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   */
  "beforeValidate",
  /**
   * Fired before cell value is rendered into the DOM (through renderer function). This can be used to manipulate the
   * value which is passed to the renderer without modifying the renderer itself.
   *
   * @event Hooks#beforeValueRender
   * @param {*} value Cell value to render.
   * @param {object} cellProperties An object containing the cell properties.
   */
  "beforeValueRender",
  /**
   * Fired after Handsontable instance is constructed (using `new` operator).
   *
   * @event Hooks#construct
   */
  "construct",
  /**
   * Fired after Handsontable instance is initiated but before table is rendered.
   *
   * @event Hooks#init
   */
  "init",
  /**
   * Fired when a column header index is about to be modified by a callback function.
   *
   * @event Hooks#modifyColHeader
   * @param {number} column Visual column header index.
   */
  "modifyColHeader",
  /**
   * Fired when a column width is about to be modified by a callback function.
   *
   * @event Hooks#modifyColWidth
   * @param {number} width Current column width.
   * @param {number} column Visual column index.
   */
  "modifyColWidth",
  /**
   * Fired when a row header index is about to be modified by a callback function.
   *
   * @event Hooks#modifyRowHeader
   * @param {number} row Visual row header index.
   */
  "modifyRowHeader",
  /**
   * Fired when a row height is about to be modified by a callback function.
   *
   * @event Hooks#modifyRowHeight
   * @param {number} height Row height.
   * @param {number} row Visual row index.
   */
  "modifyRowHeight",
  /**
   * Fired when a data was retrieved or modified.
   *
   * @event Hooks#modifyData
   * @param {number} row Physical row index.
   * @param {number} column Visual column index.
   * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value` property.
   * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
   */
  "modifyData",
  /**
   * Fired when a data was retrieved or modified from the source data set.
   *
   * @event Hooks#modifySourceData
   * @since 8.0.0
   * @param {number} row Physical row index.
   * @param {number} column Physical column index or property name.
   * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value` property.
   * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
   */
  "modifySourceData",
  /**
   * Fired when a data was retrieved or modified.
   *
   * @event Hooks#modifyRowData
   * @param {number} row Physical row index.
   */
  "modifyRowData",
  /**
   * Used to modify the cell coordinates when using the `getCell` method, opening editor, getting value from the editor
   * and saving values from the closed editor.
   *
   * @event Hooks#modifyGetCellCoords
   * @since 0.36.0
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {boolean} topmost If set to `true`, it returns the TD element from the topmost overlay. For example,
   *                          if the wanted cell is in the range of fixed rows, it will return a TD element
   *                          from the `top` overlay.
   * @returns {undefined|number[]}
   */
  "modifyGetCellCoords",
  /**
   * Allows modify the visual row index that is used to retrieve the row header element (TH) before it's
   * highlighted (proper CSS class names are added). Modifying the visual row index allows building a custom
   * implementation of the nested headers feature or other features that require highlighting other DOM
   * elements than that the rendering engine, by default, would have highlighted.
   *
   * @event Hooks#beforeHighlightingRowHeader
   * @since 8.4.0
   * @param {number} row Visual row index.
   * @param {number} headerLevel Column header level (0 = most distant to the table).
   * @param {object} highlightMeta An object that contains additional information about processed selection.
   * @returns {number|undefined}
   */
  "beforeHighlightingRowHeader",
  /**
   * Allows modify the visual column index that is used to retrieve the column header element (TH) before it's
   * highlighted (proper CSS class names are added). Modifying the visual column index allows building a custom
   * implementation of the nested headers feature or other features that require highlighting other DOM
   * elements than that the rendering engine, by default, would have highlighted.
   *
   * @event Hooks#beforeHighlightingColumnHeader
   * @since 8.4.0
   * @param {number} column Visual column index.
   * @param {number} headerLevel Row header level (0 = most distant to the table).
   * @param {object} highlightMeta An object that contains additional information about processed selection.
   * @returns {number|undefined}
   */
  "beforeHighlightingColumnHeader",
  /**
   * Fired by {@link PersistentState} plugin, after loading value, saved under given key, from browser local storage.
   *
   * The `persistentStateLoad` hook is fired even when the {@link Options#persistentState} option is disabled.
   *
   * @event Hooks#persistentStateLoad
   * @param {string} key Key.
   * @param {object} valuePlaceholder Object containing the loaded value under `valuePlaceholder.value` (if no value have been saved, `value` key will be undefined).
   */
  "persistentStateLoad",
  /**
   * Fired by {@link PersistentState} plugin after resetting data from local storage. If no key is given, all values associated with table will be cleared.
   * This hook is fired when {@link Options#persistentState} option is enabled.
   *
   * @event Hooks#persistentStateReset
   * @param {string} [key] Key.
   */
  "persistentStateReset",
  /**
   * Fired by {@link PersistentState} plugin, after saving value under given key in browser local storage.
   *
   * The `persistentStateSave` hook is fired even when the {@link Options#persistentState} option is disabled.
   *
   * @event Hooks#persistentStateSave
   * @param {string} key Key.
   * @param {Mixed} value Value to save.
   */
  "persistentStateSave",
  /**
   * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins before sorting the column. If you return `false` value inside callback for hook, then sorting
   * will be not applied by the Handsontable (useful for server-side sorting).
   *
   * This hook is fired when {@link Options#columnSorting} or {@link Options#multiColumnSorting} option is enabled.
   *
   * @event Hooks#beforeColumnSort
   * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).
   * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).
   * @returns {boolean | undefined} If `false` the column will not be sorted, `true` otherwise.
   */
  "beforeColumnSort",
  /**
   * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins after sorting the column. This hook is fired when {@link Options#columnSorting}
   * or {@link Options#multiColumnSorting} option is enabled.
   *
   * @event Hooks#afterColumnSort
   * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).
   * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).
   */
  "afterColumnSort",
  /**
   * Fired by {@link Autofill} plugin after setting range of autofill. This hook is fired when {@link Options#fillHandle}
   * option is enabled.
   *
   * @event Hooks#modifyAutofillRange
   * @param {Array} startArea Array of visual coordinates of the starting point for the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).
   * @param {Array} entireArea Array of visual coordinates of the entire area of the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).
   */
  "modifyAutofillRange",
  /**
   * Fired to allow modifying the copyable range with a callback function.
   *
   * @event Hooks#modifyCopyableRange
   * @param {Array[]} copyableRanges Array of objects defining copyable cells.
   */
  "modifyCopyableRange",
  /**
   * Fired by {@link CopyPaste} plugin before copying the values to the clipboard and before clearing values of
   * the selected cells. This hook is fired when {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#beforeCut
   * @param {Array[]} data An array of arrays which contains data to cut.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       which will be cut out.
   * @returns {*} If returns `false` then operation of the cutting out is canceled.
   * @example
   * ::: only-for javascript
   * ```js
   * // To disregard a single row, remove it from the array using data.splice(i, 1).
   * new Handsontable(element, {
   *   beforeCut: function(data, coords) {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }
   * });
   * // To cancel a cutting action, just return `false`.
   * new Handsontable(element, {
   *   beforeCut: function(data, coords) {
   *     return false;
   *   }
   * });
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * // To disregard a single row, remove it from the array using data.splice(i, 1).
   * <HotTable
   *   beforeCut={(data, coords) => {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }}
   * />
   * // To cancel a cutting action, just return `false`.
   * <HotTable
   *   beforeCut={(data, coords) => {
   *     return false;
   *   }}
   * />
   * ```
   * :::
   */
  "beforeCut",
  /**
   * Fired by {@link CopyPaste} plugin after data was cut out from the table. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#afterCut
   * @param {Array[]} data An array of arrays with the cut data.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       which was cut out.
   */
  "afterCut",
  /**
   * Fired before values are copied to the clipboard.
   *
   * @event Hooks#beforeCopy
   * @param {Array[]} data An array of arrays which contains data to copied.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                         which will copied.
   * @param {{ columnHeadersCount: number }} copiedHeadersCount (Since 12.3.0) The number of copied column headers.
   * @returns {*} If returns `false` then copying is canceled.
   *
   * @example
   * ::: only-for javascript
   * ```js
   * // To disregard a single row, remove it from array using data.splice(i, 1).
   * ...
   * new Handsontable(document.getElementById('example'), {
   *   beforeCopy: (data, coords) => {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }
   * });
   * ...
   *
   * // To cancel copying, return false from the callback.
   * ...
   * new Handsontable(document.getElementById('example'), {
   *   beforeCopy: (data, coords) => {
   *     return false;
   *   }
   * });
   * ...
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * // To disregard a single row, remove it from array using data.splice(i, 1).
   * ...
   * <HotTable
   *   beforeCopy={(data, coords) => {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }}
   * />
   * ...
   *
   * // To cancel copying, return false from the callback.
   * ...
   * <HotTable
   *   beforeCopy={(data, coords) => {
   *     return false;
   *   }}
   * />
   * ...
   * ```
   * :::
   */
  "beforeCopy",
  /**
   * Fired by {@link CopyPaste} plugin after data are pasted into table. This hook is fired when {@link Options#copyPaste}
   * option is enabled.
   *
   * @event Hooks#afterCopy
   * @param {Array[]} data An array of arrays which contains the copied data.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                         which was copied.
   * @param {{ columnHeadersCount: number }} copiedHeadersCount (Since 12.3.0) The number of copied column headers.
   */
  "afterCopy",
  /**
   * Fired by {@link CopyPaste} plugin before values are pasted into table. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#beforePaste
   * @param {Array[]} data An array of arrays which contains data to paste.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       that correspond to the previously selected area.
   * @returns {*} If returns `false` then pasting is canceled.
   * @example
   * ```js
   * ::: only-for javascript
   * // To disregard a single row, remove it from array using data.splice(i, 1).
   * new Handsontable(example, {
   *   beforePaste: (data, coords) => {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }
   * });
   * // To cancel pasting, return false from the callback.
   * new Handsontable(example, {
   *   beforePaste: (data, coords) => {
   *     return false;
   *   }
   * });
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * // To disregard a single row, remove it from array using data.splice(i, 1).
   * <HotTable
   *   beforePaste={(data, coords) => {
   *     // data -> [[1, 2, 3], [4, 5, 6]]
   *     data.splice(0, 1);
   *     // data -> [[4, 5, 6]]
   *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
   *   }}
   * />
   * // To cancel pasting, return false from the callback.
   * <HotTable
   *   beforePaste={(data, coords) => {
   *     return false;
   *   }}
   * />
   * ```
   * :::
   */
  "beforePaste",
  /**
   * Fired by {@link CopyPaste} plugin after values are pasted into table. This hook is fired when
   * {@link Options#copyPaste} option is enabled.
   *
   * @event Hooks#afterPaste
   * @param {Array[]} data An array of arrays with the pasted data.
   * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                       that correspond to the previously selected area.
   */
  "afterPaste",
  /**
   * Fired by the {@link ManualColumnFreeze} plugin, before freezing a column.
   *
   * @event Hooks#beforeColumnFreeze
   * @since 12.1.0
   * @param {number} column The visual index of the column that is going to freeze.
   * @param {boolean} freezePerformed If `true`: the column is going to freeze. If `false`: the column is not going to freeze (which might happen if the column is already frozen).
   * @returns {boolean|undefined} If `false`: the column is not going to freeze, and the `afterColumnFreeze` hook won't fire.
   */
  "beforeColumnFreeze",
  /**
   * Fired by the {@link ManualColumnFreeze} plugin, right after freezing a column.
   *
   * @event Hooks#afterColumnFreeze
   * @since 12.1.0
   * @param {number} column The visual index of the frozen column.
   * @param {boolean} freezePerformed If `true`: the column got successfully frozen. If `false`: the column didn't get frozen.
   */
  "afterColumnFreeze",
  /**
   * Fired by {@link ManualColumnMove} plugin before change order of the visual indexes. This hook is fired when
   * {@link Options#manualColumnMove} option is enabled.
   *
   * @event Hooks#beforeColumnMove
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns.
   *                            Points to where the elements will be placed after the moving action.
   *                            To check visualization of final index please take a look at
   *                            [documentation](@/guides/columns/column-moving.md).
   * @param {number|undefined} dropIndex Visual column index, being a drop index for the moved columns.
   *                                     Points to where we are going to drop the moved elements. To check
   *                                     visualization of drop index please take a look at
   *                                     [documentation](@/guides/columns/column-moving.md).
   *                                     It's `undefined` when `dragColumns` function wasn't called.
   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
   * @returns {undefined | boolean} If `false` the column will not be moved, `true` otherwise.
   */
  "beforeColumnMove",
  /**
   * Fired by {@link ManualColumnMove} plugin after changing order of the visual indexes.
   * This hook is fired when {@link Options#manualColumnMove} option is enabled.
   *
   * @event Hooks#afterColumnMove
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns.
   *                            Points to where the elements will be placed after the moving action.
   *                            To check visualization of final index please take a look at
   *                            [documentation](@/guides/columns/column-moving.md).
   * @param {number|undefined} dropIndex Visual column index, being a drop index for the moved columns.
   *                                     Points to where we are going to drop the moved elements.
   *                                     To check visualization of drop index please take a look at
   *                                     [documentation](@/guides/columns/column-moving.md).
   *                                     It's `undefined` when `dragColumns` function wasn't called.
   * @param {boolean} movePossible Indicates if it was possible to move columns to the desired position.
   * @param {boolean} orderChanged Indicates if order of columns was changed by move.
   */
  "afterColumnMove",
  /**
   * Fired by the {@link ManualColumnFreeze} plugin, before unfreezing a column.
   *
   * @event Hooks#beforeColumnUnfreeze
   * @since 12.1.0
   * @param {number} column The visual index of the column that is going to unfreeze.
   * @param {boolean} unfreezePerformed If `true`: the column is going to unfreeze. If `false`: the column is not going to unfreeze (which might happen if the column is already unfrozen).
   * @returns {boolean|undefined} If `false`: the column is not going to unfreeze, and the `afterColumnUnfreeze` hook won't fire.
   */
  "beforeColumnUnfreeze",
  /**
   * Fired by the {@link ManualColumnFreeze} plugin, right after unfreezing a column.
   *
   * @event Hooks#afterColumnUnfreeze
   * @since 12.1.0
   * @param {number} column The visual index of the unfrozen column.
   * @param {boolean} unfreezePerformed If `true`: the column got successfully unfrozen. If `false`: the column didn't get unfrozen.
   */
  "afterColumnUnfreeze",
  /**
   * Fired by {@link ManualRowMove} plugin before changing the order of the visual indexes. This hook is fired when
   * {@link Options#manualRowMove} option is enabled.
   *
   * @event Hooks#beforeRowMove
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows.
   *                            Points to where the elements will be placed after the moving action.
   *                            To check visualization of final index please take a look at
   *                            [documentation](@/guides/rows/row-moving.md).
   * @param {number|undefined} dropIndex Visual row index, being a drop index for the moved rows.
   *                                     Points to where we are going to drop the moved elements.
   *                                     To check visualization of drop index please take a look at
   *                                     [documentation](@/guides/rows/row-moving.md).
   *                                     It's `undefined` when `dragRows` function wasn't called.
   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRowMove",
  /**
   * Fired by {@link ManualRowMove} plugin after changing the order of the visual indexes.
   * This hook is fired when {@link Options#manualRowMove} option is enabled.
   *
   * @event Hooks#afterRowMove
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows.
   *                            Points to where the elements will be placed after the moving action.
   *                            To check visualization of final index please take a look at
   *                            [documentation](@/guides/rows/row-moving.md).
   * @param {number|undefined} dropIndex Visual row index, being a drop index for the moved rows.
   *                                     Points to where we are going to drop the moved elements.
   *                                     To check visualization of drop index please take a look at
   *                                     [documentation](@/guides/rows/row-moving.md).
   *                                     It's `undefined` when `dragRows` function wasn't called.
   * @param {boolean} movePossible Indicates if it was possible to move rows to the desired position.
   * @param {boolean} orderChanged Indicates if order of rows was changed by move.
   */
  "afterRowMove",
  /**
   * Fired by {@link ManualColumnResize} plugin before rendering the table with modified column sizes. This hook is
   * fired when {@link Options#manualColumnResize} option is enabled.
   *
   * @event Hooks#beforeColumnResize
   * @param {number} newSize Calculated new column width.
   * @param {number} column Visual index of the resized column.
   * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
   * @returns {number} Returns a new column size or `undefined`, if column size should be calculated automatically.
   */
  "beforeColumnResize",
  /**
   * Fired by {@link ManualColumnResize} plugin after rendering the table with modified column sizes. This hook is
   * fired when {@link Options#manualColumnResize} option is enabled.
   *
   * @event Hooks#afterColumnResize
   * @param {number} newSize Calculated new column width.
   * @param {number} column Visual index of the resized column.
   * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
   */
  "afterColumnResize",
  /**
   * Fired by {@link ManualRowResize} plugin before rendering the table with modified row sizes. This hook is
   * fired when {@link Options#manualRowResize} option is enabled.
   *
   * @event Hooks#beforeRowResize
   * @param {number} newSize Calculated new row height.
   * @param {number} row Visual index of the resized row.
   * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
   * @returns {number|undefined} Returns the new row size or `undefined` if row size should be calculated automatically.
   */
  "beforeRowResize",
  /**
   * Fired by {@link ManualRowResize} plugin after rendering the table with modified row sizes. This hook is
   * fired when {@link Options#manualRowResize} option is enabled.
   *
   * @event Hooks#afterRowResize
   * @param {number} newSize Calculated new row height.
   * @param {number} row Visual index of the resized row.
   * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
   */
  "afterRowResize",
  /**
   * Fired after getting the column header renderers.
   *
   * @event Hooks#afterGetColumnHeaderRenderers
   * @param {Function[]} renderers An array of the column header renderers.
   */
  "afterGetColumnHeaderRenderers",
  /**
   * Fired after getting the row header renderers.
   *
   * @event Hooks#afterGetRowHeaderRenderers
   * @param {Function[]} renderers An array of the row header renderers.
   */
  "afterGetRowHeaderRenderers",
  /**
   * Fired before applying stretched column width to column.
   *
   * @event Hooks#beforeStretchingColumnWidth
   * @param {number} stretchedWidth Calculated width.
   * @param {number} column Visual column index.
   * @returns {number|undefined} Returns new width which will be applied to the column element.
   */
  "beforeStretchingColumnWidth",
  /**
   * Fired by the [`Filters`](@/api/filters.md) plugin,
   * before a [column filter](@/guides/columns/column-filter.md) gets applied.
   *
   * [`beforeFilter`](#beforefilter) takes one argument (`conditionsStack`), which is an array of objects.
   * Each object represents one of your [column filters](@/api/filters.md#addcondition),
   * and consists of the following properties:
   *
   * | Property     | Possible values                                                         | Description                                                                                                              |
   * | ------------ | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
   * | `column`     | Number                                                                  | A visual index of the column to which the filter will be applied.                                                        |
   * | `conditions` | Array of objects                                                        | Each object represents one condition. For details, see [`addCondition()`](@/api/filters.md#addcondition).                |
   * | `operation`  | `'conjunction'` \| `'disjunction'` \| `'disjunctionWithExtraCondition'` | An operation to perform on your set of `conditions`. For details, see [`addCondition()`](@/api/filters.md#addcondition). |
   *
   * An example of the format of the `conditionsStack` argument:
   *
   * ```js
   * [
   *   {
   *     column: 2,
   *     conditions: [
   *       {name: 'begins_with', args: [['S']]}
   *     ],
   *     operation: 'conjunction'
   *   },
   *   {
   *     column: 4,
   *     conditions: [
   *       {name: 'not_empty', args: []}
   *     ],
   *     operation: 'conjunction'
   *   },
   * ]
   * ```
   *
   * To perform server-side filtering (i.e., to not apply filtering to Handsontable's UI),
   * set [`beforeFilter`](#beforefilter) to return `false`:
   *
   * ```js
   * new Handsontable(document.getElementById('example'), {
   *   beforeFilter: (conditionsStack) => {
   *     return false;
   *   }
   * });
   *```
   *
   * Read more:
   * - [Guides: Column filter](@/guides/columns/column-filter.md)
   * - [Hooks: `afterFilter`](#afterfilter)
   * - [Options: `filters`](@/api/options.md#filters)
   * - [Plugins: `Filters`](@/api/filters.md)
   * – [Plugin methods: `addCondition()`](@/api/filters.md#addcondition)
   *
   * @event Hooks#beforeFilter
   * @param {object[]} conditionsStack An array of objects with your [column filters](@/api/filters.md#addcondition).
   * @returns {boolean} To perform server-side filtering (i.e., to not apply filtering to Handsontable's UI), return `false`.
   */
  "beforeFilter",
  /**
   * Fired by the [`Filters`](@/api/filters.md) plugin,
   * after a [column filter](@/guides/columns/column-filter.md) gets applied.
   *
   * [`afterFilter`](#afterfilter) takes one argument (`conditionsStack`), which is an array of objects.
   * Each object represents one of your [column filters](@/api/filters.md#addcondition),
   * and consists of the following properties:
   *
   * | Property     | Possible values                                                         | Description                                                                                                              |
   * | ------------ | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
   * | `column`     | Number                                                                  | A visual index of the column to which the filter was applied.                                                            |
   * | `conditions` | Array of objects                                                        | Each object represents one condition. For details, see [`addCondition()`](@/api/filters.md#addcondition).                |
   * | `operation`  | `'conjunction'` \| `'disjunction'` \| `'disjunctionWithExtraCondition'` | An operation to perform on your set of `conditions`. For details, see [`addCondition()`](@/api/filters.md#addcondition). |
   *
   * An example of the format of the `conditionsStack` argument:
   *
   * ```js
   * [
   *   {
   *     column: 2,
   *     conditions: [
   *       {name: 'begins_with', args: [['S']]}
   *     ],
   *     operation: 'conjunction'
   *   },
   *   {
   *     column: 4,
   *     conditions: [
   *       {name: 'not_empty', args: []}
   *     ],
   *     operation: 'conjunction'
   *   },
   * ]
   * ```
   *
   * Read more:
   * - [Guides: Column filter](@/guides/columns/column-filter.md)
   * - [Hooks: `beforeFilter`](#beforefilter)
   * - [Options: `filters`](@/api/options.md#filters)
   * - [Plugins: `Filters`](@/api/filters.md)
   * – [Plugin methods: `addCondition()`](@/api/filters.md#addcondition)
   *
   * @event Hooks#afterFilter
   * @param {object[]} conditionsStack An array of objects with your [column filters](@/api/filters.md#addcondition).
   */
  "afterFilter",
  /**
   * Fired by the {@link Formulas} plugin, when any cell value changes.
   *
   * Returns an array of objects that contains:
   * - The addresses (`sheet`, `row`, `col`) and new values (`newValue`) of the changed cells.
   * - The addresses and new values of any cells that had to be recalculated (because their formulas depend on the cells that changed).
   *
   * This hook gets also fired on Handsontable's initialization, returning the addresses and values of all cells.
   *
   * Read more:
   * - [Guides: Formula calculation](@/guides/formulas/formula-calculation.md)
   * - [HyperFormula documentation: `valuesUpdated`](https://hyperformula.handsontable.com/api/interfaces/listeners.html#valuesupdated)
   *
   * @since 9.0.0
   * @event Hooks#afterFormulasValuesUpdate
   * @param {Array} changes The addresses and new values of all the changed and recalculated cells.
   */
  "afterFormulasValuesUpdate",
  /**
   * Fired when a named expression is added to the Formulas' engine instance.
   *
   * @since 9.0.0
   * @event Hooks#afterNamedExpressionAdded
   * @param {string} namedExpressionName The name of the added expression.
   * @param {Array} changes The values and location of applied changes.
   */
  "afterNamedExpressionAdded",
  /**
   * Fired when a named expression is removed from the Formulas' engine instance.
   *
   * @since 9.0.0
   * @event Hooks#afterNamedExpressionRemoved
   * @param {string} namedExpressionName The name of the removed expression.
   * @param {Array} changes The values and location of applied changes.
   */
  "afterNamedExpressionRemoved",
  /**
   * Fired when a new sheet is added to the Formulas' engine instance.
   *
   * @since 9.0.0
   * @event Hooks#afterSheetAdded
   * @param {string} addedSheetDisplayName The name of the added sheet.
   */
  "afterSheetAdded",
  /**
   * Fired when a sheet in the Formulas' engine instance is renamed.
   *
   * @since 9.0.0
   * @event Hooks#afterSheetRenamed
   * @param {string} oldDisplayName The old name of the sheet.
   * @param {string} newDisplayName The new name of the sheet.
   */
  "afterSheetRenamed",
  /**
   * Fired when a sheet is removed from the Formulas' engine instance.
   *
   * @since 9.0.0
   * @event Hooks#afterSheetRemoved
   * @param {string} removedSheetDisplayName The removed sheet name.
   * @param {Array} changes The values and location of applied changes.
   */
  "afterSheetRemoved",
  /**
   * Fired while retrieving the column header height.
   *
   * @event Hooks#modifyColumnHeaderHeight
   */
  "modifyColumnHeaderHeight",
  /**
   * Fired while retrieving a column header's value.
   *
   * @since 12.3.0
   * @event Hooks#modifyColumnHeaderValue
   * @param {string} value A column header value.
   * @param {number} visualColumnIndex A visual column index.
   * @param {number} [headerLevel=0] Header level index. Accepts positive (0 to n)
   *                                 and negative (-1 to -n) values. For positive values, 0 points to the
   *                                 topmost header. For negative values, -1 points to the bottom-most
   *                                 header (the header closest to the cells).
   * @returns {string} The column header value to be updated.
   */
  "modifyColumnHeaderValue",
  /**
   * Fired by {@link UndoRedo} plugin before the undo action. Contains information about the action that is being undone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#beforeUndo
   * @param {object} action The action object. Contains information about the action being undone. The `actionType`
   *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeUndo",
  /**
   * Fired by {@link UndoRedo} plugin before changing undo stack.
   *
   * @event Hooks#beforeUndoStackChange
   * @since 8.4.0
   * @param {Array} doneActions Stack of actions which may be undone.
   * @param {string} [source] String that identifies source of action
   *                          ([list of all available sources](@/guides/getting-started/events-and-hooks.md#definition-for-source-argument)).
   * @returns {*|boolean} If false is returned the action of changing undo stack is canceled.
   */
  "beforeUndoStackChange",
  /**
   * Fired by {@link UndoRedo} plugin after the undo action. Contains information about the action that is being undone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#afterUndo
   * @param {object} action The action object. Contains information about the action being undone. The `actionType`
   *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).
   */
  "afterUndo",
  /**
   * Fired by {@link UndoRedo} plugin after changing undo stack.
   *
   * @event Hooks#afterUndoStackChange
   * @since 8.4.0
   * @param {Array} doneActionsBefore Stack of actions which could be undone before performing new action.
   * @param {Array} doneActionsAfter Stack of actions which can be undone after performing new action.
   */
  "afterUndoStackChange",
  /**
   * Fired by {@link UndoRedo} plugin before the redo action. Contains information about the action that is being redone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#beforeRedo
   * @param {object} action The action object. Contains information about the action being redone. The `actionType`
   *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  "beforeRedo",
  /**
   * Fired by {@link UndoRedo} plugin before changing redo stack.
   *
   * @event Hooks#beforeRedoStackChange
   * @since 8.4.0
   * @param {Array} undoneActions Stack of actions which may be redone.
   */
  "beforeRedoStackChange",
  /**
   * Fired by {@link UndoRedo} plugin after the redo action. Contains information about the action that is being redone.
   * This hook is fired when {@link Options#undo} option is enabled.
   *
   * @event Hooks#afterRedo
   * @param {object} action The action object. Contains information about the action being redone. The `actionType`
   *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).
   */
  "afterRedo",
  /**
   * Fired by {@link UndoRedo} plugin after changing redo stack.
   *
   * @event Hooks#afterRedoStackChange
   * @since 8.4.0
   * @param {Array} undoneActionsBefore Stack of actions which could be redone before performing new action.
   * @param {Array} undoneActionsAfter Stack of actions which can be redone after performing new action.
   */
  "afterRedoStackChange",
  /**
   * Fired while retrieving the row header width.
   *
   * @event Hooks#modifyRowHeaderWidth
   * @param {number} rowHeaderWidth Row header width.
   */
  "modifyRowHeaderWidth",
  /**
   * Fired when the start of the selection is being modified (e.g. Moving the selection with the arrow keys).
   *
   * @event Hooks#modifyTransformStart
   * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.
   */
  "modifyTransformStart",
  /**
   * Fired when the end of the selection is being modified (e.g. Moving the selection with the arrow keys).
   *
   * @event Hooks#modifyTransformEnd
   * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.
   */
  "modifyTransformEnd",
  /**
   * Fired after the start of the selection is being modified (e.g. Moving the selection with the arrow keys).
   *
   * @event Hooks#afterModifyTransformStart
   * @param {CellCoords} coords Coords of the freshly selected cell.
   * @param {number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.
   * @param {number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.
   */
  "afterModifyTransformStart",
  /**
   * Fired after the end of the selection is being modified (e.g. Moving the selection with the arrow keys).
   *
   * @event Hooks#afterModifyTransformEnd
   * @param {CellCoords} coords Visual coords of the freshly selected cell.
   * @param {number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.
   * @param {number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.
   */
  "afterModifyTransformEnd",
  /**
   * Fired inside the `viewportRowCalculatorOverride` method. Allows modifying the row calculator parameters.
   *
   * @event Hooks#afterViewportRowCalculatorOverride
   * @param {object} calc The row calculator.
   */
  "afterViewportRowCalculatorOverride",
  /**
   * Fired inside the `viewportColumnCalculatorOverride` method. Allows modifying the row calculator parameters.
   *
   * @event Hooks#afterViewportColumnCalculatorOverride
   * @param {object} calc The row calculator.
   */
  "afterViewportColumnCalculatorOverride",
  /**
   * Fired after initializing all the plugins.
   * This hook should be added before Handsontable is initialized.
   *
   * @event Hooks#afterPluginsInitialized
   *
   * @example
   * ```js
   * Handsontable.hooks.add('afterPluginsInitialized', myCallback);
   * ```
   */
  "afterPluginsInitialized",
  /**
   * Fired by {@link HiddenRows} plugin before marking the rows as hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
   * Returning `false` in the callback will prevent the hiding action from completing.
   *
   * @event Hooks#beforeHideRows
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
   * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.
   */
  "beforeHideRows",
  /**
   * Fired by {@link HiddenRows} plugin after marking the rows as hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
   *
   * @event Hooks#afterHideRows
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
   * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any non-hidden rows, `false` otherwise.
   */
  "afterHideRows",
  /**
   * Fired by {@link HiddenRows} plugin before marking the rows as not hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
   * Returning `false` in the callback will prevent the row revealing action from completing.
   *
   * @event Hooks#beforeUnhideRows
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
   * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the revealing action will not be completed.
   */
  "beforeUnhideRows",
  /**
   * Fired by {@link HiddenRows} plugin after marking the rows as not hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
   *
   * @event Hooks#afterUnhideRows
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
   * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any hidden rows, `false` otherwise.
   */
  "afterUnhideRows",
  /**
   * Fired by {@link HiddenColumns} plugin before marking the columns as hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
   * Returning `false` in the callback will prevent the hiding action from completing.
   *
   * @event Hooks#beforeHideColumns
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
   * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.
   */
  "beforeHideColumns",
  /**
   * Fired by {@link HiddenColumns} plugin after marking the columns as hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
   *
   * @event Hooks#afterHideColumns
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
   * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any non-hidden columns, `false` otherwise.
   */
  "afterHideColumns",
  /**
   * Fired by {@link HiddenColumns} plugin before marking the columns as not hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
   * Returning `false` in the callback will prevent the column revealing action from completing.
   *
   * @event Hooks#beforeUnhideColumns
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
   * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.
   */
  "beforeUnhideColumns",
  /**
   * Fired by {@link HiddenColumns} plugin after marking the columns as not hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
   *
   * @event Hooks#afterUnhideColumns
   * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
   * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
   * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any hidden columns, `false` otherwise.
   */
  "afterUnhideColumns",
  /**
   * Fired by {@link TrimRows} plugin before trimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @event Hooks#beforeTrimRow
   * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
   * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
   * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the trimming action will not be completed.
   */
  "beforeTrimRow",
  /**
   * Fired by {@link TrimRows} plugin after trimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @event Hooks#afterTrimRow
   * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
   * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
   * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any non-trimmed rows, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the trimming action will not be completed.
   */
  "afterTrimRow",
  /**
   * Fired by {@link TrimRows} plugin before untrimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @event Hooks#beforeUntrimRow
   * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
   * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
   * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the untrimming action will not be completed.
   */
  "beforeUntrimRow",
  /**
   * Fired by {@link TrimRows} plugin after untrimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
   *
   * @event Hooks#afterUntrimRow
   * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
   * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
   * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
   * @param {boolean} stateChanged `true`, if the action affected any trimmed rows, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the untrimming action will not be completed.
   */
  "afterUntrimRow",
  /**
   * Fired by {@link DropdownMenu} plugin before opening the dropdown menu. This hook is fired when {@link Options#dropdownMenu}
   * option is enabled.
   *
   * @event Hooks#beforeDropdownMenuShow
   * @param {DropdownMenu} dropdownMenu The DropdownMenu instance.
   */
  "beforeDropdownMenuShow",
  /**
   * Fired by {@link DropdownMenu} plugin after opening the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}
   * option is enabled.
   *
   * @event Hooks#afterDropdownMenuShow
   * @param {DropdownMenu} dropdownMenu The DropdownMenu instance.
   */
  "afterDropdownMenuShow",
  /**
   * Fired by {@link DropdownMenu} plugin after hiding the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}
   * option is enabled.
   *
   * @event Hooks#afterDropdownMenuHide
   * @param {DropdownMenu} instance The DropdownMenu instance.
   */
  "afterDropdownMenuHide",
  /**
   * Fired by {@link NestedRows} plugin before adding a children to the NestedRows structure. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @event Hooks#beforeAddChild
   * @param {object} parent The parent object.
   * @param {object|undefined} element The element added as a child. If `undefined`, a blank child was added.
   * @param {number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.
   */
  "beforeAddChild",
  /**
   * Fired by {@link NestedRows} plugin after adding a children to the NestedRows structure. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @event Hooks#afterAddChild
   * @param {object} parent The parent object.
   * @param {object|undefined} element The element added as a child. If `undefined`, a blank child was added.
   * @param {number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.
   */
  "afterAddChild",
  /**
   * Fired by {@link NestedRows} plugin before detaching a child from its parent. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @event Hooks#beforeDetachChild
   * @param {object} parent An object representing the parent from which the element is to be detached.
   * @param {object} element The detached element.
   */
  "beforeDetachChild",
  /**
   * Fired by {@link NestedRows} plugin after detaching a child from its parent. This hook is fired when
   * {@link Options#nestedRows} option is enabled.
   *
   * @event Hooks#afterDetachChild
   * @param {object} parent An object representing the parent from which the element was detached.
   * @param {object} element The detached element.
   * @param {number} finalElementPosition The final row index of the detached element.
   */
  "afterDetachChild",
  /**
   * Fired after the editor is opened and rendered.
   *
   * @event Hooks#afterBeginEditing
   * @param {number} row Visual row index of the edited cell.
   * @param {number} column Visual column index of the edited cell.
   */
  "afterBeginEditing",
  /**
   * Fired by {@link MergeCells} plugin before cell merging. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#beforeMergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "beforeMergeCells",
  /**
   * Fired by {@link MergeCells} plugin after cell merging. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#afterMergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {object} mergeParent The parent collection of the provided cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "afterMergeCells",
  /**
   * Fired by {@link MergeCells} plugin before unmerging the cells. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#beforeUnmergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "beforeUnmergeCells",
  /**
   * Fired by {@link MergeCells} plugin after unmerging the cells. This hook is fired when {@link Options#mergeCells}
   * option is enabled.
   *
   * @event Hooks#afterUnmergeCells
   * @param {CellRange} cellRange Selection cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   */
  "afterUnmergeCells",
  /**
   * Fired after the table was switched into listening mode. This allows Handsontable to capture keyboard events and
   * respond in the right way.
   *
   * @event Hooks#afterListen
   */
  "afterListen",
  /**
   * Fired after the table was switched off from the listening mode. This makes the Handsontable inert for any
   * keyboard events.
   *
   * @event Hooks#afterUnlisten
   */
  "afterUnlisten",
  /**
   * Fired after the window was resized or the size of the Handsontable root element was changed.
   *
   * @event Hooks#afterRefreshDimensions
   * @param {object} previousDimensions Previous dimensions of the container.
   * @param {object} currentDimensions Current dimensions of the container.
   * @param {boolean} stateChanged `true`, if the container was re-render, `false` otherwise.
   */
  "afterRefreshDimensions",
  /**
   * Cancellable hook, called after resizing a window or after detecting size change of the
   * Handsontable root element, but before redrawing a table.
   *
   * @event Hooks#beforeRefreshDimensions
   * @param {object} previousDimensions Previous dimensions of the container.
   * @param {object} currentDimensions Current dimensions of the container.
   * @param {boolean} actionPossible `true`, if current and previous dimensions are different, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the refresh action will not be completed.
   */
  "beforeRefreshDimensions",
  /**
   * Fired by {@link CollapsibleColumns} plugin before columns collapse. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
   *
   * @event Hooks#beforeColumnCollapse
   * @since 8.0.0
   * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
   * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
   * @param {boolean} collapsePossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the collapsing action will not be completed.
   */
  "beforeColumnCollapse",
  /**
   * Fired by {@link CollapsibleColumns} plugin before columns collapse. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
   *
   * @event Hooks#afterColumnCollapse
   * @since 8.0.0
   * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
   * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
   * @param {boolean} collapsePossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
   * @param {boolean} successfullyCollapsed `true`, if the action affected any non-collapsible column, `false` otherwise.
   */
  "afterColumnCollapse",
  /**
   * Fired by {@link CollapsibleColumns} plugin before columns expand. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
   *
   * @event Hooks#beforeColumnExpand
   * @since 8.0.0
   * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
   * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
   * @param {boolean} expandPossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
   * @returns {undefined|boolean} If the callback returns `false`, the expanding action will not be completed.
   */
  "beforeColumnExpand",
  /**
   * Fired by {@link CollapsibleColumns} plugin before columns expand. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
   *
   * @event Hooks#afterColumnExpand
   * @since 8.0.0
   * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
   * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
   * @param {boolean} expandPossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
   * @param {boolean} successfullyExpanded `true`, if the action affected any non-collapsible column, `false` otherwise.
   */
  "afterColumnExpand",
  /**
   * Fired by {@link AutoColumnSize} plugin within SampleGenerator utility.
   *
   * @event Hooks#modifyAutoColumnSizeSeed
   * @since 8.4.0
   * @param {string|undefined} seed Seed ID, unique name to categorize samples.
   * @param {object} cellProperties Object containing the cell properties.
   * @param {*} cellValue Value of the cell.
   */
  "modifyAutoColumnSizeSeed"
];
var REMOVED_MESSAGE = toSingleLine`The plugin hook "[hookName]" was removed in Handsontable [removedInVersion].\x20
  Please consult release notes https://github.com/handsontable/handsontable/releases/tag/[removedInVersion] to\x20
  learn about the migration path.`;
var REMOVED_HOOKS = /* @__PURE__ */ new Map([["modifyRow", "8.0.0"], ["modifyCol", "8.0.0"], ["unmodifyRow", "8.0.0"], ["unmodifyCol", "8.0.0"], ["skipLengthCache", "8.0.0"], ["hiddenColumn", "8.0.0"], ["hiddenRow", "8.0.0"]]);
var DEPRECATED_HOOKS = /* @__PURE__ */ new Map([]);
var Hooks = class {
  static getSingleton() {
    return getGlobalSingleton();
  }
  /**
   *
   */
  constructor() {
    this.globalBucket = this.createEmptyBucket();
  }
  /**
   * Returns a new object with empty handlers related to every registered hook name.
   *
   * @returns {object} The empty bucket object.
   *
   * @example
   * ```js
   * Handsontable.hooks.createEmptyBucket();
   * // Results:
   * {
   * ...
   * afterCreateCol: [],
   * afterCreateRow: [],
   * beforeInit: [],
   * ...
   * }
   * ```
   */
  createEmptyBucket() {
    const bucket = /* @__PURE__ */ Object.create(null);
    arrayEach(REGISTERED_HOOKS, (hook2) => bucket[hook2] = []);
    return bucket;
  }
  /**
   * Get hook bucket based on the context of the object or if argument is `undefined`, get the global hook bucket.
   *
   * @param {object} [context=null] A Handsontable instance.
   * @returns {object} Returns a global or Handsontable instance bucket.
   */
  getBucket() {
    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (context) {
      if (!context.pluginHookBucket) {
        context.pluginHookBucket = this.createEmptyBucket();
      }
      return context.pluginHookBucket;
    }
    return this.globalBucket;
  }
  /**
   * Adds a listener (globally or locally) to a specified hook name.
   * If the `context` parameter is provided, the hook will be added only to the instance it references.
   * Otherwise, the callback will be used everytime the hook fires on any Handsontable instance.
   * You can provide an array of callback functions as the `callback` argument, this way they will all be fired
   * once the hook is triggered.
   *
   * @see Core#addHook
   * @param {string} key Hook name.
   * @param {Function|Array} callback Callback function or an array of functions.
   * @param {object} [context=null] The context for the hook callback to be added - a Handsontable instance or leave empty.
   * @returns {Hooks} Instance of Hooks.
   *
   * @example
   * ```js
   * // single callback, added locally
   * Handsontable.hooks.add('beforeInit', myCallback, hotInstance);
   *
   * // single callback, added globally
   * Handsontable.hooks.add('beforeInit', myCallback);
   *
   * // multiple callbacks, added locally
   * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback], hotInstance);
   *
   * // multiple callbacks, added globally
   * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback]);
   * ```
   */
  add(key, callback) {
    let context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    if (Array.isArray(callback)) {
      arrayEach(callback, (c) => this.add(key, c, context));
    } else {
      if (REMOVED_HOOKS.has(key)) {
        warn2(substitute(REMOVED_MESSAGE, {
          hookName: key,
          removedInVersion: REMOVED_HOOKS.get(key)
        }));
      }
      if (DEPRECATED_HOOKS.has(key)) {
        warn2(DEPRECATED_HOOKS.get(key));
      }
      const bucket = this.getBucket(context);
      if (typeof bucket[key] === "undefined") {
        this.register(key);
        bucket[key] = [];
      }
      callback.skip = false;
      if (bucket[key].indexOf(callback) === -1) {
        let foundInitialHook = false;
        if (callback.initialHook) {
          arrayEach(bucket[key], (cb, i) => {
            if (cb.initialHook) {
              bucket[key][i] = callback;
              foundInitialHook = true;
              return false;
            }
          });
        }
        if (!foundInitialHook) {
          bucket[key].push(callback);
        }
      }
    }
    return this;
  }
  /**
   * Adds a listener to a specified hook. After the hook runs this listener will be automatically removed from the bucket.
   *
   * @see Core#addHookOnce
   * @param {string} key Hook/Event name.
   * @param {Function|Array} callback Callback function.
   * @param {object} [context=null] A Handsontable instance.
   *
   * @example
   * ```js
   * Handsontable.hooks.once('beforeInit', myCallback, hotInstance);
   * ```
   */
  once(key, callback) {
    let context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    if (Array.isArray(callback)) {
      arrayEach(callback, (c) => this.once(key, c, context));
    } else {
      callback.runOnce = true;
      this.add(key, callback, context);
    }
  }
  /**
   * Removes a listener from a hook with a given name. If the `context` argument is provided, it removes a listener from a local hook assigned to the given Handsontable instance.
   *
   * @see Core#removeHook
   * @param {string} key Hook/Event name.
   * @param {Function} callback Callback function (needs the be the function that was previously added to the hook).
   * @param {object} [context=null] Handsontable instance.
   * @returns {boolean} Returns `true` if hook was removed, `false` otherwise.
   *
   * @example
   * ```js
   * Handsontable.hooks.remove('beforeInit', myCallback);
   * ```
   */
  remove(key, callback) {
    let context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const bucket = this.getBucket(context);
    if (typeof bucket[key] !== "undefined") {
      if (bucket[key].indexOf(callback) >= 0) {
        callback.skip = true;
        return true;
      }
    }
    return false;
  }
  /**
   * Checks whether there are any registered listeners for the provided hook name.
   * If the `context` parameter is provided, it only checks for listeners assigned to the given Handsontable instance.
   *
   * @param {string} key Hook name.
   * @param {object} [context=null] A Handsontable instance.
   * @returns {boolean} `true` for success, `false` otherwise.
   */
  has(key) {
    let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const bucket = this.getBucket(context);
    return !!(bucket[key] !== void 0 && bucket[key].length);
  }
  /**
   * Runs all local and global callbacks assigned to the hook identified by the `key` parameter.
   * It returns either a return value from the last called callback or the first parameter (`p1`) passed to the `run` function.
   *
   * @see Core#runHooks
   * @param {object} context Handsontable instance.
   * @param {string} key Hook/Event name.
   * @param {*} [p1] Parameter to be passed as an argument to the callback function.
   * @param {*} [p2] Parameter to be passed as an argument to the callback function.
   * @param {*} [p3] Parameter to be passed as an argument to the callback function.
   * @param {*} [p4] Parameter to be passed as an argument to the callback function.
   * @param {*} [p5] Parameter to be passed as an argument to the callback function.
   * @param {*} [p6] Parameter to be passed as an argument to the callback function.
   * @returns {*} Either a return value from the last called callback or `p1`.
   *
   * @example
   * ```js
   * Handsontable.hooks.run(hot, 'beforeInit');
   * ```
   */
  run(context, key, p1, p2, p3, p4, p5, p6) {
    {
      const globalHandlers = this.globalBucket[key];
      const length = globalHandlers ? globalHandlers.length : 0;
      let index2 = 0;
      if (length) {
        while (index2 < length) {
          if (!globalHandlers[index2] || globalHandlers[index2].skip) {
            index2 += 1;
            continue;
          }
          const res = fastCall(globalHandlers[index2], context, p1, p2, p3, p4, p5, p6);
          if (res !== void 0) {
            p1 = res;
          }
          if (globalHandlers[index2] && globalHandlers[index2].runOnce) {
            this.remove(key, globalHandlers[index2]);
          }
          index2 += 1;
        }
      }
    }
    {
      const localHandlers = this.getBucket(context)[key];
      const length = localHandlers ? localHandlers.length : 0;
      let index2 = 0;
      if (length) {
        while (index2 < length) {
          if (!localHandlers[index2] || localHandlers[index2].skip) {
            index2 += 1;
            continue;
          }
          const res = fastCall(localHandlers[index2], context, p1, p2, p3, p4, p5, p6);
          if (res !== void 0) {
            p1 = res;
          }
          if (localHandlers[index2] && localHandlers[index2].runOnce) {
            this.remove(key, localHandlers[index2], context);
          }
          index2 += 1;
        }
      }
    }
    return p1;
  }
  /**
   * Destroy all listeners connected to the context. If no context is provided, the global listeners will be destroyed.
   *
   * @param {object} [context=null] A Handsontable instance.
   * @example
   * ```js
   * // destroy the global listeners
   * Handsontable.hooks.destroy();
   *
   * // destroy the local listeners
   * Handsontable.hooks.destroy(hotInstance);
   * ```
   */
  destroy() {
    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    objectEach(this.getBucket(context), (value, key, bucket) => bucket[key].length = 0);
  }
  /**
   * Registers a hook name (adds it to the list of the known hook names). Used by plugins.
   * It is not necessary to call register, but if you use it, your plugin hook will be used returned by
   * the `getRegistered` method. (which itself is used in the [demo](@/guides/getting-started/events-and-hooks.md)).
   *
   * @param {string} key The hook name.
   *
   * @example
   * ```js
   * Handsontable.hooks.register('myHook');
   * ```
   */
  register(key) {
    if (!this.isRegistered(key)) {
      REGISTERED_HOOKS.push(key);
    }
  }
  /**
   * Deregisters a hook name (removes it from the list of known hook names).
   *
   * @param {string} key The hook name.
   *
   * @example
   * ```js
   * Handsontable.hooks.deregister('myHook');
   * ```
   */
  deregister(key) {
    if (this.isRegistered(key)) {
      REGISTERED_HOOKS.splice(REGISTERED_HOOKS.indexOf(key), 1);
    }
  }
  /**
   * Returns a boolean value depending on if a hook by such name has been removed or deprecated.
   *
   * @param {string} hookName The hook name to check.
   * @returns {boolean} Returns `true` if the provided hook name was marked as deprecated or
   * removed from API, `false` otherwise.
   * @example
   * ```js
   * Handsontable.hooks.isDeprecated('skipLengthCache');
   *
   * // Results:
   * true
   * ```
   */
  isDeprecated(hookName) {
    return DEPRECATED_HOOKS.has(hookName) || REMOVED_HOOKS.has(hookName);
  }
  /**
   * Returns a boolean depending on if a hook by such name has been registered.
   *
   * @param {string} hookName The hook name to check.
   * @returns {boolean} `true` for success, `false` otherwise.
   * @example
   * ```js
   * Handsontable.hooks.isRegistered('beforeInit');
   *
   * // Results:
   * true
   * ```
   */
  isRegistered(hookName) {
    return REGISTERED_HOOKS.indexOf(hookName) >= 0;
  }
  /**
   * Returns an array of registered hooks.
   *
   * @returns {Array} An array of registered hooks.
   *
   * @example
   * ```js
   * Handsontable.hooks.getRegistered();
   *
   * // Results:
   * [
   * ...
   *   'beforeInit',
   *   'beforeRender',
   *   'beforeSetRangeEnd',
   *   'beforeDrawBorders',
   *   'beforeChange',
   * ...
   * ]
   * ```
   */
  getRegistered() {
    return REGISTERED_HOOKS;
  }
};
var globalSingleton = new Hooks();
function getGlobalSingleton() {
  return globalSingleton;
}
var pluginHooks_default = Hooks;

// node_modules/handsontable/utils/staticRegister.mjs
var collection = /* @__PURE__ */ new Map();
function staticRegister() {
  let namespace = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "common";
  if (!collection.has(namespace)) {
    collection.set(namespace, /* @__PURE__ */ new Map());
  }
  const subCollection = collection.get(namespace);
  function register7(name, item) {
    subCollection.set(name, item);
  }
  function getItem6(name) {
    return subCollection.get(name);
  }
  function hasItem5(name) {
    return subCollection.has(name);
  }
  function getNames5() {
    return [...subCollection.keys()];
  }
  function getValues5() {
    return [...subCollection.values()];
  }
  return {
    register: register7,
    getItem: getItem6,
    hasItem: hasItem5,
    getNames: getNames5,
    getValues: getValues5
  };
}

// node_modules/handsontable/editors/registry.mjs
var registeredEditorClasses = /* @__PURE__ */ new WeakMap();
var {
  register,
  getItem,
  hasItem,
  getNames,
  getValues
} = staticRegister("editors");
function RegisteredEditor(editorClass) {
  const instances2 = {};
  const Clazz = editorClass;
  this.getConstructor = function() {
    return editorClass;
  };
  this.getInstance = function(hotInstance) {
    if (!(hotInstance.guid in instances2)) {
      instances2[hotInstance.guid] = new Clazz(hotInstance);
    }
    return instances2[hotInstance.guid];
  };
  pluginHooks_default.getSingleton().add("afterDestroy", function() {
    instances2[this.guid] = null;
  });
}
function _getEditorInstance(name, hotInstance) {
  let editor;
  if (typeof name === "function") {
    if (!registeredEditorClasses.get(name)) {
      _register(null, name);
    }
    editor = registeredEditorClasses.get(name);
  } else if (typeof name === "string") {
    editor = getItem(name);
  } else {
    throw Error('Only strings and functions can be passed as "editor" parameter');
  }
  if (!editor) {
    throw Error(`No editor registered under name "${name}"`);
  }
  return editor.getInstance(hotInstance);
}
function _getItem(name) {
  if (typeof name === "function") {
    return name;
  }
  if (!hasItem(name)) {
    throw Error(`No registered editor found under "${name}" name`);
  }
  return getItem(name).getConstructor();
}
function _register(name, editorClass) {
  if (name && typeof name !== "string") {
    editorClass = name;
    name = editorClass.EDITOR_TYPE;
  }
  const editorWrapper = new RegisteredEditor(editorClass);
  if (typeof name === "string") {
    register(name, editorWrapper);
  }
  registeredEditorClasses.set(editorClass, editorWrapper);
}

// node_modules/handsontable/eventManager.mjs
var listenersCounter = 0;
var EventManager = class {
  /**
   * @param {object} [context=null] An object to which event listeners will be stored.
   * @private
   */
  constructor() {
    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    this.context = context || this;
    if (!this.context.eventListeners) {
      this.context.eventListeners = [];
    }
  }
  /**
   * Register specified listener (`eventName`) to the element.
   *
   * @param {Element} element Target element.
   * @param {string} eventName Event name.
   * @param {Function} callback Function which will be called after event occur.
   * @param {AddEventListenerOptions|boolean} [options] Listener options if object or useCapture if boolean.
   * @returns {Function} Returns function which you can easily call to remove that event.
   */
  addEventListener(element, eventName, callback) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    function callbackProxy(event2) {
      callback.call(this, extendEvent(event2));
    }
    this.context.eventListeners.push({
      element,
      event: eventName,
      callback,
      callbackProxy,
      options,
      eventManager: this
    });
    element.addEventListener(eventName, callbackProxy, options);
    listenersCounter += 1;
    return () => {
      this.removeEventListener(element, eventName, callback);
    };
  }
  /**
   * Remove the event listener previously registered.
   *
   * @param {Element} element Target element.
   * @param {string} eventName Event name.
   * @param {Function} callback Function to remove from the event target. It must be the same as during registration listener.
   * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.
   */
  removeEventListener(element, eventName, callback) {
    let onlyOwnEvents = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let len = this.context.eventListeners.length;
    let tmpEvent;
    while (len) {
      len -= 1;
      tmpEvent = this.context.eventListeners[len];
      if (tmpEvent.event === eventName && tmpEvent.element === element) {
        if (callback && callback !== tmpEvent.callback) {
          continue;
        }
        if (onlyOwnEvents && tmpEvent.eventManager !== this) {
          continue;
        }
        this.context.eventListeners.splice(len, 1);
        tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, tmpEvent.options);
        listenersCounter -= 1;
      }
    }
  }
  /**
   * Clear all previously registered events.
   *
   * @private
   * @since 0.15.0-beta3
   * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.
   */
  clearEvents() {
    let onlyOwnEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!this.context) {
      return;
    }
    let len = this.context.eventListeners.length;
    while (len) {
      len -= 1;
      const event2 = this.context.eventListeners[len];
      if (onlyOwnEvents && event2.eventManager !== this) {
        continue;
      }
      this.context.eventListeners.splice(len, 1);
      event2.element.removeEventListener(event2.event, event2.callbackProxy, event2.options);
      listenersCounter -= 1;
    }
  }
  /**
   * Clear all previously registered events.
   */
  clear() {
    this.clearEvents();
  }
  /**
   * Destroy instance of EventManager, clearing all events of the context.
   */
  destroy() {
    this.clearEvents();
    this.context = null;
  }
  /**
   * Destroy instance of EventManager, clearing only the own events.
   */
  destroyWithOwnEventsOnly() {
    this.clearEvents(true);
    this.context = null;
  }
  /**
   * Trigger event at the specified target element.
   *
   * @param {Element} element Target element.
   * @param {string} eventName Event name.
   */
  fireEvent(element, eventName) {
    let rootDocument = element.document;
    let rootWindow = element;
    if (!rootDocument) {
      rootDocument = element.ownerDocument ? element.ownerDocument : element;
      rootWindow = rootDocument.defaultView;
    }
    const options = {
      bubbles: true,
      cancelable: eventName !== "mousemove",
      view: rootWindow,
      detail: 0,
      screenX: 0,
      screenY: 0,
      clientX: 1,
      clientY: 1,
      ctrlKey: false,
      altKey: false,
      shiftKey: false,
      metaKey: false,
      button: 0,
      relatedTarget: void 0
    };
    let event2;
    if (rootDocument.createEvent) {
      event2 = rootDocument.createEvent("MouseEvents");
      event2.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, options.relatedTarget || rootDocument.body.parentNode);
    } else {
      event2 = rootDocument.createEventObject();
    }
    if (element.dispatchEvent) {
      element.dispatchEvent(event2);
    } else {
      element.fireEvent(`on${eventName}`, event2);
    }
  }
};
function extendEvent(event2) {
  const nativeStopImmediatePropagation = event2.stopImmediatePropagation;
  event2.stopImmediatePropagation = function() {
    nativeStopImmediatePropagation.apply(this);
    stopImmediatePropagation(this);
  };
  return event2;
}
var eventManager_default = EventManager;
function getListenersCounter() {
  return listenersCounter;
}

// node_modules/handsontable/editorManager.mjs
var SHORTCUTS_GROUP_NAVIGATION = "editorManager.navigation";
var SHORTCUTS_GROUP_EDITOR = "editorManager.handlingEditor";
var EditorManager = class {
  /**
   * @param {Core} instance The Handsontable instance.
   * @param {TableMeta} tableMeta The table meta instance.
   * @param {Selection} selection The selection instance.
   */
  constructor(instance, tableMeta, selection) {
    this.instance = instance;
    this.tableMeta = tableMeta;
    this.selection = selection;
    this.eventManager = new eventManager_default(instance);
    this.destroyed = false;
    this.lock = false;
    this.activeEditor = void 0;
    this.cellProperties = void 0;
    const shortcutManager = this.instance.getShortcutManager();
    shortcutManager.addContext("editor");
    this.registerShortcuts();
    this.instance.addHook("afterDocumentKeyDown", (event2) => this.onAfterDocumentKeyDown(event2));
    this.eventManager.addEventListener(this.instance.rootDocument.documentElement, "compositionstart", (event2) => {
      if (!this.destroyed && this.instance.isListening()) {
        this.openEditor("", event2);
      }
    });
    this.instance.view._wt.update("onCellDblClick", (event2, coords, elem) => this.onCellDblClick(event2, coords, elem));
  }
  /**
   * Register shortcuts responsible for handling some actions related to an editor.
   *
   * @private
   */
  registerShortcuts() {
    const shortcutManager = this.instance.getShortcutManager();
    const gridContext = shortcutManager.getContext("grid");
    const editorContext = shortcutManager.getContext("editor");
    const config = {
      group: SHORTCUTS_GROUP_EDITOR
    };
    editorContext.addShortcuts([{
      keys: [["Enter"], ["Enter", "Shift"], ["Enter", "Control/Meta"], ["Enter", "Control/Meta", "Shift"]],
      callback: (event2, keys2) => {
        this.closeEditorAndSaveChanges(shortcutManager.isCtrlPressed());
        this.moveSelectionAfterEnter(keys2.includes("shift"));
      }
    }, {
      keys: [["Escape"], ["Escape", "Control/Meta"]],
      callback: () => {
        this.closeEditorAndRestoreOriginalValue(shortcutManager.isCtrlPressed());
        this.activeEditor.focus();
      }
    }], config);
    gridContext.addShortcuts([{
      keys: [["F2"]],
      callback: (event2) => {
        this.openEditor(null, event2, true);
      }
    }, {
      keys: [["Backspace"], ["Delete"]],
      callback: () => {
        this.instance.emptySelectedCells();
        this.prepareEditor();
      }
    }, {
      keys: [["Enter"], ["Enter", "Shift"]],
      callback: (event2, keys2) => {
        if (this.instance.getSettings().enterBeginsEditing) {
          if (this.cellProperties.readOnly) {
            this.moveSelectionAfterEnter();
          } else {
            this.openEditor(null, event2, true);
          }
        } else {
          this.moveSelectionAfterEnter(keys2.includes("shift"));
        }
        stopImmediatePropagation(event2);
      }
    }], {
      ...config,
      runOnlyIf: () => isDefined(this.instance.getSelected())
    });
  }
  /**
   * Lock the editor from being prepared and closed. Locking the editor prevents its closing and
   * reinitialized after selecting the new cell. This feature is necessary for a mobile editor.
   */
  lockEditor() {
    this.lock = true;
  }
  /**
   * Unlock the editor from being prepared and closed. This method restores the original behavior of
   * the editors where for every new selection its instances are closed.
   */
  unlockEditor() {
    this.lock = false;
  }
  /**
   * Destroy current editor, if exists.
   *
   * @param {boolean} revertOriginal If `false` and the cell using allowInvalid option,
   *                                 then an editor won't be closed until validation is passed.
   */
  destroyEditor(revertOriginal) {
    if (!this.lock) {
      this.closeEditor(revertOriginal);
    }
  }
  /**
   * Get active editor.
   *
   * @returns {BaseEditor}
   */
  getActiveEditor() {
    return this.activeEditor;
  }
  /**
   * Prepare text input to be displayed at given grid cell.
   */
  prepareEditor() {
    if (this.lock) {
      return;
    }
    if (this.activeEditor && this.activeEditor.isWaiting()) {
      this.closeEditor(false, false, (dataSaved) => {
        if (dataSaved) {
          this.prepareEditor();
        }
      });
      return;
    }
    const {
      row,
      col
    } = this.instance.getSelectedRangeLast().highlight;
    const modifiedCellCoords = this.instance.runHooks("modifyGetCellCoords", row, col);
    let visualRowToCheck = row;
    let visualColumnToCheck = col;
    if (Array.isArray(modifiedCellCoords)) {
      [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;
    }
    this.cellProperties = this.instance.getCellMeta(visualRowToCheck, visualColumnToCheck);
    const {
      activeElement
    } = this.instance.rootDocument;
    if (activeElement && isOutsideInput(activeElement)) {
      activeElement.blur();
    }
    if (!this.isCellEditable()) {
      this.clearActiveEditor();
      return;
    }
    const td = this.instance.getCell(row, col, true);
    if (td) {
      const editorClass = this.instance.getCellEditor(this.cellProperties);
      const prop = this.instance.colToProp(visualColumnToCheck);
      const originalValue = this.instance.getSourceDataAtCell(this.instance.toPhysicalRow(visualRowToCheck), visualColumnToCheck);
      this.activeEditor = _getEditorInstance(editorClass, this.instance);
      this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);
    }
  }
  /**
   * Check is editor is opened/showed.
   *
   * @returns {boolean}
   */
  isEditorOpened() {
    return this.activeEditor && this.activeEditor.isOpened();
  }
  /**
   * Open editor with initial value.
   *
   * @param {null|string} newInitialValue New value from which editor will start if handled property it's not the `null`.
   * @param {Event} event The event object.
   * @param {boolean} [enableFullEditMode=false] When true, an editor works in full editing mode. Mode disallows closing an editor
   *                                             when arrow keys are pressed.
   */
  openEditor(newInitialValue, event2) {
    let enableFullEditMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!this.isCellEditable()) {
      this.clearActiveEditor();
      return;
    }
    if (!this.activeEditor) {
      const {
        row,
        col
      } = this.instance.getSelectedRangeLast().highlight;
      const renderableRowIndex = this.instance.rowIndexMapper.getRenderableFromVisualIndex(row);
      const renderableColumnIndex = this.instance.columnIndexMapper.getRenderableFromVisualIndex(col);
      this.instance.view.scrollViewport(this.instance._createCellCoords(renderableRowIndex, renderableColumnIndex));
      this.instance.view.render();
      this.prepareEditor();
    }
    if (this.activeEditor) {
      if (enableFullEditMode) {
        this.activeEditor.enableFullEditMode();
      }
      this.activeEditor.beginEditing(newInitialValue, event2);
    }
  }
  /**
   * Close editor, finish editing cell.
   *
   * @param {boolean} restoreOriginalValue If `true`, then closes editor without saving value from the editor into a cell.
   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.
   * @param {Function} callback The callback function, fired after editor closing.
   */
  closeEditor(restoreOriginalValue, isCtrlPressed, callback) {
    if (this.activeEditor) {
      this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);
    } else if (callback) {
      callback(false);
    }
  }
  /**
   * Close editor and save changes.
   *
   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.
   */
  closeEditorAndSaveChanges(isCtrlPressed) {
    this.closeEditor(false, isCtrlPressed);
  }
  /**
   * Close editor and restore original value.
   *
   * @param {boolean} isCtrlPressed Indication of whether the CTRL button is pressed.
   */
  closeEditorAndRestoreOriginalValue(isCtrlPressed) {
    this.closeEditor(true, isCtrlPressed);
  }
  /**
   * Clears reference to an instance of the active editor.
   *
   * @private
   */
  clearActiveEditor() {
    this.activeEditor = void 0;
  }
  /**
   * Checks if the currently selected cell (pointed by selection highlight coords) is editable.
   * Editable cell is when:
   *   - the cell has defined an editor type;
   *   - the cell is not marked as read-only;
   *   - the cell is not hidden.
   *
   * @private
   * @returns {boolean}
   */
  isCellEditable() {
    const editorClass = this.instance.getCellEditor(this.cellProperties);
    const {
      row,
      col
    } = this.instance.getSelectedRangeLast().highlight;
    const {
      rowIndexMapper,
      columnIndexMapper
    } = this.instance;
    const isCellHidden = rowIndexMapper.isHidden(this.instance.toPhysicalRow(row)) || columnIndexMapper.isHidden(this.instance.toPhysicalColumn(col));
    if (this.cellProperties.readOnly || !editorClass || isCellHidden) {
      return false;
    }
    return true;
  }
  /**
   * Controls selection's behaviour after clicking `Enter`.
   *
   * @private
   * @param {boolean} isShiftPressed If `true`, then the selection will move up after hit enter.
   */
  moveSelectionAfterEnter(isShiftPressed) {
    const enterMoves = typeof this.tableMeta.enterMoves === "function" ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves;
    if (isShiftPressed) {
      this.selection.transformStart(-enterMoves.row, -enterMoves.col);
    } else {
      this.selection.transformStart(enterMoves.row, enterMoves.col, true);
    }
  }
  /**
   * OnAfterDocumentKeyDown callback.
   *
   * @private
   * @param {KeyboardEvent} event The keyboard event object.
   */
  onAfterDocumentKeyDown(event2) {
    if (!this.instance.isListening()) {
      return;
    }
    const {
      keyCode
    } = event2;
    if (!this.selection.isSelected()) {
      return;
    }
    const isCtrlPressed = (event2.ctrlKey || event2.metaKey) && !event2.altKey;
    if (!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) {
      if (!isFunctionKey(keyCode) && !isCtrlMetaKey(keyCode) && !isCtrlPressed && !this.isEditorOpened()) {
        const shortcutManager = this.instance.getShortcutManager();
        const editorContext = shortcutManager.getContext("editor");
        const runOnlySelectedConfig = {
          runOnlyIf: () => isDefined(this.instance.getSelected()),
          group: SHORTCUTS_GROUP_NAVIGATION
        };
        editorContext.addShortcuts([{
          keys: [["ArrowUp"]],
          callback: () => {
            this.instance.selection.transformStart(-1, 0);
          }
        }, {
          keys: [["ArrowDown"]],
          callback: () => {
            this.instance.selection.transformStart(1, 0);
          }
        }, {
          keys: [["ArrowLeft"]],
          callback: () => {
            this.instance.selection.transformStart(0, -1 * this.instance.getDirectionFactor());
          }
        }, {
          keys: [["ArrowRight"]],
          callback: () => {
            this.instance.selection.transformStart(0, this.instance.getDirectionFactor());
          }
        }], runOnlySelectedConfig);
        this.openEditor("", event2);
      }
    }
  }
  /**
   * OnCellDblClick callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   * @param {object} coords The cell coordinates.
   * @param {HTMLTableCellElement|HTMLTableHeaderCellElement} elem The element which triggers the action.
   */
  onCellDblClick(event2, coords, elem) {
    if (elem.nodeName === "TD") {
      this.openEditor(null, event2, true);
    }
  }
  /**
   * Destroy the instance.
   */
  destroy() {
    this.destroyed = true;
    this.eventManager.destroy();
  }
};
var instances = /* @__PURE__ */ new WeakMap();
EditorManager.getInstance = function(hotInstance, tableMeta, selection) {
  let editorManager = instances.get(hotInstance);
  if (!editorManager) {
    editorManager = new EditorManager(hotInstance, tableMeta, selection);
    instances.set(hotInstance, editorManager);
  }
  return editorManager;
};
var editorManager_default = EditorManager;

// node_modules/handsontable/utils/parseTable.mjs
var parseTable_exports = {};
__export(parseTable_exports, {
  _dataToHTML: () => _dataToHTML,
  htmlToGridSettings: () => htmlToGridSettings,
  instanceToHTML: () => instanceToHTML
});
var ESCAPED_HTML_CHARS = {
  "&nbsp;": " ",
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">"
};
var regEscapedChars = new RegExp(Object.keys(ESCAPED_HTML_CHARS).map((key) => `(${key})`).join("|"), "gi");
function isHTMLTable(element) {
  return (element && element.nodeName || "") === "TABLE";
}
function instanceToHTML(instance) {
  const hasColumnHeaders = instance.hasColHeaders();
  const hasRowHeaders = instance.hasRowHeaders();
  const coords = [hasColumnHeaders ? -1 : 0, hasRowHeaders ? -1 : 0, instance.countRows() - 1, instance.countCols() - 1];
  const data = instance.getData(...coords);
  const countRows = data.length;
  const countCols = countRows > 0 ? data[0].length : 0;
  const TABLE = ["<table>", "</table>"];
  const THEAD = hasColumnHeaders ? ["<thead>", "</thead>"] : [];
  const TBODY = ["<tbody>", "</tbody>"];
  const rowModifier = hasRowHeaders ? 1 : 0;
  const columnModifier = hasColumnHeaders ? 1 : 0;
  for (let row = 0; row < countRows; row += 1) {
    const isColumnHeadersRow = hasColumnHeaders && row === 0;
    const CELLS = [];
    for (let column = 0; column < countCols; column += 1) {
      const isRowHeadersColumn = !isColumnHeadersRow && hasRowHeaders && column === 0;
      let cell = "";
      if (isColumnHeadersRow) {
        cell = `<th>${instance.getColHeader(column - rowModifier)}</th>`;
      } else if (isRowHeadersColumn) {
        cell = `<th>${instance.getRowHeader(row - columnModifier)}</th>`;
      } else {
        const cellData = data[row][column];
        const {
          hidden,
          rowspan,
          colspan
        } = instance.getCellMeta(row - columnModifier, column - rowModifier);
        if (!hidden) {
          const attrs = [];
          if (rowspan) {
            attrs.push(`rowspan="${rowspan}"`);
          }
          if (colspan) {
            attrs.push(`colspan="${colspan}"`);
          }
          if (isEmpty(cellData)) {
            cell = `<td ${attrs.join(" ")}></td>`;
          } else {
            const value = cellData.toString().replace("<", "&lt;").replace(">", "&gt;").replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, "<br>\r\n").replace(/\x20/gi, "&nbsp;").replace(/\t/gi, "&#9;");
            cell = `<td ${attrs.join(" ")}>${value}</td>`;
          }
        }
      }
      CELLS.push(cell);
    }
    const TR = ["<tr>", ...CELLS, "</tr>"].join("");
    if (isColumnHeadersRow) {
      THEAD.splice(1, 0, TR);
    } else {
      TBODY.splice(-1, 0, TR);
    }
  }
  TABLE.splice(1, 0, THEAD.join(""), TBODY.join(""));
  return TABLE.join("");
}
function _dataToHTML(input) {
  const inputLen = input.length;
  const result = ["<table>"];
  for (let row = 0; row < inputLen; row += 1) {
    const rowData = input[row];
    const columnsLen = rowData.length;
    const columnsResult = [];
    if (row === 0) {
      result.push("<tbody>");
    }
    for (let column = 0; column < columnsLen; column += 1) {
      const cellData = rowData[column];
      const parsedCellData = isEmpty(cellData) ? "" : cellData.toString().replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, "<br>\r\n").replace(/\x20{2,}/gi, (substring) => {
        return `<span style="mso-spacerun: yes">${"&nbsp;".repeat(substring.length - 1)} </span>`;
      }).replace(/\t/gi, "&#9;");
      columnsResult.push(`<td>${parsedCellData}</td>`);
    }
    result.push("<tr>", ...columnsResult, "</tr>");
    if (row + 1 === inputLen) {
      result.push("</tbody>");
    }
  }
  result.push("</table>");
  return result.join("");
}
function htmlToGridSettings(element) {
  let rootDocument = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document;
  const settingsObj = {};
  const fragment = rootDocument.createDocumentFragment();
  const tempElem = rootDocument.createElement("div");
  fragment.appendChild(tempElem);
  let checkElement = element;
  if (typeof checkElement === "string") {
    const escapedAdjacentHTML = checkElement.replace(/<td\b[^>]*?>([\s\S]*?)<\/\s*td>/g, (cellFragment) => {
      const openingTag = cellFragment.match(/<td\b[^>]*?>/g)[0];
      const cellValue = cellFragment.substring(openingTag.length, cellFragment.lastIndexOf("<")).replace(/(<(?!br)([^>]+)>)/gi, "");
      const closingTag = "</td>";
      return `${openingTag}${cellValue}${closingTag}`;
    });
    tempElem.insertAdjacentHTML("afterbegin", `${escapedAdjacentHTML}`);
    checkElement = tempElem.querySelector("table");
  }
  if (!checkElement || !isHTMLTable(checkElement)) {
    return;
  }
  const generator = tempElem.querySelector('meta[name$="enerator"]');
  const hasRowHeaders = checkElement.querySelector("tbody th") !== null;
  const trElement = checkElement.querySelector("tr");
  const countCols = !trElement ? 0 : Array.from(trElement.cells).reduce((cols, cell) => cols + cell.colSpan, 0) - (hasRowHeaders ? 1 : 0);
  const fixedRowsBottom = checkElement.tFoot && Array.from(checkElement.tFoot.rows) || [];
  const fixedRowsTop = [];
  let hasColHeaders = false;
  let thRowsLen = 0;
  let countRows = 0;
  if (checkElement.tHead) {
    const thRows = Array.from(checkElement.tHead.rows).filter((tr) => {
      const isDataRow = tr.querySelector("td") !== null;
      if (isDataRow) {
        fixedRowsTop.push(tr);
      }
      return !isDataRow;
    });
    thRowsLen = thRows.length;
    hasColHeaders = thRowsLen > 0;
    if (thRowsLen > 1) {
      settingsObj.nestedHeaders = Array.from(thRows).reduce((rows, row) => {
        const headersRow = Array.from(row.cells).reduce((headers, header, currentIndex) => {
          if (hasRowHeaders && currentIndex === 0) {
            return headers;
          }
          const {
            colSpan: colspan,
            innerHTML
          } = header;
          const nextHeader = colspan > 1 ? {
            label: innerHTML,
            colspan
          } : innerHTML;
          headers.push(nextHeader);
          return headers;
        }, []);
        rows.push(headersRow);
        return rows;
      }, []);
    } else if (hasColHeaders) {
      settingsObj.colHeaders = Array.from(thRows[0].children).reduce((headers, header, index2) => {
        if (hasRowHeaders && index2 === 0) {
          return headers;
        }
        headers.push(header.innerHTML);
        return headers;
      }, []);
    }
  }
  if (fixedRowsTop.length) {
    settingsObj.fixedRowsTop = fixedRowsTop.length;
  }
  if (fixedRowsBottom.length) {
    settingsObj.fixedRowsBottom = fixedRowsBottom.length;
  }
  const dataRows = [...fixedRowsTop, ...Array.from(checkElement.tBodies).reduce((sections, section) => {
    sections.push(...Array.from(section.rows));
    return sections;
  }, []), ...fixedRowsBottom];
  countRows = dataRows.length;
  const dataArr = new Array(countRows);
  for (let r = 0; r < countRows; r++) {
    dataArr[r] = new Array(countCols);
  }
  const mergeCells = [];
  const rowHeaders = [];
  for (let row = 0; row < countRows; row++) {
    const tr = dataRows[row];
    const cells = Array.from(tr.cells);
    const cellsLen = cells.length;
    for (let cellId = 0; cellId < cellsLen; cellId++) {
      const cell = cells[cellId];
      const {
        nodeName,
        innerHTML,
        rowSpan: rowspan,
        colSpan: colspan
      } = cell;
      const col = dataArr[row].findIndex((value) => value === void 0);
      if (nodeName === "TD") {
        if (rowspan > 1 || colspan > 1) {
          for (let rstart = row; rstart < row + rowspan; rstart++) {
            if (rstart < countRows) {
              for (let cstart = col; cstart < col + colspan; cstart++) {
                dataArr[rstart][cstart] = null;
              }
            }
          }
          const styleAttr = cell.getAttribute("style");
          const ignoreMerge = styleAttr && styleAttr.includes("mso-ignore:colspan");
          if (!ignoreMerge) {
            mergeCells.push({
              col,
              row,
              rowspan,
              colspan
            });
          }
        }
        let cellValue = "";
        if (generator && /excel/gi.test(generator.content)) {
          cellValue = innerHTML.replace(/[\r\n][\x20]{0,2}/g, " ").replace(/<br(\s*|\/)>[\r\n]?[\x20]{0,3}/gim, "\r\n");
        } else {
          cellValue = innerHTML.replace(/<br(\s*|\/)>[\r\n]?/gim, "\r\n");
        }
        dataArr[row][col] = cellValue.replace(regEscapedChars, (match) => ESCAPED_HTML_CHARS[match]);
      } else {
        rowHeaders.push(innerHTML);
      }
    }
  }
  if (mergeCells.length) {
    settingsObj.mergeCells = mergeCells;
  }
  if (rowHeaders.length) {
    settingsObj.rowHeaders = rowHeaders;
  }
  if (dataArr.length) {
    settingsObj.data = dataArr;
  }
  return settingsObj;
}

// node_modules/handsontable/helpers/number.mjs
var number_exports = {};
__export(number_exports, {
  isNumeric: () => isNumeric,
  isNumericLike: () => isNumericLike,
  rangeEach: () => rangeEach,
  rangeEachReverse: () => rangeEachReverse,
  valueAccordingPercent: () => valueAccordingPercent
});
function isNumeric(value) {
  let additionalDelimiters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  const type = typeof value;
  if (type === "number") {
    return !isNaN(value) && isFinite(value);
  } else if (type === "string") {
    if (value.length === 0) {
      return false;
    } else if (value.length === 1) {
      return /\d/.test(value);
    }
    const delimiter = Array.from(/* @__PURE__ */ new Set([".", ...additionalDelimiters])).map((d) => `\\${d}`).join("|");
    return new RegExp(`^[+-]?\\s*(((${delimiter})?\\d+((${delimiter})\\d+)?(e[+-]?\\d+)?)|(0x[a-f\\d]+))$`, "i").test(value.trim());
  } else if (type === "object") {
    return !!value && typeof value.valueOf() === "number" && !(value instanceof Date);
  }
  return false;
}
function isNumericLike(value) {
  return isNumeric(value, [","]);
}
function rangeEach(rangeFrom, rangeTo, iteratee) {
  let index2 = -1;
  if (typeof rangeTo === "function") {
    iteratee = rangeTo;
    rangeTo = rangeFrom;
  } else {
    index2 = rangeFrom - 1;
  }
  while (++index2 <= rangeTo) {
    if (iteratee(index2) === false) {
      break;
    }
  }
}
function rangeEachReverse(rangeFrom, rangeTo, iteratee) {
  let index2 = rangeFrom + 1;
  if (typeof rangeTo === "function") {
    iteratee = rangeTo;
    rangeTo = 0;
  }
  while (--index2 >= rangeTo) {
    if (iteratee(index2) === false) {
      break;
    }
  }
}
function valueAccordingPercent(value, percent) {
  percent = parseInt(percent.toString().replace("%", ""), 10);
  percent = isNaN(percent) ? 0 : percent;
  return parseInt(value * percent / 100, 10);
}

// node_modules/handsontable/utils/dataStructures/priorityMap.mjs
var ASC = "asc";
var DESC = "desc";
var ORDER_MAP = /* @__PURE__ */ new Map([[ASC, [-1, 1]], [DESC, [1, -1]]]);
var DEFAULT_ERROR_PRIORITY_EXISTS = (priority) => `The priority '${priority}' is already declared in a map.`;
var DEFAULT_ERROR_PRIORITY_NAN = (priority) => `The priority '${priority}' is not a number.`;
function createPriorityMap() {
  let {
    errorPriorityExists,
    errorPriorityNaN
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const priorityMap = /* @__PURE__ */ new Map();
  errorPriorityExists = isFunction2(errorPriorityExists) ? errorPriorityExists : DEFAULT_ERROR_PRIORITY_EXISTS;
  errorPriorityNaN = isFunction2(errorPriorityNaN) ? errorPriorityNaN : DEFAULT_ERROR_PRIORITY_NAN;
  function addItem(priority, item) {
    if (!isNumeric(priority)) {
      throw new Error(errorPriorityNaN(priority));
    }
    if (priorityMap.has(priority)) {
      throw new Error(errorPriorityExists(priority));
    }
    priorityMap.set(priority, item);
  }
  function getItems2() {
    let order = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ASC;
    const [left2, right2] = ORDER_MAP.get(order) || ORDER_MAP.get(ASC);
    return [...priorityMap].sort((a, b) => a[0] < b[0] ? left2 : right2).map((item) => item[1]);
  }
  return {
    addItem,
    getItems: getItems2
  };
}

// node_modules/handsontable/utils/dataStructures/uniqueMap.mjs
var DEFAULT_ERROR_ID_EXISTS = (id) => `The id '${id}' is already declared in a map.`;
function createUniqueMap() {
  let {
    errorIdExists
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const uniqueMap = /* @__PURE__ */ new Map();
  errorIdExists = isFunction2(errorIdExists) ? errorIdExists : DEFAULT_ERROR_ID_EXISTS;
  function addItem(id, item) {
    if (hasItem5(id)) {
      throw new Error(errorIdExists(id));
    }
    uniqueMap.set(id, item);
  }
  function removeItem(id) {
    return uniqueMap.delete(id);
  }
  function clear() {
    uniqueMap.clear();
  }
  function getId(item) {
    const [itemId] = getItems2().find((_ref2) => {
      let [id, element] = _ref2;
      if (item === element) {
        return id;
      }
      return false;
    }) || [null];
    return itemId;
  }
  function getItem6(id) {
    return uniqueMap.get(id);
  }
  function getItems2() {
    return [...uniqueMap];
  }
  function hasItem5(id) {
    return uniqueMap.has(id);
  }
  return {
    addItem,
    clear,
    getId,
    getItem: getItem6,
    getItems: getItems2,
    hasItem: hasItem5,
    removeItem
  };
}

// node_modules/handsontable/utils/dataStructures/uniqueSet.mjs
var DEFAULT_ERROR_ITEM_EXISTS = (item) => `'${item}' value is already declared in a unique set.`;
function createUniqueSet() {
  let {
    errorItemExists
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const uniqueSet = /* @__PURE__ */ new Set();
  errorItemExists = isFunction2(errorItemExists) ? errorItemExists : DEFAULT_ERROR_ITEM_EXISTS;
  function addItem(item) {
    if (uniqueSet.has(item)) {
      throw new Error(errorItemExists(item));
    }
    uniqueSet.add(item);
  }
  function getItems2() {
    return [...uniqueSet];
  }
  function clear() {
    uniqueSet.clear();
  }
  return {
    addItem,
    clear,
    getItems: getItems2
  };
}

// node_modules/handsontable/plugins/registry.mjs
var ERROR_PLUGIN_REGISTERED = (pluginName) => `There is already registered "${pluginName}" plugin.`;
var ERROR_PRIORITY_REGISTERED = (priority) => `There is already registered plugin on priority "${priority}".`;
var ERROR_PRIORITY_NAN = (priority) => `The priority "${priority}" is not a number.`;
var priorityPluginsQueue = createPriorityMap({
  errorPriorityExists: ERROR_PRIORITY_REGISTERED,
  errorPriorityNaN: ERROR_PRIORITY_NAN
});
var uniquePluginsQueue = createUniqueSet({
  errorItemExists: ERROR_PLUGIN_REGISTERED
});
var uniquePluginsList = createUniqueMap({
  errorIdExists: ERROR_PLUGIN_REGISTERED
});
function getPluginsNames() {
  return [...priorityPluginsQueue.getItems(), ...uniquePluginsQueue.getItems()];
}
function getPlugin(pluginName) {
  const unifiedPluginName = toUpperCaseFirst(pluginName);
  return uniquePluginsList.getItem(unifiedPluginName);
}
function hasPlugin(pluginName) {
  return getPlugin(pluginName) ? true : false;
}
function registerPlugin(pluginName, pluginClass, priority) {
  [pluginName, pluginClass, priority] = unifyPluginArguments(pluginName, pluginClass, priority);
  if (getPlugin(pluginName) === void 0) {
    _registerPlugin(pluginName, pluginClass, priority);
  }
}
function _registerPlugin(pluginName, pluginClass, priority) {
  const unifiedPluginName = toUpperCaseFirst(pluginName);
  if (uniquePluginsList.hasItem(unifiedPluginName)) {
    throw new Error(ERROR_PLUGIN_REGISTERED(unifiedPluginName));
  }
  if (priority === void 0) {
    uniquePluginsQueue.addItem(unifiedPluginName);
  } else {
    priorityPluginsQueue.addItem(priority, unifiedPluginName);
  }
  uniquePluginsList.addItem(unifiedPluginName, pluginClass);
}
function unifyPluginArguments(pluginName, pluginClass, priority) {
  if (typeof pluginName === "function") {
    pluginClass = pluginName;
    pluginName = pluginClass.PLUGIN_KEY;
    priority = pluginClass.PLUGIN_PRIORITY;
  }
  return [pluginName, pluginClass, priority];
}

// node_modules/handsontable/renderers/registry.mjs
var {
  register: register2,
  getItem: getItem2,
  hasItem: hasItem2,
  getNames: getNames2,
  getValues: getValues2
} = staticRegister("renderers");
function _getItem2(name) {
  if (typeof name === "function") {
    return name;
  }
  if (!hasItem2(name)) {
    throw Error(`No registered renderer found under "${name}" name`);
  }
  return getItem2(name);
}
function _register2(name, renderer) {
  if (typeof name !== "string") {
    renderer = name;
    name = renderer.RENDERER_TYPE;
  }
  register2(name, renderer);
}

// node_modules/handsontable/validators/registry.mjs
var {
  register: register3,
  getItem: getItem3,
  hasItem: hasItem3,
  getNames: getNames3,
  getValues: getValues3
} = staticRegister("validators");
function _getItem3(name) {
  if (typeof name === "function") {
    return name;
  }
  if (!hasItem3(name)) {
    throw Error(`No registered validator found under "${name}" name`);
  }
  return getItem3(name);
}
function _register3(name, validator) {
  if (typeof name !== "string") {
    validator = name;
    name = validator.VALIDATOR_TYPE;
  }
  register3(name, validator);
}

// node_modules/core-js/modules/es.array.at.js
var $4 = require_export();
var toObject3 = require_to_object();
var lengthOfArrayLike2 = require_length_of_array_like();
var toIntegerOrInfinity = require_to_integer_or_infinity();
var addToUnscopables = require_add_to_unscopables();
$4({ target: "Array", proto: true }, {
  at: function at(index2) {
    var O = toObject3(this);
    var len = lengthOfArrayLike2(O);
    var relativeIndex = toIntegerOrInfinity(index2);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return k < 0 || k >= len ? void 0 : O[k];
  }
});
addToUnscopables("at");

// node_modules/handsontable/3rdparty/walkontable/src/calculator/constants.mjs
var RENDER_TYPE = 1;
var FULLY_VISIBLE_TYPE = 2;

// node_modules/handsontable/3rdparty/walkontable/src/calculator/viewportColumns.mjs
var privatePool = /* @__PURE__ */ new WeakMap();
var ViewportColumnsCalculator = class _ViewportColumnsCalculator {
  /**
   * Default column width.
   *
   * @type {number}
   */
  static get DEFAULT_WIDTH() {
    return 50;
  }
  /**
   * @param {object} options Object with all options specified for column viewport calculation.
   * @param {number} options.viewportSize Width of the viewport.
   * @param {number} options.scrollOffset Current horizontal scroll position of the viewport.
   * @param {number} options.totalItems Total number of columns.
   * @param {Function} options.itemSizeFn Function that returns the width of the column at a given index (in px).
   * @param {Function} options.overrideFn Function that changes calculated this.startRow, this.endRow (used by
   *   MergeCells plugin).
   * @param {string} options.calculationType String which describes types of calculation which will be performed.
   * @param {string} options.inlineStartOffset Inline-start offset of the parent container.
   * @param {string} [options.stretchMode] Stretch mode 'all' or 'last'.
   * @param {Function} [options.stretchingItemWidthFn] Function that returns the new width of the stretched column.
   */
  constructor() {
    let {
      viewportSize,
      scrollOffset,
      totalItems,
      itemSizeFn,
      overrideFn,
      calculationType,
      stretchMode,
      stretchingItemWidthFn = (width) => width,
      inlineStartOffset
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    privatePool.set(this, {
      viewportWidth: viewportSize,
      scrollOffset,
      totalColumns: totalItems,
      columnWidthFn: itemSizeFn,
      overrideFn,
      calculationType,
      stretchingColumnWidthFn: stretchingItemWidthFn,
      inlineStartOffset
    });
    this.count = 0;
    this.startColumn = null;
    this.endColumn = null;
    this.startPosition = null;
    this.isVisibleInTrimmingContainer = false;
    this.stretchAllRatio = 0;
    this.stretchLastWidth = 0;
    this.stretch = stretchMode;
    this.totalTargetWidth = 0;
    this.needVerifyLastColumnWidth = true;
    this.stretchAllColumnsWidth = [];
    this.calculate();
  }
  /**
   * Calculates viewport.
   */
  calculate() {
    let sum = 0;
    let needReverse = true;
    const startPositions = [];
    let columnWidth;
    let firstVisibleColumnWidth = 0;
    let lastVisibleColumnWidth = 0;
    const priv = privatePool.get(this);
    const calculationType = priv.calculationType;
    const overrideFn = priv.overrideFn;
    const scrollOffset = priv.scrollOffset;
    const zeroBasedScrollOffset = Math.max(priv.scrollOffset, 0);
    const totalColumns = priv.totalColumns;
    const viewportWidth = priv.viewportWidth;
    const compensatedViewportWidth = zeroBasedScrollOffset > 0 ? viewportWidth + 1 : viewportWidth;
    for (let i = 0; i < totalColumns; i++) {
      columnWidth = this._getColumnWidth(i);
      if (sum <= zeroBasedScrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {
        this.startColumn = i;
        firstVisibleColumnWidth = columnWidth;
      }
      if (sum >= zeroBasedScrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? columnWidth : 0) <= zeroBasedScrollOffset + compensatedViewportWidth) {
        if (this.startColumn === null || this.startColumn === void 0) {
          this.startColumn = i;
          firstVisibleColumnWidth = columnWidth;
        }
        this.endColumn = i;
      }
      startPositions.push(sum);
      sum += columnWidth;
      lastVisibleColumnWidth = columnWidth;
      if (calculationType !== FULLY_VISIBLE_TYPE) {
        this.endColumn = i;
      }
      if (sum >= zeroBasedScrollOffset + viewportWidth) {
        needReverse = false;
        break;
      }
    }
    const mostRightScrollOffset = scrollOffset + viewportWidth - compensatedViewportWidth;
    const inlineEndColumnOffset = calculationType === FULLY_VISIBLE_TYPE ? 0 : lastVisibleColumnWidth;
    const inlineStartColumnOffset = calculationType === FULLY_VISIBLE_TYPE ? firstVisibleColumnWidth : 0;
    if (
      // the table is to the left of the viewport
      mostRightScrollOffset < -1 * priv.inlineStartOffset || scrollOffset > startPositions.at(-1) + inlineEndColumnOffset || // the table is to the right of the viewport
      -1 * priv.scrollOffset - priv.viewportWidth > -1 * inlineStartColumnOffset
    ) {
      this.isVisibleInTrimmingContainer = false;
    } else {
      this.isVisibleInTrimmingContainer = true;
    }
    if (this.endColumn === totalColumns - 1 && needReverse) {
      this.startColumn = this.endColumn;
      while (this.startColumn > 0) {
        const viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];
        if (viewportSum <= viewportWidth || calculationType !== FULLY_VISIBLE_TYPE) {
          this.startColumn -= 1;
        }
        if (viewportSum > viewportWidth) {
          break;
        }
      }
    }
    if (calculationType === RENDER_TYPE && this.startColumn !== null && overrideFn) {
      overrideFn(this);
    }
    this.startPosition = startPositions[this.startColumn];
    if (this.startPosition === void 0) {
      this.startPosition = null;
    }
    if (totalColumns < this.endColumn) {
      this.endColumn = totalColumns - 1;
    }
    if (this.startColumn !== null) {
      this.count = this.endColumn - this.startColumn + 1;
    }
  }
  /**
   * Recalculate columns stretching.
   *
   * @param {number} totalWidth The total width of the table.
   */
  refreshStretching(totalWidth) {
    if (this.stretch === "none") {
      return;
    }
    let totalColumnsWidth = totalWidth;
    this.totalTargetWidth = totalColumnsWidth;
    const priv = privatePool.get(this);
    const totalColumns = priv.totalColumns;
    let sumAll = 0;
    for (let i = 0; i < totalColumns; i++) {
      const columnWidth = this._getColumnWidth(i);
      const permanentColumnWidth = priv.stretchingColumnWidthFn(void 0, i);
      if (typeof permanentColumnWidth === "number") {
        totalColumnsWidth -= permanentColumnWidth;
      } else {
        sumAll += columnWidth;
      }
    }
    const remainingSize = totalColumnsWidth - sumAll;
    if (this.stretch === "all" && remainingSize > 0) {
      this.stretchAllRatio = totalColumnsWidth / sumAll;
      this.stretchAllColumnsWidth = [];
      this.needVerifyLastColumnWidth = true;
    } else if (this.stretch === "last" && totalColumnsWidth !== Infinity) {
      const columnWidth = this._getColumnWidth(totalColumns - 1);
      const lastColumnWidth = remainingSize + columnWidth;
      this.stretchLastWidth = lastColumnWidth >= 0 ? lastColumnWidth : columnWidth;
    }
  }
  /**
   * Get stretched column width based on stretchH (all or last) setting passed in handsontable instance.
   *
   * @param {number} column The visual column index.
   * @param {number} baseWidth The default column width.
   * @returns {number|null}
   */
  getStretchedColumnWidth(column, baseWidth) {
    let result = null;
    if (this.stretch === "all" && this.stretchAllRatio !== 0) {
      result = this._getStretchedAllColumnWidth(column, baseWidth);
    } else if (this.stretch === "last" && this.stretchLastWidth !== 0) {
      result = this._getStretchedLastColumnWidth(column);
    }
    return result;
  }
  /**
   * @param {number} column The visual column index.
   * @param {number} baseWidth The default column width.
   * @returns {number}
   * @private
   */
  _getStretchedAllColumnWidth(column, baseWidth) {
    let sumRatioWidth = 0;
    const priv = privatePool.get(this);
    const totalColumns = priv.totalColumns;
    if (!this.stretchAllColumnsWidth[column]) {
      const stretchedWidth = Math.round(baseWidth * this.stretchAllRatio);
      const newStretchedWidth = priv.stretchingColumnWidthFn(stretchedWidth, column);
      if (newStretchedWidth === void 0) {
        this.stretchAllColumnsWidth[column] = stretchedWidth;
      } else {
        this.stretchAllColumnsWidth[column] = isNaN(newStretchedWidth) ? this._getColumnWidth(column) : newStretchedWidth;
      }
    }
    if (this.stretchAllColumnsWidth.length === totalColumns && this.needVerifyLastColumnWidth) {
      this.needVerifyLastColumnWidth = false;
      for (let i = 0; i < this.stretchAllColumnsWidth.length; i++) {
        sumRatioWidth += this.stretchAllColumnsWidth[i];
      }
      if (sumRatioWidth !== this.totalTargetWidth) {
        this.stretchAllColumnsWidth[this.stretchAllColumnsWidth.length - 1] += this.totalTargetWidth - sumRatioWidth;
      }
    }
    return this.stretchAllColumnsWidth[column];
  }
  /**
   * @param {number} column The visual column index.
   * @returns {number|null}
   * @private
   */
  _getStretchedLastColumnWidth(column) {
    const priv = privatePool.get(this);
    const totalColumns = priv.totalColumns;
    if (column === totalColumns - 1) {
      return this.stretchLastWidth;
    }
    return null;
  }
  /**
   * @param {number} column The visual column index.
   * @returns {number}
   * @private
   */
  _getColumnWidth(column) {
    let width = privatePool.get(this).columnWidthFn(column);
    if (isNaN(width)) {
      width = _ViewportColumnsCalculator.DEFAULT_WIDTH;
    }
    return width;
  }
};
var viewportColumns_default = ViewportColumnsCalculator;

// node_modules/handsontable/3rdparty/walkontable/src/calculator/viewportRows.mjs
var privatePool2 = /* @__PURE__ */ new WeakMap();
var ViewportRowsCalculator = class _ViewportRowsCalculator {
  /**
   * Default row height.
   *
   * @type {number}
   */
  static get DEFAULT_HEIGHT() {
    return 23;
  }
  /**
   * @param {object} options Object with all options specified for row viewport calculation.
   * @param {number} options.viewportSize Height of the viewport.
   * @param {number} options.scrollOffset Current vertical scroll position of the viewport.
   * @param {number} options.totalItems Total number of rows.
   * @param {Function} options.itemSizeFn Function that returns the height of the row at a given index (in px).
   * @param {Function} options.overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin).
   * @param {string} options.calculationType String which describes types of calculation which will be performed.
   * @param {number} options.scrollbarHeight The scrollbar height.
   */
  constructor() {
    let {
      viewportSize,
      scrollOffset,
      totalItems,
      itemSizeFn,
      overrideFn,
      calculationType,
      scrollbarHeight
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    privatePool2.set(this, {
      viewportHeight: viewportSize,
      scrollOffset,
      totalRows: totalItems,
      rowHeightFn: itemSizeFn,
      overrideFn,
      calculationType,
      horizontalScrollbarHeight: scrollbarHeight
    });
    this.count = 0;
    this.startRow = null;
    this.endRow = null;
    this.startPosition = null;
    this.isVisibleInTrimmingContainer = false;
    this.calculate();
  }
  /**
   * Calculates viewport.
   */
  calculate() {
    const priv = privatePool2.get(this);
    const calculationType = priv.calculationType;
    const overrideFn = priv.overrideFn;
    const rowHeightFn = priv.rowHeightFn;
    const scrollOffset = priv.scrollOffset;
    const zeroBasedScrollOffset = Math.max(priv.scrollOffset, 0);
    const totalRows = priv.totalRows;
    const viewportHeight = priv.viewportHeight;
    const horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;
    let sum = 0;
    let needReverse = true;
    const startPositions = [];
    let rowHeight;
    let firstVisibleRowHeight = 0;
    let lastVisibleRowHeight = 0;
    for (let i = 0; i < totalRows; i++) {
      rowHeight = rowHeightFn(i);
      if (isNaN(rowHeight)) {
        rowHeight = _ViewportRowsCalculator.DEFAULT_HEIGHT;
      }
      if (sum <= zeroBasedScrollOffset && calculationType !== FULLY_VISIBLE_TYPE) {
        this.startRow = i;
        firstVisibleRowHeight = rowHeight;
      }
      if (sum >= zeroBasedScrollOffset && sum + (calculationType === FULLY_VISIBLE_TYPE ? rowHeight : 0) <= zeroBasedScrollOffset + viewportHeight - horizontalScrollbarHeight) {
        if (this.startRow === null) {
          this.startRow = i;
          firstVisibleRowHeight = rowHeight;
        }
        this.endRow = i;
      }
      startPositions.push(sum);
      sum += rowHeight;
      lastVisibleRowHeight = rowHeight;
      if (calculationType !== FULLY_VISIBLE_TYPE) {
        this.endRow = i;
      }
      if (sum >= zeroBasedScrollOffset + viewportHeight - horizontalScrollbarHeight) {
        needReverse = false;
        break;
      }
    }
    const mostBottomScrollOffset = scrollOffset + viewportHeight - horizontalScrollbarHeight;
    const topRowOffset = calculationType === FULLY_VISIBLE_TYPE ? firstVisibleRowHeight : 0;
    const bottomRowOffset = calculationType === FULLY_VISIBLE_TYPE ? 0 : lastVisibleRowHeight;
    if (mostBottomScrollOffset < topRowOffset || scrollOffset > startPositions.at(-1) + bottomRowOffset) {
      this.isVisibleInTrimmingContainer = false;
    } else {
      this.isVisibleInTrimmingContainer = true;
    }
    if (this.endRow === totalRows - 1 && needReverse) {
      this.startRow = this.endRow;
      while (this.startRow > 0) {
        const viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];
        if (viewportSum <= viewportHeight - horizontalScrollbarHeight || calculationType !== FULLY_VISIBLE_TYPE) {
          this.startRow -= 1;
        }
        if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {
          break;
        }
      }
    }
    if (calculationType === RENDER_TYPE && this.startRow !== null && overrideFn) {
      overrideFn(this);
    }
    this.startPosition = startPositions[this.startRow];
    if (this.startPosition === void 0) {
      this.startPosition = null;
    }
    if (totalRows < this.endRow) {
      this.endRow = totalRows - 1;
    }
    if (this.startRow !== null) {
      this.count = this.endRow - this.startRow + 1;
    }
  }
};
var viewportRows_default = ViewportRowsCalculator;

// node_modules/handsontable/3rdparty/walkontable/src/cell/coords.mjs
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _isRtl = /* @__PURE__ */ new WeakMap();
var CellCoords = class _CellCoords {
  constructor(row, column) {
    let isRtl = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    _defineProperty(this, "row", null);
    _defineProperty(this, "col", null);
    _classPrivateFieldInitSpec(this, _isRtl, {
      writable: true,
      value: false
    });
    _classPrivateFieldSet(this, _isRtl, isRtl);
    if (typeof row !== "undefined" && typeof column !== "undefined") {
      this.row = row;
      this.col = column;
    }
  }
  /**
   * Checks if the coordinates in your `CellCoords` instance are valid
   * in the context of a given Walkontable instance.
   *
   * The `row` index:
   * - Can't be negative.
   * - Can't be higher than the total number of rows in the Walkontable instance.
   *
   * The `col` index:
   * - Can't be negative.
   * - Can't be higher than the total number of columns in the Walkontable instance.
   *
   * @param {Walkontable} wot A Walkontable instance.
   * @returns {boolean} `true`: The coordinates are valid.
   */
  isValid(wot) {
    if (this.row < 0 || this.col < 0) {
      return false;
    }
    if (this.row >= wot.getSetting("totalRows") || this.col >= wot.getSetting("totalColumns")) {
      return false;
    }
    return true;
  }
  /**
   * Checks if another set of coordinates (`cellCoords`)
   * is equal to the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} cellCoords Coordinates to check.
   * @returns {boolean}
   */
  isEqual(cellCoords) {
    if (cellCoords === this) {
      return true;
    }
    return this.row === cellCoords.row && this.col === cellCoords.col;
  }
  /**
   * Checks if another set of coordinates (`testedCoords`)
   * is south-east of the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} testedCoords Coordinates to check.
   * @returns {boolean}
   */
  isSouthEastOf(testedCoords) {
    return this.row >= testedCoords.row && (_classPrivateFieldGet(this, _isRtl) ? this.col <= testedCoords.col : this.col >= testedCoords.col);
  }
  /**
   * Checks if another set of coordinates (`testedCoords`)
   * is north-west of the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} testedCoords Coordinates to check.
   * @returns {boolean}
   */
  isNorthWestOf(testedCoords) {
    return this.row <= testedCoords.row && (_classPrivateFieldGet(this, _isRtl) ? this.col >= testedCoords.col : this.col <= testedCoords.col);
  }
  /**
   * Checks if another set of coordinates (`testedCoords`)
   * is south-west of the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} testedCoords Coordinates to check.
   * @returns {boolean}
   */
  isSouthWestOf(testedCoords) {
    return this.row >= testedCoords.row && (_classPrivateFieldGet(this, _isRtl) ? this.col >= testedCoords.col : this.col <= testedCoords.col);
  }
  /**
   * Checks if another set of coordinates (`testedCoords`)
   * is north-east of the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} testedCoords Coordinates to check.
   * @returns {boolean}
   */
  isNorthEastOf(testedCoords) {
    return this.row <= testedCoords.row && (_classPrivateFieldGet(this, _isRtl) ? this.col <= testedCoords.col : this.col >= testedCoords.col);
  }
  /**
   * Normalizes the coordinates in your `CellCoords` instance to the nearest valid position.
   *
   * Coordinates that point to headers (negative values) are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  normalize() {
    this.row = this.row === null ? this.row : Math.max(this.row, 0);
    this.col = this.col === null ? this.col : Math.max(this.col, 0);
    return this;
  }
  /**
   * Clones your `CellCoords` instance.
   *
   * @returns {CellCoords}
   */
  clone() {
    return new _CellCoords(this.row, this.col, _classPrivateFieldGet(this, _isRtl));
  }
  /**
   * Converts your `CellCoords` instance into an object literal with `row` and `col` properties.
   *
   * @returns {{row: number, col: number}} An object literal with `row` and `col` properties.
   */
  toObject() {
    return {
      row: this.row,
      col: this.col
    };
  }
};
var coords_default = CellCoords;

// node_modules/handsontable/3rdparty/walkontable/src/cell/range.mjs
function _classPrivateFieldInitSpec2(obj, privateMap, value) {
  _checkPrivateRedeclaration2(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration2(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldGet2(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
  return _classApplyDescriptorGet2(receiver, descriptor);
}
function _classApplyDescriptorGet2(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet2(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
  _classApplyDescriptorSet2(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor2(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet2(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _isRtl2 = /* @__PURE__ */ new WeakMap();
var CellRange = class _CellRange {
  constructor(highlight) {
    let from2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : highlight;
    let to2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : highlight;
    let isRtl = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    _defineProperty2(this, "highlight", null);
    _defineProperty2(this, "from", null);
    _defineProperty2(this, "to", null);
    _classPrivateFieldInitSpec2(this, _isRtl2, {
      writable: true,
      value: false
    });
    this.highlight = highlight.clone().normalize();
    this.from = from2.clone();
    this.to = to2.clone();
    _classPrivateFieldSet2(this, _isRtl2, isRtl);
  }
  /**
   * Highlights cell selection at the `coords` coordinates.
   *
   * @param {CellCoords} coords Coordinates to use.
   * @returns {CellRange}
   */
  setHighlight(coords) {
    this.highlight = coords.clone().normalize();
    return this;
  }
  /**
   * Sets the `coords` coordinates as the start of your range.
   *
   * @param {CellCoords} coords Coordinates to use.
   * @returns {CellRange}
   */
  setFrom(coords) {
    this.from = coords.clone();
    return this;
  }
  /**
   * Sets the `coords` coordinates as the end of your range.
   *
   * @param {CellCoords} coords Coordinates to use.
   * @returns {CellRange}
   */
  setTo(coords) {
    this.to = coords.clone();
    return this;
  }
  /**
   * Checks if the coordinates in your `CellRange` instance are valid
   * in the context of a given Walkontable instance.
   *
   * See the [`isValid()`](@/api/cellCoords.md#isvalid) method of the [`CellCoords`](@/api/cellCoords.md) class.
   *
   * @param {Walkontable} wot A Walkontable instance.
   * @returns {boolean}
   */
  isValid(wot) {
    return this.from.isValid(wot) && this.to.isValid(wot);
  }
  /**
   * Checks if your range is just a single cell.
   *
   * @returns {boolean}
   */
  isSingle() {
    return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;
  }
  /**
   * Returns the height of your range (as a number of rows, including row headers).
   *
   * @returns {number}
   */
  getOuterHeight() {
    return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;
  }
  /**
   * Returns the width of your range (as a number of columns, including column headers).
   *
   * @returns {number}
   */
  getOuterWidth() {
    return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;
  }
  /**
   * Returns the height of your range (as a number of rows, excluding row headers).
   *
   * @returns {number}
   */
  getHeight() {
    if (this.from.row < 0 && this.to.row < 0) {
      return 0;
    }
    const fromRow = Math.max(this.from.row, 0);
    const toRow = Math.max(this.to.row, 0);
    return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;
  }
  /**
   * Returns the width of your range (as a number of columns, excluding column headers).
   *
   * @returns {number}
   */
  getWidth() {
    if (this.from.col < 0 && this.to.col < 0) {
      return 0;
    }
    const fromCol = Math.max(this.from.col, 0);
    const toCol = Math.max(this.to.col, 0);
    return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;
  }
  /**
   * Returns the number of cells within your range (excluding column and row headers).
   *
   * @returns {number}
   */
  getCellsCount() {
    return this.getWidth() * this.getHeight();
  }
  /**
   * Checks if another set of coordinates (`cellCoords`)
   * is within the `from` and `to` coordinates of your range.
   *
   * @param {CellCoords} cellCoords Coordinates to check.
   * @returns {boolean}
   */
  includes(cellCoords) {
    const {
      row,
      col
    } = cellCoords;
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    return topStart.row <= row && bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;
  }
  /**
   * Checks if another range (`cellRange`) is within your range.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  includesRange(cellRange) {
    return this.includes(cellRange.getOuterTopStartCorner()) && this.includes(cellRange.getOuterBottomEndCorner());
  }
  /**
   * Checks if another range (`cellRange`) is equal to your range.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  isEqual(cellRange) {
    return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);
  }
  /**
   * Checks if another range (`cellRange`) overlaps your range.
   *
   * Range A overlaps range B if the intersection of A and B (or B and A) is not empty.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  overlaps(cellRange) {
    return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());
  }
  /**
   * Checks if another range (`cellRange`) is south-east of your range.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  isSouthEastOf(cellRange) {
    return this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || this.getOuterBottomRightCorner().isSouthEastOf(cellRange);
  }
  /**
   * Checks if another range (`cellRange`) is north-west of your range.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  isNorthWestOf(cellRange) {
    return this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || this.getOuterBottomRightCorner().isNorthWestOf(cellRange);
  }
  /**
   * Checks if another range (`cellRange`) overlaps your range horizontally.
   *
   * For example: returns `true` if the last column of your range is `5`
   * and the first column of the `cellRange` range is `3`.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  isOverlappingHorizontally(cellRange) {
    return this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col || this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col && this.getOuterTopLeftCorner().col >= cellRange.getOuterTopLeftCorner().col;
  }
  /**
   * Checks if another range (`cellRange`) overlaps your range vertically.
   *
   * For example: returns `true` if the last row of your range is `5`
   * and the first row of the `cellRange` range is `3`.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  isOverlappingVertically(cellRange) {
    return this.getOuterBottomRightCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomRightCorner().row <= cellRange.getOuterBottomRightCorner().row || this.getOuterTopRightCorner().row <= cellRange.getOuterBottomRightCorner().row && this.getOuterTopRightCorner().row >= cellRange.getOuterTopRightCorner().row;
  }
  /**
   * Adds a cell to your range, at `cellCoords` coordinates.
   *
   * The `cellCoords` coordinates must exceed a corner of your range.
   *
   * @param {CellCoords} cellCoords A new cell's coordinates.
   * @returns {boolean}
   */
  expand(cellCoords) {
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    if (cellCoords.row < topStart.row || cellCoords.col < topStart.col || cellCoords.row > bottomEnd.row || cellCoords.col > bottomEnd.col) {
      this.from = this._createCellCoords(Math.min(topStart.row, cellCoords.row), Math.min(topStart.col, cellCoords.col));
      this.to = this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), Math.max(bottomEnd.col, cellCoords.col));
      return true;
    }
    return false;
  }
  /**
   * Expand your range with another range (`expandingRange`).
   *
   * @param {CellRange} expandingRange A new range.
   * @returns {boolean}
   */
  expandByRange(expandingRange) {
    if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {
      return false;
    }
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    const initialDirection = this.getDirection();
    const expandingTopStart = expandingRange.getOuterTopStartCorner();
    const expandingBottomEnd = expandingRange.getOuterBottomEndCorner();
    const resultTopRow = Math.min(topStart.row, expandingTopStart.row);
    const resultTopCol = Math.min(topStart.col, expandingTopStart.col);
    const resultBottomRow = Math.max(bottomEnd.row, expandingBottomEnd.row);
    const resultBottomCol = Math.max(bottomEnd.col, expandingBottomEnd.col);
    const finalFrom = this._createCellCoords(resultTopRow, resultTopCol);
    const finalTo = this._createCellCoords(resultBottomRow, resultBottomCol);
    this.from = finalFrom;
    this.to = finalTo;
    this.setDirection(initialDirection);
    if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === "N-S") {
      this.flipDirectionVertically();
    }
    if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === "W-E") {
      this.flipDirectionHorizontally();
    }
    return true;
  }
  /**
   * Gets the direction of the selection.
   *
   * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.
   */
  getDirection() {
    if (this.from.isNorthWestOf(this.to)) {
      return "NW-SE";
    } else if (this.from.isNorthEastOf(this.to)) {
      return "NE-SW";
    } else if (this.from.isSouthEastOf(this.to)) {
      return "SE-NW";
    } else if (this.from.isSouthWestOf(this.to)) {
      return "SW-NE";
    }
  }
  /**
   * Sets the direction of the selection.
   *
   * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.
   */
  setDirection(direction) {
    switch (direction) {
      case "NW-SE":
        [this.from, this.to] = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];
        break;
      case "NE-SW":
        [this.from, this.to] = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];
        break;
      case "SE-NW":
        [this.from, this.to] = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];
        break;
      case "SW-NE":
        [this.from, this.to] = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];
        break;
      default:
        break;
    }
  }
  /**
   * Gets the vertical direction of the selection.
   *
   * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).
   */
  getVerticalDirection() {
    return ["NE-SW", "NW-SE"].indexOf(this.getDirection()) > -1 ? "N-S" : "S-N";
  }
  /**
   * Gets the horizontal direction of the selection.
   *
   * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).
   */
  getHorizontalDirection() {
    return ["NW-SE", "SW-NE"].indexOf(this.getDirection()) > -1 ? "W-E" : "E-W";
  }
  /**
   * Flips the direction of your range vertically (e.g., `NW-SE` changes to `SW-NE`).
   */
  flipDirectionVertically() {
    const direction = this.getDirection();
    switch (direction) {
      case "NW-SE":
        this.setDirection("SW-NE");
        break;
      case "NE-SW":
        this.setDirection("SE-NW");
        break;
      case "SE-NW":
        this.setDirection("NE-SW");
        break;
      case "SW-NE":
        this.setDirection("NW-SE");
        break;
      default:
        break;
    }
  }
  /**
   * Flips the direction of your range horizontally (e.g., `NW-SE` changes to `NE-SW`).
   */
  flipDirectionHorizontally() {
    const direction = this.getDirection();
    switch (direction) {
      case "NW-SE":
        this.setDirection("NE-SW");
        break;
      case "NE-SW":
        this.setDirection("NW-SE");
        break;
      case "SE-NW":
        this.setDirection("SW-NE");
        break;
      case "SW-NE":
        this.setDirection("SE-NW");
        break;
      default:
        break;
    }
  }
  /**
   * Gets the top-left (in LTR) or top-right (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getTopStartCorner() {
    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();
  }
  /**
   * Gets the top-left corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getTopLeftCorner() {
    return _classPrivateFieldGet2(this, _isRtl2) ? this.getTopEndCorner() : this.getTopStartCorner();
  }
  /**
   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getBottomEndCorner() {
    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();
  }
  /**
   * Gets the bottom right corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getBottomRightCorner() {
    return _classPrivateFieldGet2(this, _isRtl2) ? this.getBottomStartCorner() : this.getBottomEndCorner();
  }
  /**
   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getTopEndCorner() {
    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();
  }
  /**
   * Gets the top right corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getTopRightCorner() {
    return _classPrivateFieldGet2(this, _isRtl2) ? this.getTopStartCorner() : this.getTopEndCorner();
  }
  /**
   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getBottomStartCorner() {
    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();
  }
  /**
   * Gets the bottom left corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getBottomLeftCorner() {
    return _classPrivateFieldGet2(this, _isRtl2) ? this.getBottomEndCorner() : this.getBottomStartCorner();
  }
  /**
   * Gets the top left (in LTR) or top right (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the top and start coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterTopStartCorner() {
    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
  }
  /**
   * Gets the top left corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the top and left coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterTopLeftCorner() {
    return _classPrivateFieldGet2(this, _isRtl2) ? this.getOuterTopEndCorner() : this.getOuterTopStartCorner();
  }
  /**
   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the top and start coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterBottomEndCorner() {
    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
  }
  /**
   * Gets the bottom right corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the top and left coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterBottomRightCorner() {
    return _classPrivateFieldGet2(this, _isRtl2) ? this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();
  }
  /**
   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the top and start coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterTopEndCorner() {
    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
  }
  /**
   * Gets the top right corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the top and left coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterTopRightCorner() {
    return _classPrivateFieldGet2(this, _isRtl2) ? this.getOuterTopStartCorner() : this.getOuterTopEndCorner();
  }
  /**
   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the top and start coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterBottomStartCorner() {
    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
  }
  /**
   * Gets the bottom left corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the top and left coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterBottomLeftCorner() {
    return _classPrivateFieldGet2(this, _isRtl2) ? this.getOuterBottomEndCorner() : this.getOuterBottomStartCorner();
  }
  /**
   * Checks if a set of coordinates (`coords`) matches one of the 4 corners of your range.
   *
   * @param {CellCoords} coords Coordinates to check.
   * @param {CellRange} [expandedRange] A range to compare with.
   * @returns {boolean}
   */
  isCorner(coords, expandedRange) {
    if (expandedRange && expandedRange.includes(coords) && (this.getOuterTopLeftCorner().isEqual(this._createCellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getOuterTopRightCorner().isEqual(this._createCellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getOuterBottomLeftCorner().isEqual(this._createCellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getOuterBottomRightCorner().isEqual(this._createCellCoords(expandedRange.to.row, expandedRange.to.col)))) {
      return true;
    }
    return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());
  }
  /**
   * Gets the coordinates of a range corner opposite to the provided `coords`.
   *
   * For example: if the `coords` coordinates match the bottom-right corner of your range,
   * the coordinates of the top-left corner of your range are returned.
   *
   * @param {CellCoords} coords Coordinates to check.
   * @param {CellRange} [expandedRange] A range to compare with.
   * @returns {CellCoords}
   */
  getOppositeCorner(coords, expandedRange) {
    if (!(coords instanceof coords_default)) {
      return false;
    }
    if (expandedRange) {
      const {
        from: from2,
        to: to2
      } = expandedRange;
      if (expandedRange.includes(coords)) {
        if (this.getOuterTopStartCorner().isEqual(this._createCellCoords(from2.row, from2.col))) {
          return this.getOuterBottomEndCorner();
        }
        if (this.getOuterTopEndCorner().isEqual(this._createCellCoords(from2.row, to2.col))) {
          return this.getOuterBottomStartCorner();
        }
        if (this.getOuterBottomStartCorner().isEqual(this._createCellCoords(to2.row, from2.col))) {
          return this.getOuterTopEndCorner();
        }
        if (this.getOuterBottomEndCorner().isEqual(this._createCellCoords(to2.row, to2.col))) {
          return this.getOuterTopStartCorner();
        }
      }
    }
    if (coords.isEqual(this.getOuterBottomEndCorner())) {
      return this.getOuterTopStartCorner();
    } else if (coords.isEqual(this.getOuterTopStartCorner())) {
      return this.getOuterBottomEndCorner();
    } else if (coords.isEqual(this.getOuterTopEndCorner())) {
      return this.getOuterBottomStartCorner();
    } else if (coords.isEqual(this.getOuterBottomStartCorner())) {
      return this.getOuterTopEndCorner();
    }
  }
  /**
   * Indicates which borders (top, right, bottom, left) are shared between
   * your `CellRange`instance and another `range` that's within your range.
   *
   * @param {CellRange} range A range to compare with.
   * @returns {Array<'top' | 'right' | 'bottom' | 'left'>}
   */
  getBordersSharedWith(range) {
    if (!this.includesRange(range)) {
      return [];
    }
    const thisBorders = {
      top: Math.min(this.from.row, this.to.row),
      bottom: Math.max(this.from.row, this.to.row),
      left: Math.min(this.from.col, this.to.col),
      right: Math.max(this.from.col, this.to.col)
    };
    const rangeBorders = {
      top: Math.min(range.from.row, range.to.row),
      bottom: Math.max(range.from.row, range.to.row),
      left: Math.min(range.from.col, range.to.col),
      right: Math.max(range.from.col, range.to.col)
    };
    const result = [];
    if (thisBorders.top === rangeBorders.top) {
      result.push("top");
    }
    if (thisBorders.right === rangeBorders.right) {
      result.push("right");
    }
    if (thisBorders.bottom === rangeBorders.bottom) {
      result.push("bottom");
    }
    if (thisBorders.left === rangeBorders.left) {
      result.push("left");
    }
    return result;
  }
  /**
   * Gets the coordinates of the inner cells of your range.
   *
   * @returns {CellCoords[]}
   */
  getInner() {
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    const out = [];
    for (let r = topStart.row; r <= bottomEnd.row; r++) {
      for (let c = topStart.col; c <= bottomEnd.col; c++) {
        if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {
          out.push(this._createCellCoords(r, c));
        }
      }
    }
    return out;
  }
  /**
   * Gets the coordinates of all cells of your range.
   *
   * @returns {CellCoords[]}
   */
  getAll() {
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    const out = [];
    for (let r = topStart.row; r <= bottomEnd.row; r++) {
      for (let c = topStart.col; c <= bottomEnd.col; c++) {
        if (topStart.row === r && topStart.col === c) {
          out.push(topStart);
        } else if (bottomEnd.row === r && bottomEnd.col === c) {
          out.push(bottomEnd);
        } else {
          out.push(this._createCellCoords(r, c));
        }
      }
    }
    return out;
  }
  /**
   * Runs a callback function on all cells within your range.
   *
   * You can break the iteration by returning `false` in the callback function.
   *
   * @param {function(number, number): boolean} callback A callback function.
   */
  forAll(callback) {
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    for (let r = topStart.row; r <= bottomEnd.row; r++) {
      for (let c = topStart.col; c <= bottomEnd.col; c++) {
        const breakIteration = callback(r, c);
        if (breakIteration === false) {
          return;
        }
      }
    }
  }
  /**
   * Clones your `CellRange` instance.
   *
   * @returns {CellRange}
   */
  clone() {
    return new _CellRange(this.highlight, this.from, this.to, _classPrivateFieldGet2(this, _isRtl2));
  }
  /**
   * Converts your `CellRange` instance into an object literal with the following properties:
   *
   * - `from`
   *    - `row`
   *    - `col`
   * - `to`
   *    - `row`
   *    - `col`
   *
   * @returns {{from: {row: number, col: number}, to: {row: number, col: number}}} An object literal with `from` and `to` properties.
   */
  toObject() {
    return {
      from: this.from.toObject(),
      to: this.to.toObject()
    };
  }
  /**
   * Creates and returns a new instance of the `CellCoords` class.
   *
   * The new `CellCoords` instance automatically inherits the LTR/RTL flag
   * from your `CellRange` instance.
   *
   * @private
   * @param {number} row A row index.
   * @param {number} column A column index.
   * @returns {CellCoords}
   */
  _createCellCoords(row, column) {
    return new coords_default(row, column, _classPrivateFieldGet2(this, _isRtl2));
  }
};
var range_default = CellRange;

// node_modules/handsontable/helpers/feature.mjs
var feature_exports = {};
__export(feature_exports, {
  cancelAnimationFrame: () => cancelAnimationFrame,
  getComparisonFunction: () => getComparisonFunction,
  isTouchSupported: () => isTouchSupported,
  requestAnimationFrame: () => requestAnimationFrame
});
function requestAnimationFrame(callback) {
  return window.requestAnimationFrame(callback);
}
function cancelAnimationFrame(id) {
  window.cancelAnimationFrame(id);
}
function isTouchSupported() {
  return "ontouchstart" in window;
}
var comparisonFunction;
function getComparisonFunction(language) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (comparisonFunction) {
    return comparisonFunction;
  }
  if (typeof Intl === "object") {
    comparisonFunction = new Intl.Collator(language, options).compare;
  } else if (typeof String.prototype.localeCompare === "function") {
    comparisonFunction = (a, b) => `${a}`.localeCompare(b);
  } else {
    comparisonFunction = (a, b) => {
      if (a === b) {
        return 0;
      }
      return a > b ? -1 : 1;
    };
  }
  return comparisonFunction;
}

// node_modules/handsontable/3rdparty/walkontable/src/event.mjs
var privatePool3 = /* @__PURE__ */ new WeakMap();
var Event2 = class {
  /**
   * @param {FacadeGetter} facadeGetter Gets an instance facade.
   * @param {DomBindings} domBindings Bindings into dom.
   * @param {Settings} wtSettings The walkontable settings.
   * @param {EventManager} eventManager The walkontable event manager.
   * @param {Table} wtTable The table.
   * @param {Selections} selections Selections.
   * @param {Event} [parent=null] The main Event instance.
   */
  constructor(facadeGetter, domBindings, wtSettings, eventManager, wtTable, selections) {
    let parent = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
    this.wtSettings = wtSettings;
    this.domBindings = domBindings;
    this.wtTable = wtTable;
    this.selections = selections;
    this.parent = parent;
    this.eventManager = eventManager;
    this.facadeGetter = facadeGetter;
    privatePool3.set(this, {
      selectedCellBeforeTouchEnd: void 0,
      dblClickTimeout: [null, null],
      dblClickOrigin: [null, null]
    });
    this.registerEvents();
  }
  /**
   * Adds listeners for mouse and touch events.
   *
   * @private
   */
  registerEvents() {
    this.eventManager.addEventListener(this.wtTable.holder, "contextmenu", (event2) => this.onContextMenu(event2));
    this.eventManager.addEventListener(this.wtTable.TABLE, "mouseover", (event2) => this.onMouseOver(event2));
    this.eventManager.addEventListener(this.wtTable.TABLE, "mouseout", (event2) => this.onMouseOut(event2));
    const initTouchEvents = () => {
      this.eventManager.addEventListener(this.wtTable.holder, "touchstart", (event2) => this.onTouchStart(event2));
      this.eventManager.addEventListener(this.wtTable.holder, "touchend", (event2) => this.onTouchEnd(event2));
      if (!this.momentumScrolling) {
        this.momentumScrolling = {};
      }
      this.eventManager.addEventListener(this.wtTable.holder, "scroll", () => {
        clearTimeout(this.momentumScrolling._timeout);
        if (!this.momentumScrolling.ongoing) {
          this.wtSettings.getSetting("onBeforeTouchScroll");
        }
        this.momentumScrolling.ongoing = true;
        this.momentumScrolling._timeout = setTimeout(() => {
          if (!this.touchApplied) {
            this.momentumScrolling.ongoing = false;
            this.wtSettings.getSetting("onAfterMomentumScroll");
          }
        }, 200);
      });
    };
    const initMouseEvents = () => {
      this.eventManager.addEventListener(this.wtTable.holder, "mouseup", (event2) => this.onMouseUp(event2));
      this.eventManager.addEventListener(this.wtTable.holder, "mousedown", (event2) => this.onMouseDown(event2));
    };
    if (isMobileBrowser()) {
      initTouchEvents();
    } else {
      if (isTouchSupported()) {
        initTouchEvents();
      }
      initMouseEvents();
    }
  }
  /**
   * Checks if an element is already selected.
   *
   * @private
   * @param {Element} touchTarget An element to check.
   * @returns {boolean}
   */
  selectedCellWasTouched(touchTarget) {
    const priv = privatePool3.get(this);
    const cellUnderFinger = this.parentCell(touchTarget);
    const coordsOfCellUnderFinger = cellUnderFinger.coords;
    if (priv.selectedCellBeforeTouchEnd && coordsOfCellUnderFinger) {
      const [rowTouched, rowSelected] = [coordsOfCellUnderFinger.row, priv.selectedCellBeforeTouchEnd.from.row];
      const [colTouched, colSelected] = [coordsOfCellUnderFinger.col, priv.selectedCellBeforeTouchEnd.from.col];
      return rowTouched === rowSelected && colTouched === colSelected;
    }
    return false;
  }
  /**
   * Gets closest TD or TH element.
   *
   * @private
   * @param {Element} elem An element from the traversing starts.
   * @returns {object} Contains coordinates and reference to TD or TH if it exists. Otherwise it's empty object.
   */
  parentCell(elem) {
    const cell = {};
    const TABLE = this.wtTable.TABLE;
    const TD = closestDown(elem, ["TD", "TH"], TABLE);
    if (TD) {
      cell.coords = this.wtTable.getCoords(TD);
      cell.TD = TD;
    } else if (hasClass(elem, "wtBorder") && hasClass(elem, "current")) {
      cell.coords = this.selections.getCell().cellRange.highlight;
      cell.TD = this.wtTable.getCell(cell.coords);
    } else if (hasClass(elem, "wtBorder") && hasClass(elem, "area")) {
      if (this.selections.createOrGetArea().cellRange) {
        cell.coords = this.selections.createOrGetArea().cellRange.to;
        cell.TD = this.wtTable.getCell(cell.coords);
      }
    }
    return cell;
  }
  /**
   * OnMouseDown callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onMouseDown(event2) {
    const priv = privatePool3.get(this);
    const activeElement = this.domBindings.rootDocument.activeElement;
    const getParentNode = partial(getParent, event2.target);
    const realTarget = event2.target;
    if (realTarget === activeElement || getParentNode(0) === activeElement || getParentNode(1) === activeElement) {
      return;
    }
    const cell = this.parentCell(realTarget);
    if (hasClass(realTarget, "corner")) {
      this.wtSettings.getSetting("onCellCornerMouseDown", event2, realTarget);
    } else if (cell.TD && this.wtSettings.has("onCellMouseDown")) {
      this.callListener("onCellMouseDown", event2, cell.coords, cell.TD);
    }
    if ((event2.button === 0 || this.touchApplied) && cell.TD) {
      priv.dblClickOrigin[0] = cell.TD;
      clearTimeout(priv.dblClickTimeout[0]);
      priv.dblClickTimeout[0] = setTimeout(() => {
        priv.dblClickOrigin[0] = null;
      }, 1e3);
    }
  }
  /**
   * OnContextMenu callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onContextMenu(event2) {
    if (this.wtSettings.has("onCellContextMenu")) {
      const cell = this.parentCell(event2.target);
      if (cell.TD) {
        this.callListener("onCellContextMenu", event2, cell.coords, cell.TD);
      }
    }
  }
  /**
   * OnMouseOver callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onMouseOver(event2) {
    if (!this.wtSettings.has("onCellMouseOver")) {
      return;
    }
    const table = this.wtTable.TABLE;
    const td = closestDown(event2.target, ["TD", "TH"], table);
    const parent = this.parent || this;
    if (td && td !== parent.lastMouseOver && isChildOf(td, table)) {
      parent.lastMouseOver = td;
      this.callListener("onCellMouseOver", event2, this.wtTable.getCoords(td), td);
    }
  }
  /**
   * OnMouseOut callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onMouseOut(event2) {
    if (!this.wtSettings.has("onCellMouseOut")) {
      return;
    }
    const table = this.wtTable.TABLE;
    const lastTD = closestDown(event2.target, ["TD", "TH"], table);
    const nextTD = closestDown(event2.relatedTarget, ["TD", "TH"], table);
    const parent = this.parent || this;
    if (lastTD && lastTD !== nextTD && isChildOf(lastTD, table)) {
      this.callListener("onCellMouseOut", event2, this.wtTable.getCoords(lastTD), lastTD);
      if (nextTD === null) {
        parent.lastMouseOver = null;
      }
    }
  }
  /**
   * OnMouseUp callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onMouseUp(event2) {
    const priv = privatePool3.get(this);
    const cell = this.parentCell(event2.target);
    if (cell.TD && this.wtSettings.has("onCellMouseUp")) {
      this.callListener("onCellMouseUp", event2, cell.coords, cell.TD);
    }
    if (event2.button !== 0 && !this.touchApplied) {
      return;
    }
    if (cell.TD === priv.dblClickOrigin[0] && cell.TD === priv.dblClickOrigin[1]) {
      if (hasClass(event2.target, "corner")) {
        this.callListener("onCellCornerDblClick", event2, cell.coords, cell.TD);
      } else {
        this.callListener("onCellDblClick", event2, cell.coords, cell.TD);
      }
      priv.dblClickOrigin[0] = null;
      priv.dblClickOrigin[1] = null;
    } else if (cell.TD === priv.dblClickOrigin[0]) {
      priv.dblClickOrigin[1] = cell.TD;
      clearTimeout(priv.dblClickTimeout[1]);
      priv.dblClickTimeout[1] = setTimeout(() => {
        priv.dblClickOrigin[1] = null;
      }, 500);
    }
  }
  /**
   * OnTouchStart callback. Simulates mousedown event.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onTouchStart(event2) {
    const priv = privatePool3.get(this);
    priv.selectedCellBeforeTouchEnd = this.selections.getCell().cellRange;
    this.touchApplied = true;
    this.onMouseDown(event2);
  }
  /**
   * OnTouchEnd callback. Simulates mouseup event.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onTouchEnd(event2) {
    var _this$parentCell;
    const target = event2.target;
    const parentCellCoords = (_this$parentCell = this.parentCell(target)) === null || _this$parentCell === void 0 ? void 0 : _this$parentCell.coords;
    const isCellsRange = isDefined(parentCellCoords) && parentCellCoords.row >= 0 && parentCellCoords.col >= 0;
    const isEventCancelable = event2.cancelable && isCellsRange && this.wtSettings.getSetting("isDataViewInstance");
    if (isEventCancelable) {
      const interactiveElements = ["A", "BUTTON", "INPUT"];
      if (isIOS() && (isChromeWebKit() || isFirefoxWebKit()) && this.selectedCellWasTouched(target) && !interactiveElements.includes(target.tagName)) {
        event2.preventDefault();
      } else if (!this.selectedCellWasTouched(target)) {
        event2.preventDefault();
      }
    }
    this.onMouseUp(event2);
    this.touchApplied = false;
  }
  /**
   * Call listener with backward compatibility.
   *
   * @private
   * @param {string} name Name of listener.
   * @param {MouseEvent} event The event object.
   * @param {CellCoords} coords Coordinates.
   * @param {HTMLElement} target Event target.
   */
  callListener(name, event2, coords, target) {
    const listener = this.wtSettings.getSettingPure(name);
    if (listener) {
      listener(event2, coords, target, this.facadeGetter());
    }
  }
  /**
   * Clears double-click timeouts and destroys the internal eventManager instance.
   */
  destroy() {
    const priv = privatePool3.get(this);
    clearTimeout(priv.dblClickTimeout[0]);
    clearTimeout(priv.dblClickTimeout[1]);
    this.eventManager.destroy();
  }
};
var event_default = Event2;

// node_modules/handsontable/3rdparty/walkontable/src/filter/column.mjs
var ColumnFilter = class {
  /**
   * @param {number} offset The scroll horizontal offset.
   * @param {number} total The total width of the table.
   * @param {number} countTH The number of rendered row headers.
   */
  constructor(offset3, total, countTH) {
    this.offset = offset3;
    this.total = total;
    this.countTH = countTH;
  }
  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  offsetted(index2) {
    return index2 + this.offset;
  }
  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  unOffsetted(index2) {
    return index2 - this.offset;
  }
  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  renderedToSource(index2) {
    return this.offsetted(index2);
  }
  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  sourceToRendered(index2) {
    return this.unOffsetted(index2);
  }
  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  offsettedTH(index2) {
    return index2 - this.countTH;
  }
  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  unOffsettedTH(index2) {
    return index2 + this.countTH;
  }
  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  visibleRowHeadedColumnToSourceColumn(index2) {
    return this.renderedToSource(this.offsettedTH(index2));
  }
  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  sourceColumnToVisibleRowHeadedColumn(index2) {
    return this.unOffsettedTH(this.sourceToRendered(index2));
  }
};
var column_default = ColumnFilter;

// node_modules/handsontable/3rdparty/walkontable/src/filter/row.mjs
var RowFilter = class {
  /**
   * @param {number} offset The scroll vertical offset.
   * @param {number} total The total height of the table.
   * @param {number} countTH The number of rendered column headers.
   */
  constructor(offset3, total, countTH) {
    this.offset = offset3;
    this.total = total;
    this.countTH = countTH;
  }
  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  offsetted(index2) {
    return index2 + this.offset;
  }
  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  unOffsetted(index2) {
    return index2 - this.offset;
  }
  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  renderedToSource(index2) {
    return this.offsetted(index2);
  }
  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  sourceToRendered(index2) {
    return this.unOffsetted(index2);
  }
  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  offsettedTH(index2) {
    return index2 - this.countTH;
  }
  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  unOffsettedTH(index2) {
    return index2 + this.countTH;
  }
  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  visibleColHeadedRowToSourceRow(index2) {
    return this.renderedToSource(this.offsettedTH(index2));
  }
  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  sourceRowToVisibleColHeadedRow(index2) {
    return this.unOffsettedTH(this.sourceToRendered(index2));
  }
};
var row_default = RowFilter;

// node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/constants.mjs
var WORKING_SPACE_ALL = 0;
var WORKING_SPACE_TOP = 1;
var WORKING_SPACE_BOTTOM = 2;

// node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/viewSize.mjs
var ViewSize = class {
  constructor() {
    this.currentSize = 0;
    this.nextSize = 0;
    this.currentOffset = 0;
    this.nextOffset = 0;
  }
  /**
   * Sets new size of the rendered DOM elements.
   *
   * @param {number} size The size.
   */
  setSize(size) {
    this.currentSize = this.nextSize;
    this.nextSize = size;
  }
  /**
   * Sets new offset.
   *
   * @param {number} offset The offset.
   */
  setOffset(offset3) {
    this.currentOffset = this.nextOffset;
    this.nextOffset = offset3;
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/viewSizeSet.mjs
var ViewSizeSet = class {
  constructor() {
    this.size = new ViewSize();
    this.workingSpace = WORKING_SPACE_ALL;
    this.sharedSize = null;
  }
  /**
   * Sets the size for rendered elements. It can be a size for rows, cells or size for row
   * headers etc.
   *
   * @param {number} size The size.
   */
  setSize(size) {
    this.size.setSize(size);
  }
  /**
   * Sets the offset for rendered elements. The offset describes the shift between 0 and
   * the first rendered element according to the scroll position.
   *
   * @param {number} offset The offset.
   */
  setOffset(offset3) {
    this.size.setOffset(offset3);
  }
  /**
   * Returns ViewSize instance.
   *
   * @returns {ViewSize}
   */
  getViewSize() {
    return this.size;
  }
  /**
   * Checks if this ViewSizeSet is sharing the size with another instance.
   *
   * @returns {boolean}
   */
  isShared() {
    return this.sharedSize instanceof ViewSize;
  }
  /**
   * Checks what working space describes this size instance.
   *
   * @param {number} workingSpace The number which describes the type of the working space (see constants.js).
   * @returns {boolean}
   */
  isPlaceOn(workingSpace) {
    return this.workingSpace === workingSpace;
  }
  /**
   * Appends the ViewSizeSet instance to this instance that turns it into a shared mode.
   *
   * @param {ViewSizeSet} viewSize The instance of the ViewSizeSet class.
   */
  append(viewSize) {
    this.workingSpace = WORKING_SPACE_TOP;
    viewSize.workingSpace = WORKING_SPACE_BOTTOM;
    this.sharedSize = viewSize.getViewSize();
  }
  /**
   * Prepends the ViewSize instance to this instance that turns it into a shared mode.
   *
   * @param {ViewSizeSet} viewSize The instance of the ViewSizeSet class.
   */
  prepend(viewSize) {
    this.workingSpace = WORKING_SPACE_BOTTOM;
    viewSize.workingSpace = WORKING_SPACE_TOP;
    this.sharedSize = viewSize.getViewSize();
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/view.mjs
var OrderView = class {
  constructor(rootNode, nodesPool, childNodeType) {
    this.rootNode = rootNode;
    this.nodesPool = nodesPool;
    this.sizeSet = new ViewSizeSet();
    this.childNodeType = childNodeType.toUpperCase();
    this.visualIndex = 0;
    this.collectedNodes = [];
  }
  /**
   * Sets the size for rendered elements. It can be a size for rows, cells or size for row
   * headers etc. It depends for what table renderer this instance was created.
   *
   * @param {number} size The size.
   * @returns {OrderView}
   */
  setSize(size) {
    this.sizeSet.setSize(size);
    return this;
  }
  /**
   * Sets the offset for rendered elements. The offset describes the shift between 0 and
   * the first rendered element according to the scroll position.
   *
   * @param {number} offset The offset.
   * @returns {OrderView}
   */
  setOffset(offset3) {
    this.sizeSet.setOffset(offset3);
    return this;
  }
  /**
   * Checks if this instance of the view shares the root node with another instance. This happens only once when
   * a row (TR) as a root node is managed by two OrderView instances. If this happens another DOM injection
   * algorithm is performed to achieve consistent order.
   *
   * @returns {boolean}
   */
  isSharedViewSet() {
    return this.sizeSet.isShared();
  }
  /**
   * Returns rendered DOM element based on visual index.
   *
   * @param {number} visualIndex The visual index.
   * @returns {HTMLElement}
   */
  getNode(visualIndex) {
    return visualIndex < this.collectedNodes.length ? this.collectedNodes[visualIndex] : null;
  }
  /**
   * Returns currently processed DOM element.
   *
   * @returns {HTMLElement}
   */
  getCurrentNode() {
    const length = this.collectedNodes.length;
    return length > 0 ? this.collectedNodes[length - 1] : null;
  }
  /**
   * Returns rendered child count for this instance.
   *
   * @returns {number}
   */
  getRenderedChildCount() {
    const {
      rootNode,
      sizeSet
    } = this;
    let childElementCount = 0;
    if (this.isSharedViewSet()) {
      let element = rootNode.firstElementChild;
      while (element) {
        if (element.tagName === this.childNodeType) {
          childElementCount += 1;
        } else if (sizeSet.isPlaceOn(WORKING_SPACE_TOP)) {
          break;
        }
        element = element.nextElementSibling;
      }
    } else {
      childElementCount = rootNode.childElementCount;
    }
    return childElementCount;
  }
  /**
   * Setups and prepares all necessary properties and start the rendering process.
   * This method has to be called only once (at the start) for the render cycle.
   */
  start() {
    this.collectedNodes.length = 0;
    this.visualIndex = 0;
    const {
      rootNode,
      sizeSet
    } = this;
    const isShared = this.isSharedViewSet();
    const {
      nextSize
    } = sizeSet.getViewSize();
    let childElementCount = this.getRenderedChildCount();
    while (childElementCount < nextSize) {
      const newNode = this.nodesPool();
      if (!isShared || isShared && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {
        rootNode.appendChild(newNode);
      } else {
        rootNode.insertBefore(newNode, rootNode.firstChild);
      }
      childElementCount += 1;
    }
    const isSharedPlacedOnTop = isShared && sizeSet.isPlaceOn(WORKING_SPACE_TOP);
    while (childElementCount > nextSize) {
      rootNode.removeChild(isSharedPlacedOnTop ? rootNode.firstChild : rootNode.lastChild);
      childElementCount -= 1;
    }
  }
  /**
   * Renders the DOM element based on visual index (which is calculated internally).
   * This method has to be called as many times as the size count is met (to cover all previously rendered DOM elements).
   */
  render() {
    const {
      rootNode,
      sizeSet
    } = this;
    let visualIndex = this.visualIndex;
    if (this.isSharedViewSet() && sizeSet.isPlaceOn(WORKING_SPACE_BOTTOM)) {
      visualIndex += sizeSet.sharedSize.nextSize;
    }
    let node = rootNode.childNodes[visualIndex];
    if (node.tagName !== this.childNodeType) {
      const newNode = this.nodesPool();
      rootNode.replaceChild(newNode, node);
      node = newNode;
    }
    this.collectedNodes.push(node);
    this.visualIndex += 1;
  }
  /**
   * Ends the render process.
   * This method has to be called only once (at the end) for the render cycle.
   */
  end() {
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/utils/orderView/sharedView.mjs
var SharedOrderView = class extends OrderView {
  /**
   * The method results in merging external order view into the current order. This happens only for order views which
   * operate on the same root node.
   *
   * In the table, there is only one scenario when this happens. TR root element
   * has a common root node with cells order view and row headers order view. Both classes have to share
   * information about their order sizes to make proper diff calculations.
   *
   * @param {OrderView} orderView The order view to merging with. The view will be added at the beginning of the list.
   * @returns {SharedOrderView}
   */
  prependView(orderView) {
    this.sizeSet.prepend(orderView.sizeSet);
    orderView.sizeSet.append(this.sizeSet);
    return this;
  }
  /**
   * The method results in merging external order view into the current order. This happens only for order views which
   * operate on the same root node.
   *
   * In the table, there is only one scenario when this happens. TR root element
   * has a common root node with cells order view and row headers order view. Both classes have to share
   * information about their order sizes to make proper diff calculations.
   *
   * @param {OrderView} orderView The order view to merging with. The view will be added at the end of the list.
   * @returns {SharedOrderView}
   */
  appendView(orderView) {
    this.sizeSet.append(orderView.sizeSet);
    orderView.sizeSet.prepend(this.sizeSet);
    return this;
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/utils/nodesPool.mjs
var NodesPool = class {
  constructor(nodeType) {
    this.nodeType = nodeType.toUpperCase();
  }
  /**
   * Set document owner for this instance.
   *
   * @param {HTMLDocument} rootDocument The document window owner.
   */
  setRootDocument(rootDocument) {
    this.rootDocument = rootDocument;
  }
  /**
   * Obtains an element. The returned elements in the feature can be cached.
   *
   * @returns {HTMLElement}
   */
  obtain() {
    return this.rootDocument.createElement(this.nodeType);
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/renderer/_base.mjs
var BaseRenderer = class {
  constructor(nodeType, rootNode) {
    this.nodesPool = typeof nodeType === "string" ? new NodesPool(nodeType) : null;
    this.nodeType = nodeType;
    this.rootNode = rootNode;
    this.table = null;
    this.renderedNodes = 0;
  }
  /**
   * Sets the table renderer instance to the current renderer.
   *
   * @param {TableRenderer} table The TableRenderer instance.
   */
  setTable(table) {
    if (this.nodesPool) {
      this.nodesPool.setRootDocument(table.rootDocument);
    }
    this.table = table;
  }
  /**
   * Adjusts the number of rendered nodes.
   */
  adjust() {
  }
  /**
   * Renders the contents to the elements.
   */
  render() {
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/renderer/rowHeaders.mjs
var RowHeadersRenderer = class extends BaseRenderer {
  constructor() {
    super("TH");
    this.orderViews = /* @__PURE__ */ new WeakMap();
    this.sourceRowIndex = 0;
  }
  /**
   * Obtains the instance of the SharedOrderView class which is responsible for rendering the nodes to the root node.
   *
   * @param {HTMLTableRowElement} rootNode The TR element, which is root element for row headers (TH).
   * @returns {SharedOrderView}
   */
  obtainOrderView(rootNode) {
    let orderView;
    if (this.orderViews.has(rootNode)) {
      orderView = this.orderViews.get(rootNode);
    } else {
      orderView = new SharedOrderView(rootNode, (sourceColumnIndex) => this.nodesPool.obtain(this.sourceRowIndex, sourceColumnIndex), this.nodeType);
      this.orderViews.set(rootNode, orderView);
    }
    return orderView;
  }
  /**
   * Renders the cells.
   */
  render() {
    const {
      rowsToRender,
      rowHeaderFunctions,
      rowHeadersCount,
      rows,
      cells
    } = this.table;
    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
      const sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);
      const TR = rows.getRenderedNode(visibleRowIndex);
      this.sourceRowIndex = sourceRowIndex;
      const orderView = this.obtainOrderView(TR);
      const cellsView = cells.obtainOrderView(TR);
      orderView.appendView(cellsView).setSize(rowHeadersCount).setOffset(this.table.renderedColumnToSource(0)).start();
      for (let visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
        orderView.render();
        const TH = orderView.getCurrentNode();
        TH.className = "";
        TH.removeAttribute("style");
        rowHeaderFunctions[visibleColumnIndex](sourceRowIndex, TH, visibleColumnIndex);
      }
      orderView.end();
    }
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/renderer/columnHeaders.mjs
var ColumnHeadersRenderer = class extends BaseRenderer {
  constructor(rootNode) {
    super(null, rootNode);
  }
  /**
   * Adjusts the number of the rendered elements.
   */
  adjust() {
    const {
      columnHeadersCount,
      rowHeadersCount
    } = this.table;
    let TR = this.rootNode.firstChild;
    if (columnHeadersCount) {
      const {
        columnsToRender
      } = this.table;
      const allColumnsToRender = columnsToRender + rowHeadersCount;
      for (let i = 0, len = columnHeadersCount; i < len; i++) {
        TR = this.rootNode.childNodes[i];
        if (!TR) {
          TR = this.table.rootDocument.createElement("tr");
          this.rootNode.appendChild(TR);
        }
        this.renderedNodes = TR.childNodes.length;
        while (this.renderedNodes < allColumnsToRender) {
          TR.appendChild(this.table.rootDocument.createElement("th"));
          this.renderedNodes += 1;
        }
        while (this.renderedNodes > allColumnsToRender) {
          TR.removeChild(TR.lastChild);
          this.renderedNodes -= 1;
        }
      }
      const theadChildrenLength = this.rootNode.childNodes.length;
      if (theadChildrenLength > columnHeadersCount) {
        for (let i = columnHeadersCount; i < theadChildrenLength; i++) {
          this.rootNode.removeChild(this.rootNode.lastChild);
        }
      }
    } else if (TR) {
      empty(TR);
    }
  }
  /**
   * Renders the TH elements.
   */
  render() {
    const {
      columnHeadersCount
    } = this.table;
    for (let rowHeaderIndex = 0; rowHeaderIndex < columnHeadersCount; rowHeaderIndex += 1) {
      const {
        columnHeaderFunctions,
        columnsToRender,
        rowHeadersCount
      } = this.table;
      const TR = this.rootNode.childNodes[rowHeaderIndex];
      for (let renderedColumnIndex = -1 * rowHeadersCount; renderedColumnIndex < columnsToRender; renderedColumnIndex += 1) {
        const sourceColumnIndex = this.table.renderedColumnToSource(renderedColumnIndex);
        const TH = TR.childNodes[renderedColumnIndex + rowHeadersCount];
        TH.className = "";
        TH.removeAttribute("style");
        columnHeaderFunctions[rowHeaderIndex](sourceColumnIndex, TH, rowHeaderIndex);
      }
    }
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/renderer/colGroup.mjs
var ColGroupRenderer = class extends BaseRenderer {
  constructor(rootNode) {
    super(null, rootNode);
  }
  /**
   * Adjusts the number of the rendered elements.
   */
  adjust() {
    const {
      columnsToRender,
      rowHeadersCount
    } = this.table;
    const allColumnsToRender = columnsToRender + rowHeadersCount;
    while (this.renderedNodes < allColumnsToRender) {
      this.rootNode.appendChild(this.table.rootDocument.createElement("col"));
      this.renderedNodes += 1;
    }
    while (this.renderedNodes > allColumnsToRender) {
      this.rootNode.removeChild(this.rootNode.lastChild);
      this.renderedNodes -= 1;
    }
  }
  /**
   * Renders the col group elements.
   */
  render() {
    this.adjust();
    const {
      columnsToRender,
      rowHeadersCount
    } = this.table;
    for (let visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
      const sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
      const width = this.table.columnUtils.getHeaderWidth(sourceColumnIndex);
      this.rootNode.childNodes[visibleColumnIndex].style.width = `${width}px`;
    }
    for (let visibleColumnIndex = 0; visibleColumnIndex < columnsToRender; visibleColumnIndex++) {
      const sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
      const width = this.table.columnUtils.getStretchedColumnWidth(sourceColumnIndex);
      this.rootNode.childNodes[visibleColumnIndex + rowHeadersCount].style.width = `${width}px`;
    }
    const firstChild = this.rootNode.firstChild;
    if (firstChild) {
      addClass(firstChild, "rowHeader");
    }
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/renderer/rows.mjs
var performanceWarningAppeared = false;
var RowsRenderer = class extends BaseRenderer {
  constructor(rootNode) {
    super("TR", rootNode);
    this.orderView = new OrderView(rootNode, (sourceRowIndex) => this.nodesPool.obtain(sourceRowIndex), this.nodeType);
  }
  /**
   * Returns currently rendered node.
   *
   * @param {string} visualIndex Visual index of the rendered node (it always goeas from 0 to N).
   * @returns {HTMLTableRowElement}
   */
  getRenderedNode(visualIndex) {
    return this.orderView.getNode(visualIndex);
  }
  /**
   * Renders the cells.
   */
  render() {
    const {
      rowsToRender
    } = this.table;
    if (!performanceWarningAppeared && rowsToRender > 1e3) {
      performanceWarningAppeared = true;
      warn2(toSingleLine`Performance tip: Handsontable rendered more than 1000 visible rows. Consider limiting\x20
        the number of rendered rows by specifying the table height and/or turning off the "renderAllRows" option.`);
    }
    this.orderView.setSize(rowsToRender).setOffset(this.table.renderedRowToSource(0)).start();
    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
      this.orderView.render();
    }
    this.orderView.end();
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/renderer/cells.mjs
var CellsRenderer = class extends BaseRenderer {
  constructor() {
    super("TD");
    this.orderViews = /* @__PURE__ */ new WeakMap();
    this.sourceRowIndex = 0;
  }
  /**
   * Obtains the instance of the SharedOrderView class which is responsible for rendering the nodes to the root node.
   *
   * @param {HTMLTableRowElement} rootNode The TR element, which is root element for cells (TD).
   * @returns {SharedOrderView}
   */
  obtainOrderView(rootNode) {
    let orderView;
    if (this.orderViews.has(rootNode)) {
      orderView = this.orderViews.get(rootNode);
    } else {
      orderView = new SharedOrderView(rootNode, (sourceColumnIndex) => this.nodesPool.obtain(this.sourceRowIndex, sourceColumnIndex), this.nodeType);
      this.orderViews.set(rootNode, orderView);
    }
    return orderView;
  }
  /**
   * Renders the cells.
   */
  render() {
    const {
      rowsToRender,
      columnsToRender,
      rows,
      rowHeaders
    } = this.table;
    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
      const sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);
      const TR = rows.getRenderedNode(visibleRowIndex);
      this.sourceRowIndex = sourceRowIndex;
      const orderView = this.obtainOrderView(TR);
      const rowHeadersView = rowHeaders.obtainOrderView(TR);
      orderView.prependView(rowHeadersView).setSize(columnsToRender).setOffset(this.table.renderedColumnToSource(0)).start();
      for (let visibleColumnIndex = 0; visibleColumnIndex < columnsToRender; visibleColumnIndex++) {
        orderView.render();
        const TD = orderView.getCurrentNode();
        const sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
        if (!hasClass(TD, "hide")) {
          TD.className = "";
        }
        TD.removeAttribute("style");
        TD.removeAttribute("dir");
        this.table.cellRenderer(sourceRowIndex, sourceColumnIndex, TD);
      }
      orderView.end();
    }
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/renderer/table.mjs
var TableRenderer = class {
  constructor(rootNode) {
    let {
      cellRenderer
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.rootNode = rootNode;
    this.rootDocument = this.rootNode.ownerDocument;
    this.rowHeaders = null;
    this.columnHeaders = null;
    this.colGroup = null;
    this.rows = null;
    this.cells = null;
    this.rowFilter = null;
    this.columnFilter = null;
    this.rowUtils = null;
    this.columnUtils = null;
    this.rowsToRender = 0;
    this.columnsToRender = 0;
    this.rowHeaderFunctions = [];
    this.rowHeadersCount = 0;
    this.columnHeaderFunctions = [];
    this.columnHeadersCount = 0;
    this.cellRenderer = cellRenderer;
  }
  /**
   * Set row and column util classes.
   *
   * @param {RowUtils} rowUtils RowUtils instance which provides useful methods related to row sizes.
   * @param {ColumnUtils} columnUtils ColumnUtils instance which provides useful methods related to row sizes.
   */
  setAxisUtils(rowUtils, columnUtils) {
    this.rowUtils = rowUtils;
    this.columnUtils = columnUtils;
  }
  /**
   * Sets viewport size of the table.
   *
   * @param {number} rowsCount An amount of rows to render.
   * @param {number} columnsCount An amount of columns to render.
   */
  setViewportSize(rowsCount, columnsCount) {
    this.rowsToRender = rowsCount;
    this.columnsToRender = columnsCount;
  }
  /**
   * Sets row and column filter instances.
   *
   * @param {RowFilter} rowFilter Row filter instance which contains all necessary information about row index transformation.
   * @param {ColumnFilter} columnFilter Column filter instance which contains all necessary information about row
   * index transformation.
   */
  setFilters(rowFilter, columnFilter) {
    this.rowFilter = rowFilter;
    this.columnFilter = columnFilter;
  }
  /**
   * Sets row and column header functions.
   *
   * @param {Function[]} rowHeaders Row header functions. Factories for creating content for row headers.
   * @param {Function[]} columnHeaders Column header functions. Factories for creating content for column headers.
   */
  setHeaderContentRenderers(rowHeaders, columnHeaders) {
    this.rowHeaderFunctions = rowHeaders;
    this.rowHeadersCount = rowHeaders.length;
    this.columnHeaderFunctions = columnHeaders;
    this.columnHeadersCount = columnHeaders.length;
  }
  /**
   * Sets table renderers.
   *
   * @param {renderers} renderers The renderer units.
   * @param {RowHeadersRenderer} renderers.rowHeaders Row headers renderer.
   * @param {ColumnHeadersRenderer} renderers.columnHeaders Column headers renderer.
   * @param {ColGroupRenderer} renderers.colGroup Col group renderer.
   * @param {RowsRenderer} renderers.rows Rows renderer.
   * @param {CellsRenderer} renderers.cells Cells renderer.
   */
  setRenderers() {
    let {
      rowHeaders,
      columnHeaders,
      colGroup,
      rows,
      cells
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    rowHeaders.setTable(this);
    columnHeaders.setTable(this);
    colGroup.setTable(this);
    rows.setTable(this);
    cells.setTable(this);
    this.rowHeaders = rowHeaders;
    this.columnHeaders = columnHeaders;
    this.colGroup = colGroup;
    this.rows = rows;
    this.cells = cells;
  }
  /**
   * Transforms visual/rendered row index to source index.
   *
   * @param {number} rowIndex Rendered index.
   * @returns {number}
   */
  renderedRowToSource(rowIndex) {
    return this.rowFilter.renderedToSource(rowIndex);
  }
  /**
   * Transforms visual/rendered column index to source index.
   *
   * @param {number} columnIndex Rendered index.
   * @returns {number}
   */
  renderedColumnToSource(columnIndex) {
    return this.columnFilter.renderedToSource(columnIndex);
  }
  /**
   * Renders the table.
   */
  render() {
    this.colGroup.adjust();
    this.columnHeaders.adjust();
    this.rows.adjust();
    this.rowHeaders.adjust();
    this.columnHeaders.render();
    this.rows.render();
    this.rowHeaders.render();
    this.cells.render();
    this.columnUtils.calculateWidths();
    this.colGroup.render();
    const {
      rowsToRender,
      rows
    } = this;
    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
      const TR = rows.getRenderedNode(visibleRowIndex);
      if (TR.firstChild) {
        const sourceRowIndex = this.renderedRowToSource(visibleRowIndex);
        const rowHeight = this.rowUtils.getHeight(sourceRowIndex);
        if (rowHeight) {
          TR.firstChild.style.height = `${rowHeight - 1}px`;
        } else {
          TR.firstChild.style.height = "";
        }
      }
    }
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/renderer/index.mjs
var Renderer = class {
  constructor() {
    let {
      TABLE,
      THEAD,
      COLGROUP,
      TBODY,
      rowUtils,
      columnUtils,
      cellRenderer
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.renderer = new TableRenderer(TABLE, {
      cellRenderer
    });
    this.renderer.setRenderers({
      rowHeaders: new RowHeadersRenderer(),
      columnHeaders: new ColumnHeadersRenderer(THEAD),
      colGroup: new ColGroupRenderer(COLGROUP),
      rows: new RowsRenderer(TBODY),
      cells: new CellsRenderer()
    });
    this.renderer.setAxisUtils(rowUtils, columnUtils);
  }
  /**
   * Sets filter calculators for newly calculated row and column position. The filters are used to transform visual
   * indexes (0 to N) to source indexes provided by Handsontable.
   *
   * @param {RowFilter} rowFilter The row filter instance.
   * @param {ColumnFilter} columnFilter The column filter instance.
   * @returns {Renderer}
   */
  setFilters(rowFilter, columnFilter) {
    this.renderer.setFilters(rowFilter, columnFilter);
    return this;
  }
  /**
   * Sets the viewport size of the rendered table.
   *
   * @param {number} rowsCount An amount of rows to render.
   * @param {number} columnsCount An amount of columns to render.
   * @returns {Renderer}
   */
  setViewportSize(rowsCount, columnsCount) {
    this.renderer.setViewportSize(rowsCount, columnsCount);
    return this;
  }
  /**
   * Sets row and column header functions.
   *
   * @param {Function[]} rowHeaders Row header functions. Factories for creating content for row headers.
   * @param {Function[]} columnHeaders Column header functions. Factories for creating content for column headers.
   * @returns {Renderer}
   */
  setHeaderContentRenderers(rowHeaders, columnHeaders) {
    this.renderer.setHeaderContentRenderers(rowHeaders, columnHeaders);
    return this;
  }
  /**
   * Adjusts the table (preparing for render).
   */
  adjust() {
    this.renderer.adjust();
  }
  /**
   * Renders the table.
   */
  render() {
    this.renderer.render();
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/utils/column.mjs
var ColumnUtils = class {
  /**
   * @param {TableDao} dataAccessObject The table Data Access Object.
   * @param {Settings} wtSettings The walkontable settings.
   */
  constructor(dataAccessObject, wtSettings) {
    this.dataAccessObject = dataAccessObject;
    this.wtSettings = wtSettings;
    this.headerWidths = /* @__PURE__ */ new Map();
  }
  /**
   * Returns column width based on passed source index.
   *
   * @param {number} sourceIndex Column source index.
   * @returns {number}
   */
  getWidth(sourceIndex) {
    return this.wtSettings.getSetting("columnWidth", sourceIndex) || this.wtSettings.getSetting("defaultColumnWidth");
  }
  /**
   * Returns stretched column width based on passed source index.
   *
   * @param {number} sourceIndex Column source index.
   * @returns {number}
   */
  getStretchedColumnWidth(sourceIndex) {
    const calculator = this.dataAccessObject.wtViewport.columnsRenderCalculator;
    let width = this.getWidth(sourceIndex);
    if (calculator) {
      const stretchedWidth = calculator.getStretchedColumnWidth(sourceIndex, width);
      if (stretchedWidth) {
        width = stretchedWidth;
      }
    }
    return width;
  }
  /**
   * Returns column header height based on passed header level.
   *
   * @param {number} level Column header level.
   * @returns {number}
   */
  getHeaderHeight(level) {
    let height = this.wtSettings.getSetting("defaultRowHeight");
    const oversizedHeight = this.dataAccessObject.wtViewport.oversizedColumnHeaders[level];
    if (oversizedHeight !== void 0) {
      height = height ? Math.max(height, oversizedHeight) : oversizedHeight;
    }
    return height;
  }
  /**
   * Returns column header width based on passed source index.
   *
   * @param {number} sourceIndex Column source index.
   * @returns {number}
   */
  getHeaderWidth(sourceIndex) {
    return this.headerWidths.get(this.dataAccessObject.wtTable.columnFilter.sourceToRendered(sourceIndex));
  }
  /**
   * Calculates column header widths that can be retrieved from the cache.
   */
  calculateWidths() {
    const {
      wtSettings
    } = this;
    const {
      wtTable,
      wtViewport,
      cloneSource
    } = this.dataAccessObject;
    const mainHolder = cloneSource ? cloneSource.wtTable.holder : wtTable.holder;
    const scrollbarCompensation = mainHolder.offsetHeight < mainHolder.scrollHeight ? getScrollbarWidth() : 0;
    let rowHeaderWidthSetting = wtSettings.getSetting("rowHeaderWidth");
    wtViewport.columnsRenderCalculator.refreshStretching(wtViewport.getViewportWidth() - scrollbarCompensation);
    rowHeaderWidthSetting = wtSettings.getSetting("onModifyRowHeaderWidth", rowHeaderWidthSetting);
    if (rowHeaderWidthSetting !== null && rowHeaderWidthSetting !== void 0) {
      const rowHeadersCount = wtSettings.getSetting("rowHeaders").length;
      const defaultColumnWidth = wtSettings.getSetting("defaultColumnWidth");
      for (let visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
        let width = Array.isArray(rowHeaderWidthSetting) ? rowHeaderWidthSetting[visibleColumnIndex] : rowHeaderWidthSetting;
        width = width === null || width === void 0 ? defaultColumnWidth : width;
        this.headerWidths.set(visibleColumnIndex, width);
      }
    }
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/utils/row.mjs
var RowUtils = class {
  /**
   * @param {TableDao} dataAccessObject The table Data Access Object.
   * @param {Settings} wtSettings The walkontable settings.
   */
  constructor(dataAccessObject, wtSettings) {
    this.dataAccessObject = dataAccessObject;
    this.wtSettings = wtSettings;
  }
  /**
   * Returns row height based on passed source index.
   *
   * @param {number} sourceIndex Row source index.
   * @returns {number}
   */
  getHeight(sourceIndex) {
    let height = this.wtSettings.getSetting("rowHeight", sourceIndex);
    const oversizedHeight = this.dataAccessObject.wtViewport.oversizedRows[sourceIndex];
    if (oversizedHeight !== void 0) {
      height = height === void 0 ? oversizedHeight : Math.max(height, oversizedHeight);
    }
    return height;
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/table.mjs
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive3(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Table = class {
  /**
   *
   * @abstract
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {'master'|CLONE_TYPES_ENUM} name Overlay name.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings, name) {
    _defineProperty3(this, "wtSettings", null);
    _defineProperty3(this, "domBindings", void 0);
    _defineProperty3(this, "TBODY", null);
    _defineProperty3(this, "THEAD", null);
    _defineProperty3(this, "COLGROUP", null);
    _defineProperty3(this, "hasTableHeight", true);
    _defineProperty3(this, "hasTableWidth", true);
    _defineProperty3(this, "isTableVisible", false);
    _defineProperty3(this, "tableOffset", 0);
    _defineProperty3(this, "holderOffset", 0);
    this.domBindings = domBindings;
    this.isMaster = name === "master";
    this.name = name;
    this.dataAccessObject = dataAccessObject;
    this.facadeGetter = facadeGetter;
    this.wtSettings = wtSettings;
    this.instance = this.dataAccessObject.wot;
    this.wot = this.dataAccessObject.wot;
    this.TABLE = domBindings.rootTable;
    removeTextNodes(this.TABLE);
    this.spreader = this.createSpreader(this.TABLE);
    this.hider = this.createHider(this.spreader);
    this.holder = this.createHolder(this.hider);
    this.wtRootElement = this.holder.parentNode;
    if (this.isMaster) {
      this.alignOverlaysWithTrimmingContainer();
    }
    this.fixTableDomTree();
    this.rowFilter = null;
    this.columnFilter = null;
    this.correctHeaderWidth = false;
    const origRowHeaderWidth = this.wtSettings.getSettingPure("rowHeaderWidth");
    this.wtSettings.update("rowHeaderWidth", () => this._modifyRowHeaderWidth(origRowHeaderWidth));
    this.rowUtils = new RowUtils(this.dataAccessObject, this.wtSettings);
    this.columnUtils = new ColumnUtils(this.dataAccessObject, this.wtSettings);
    this.tableRenderer = new Renderer({
      // TODO refactoring, It can be passed through IOC.
      TABLE: this.TABLE,
      THEAD: this.THEAD,
      COLGROUP: this.COLGROUP,
      TBODY: this.TBODY,
      rowUtils: this.rowUtils,
      columnUtils: this.columnUtils,
      cellRenderer: this.wtSettings.getSettingPure("cellRenderer")
    });
  }
  /**
   * Returns a boolean that is true if this Table represents a specific overlay, identified by the overlay name.
   * For MasterTable, it returns false.
   *
   * @param {string} overlayTypeName The overlay type.
   * @returns {boolean}
   */
  is(overlayTypeName) {
    return this.name === overlayTypeName;
  }
  /**
   *
   */
  fixTableDomTree() {
    const rootDocument = this.domBindings.rootDocument;
    this.TBODY = this.TABLE.querySelector("tbody");
    if (!this.TBODY) {
      this.TBODY = rootDocument.createElement("tbody");
      this.TABLE.appendChild(this.TBODY);
    }
    this.THEAD = this.TABLE.querySelector("thead");
    if (!this.THEAD) {
      this.THEAD = rootDocument.createElement("thead");
      this.TABLE.insertBefore(this.THEAD, this.TBODY);
    }
    this.COLGROUP = this.TABLE.querySelector("colgroup");
    if (!this.COLGROUP) {
      this.COLGROUP = rootDocument.createElement("colgroup");
      this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
    }
  }
  /**
   * @param {HTMLTableElement} table An element to process.
   * @returns {HTMLElement}
   */
  createSpreader(table) {
    const parent = table.parentNode;
    let spreader;
    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, "wtHolder")) {
      spreader = this.domBindings.rootDocument.createElement("div");
      spreader.className = "wtSpreader";
      if (parent) {
        parent.insertBefore(spreader, table);
      }
      spreader.appendChild(table);
    }
    spreader.style.position = "relative";
    return spreader;
  }
  /**
   * @param {HTMLElement} spreader An element to the hider element is injected.
   * @returns {HTMLElement}
   */
  createHider(spreader) {
    const parent = spreader.parentNode;
    let hider;
    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, "wtHolder")) {
      hider = this.domBindings.rootDocument.createElement("div");
      hider.className = "wtHider";
      if (parent) {
        parent.insertBefore(hider, spreader);
      }
      hider.appendChild(spreader);
    }
    return hider;
  }
  /**
   *
   * @param {HTMLElement} hider An element to the holder element is injected.
   * @returns {HTMLElement}
   */
  createHolder(hider) {
    const parent = hider.parentNode;
    let holder2;
    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, "wtHolder")) {
      holder2 = this.domBindings.rootDocument.createElement("div");
      holder2.style.position = "relative";
      holder2.className = "wtHolder";
      if (parent) {
        parent.insertBefore(holder2, hider);
      }
      if (this.isMaster) {
        holder2.parentNode.className += "ht_master handsontable";
        holder2.parentNode.setAttribute("dir", this.wtSettings.getSettingPure("rtlMode") ? "rtl" : "ltr");
      }
      holder2.appendChild(hider);
    }
    return holder2;
  }
  /**
   * Redraws the table.
   *
   * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.
   *                                   If FALSE or UNDEFINED, will perform a full redraw.
   * @returns {Table}
   */
  draw() {
    let fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const {
      wtSettings
    } = this;
    const {
      wtOverlays,
      wtViewport
    } = this.dataAccessObject;
    const totalRows = wtSettings.getSetting("totalRows");
    const totalColumns = wtSettings.getSetting("totalColumns");
    const rowHeaders = wtSettings.getSetting("rowHeaders");
    const rowHeadersCount = rowHeaders.length;
    const columnHeaders = wtSettings.getSetting("columnHeaders");
    const columnHeadersCount = columnHeaders.length;
    let syncScroll = false;
    let runFastDraw = fastDraw;
    if (this.isMaster) {
      this.holderOffset = offset2(this.holder);
      runFastDraw = wtViewport.createRenderCalculators(runFastDraw);
      if (rowHeadersCount && !wtSettings.getSetting("fixedColumnsStart")) {
        const leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();
        const previousState = this.correctHeaderWidth;
        this.correctHeaderWidth = leftScrollPos !== 0;
        if (previousState !== this.correctHeaderWidth) {
          runFastDraw = false;
        }
      }
    }
    if (this.isMaster) {
      syncScroll = wtOverlays.updateStateOfRendering();
    }
    if (runFastDraw) {
      if (this.isMaster) {
        wtViewport.createVisibleCalculators();
      }
      if (wtOverlays) {
        wtOverlays.refresh(true);
      }
    } else {
      if (this.isMaster) {
        this.tableOffset = offset2(this.TABLE);
      } else {
        this.tableOffset = this.dataAccessObject.parentTableOffset;
      }
      const startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;
      const startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;
      this.rowFilter = new row_default(startRow, totalRows, columnHeadersCount);
      this.columnFilter = new column_default(startColumn, totalColumns, rowHeadersCount);
      let performRedraw = true;
      if (this.isMaster) {
        this.alignOverlaysWithTrimmingContainer();
        const skipRender = {};
        this.wtSettings.getSetting("beforeDraw", true, skipRender);
        performRedraw = skipRender.skipRender !== true;
      }
      if (performRedraw) {
        this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);
        if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_INLINE_START_CORNER)) {
          this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);
        }
        this.resetOversizedRows();
        this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();
        let workspaceWidth;
        if (this.isMaster) {
          workspaceWidth = this.dataAccessObject.workspaceWidth;
          this.dataAccessObject.wtViewport.containerWidth = null;
          this.markOversizedColumnHeaders();
        }
        this.adjustColumnHeaderHeights();
        if (this.isMaster || this.is(CLONE_BOTTOM)) {
          this.markOversizedRows();
        }
        if (this.isMaster) {
          this.dataAccessObject.wtViewport.createVisibleCalculators();
          this.dataAccessObject.wtOverlays.refresh(false);
          this.dataAccessObject.wtOverlays.applyToDOM();
          const hiderWidth = outerWidth(this.hider);
          const tableWidth = outerWidth(this.TABLE);
          if (hiderWidth !== 0 && tableWidth !== hiderWidth) {
            this.columnUtils.calculateWidths();
            this.tableRenderer.renderer.colGroup.render();
          }
          if (workspaceWidth !== this.dataAccessObject.wtViewport.getWorkspaceWidth()) {
            this.dataAccessObject.wtViewport.containerWidth = null;
            this.columnUtils.calculateWidths();
            this.tableRenderer.renderer.colGroup.render();
          }
          this.wtSettings.getSetting("onDraw", true);
        } else if (this.is(CLONE_BOTTOM)) {
          this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();
        }
      }
    }
    let positionChanged = false;
    if (this.isMaster) {
      positionChanged = wtOverlays.topOverlay.resetFixedPosition();
      if (wtOverlays.bottomOverlay.clone) {
        positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;
      }
      positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || positionChanged;
      if (wtOverlays.topInlineStartCornerOverlay) {
        wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();
      }
      if (wtOverlays.bottomInlineStartCornerOverlay && wtOverlays.bottomInlineStartCornerOverlay.clone) {
        wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();
      }
    }
    if (positionChanged) {
      wtOverlays.refreshAll();
      wtOverlays.adjustElementsSize();
    } else {
      this.refreshSelections(runFastDraw);
    }
    if (syncScroll) {
      wtOverlays.syncScrollWithMaster();
    }
    this.dataAccessObject.drawn = true;
    return this;
  }
  /**
   * @param {number} col The visual column index.
   */
  markIfOversizedColumnHeader(col) {
    const sourceColIndex = this.columnFilter.renderedToSource(col);
    let level = this.wtSettings.getSetting("columnHeaders").length;
    const defaultRowHeight = this.wtSettings.getSetting("defaultRowHeight");
    let previousColHeaderHeight;
    let currentHeader;
    let currentHeaderHeight;
    const columnHeaderHeightSetting = this.wtSettings.getSetting("columnHeaderHeight") || [];
    while (level) {
      level -= 1;
      previousColHeaderHeight = this.getColumnHeaderHeight(level);
      currentHeader = this.getColumnHeader(sourceColIndex, level);
      if (!currentHeader) {
        continue;
      }
      currentHeaderHeight = innerHeight(currentHeader);
      if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {
        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;
      }
      if (Array.isArray(columnHeaderHeightSetting)) {
        if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {
          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];
        }
      } else if (!isNaN(columnHeaderHeightSetting)) {
        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;
      }
      if (this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {
        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;
      }
    }
  }
  /**
   *
   */
  adjustColumnHeaderHeights() {
    const {
      wtSettings
    } = this;
    const children = this.THEAD.childNodes;
    const oversizedColumnHeaders = this.dataAccessObject.wtViewport.oversizedColumnHeaders;
    const columnHeaders = wtSettings.getSetting("columnHeaders");
    for (let i = 0, len = columnHeaders.length; i < len; i++) {
      if (oversizedColumnHeaders[i]) {
        if (!children[i] || children[i].childNodes.length === 0) {
          return;
        }
        children[i].childNodes[0].style.height = `${oversizedColumnHeaders[i]}px`;
      }
    }
  }
  /**
   * Resets cache of row heights. The cache should be cached for each render cycle in a case
   * when new cell values have content which increases/decreases cell height.
   */
  resetOversizedRows() {
    const {
      wtSettings
    } = this;
    const {
      wtViewport
    } = this.dataAccessObject;
    if (!this.isMaster && !this.is(CLONE_BOTTOM)) {
      return;
    }
    if (!wtSettings.getSetting("externalRowCalculator")) {
      const rowsToRender = this.getRenderedRowsCount();
      for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        const sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);
        if (wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {
          wtViewport.oversizedRows[sourceRow] = void 0;
        }
      }
    }
  }
  /**
   * @param {string} className The CSS class name to remove from the table cells.
   */
  removeClassFromCells(className) {
    const nodes = this.TABLE.querySelectorAll(`.${className}`);
    for (let i = 0, len = nodes.length; i < len; i++) {
      removeClass(nodes[i], className);
    }
  }
  /**
   * Refresh the table selection by re-rendering Selection instances connected with that instance.
   *
   * @param {boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.
   */
  refreshSelections(fastDraw) {
    const {
      wtSettings
    } = this;
    const {
      selections
    } = this.dataAccessObject;
    if (!selections) {
      return;
    }
    const highlights = Array.from(selections);
    const len = highlights.length;
    if (fastDraw) {
      const classesToRemove = [];
      for (let i = 0; i < len; i++) {
        const {
          highlightHeaderClassName,
          highlightRowClassName,
          highlightColumnClassName
        } = highlights[i].settings;
        const classNames = highlights[i].classNames;
        const classNamesLength = classNames.length;
        for (let j = 0; j < classNamesLength; j++) {
          if (!classesToRemove.includes(classNames[j])) {
            classesToRemove.push(classNames[j]);
          }
        }
        if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {
          classesToRemove.push(highlightHeaderClassName);
        }
        if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {
          classesToRemove.push(highlightRowClassName);
        }
        if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {
          classesToRemove.push(highlightColumnClassName);
        }
      }
      const additionalClassesToRemove = wtSettings.getSetting("onBeforeRemoveCellClassNames");
      if (Array.isArray(additionalClassesToRemove)) {
        for (let i = 0; i < additionalClassesToRemove.length; i++) {
          classesToRemove.push(additionalClassesToRemove[i]);
        }
      }
      const classesToRemoveLength = classesToRemove.length;
      for (let i = 0; i < classesToRemoveLength; i++) {
        this.removeClassFromCells(classesToRemove[i]);
      }
    }
    for (let i = 0; i < len; i++) {
      highlights[i].draw(this.facadeGetter(), fastDraw);
    }
  }
  /**
   * Get cell element at coords.
   * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the
   * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column
   * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the
   * outmost header element.
   *
   * In case an element for the coords is not rendered, the method returns an error code.
   * To produce the error code, the input parameters are validated in the order in which they
   * are given. Thus, if both the row and the column coords are out of the rendered bounds,
   * the method returns the error code for the row.
   *
   * @param {CellCoords} coords The cell coordinates.
   * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:
   *  -1 row before viewport
   *  -2 row after viewport
   *  -3 column before viewport
   *  -4 column after viewport.
   */
  getCell(coords) {
    let row = coords.row;
    let column = coords.col;
    const hookResult = this.wtSettings.getSetting("onModifyGetCellCoords", row, column);
    if (hookResult && Array.isArray(hookResult)) {
      [row, column] = hookResult;
    }
    if (this.isRowBeforeRenderedRows(row)) {
      return -1;
    } else if (this.isRowAfterRenderedRows(row)) {
      return -2;
    } else if (this.isColumnBeforeRenderedColumns(column)) {
      return -3;
    } else if (this.isColumnAfterRenderedColumns(column)) {
      return -4;
    }
    const TR = this.getRow(row);
    if (!TR && row >= 0) {
      throw new Error("TR was expected to be rendered but is not");
    }
    const TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];
    if (!TD && column >= 0) {
      throw new Error("TD or TH was expected to be rendered but is not");
    }
    return TD;
  }
  /**
   * Get the DOM element of the row with the provided index.
   *
   * @param {number} rowIndex Row index.
   * @returns {HTMLTableRowElement|boolean} Return the row's DOM element or `false` if the row with the provided
   * index doesn't exist.
   */
  getRow(rowIndex) {
    let renderedRowIndex = null;
    let parentElement = null;
    if (rowIndex < 0) {
      var _this$rowFilter;
      renderedRowIndex = (_this$rowFilter = this.rowFilter) === null || _this$rowFilter === void 0 ? void 0 : _this$rowFilter.sourceRowToVisibleColHeadedRow(rowIndex);
      parentElement = this.THEAD;
    } else {
      var _this$rowFilter2;
      renderedRowIndex = (_this$rowFilter2 = this.rowFilter) === null || _this$rowFilter2 === void 0 ? void 0 : _this$rowFilter2.sourceToRendered(rowIndex);
      parentElement = this.TBODY;
    }
    if (renderedRowIndex !== void 0 && parentElement !== void 0) {
      if (parentElement.childNodes.length < renderedRowIndex + 1) {
        return false;
      } else {
        return parentElement.childNodes[renderedRowIndex];
      }
    } else {
      return false;
    }
  }
  /**
   * GetColumnHeader.
   *
   * @param {number} col Column index.
   * @param {number} [level=0] Header level (0 = most distant to the table).
   * @returns {object} HTMLElement on success or undefined on error.
   */
  getColumnHeader(col) {
    let level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const TR = this.THEAD.childNodes[level];
    return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
  }
  /**
   * Gets all columns headers (TH elements) from the table.
   *
   * @param {number} column A source column index.
   * @returns {HTMLTableCellElement[]}
   */
  getColumnHeaders(column) {
    const THs = [];
    const visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);
    this.THEAD.childNodes.forEach((TR) => {
      const TH = TR.childNodes[visibleColumn];
      if (TH) {
        THs.push(TH);
      }
    });
    return THs;
  }
  /**
   * GetRowHeader.
   *
   * @param {number} row Row index.
   * @param {number} [level=0] Header level (0 = most distant to the table).
   * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have
   *   row headers`.
   */
  getRowHeader(row) {
    let level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
      return;
    }
    const rowHeadersCount = this.wtSettings.getSetting("rowHeaders").length;
    if (level >= rowHeadersCount) {
      return;
    }
    const TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
    return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];
  }
  /**
   * Gets all rows headers (TH elements) from the table.
   *
   * @param {number} row A source row index.
   * @returns {HTMLTableCellElement[]}
   */
  getRowHeaders(row) {
    if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
      return [];
    }
    const THs = [];
    const rowHeadersCount = this.wtSettings.getSetting("rowHeaders").length;
    for (let renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {
      const TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
      const TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];
      if (TH) {
        THs.push(TH);
      }
    }
    return THs;
  }
  /**
   * Returns cell coords object for a given TD (or a child element of a TD element).
   *
   * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).
   * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the
   *   provided element is not applicable.
   */
  getCoords(TD) {
    let cellElement = TD;
    if (cellElement.nodeName !== "TD" && cellElement.nodeName !== "TH") {
      cellElement = closest(cellElement, ["TD", "TH"]);
    }
    if (cellElement === null) {
      return null;
    }
    const TR = cellElement.parentNode;
    const CONTAINER = TR.parentNode;
    let row = index(TR);
    let col = cellElement.cellIndex;
    if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {
      if (CONTAINER.nodeName === "THEAD") {
        row -= CONTAINER.childNodes.length;
      }
    } else if (overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {
      const totalRows = this.wtSettings.getSetting("totalRows");
      row = totalRows - CONTAINER.childNodes.length + row;
    } else if (CONTAINER === this.THEAD) {
      row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
    } else {
      row = this.rowFilter.renderedToSource(row);
    }
    if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_INLINE_START, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement)) {
      col = this.columnFilter.offsettedTH(col);
    } else {
      col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);
    }
    return this.wot.createCellCoords(row, col);
  }
  /**
   * Check if any of the rendered rows is higher than expected, and if so, cache them.
   */
  markOversizedRows() {
    if (this.wtSettings.getSetting("externalRowCalculator")) {
      return;
    }
    let rowCount = this.TBODY.childNodes.length;
    const expectedTableHeight = rowCount * this.wtSettings.getSetting("defaultRowHeight");
    const actualTableHeight = innerHeight(this.TBODY) - 1;
    let previousRowHeight;
    let rowInnerHeight;
    let sourceRowIndex;
    let currentTr;
    let rowHeader;
    if (expectedTableHeight === actualTableHeight && !this.wtSettings.getSetting("fixedRowsBottom")) {
      return;
    }
    while (rowCount) {
      rowCount -= 1;
      sourceRowIndex = this.rowFilter.renderedToSource(rowCount);
      previousRowHeight = this.getRowHeight(sourceRowIndex);
      currentTr = this.getTrForRow(sourceRowIndex);
      rowHeader = currentTr.querySelector("th");
      if (rowHeader) {
        rowInnerHeight = innerHeight(rowHeader);
      } else {
        rowInnerHeight = innerHeight(currentTr) - 1;
      }
      if (!previousRowHeight && this.wtSettings.getSetting("defaultRowHeight") < rowInnerHeight || previousRowHeight < rowInnerHeight) {
        rowInnerHeight += 1;
        this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;
      }
    }
  }
  /**
   * @param {number} row The visual row index.
   * @returns {HTMLTableElement}
   */
  getTrForRow(row) {
    return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
  }
  /**
   * Checks if the column index (negative value from -1 to N) is rendered.
   *
   * @param {number} column The column index (negative value from -1 to N).
   * @returns {boolean}
   */
  isColumnHeaderRendered(column) {
    if (column >= 0) {
      return false;
    }
    const rowHeaders = this.wtSettings.getSetting("rowHeaders");
    const rowHeadersCount = rowHeaders.length;
    return Math.abs(column) <= rowHeadersCount;
  }
  /**
   * Checks if the row index (negative value from -1 to N) is rendered.
   *
   * @param {number} row The row index (negative value from -1 to N).
   * @returns {boolean}
   */
  isRowHeaderRendered(row) {
    if (row >= 0) {
      return false;
    }
    const columnHeaders = this.wtSettings.getSetting("columnHeaders");
    const columnHeadersCount = columnHeaders.length;
    return Math.abs(row) <= columnHeadersCount;
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Check if the given row index is lower than the index of the first row that
   * is currently rendered and return TRUE in that case, or FALSE otherwise.
   *
   * Negative row index is used to check the columns' headers.
   *
   *  Headers
   *           +--------------+                                     │
   *       -3  │    │    │    │                                     │
   *           +--------------+                                     │
   *       -2  │    │    │    │                                     │ TRUE
   *           +--------------+                                     │
   *       -1  │    │    │    │                                     │
   *  Cells  +==================+                                   │
   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │
   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)
   *        1  │ A2 │ B2 │ C2 │      not render the first row.      │
   *           +--------------+                                     │ FALSE
   *        2  │ A3 │ B3 │ C3 │                                     │
   *           +--------------+                                  ---+ last rendered row
   *                                                                │
   *                                                                │ FALSE
   *
   * @param {number} row The visual row index.
   * @memberof Table#
   * @function isRowBeforeRenderedRows
   * @returns {boolean}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  isRowBeforeRenderedRows(row) {
    const first = this.getFirstRenderedRow();
    if (row < 0 && first <= 0) {
      return !this.isRowHeaderRendered(row);
    }
    return row < first;
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Check if the given column index is greater than the index of the last column that
   * is currently rendered and return TRUE in that case, or FALSE otherwise.
   *
   * The negative row index is used to check the columns' headers. However,
   * keep in mind that for negative indexes, the method always returns FALSE as
   * it is not possible to render headers partially. The "after" index can not be
   * lower than -1.
   *
   *  Headers
   *           +--------------+                                     │
   *       -3  │    │    │    │                                     │
   *           +--------------+                                     │
   *       -2  │    │    │    │                                     │ FALSE
   *           +--------------+                                     │
   *       -1  │    │    │    │                                     │
   *  Cells  +==================+                                   │
   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │
   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)
   *        1  │ A2 │ B2 │ C2 │      not render the first rows      │
   *           +--------------+                                     │ FALSE
   *        2  │ A3 │ B3 │ C3 │                                     │
   *           +--------------+                                  ---+ last rendered row
   *                                                                │
   *                                                                │ TRUE
   *
   * @param {number} row The visual row index.
   * @memberof Table#
   * @function isRowAfterRenderedRows
   * @returns {boolean}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  isRowAfterRenderedRows(row) {
    return row > this.getLastRenderedRow();
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Check if the given column index is lower than the index of the first column that
   * is currently rendered and return TRUE in that case, or FALSE otherwise.
   *
   * Negative column index is used to check the rows' headers.
   *
   *                            For fixedColumnsStart: 1 the master overlay
   *                            do not render this first columns.
   *  Headers    -3   -2   -1    |
   *           +----+----+----║┄ ┄ +------+------+
   *           │    │    │    ║    │  B1  │  C1  │
   *           +--------------║┄ ┄ --------------│
   *           │    │    │    ║    │  B2  │  C2  │
   *           +--------------║┄ ┄ --------------│
   *           │    │    │    ║    │  B3  │  C3  │
   *           +----+----+----║┄ ┄ +------+------+
   *                               ╷             ╷
   *      -------------------------+-------------+---------------->
   *          TRUE             first    FALSE   last         FALSE
   *                           rendered         rendered
   *                           column           column
   *
   * @param {number} column The visual column index.
   * @memberof Table#
   * @function isColumnBeforeRenderedColumns
   * @returns {boolean}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  isColumnBeforeRenderedColumns(column) {
    const first = this.getFirstRenderedColumn();
    if (column < 0 && first <= 0) {
      return !this.isColumnHeaderRendered(column);
    }
    return column < first;
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Check if the given column index is greater than the index of the last column that
   * is currently rendered and return TRUE in that case, or FALSE otherwise.
   *
   * The negative column index is used to check the rows' headers. However,
   * keep in mind that for negative indexes, the method always returns FALSE as
   * it is not possible to render headers partially. The "after" index can not be
   * lower than -1.
   *
   *                            For fixedColumnsStart: 1 the master overlay
   *                            do not render this first columns.
   *  Headers    -3   -2   -1    |
   *           +----+----+----║┄ ┄ +------+------+
   *           │    │    │    ║    │  B1  │  C1  │
   *           +--------------║┄ ┄ --------------│
   *           │    │    │    ║    │  B2  │  C2  │
   *           +--------------║┄ ┄ --------------│
   *           │    │    │    ║    │  B3  │  C3  │
   *           +----+----+----║┄ ┄ +------+------+
   *                               ╷             ╷
   *      -------------------------+-------------+---------------->
   *          FALSE             first    FALSE   last         TRUE
   *                           rendered         rendered
   *                           column           column
   *
   * @param {number} column The visual column index.
   * @memberof Table#
   * @function isColumnAfterRenderedColumns
   * @returns {boolean}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  isColumnAfterRenderedColumns(column) {
    return this.columnFilter && column > this.getLastRenderedColumn();
  }
  isColumnAfterViewport(column) {
    return this.columnFilter && column > this.getLastVisibleColumn();
  }
  isRowAfterViewport(row) {
    return this.rowFilter && row > this.getLastVisibleRow();
  }
  isColumnBeforeViewport(column) {
    return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;
  }
  isLastRowFullyVisible() {
    return this.getLastVisibleRow() === this.getLastRenderedRow();
  }
  isLastColumnFullyVisible() {
    return this.getLastVisibleColumn() === this.getLastRenderedColumn();
  }
  allRowsInViewport() {
    return this.wtSettings.getSetting("totalRows") === this.getVisibleRowsCount();
  }
  allColumnsInViewport() {
    return this.wtSettings.getSetting("totalColumns") === this.getVisibleColumnsCount();
  }
  /**
   * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.
   *
   * @param {number} sourceRow The physical row index.
   * @returns {number}
   */
  getRowHeight(sourceRow) {
    return this.rowUtils.getHeight(sourceRow);
  }
  /**
   * @param {number} level The column level.
   * @returns {number}
   */
  getColumnHeaderHeight(level) {
    return this.columnUtils.getHeaderHeight(level);
  }
  /**
   * @param {number} sourceColumn The physical column index.
   * @returns {number}
   */
  getColumnWidth(sourceColumn) {
    return this.columnUtils.getWidth(sourceColumn);
  }
  /**
   * @param {number} sourceColumn The physical column index.
   * @returns {number}
   */
  getStretchedColumnWidth(sourceColumn) {
    return this.columnUtils.getStretchedColumnWidth(sourceColumn);
  }
  /**
   * Checks if the table has defined size. It returns `true` when the table has width and height
   * set bigger than `0px`.
   *
   * @returns {boolean}
   */
  hasDefinedSize() {
    return this.hasTableHeight && this.hasTableWidth;
  }
  /**
   * Gets table's width. The returned width is the width of the rendered cells that fit in the
   * current viewport. The value may change depends on the viewport position (scroll position).
   *
   * @returns {number}
   */
  getWidth() {
    return outerWidth(this.TABLE);
  }
  /**
   * Gets table's height. The returned height is the height of the rendered cells that fit in the
   * current viewport. The value may change depends on the viewport position (scroll position).
   *
   * @returns {number}
   */
  getHeight() {
    return outerHeight(this.TABLE);
  }
  /**
   * Gets table's total width. The returned width is the width of all rendered cells (including headers)
   * that can be displayed in the table.
   *
   * @returns {number}
   */
  getTotalWidth() {
    const width = outerWidth(this.hider);
    return width !== 0 ? width : this.getWidth();
  }
  /**
   * Gets table's total height. The returned height is the height of all rendered cells (including headers)
   * that can be displayed in the table.
   *
   * @returns {number}
   */
  getTotalHeight() {
    const height = outerHeight(this.hider);
    return height !== 0 ? height : this.getHeight();
  }
  /**
   * Checks if the table is visible. It returns `true` when the holder element (or its parents)
   * has CSS 'display' property different than 'none'.
   *
   * @returns {boolean}
   */
  isVisible() {
    return isVisible(this.TABLE);
  }
  /**
   * Modify row header widths provided by user in class contructor.
   *
   * @private
   * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..
   * @returns {number}
   */
  _modifyRowHeaderWidth(rowHeaderWidthFactory) {
    let widths = isFunction2(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;
    if (Array.isArray(widths)) {
      widths = [...widths];
      widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);
    } else {
      widths = this._correctRowHeaderWidth(widths);
    }
    return widths;
  }
  /**
   * Correct row header width if necessary.
   *
   * @private
   * @param {number} width The width to process.
   * @returns {number}
   */
  _correctRowHeaderWidth(width) {
    let rowHeaderWidth = width;
    if (typeof width !== "number") {
      rowHeaderWidth = this.wtSettings.getSetting("defaultColumnWidth");
    }
    if (this.correctHeaderWidth) {
      rowHeaderWidth += 1;
    }
    return rowHeaderWidth;
  }
};
var table_default = Table;

// node_modules/handsontable/3rdparty/walkontable/src/table/mixin/stickyRowsBottom.mjs
var MIXIN_NAME = "stickyRowsBottom";
var stickyRowsBottom = {
  /**
   * Get the source index of the first rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedRow() {
    const totalRows = this.wtSettings.getSetting("totalRows");
    const fixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
    const index2 = totalRows - fixedRowsBottom;
    if (totalRows === 0 || fixedRowsBottom === 0) {
      return -1;
    }
    if (index2 < 0) {
      return 0;
    }
    return index2;
  },
  /**
   * Get the source index of the first row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleRow() {
    return this.getFirstRenderedRow();
  },
  /**
   * Get the source index of the last rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedRow() {
    return this.wtSettings.getSetting("totalRows") - 1;
  },
  /**
   * Get the source index of the last row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleRow() {
    return this.getLastRenderedRow();
  },
  /**
   * Get the number of rendered rows.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedRowsCount() {
    const totalRows = this.wtSettings.getSetting("totalRows");
    return Math.min(this.wtSettings.getSetting("fixedRowsBottom"), totalRows);
  },
  /**
   * Get the number of fully visible rows in the viewport.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleRowsCount() {
    return this.getRenderedRowsCount();
  }
};
defineGetter(stickyRowsBottom, "MIXIN_NAME", MIXIN_NAME, {
  writable: false,
  enumerable: false
});
var stickyRowsBottom_default = stickyRowsBottom;

// node_modules/handsontable/3rdparty/walkontable/src/table/mixin/stickyColumnsStart.mjs
var MIXIN_NAME2 = "stickyColumnsStart";
var stickyColumnsStart = {
  /**
   * Get the source index of the first rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedColumn() {
    const totalColumns = this.wtSettings.getSetting("totalColumns");
    if (totalColumns === 0) {
      return -1;
    }
    return 0;
  },
  /**
   * Get the source index of the first column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleColumn() {
    return this.getFirstRenderedColumn();
  },
  /**
   * Get the source index of the last rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedColumn() {
    return this.getRenderedColumnsCount() - 1;
  },
  /**
   * Get the source index of the last column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleColumn() {
    return this.getLastRenderedColumn();
  },
  /**
   * Get the number of rendered columns.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedColumnsCount() {
    const totalColumns = this.wtSettings.getSetting("totalColumns");
    return Math.min(this.wtSettings.getSetting("fixedColumnsStart"), totalColumns);
  },
  /**
   * Get the number of fully visible columns in the viewport.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleColumnsCount() {
    return this.getRenderedColumnsCount();
  }
};
defineGetter(stickyColumnsStart, "MIXIN_NAME", MIXIN_NAME2, {
  writable: false,
  enumerable: false
});
var stickyColumnsStart_default = stickyColumnsStart;

// node_modules/handsontable/3rdparty/walkontable/src/table/bottomInlineStartCorner.mjs
var BottomInlineStartCornerOverlayTable = class extends table_default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_BOTTOM_INLINE_START_CORNER);
  }
};
mixin(BottomInlineStartCornerOverlayTable, stickyRowsBottom_default);
mixin(BottomInlineStartCornerOverlayTable, stickyColumnsStart_default);
var bottomInlineStartCorner_default = BottomInlineStartCornerOverlayTable;

// node_modules/handsontable/3rdparty/walkontable/src/overlay/constants.mjs
var CLONE_TOP = "top";
var CLONE_BOTTOM = "bottom";
var CLONE_INLINE_START = "inline_start";
var CLONE_TOP_INLINE_START_CORNER = "top_inline_start_corner";
var CLONE_BOTTOM_INLINE_START_CORNER = "bottom_inline_start_corner";
var CLONE_TYPES = [CLONE_TOP, CLONE_BOTTOM, CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, CLONE_BOTTOM_INLINE_START_CORNER];
var CLONE_CLASS_NAMES = /* @__PURE__ */ new Map([[CLONE_TOP, `ht_clone_${CLONE_TOP}`], [CLONE_BOTTOM, `ht_clone_${CLONE_BOTTOM}`], [CLONE_INLINE_START, `ht_clone_${CLONE_INLINE_START} ht_clone_left`], [CLONE_TOP_INLINE_START_CORNER, `ht_clone_${CLONE_TOP_INLINE_START_CORNER} ht_clone_top_left_corner`], [CLONE_BOTTOM_INLINE_START_CORNER, `ht_clone_${CLONE_BOTTOM_INLINE_START_CORNER} ht_clone_bottom_left_corner`]]);

// node_modules/handsontable/3rdparty/walkontable/src/scroll.mjs
function _defineProperty4(obj, key, value) {
  key = _toPropertyKey4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey4(arg) {
  var key = _toPrimitive4(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive4(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Scroll = class {
  /**
   * @param {ScrollDao} dataAccessObject Tha data access object.
   */
  constructor(dataAccessObject) {
    _defineProperty4(this, "dataAccessObject", void 0);
    _defineProperty4(this, "lastScrolledColumnPos", -1);
    _defineProperty4(this, "lastScrolledRowPos", -1);
    this.dataAccessObject = dataAccessObject;
  }
  /**
   * Scrolls viewport to a cell.
   *
   * @param {CellCoords} coords The cell coordinates.
   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.
   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.
   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.
   * @returns {boolean}
   */
  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
    const scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);
    const scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);
    return scrolledHorizontally || scrolledVertically;
  }
  /**
   * Scrolls viewport to a column.
   *
   * @param {number} column Visual column index.
   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.
   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.
   * @returns {boolean}
   */
  scrollViewportHorizontally(column, snapToRight, snapToLeft) {
    const {
      drawn,
      totalColumns
    } = this.dataAccessObject;
    if (!drawn || !Number.isInteger(column) || column < 0 || column > totalColumns) {
      return false;
    }
    const firstVisibleColumn = this.getFirstVisibleColumn();
    const lastVisibleColumn = this.getLastVisibleColumn();
    const autoSnapping = snapToRight === void 0 && snapToLeft === void 0;
    const {
      fixedColumnsStart,
      inlineStartOverlay
    } = this.dataAccessObject;
    if (autoSnapping && column < fixedColumnsStart) {
      return false;
    }
    let result = false;
    if (firstVisibleColumn === -1) {
      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > this.lastScrolledColumnPos : snapToRight);
    } else if (autoSnapping && (column < firstVisibleColumn || column > lastVisibleColumn) || !autoSnapping) {
      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > lastVisibleColumn : snapToRight);
    }
    if (result) {
      this.lastScrolledColumnPos = column;
    }
    return result;
  }
  /**
   * Scrolls viewport to a row.
   *
   * @param {number} row Visual row index.
   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.
   * @returns {boolean}
   */
  scrollViewportVertically(row, snapToTop, snapToBottom) {
    const {
      drawn,
      totalRows
    } = this.dataAccessObject;
    if (!drawn || !Number.isInteger(row) || row < 0 || row > totalRows) {
      return false;
    }
    const firstVisibleRow = this.getFirstVisibleRow();
    const lastVisibleRow = this.getLastVisibleRow();
    const autoSnapping = snapToTop === void 0 && snapToBottom === void 0;
    const {
      fixedRowsBottom,
      fixedRowsTop,
      topOverlay
    } = this.dataAccessObject;
    if (autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - 1)) {
      return false;
    }
    let result = false;
    if (firstVisibleRow === -1) {
      result = topOverlay.scrollTo(row, autoSnapping ? row > this.lastScrolledRowPos : snapToBottom);
    } else if (autoSnapping && (row < firstVisibleRow || row > lastVisibleRow) || !autoSnapping) {
      result = topOverlay.scrollTo(row, autoSnapping ? row > lastVisibleRow : snapToBottom);
    }
    if (result) {
      this.lastScrolledRowPos = row;
    }
    return result;
  }
  /**
   * Get first visible row based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getFirstVisibleRow() {
    const {
      topOverlay,
      wtTable,
      wtViewport,
      totalRows,
      fixedRowsTop,
      rootWindow
    } = this.dataAccessObject;
    let firstVisibleRow = wtTable.getFirstVisibleRow();
    if (topOverlay.mainTableScrollableElement === rootWindow) {
      const rootElementOffset = offset2(wtTable.wtRootElement);
      const totalTableHeight = innerHeight(wtTable.hider);
      const windowHeight = innerHeight(rootWindow);
      const windowScrollTop = getScrollTop(rootWindow, rootWindow);
      if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {
        let rowsHeight = wtViewport.getColumnHeaderHeight();
        rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);
        for (let row = totalRows; row > 0; row--) {
          rowsHeight += topOverlay.sumCellSizes(row - 1, row);
          if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {
            firstVisibleRow = row;
            break;
          }
        }
      }
    }
    return firstVisibleRow;
  }
  /**
   * Get last visible row based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getLastVisibleRow() {
    const {
      topOverlay,
      wtTable,
      wtViewport,
      totalRows,
      rootWindow
    } = this.dataAccessObject;
    let lastVisibleRow = wtTable.getLastVisibleRow();
    if (topOverlay.mainTableScrollableElement === rootWindow) {
      const rootElementOffset = offset2(wtTable.wtRootElement);
      const windowScrollTop = getScrollTop(rootWindow, rootWindow);
      if (rootElementOffset.top > windowScrollTop) {
        const windowHeight = innerHeight(rootWindow);
        let rowsHeight = wtViewport.getColumnHeaderHeight();
        for (let row = 1; row <= totalRows; row++) {
          rowsHeight += topOverlay.sumCellSizes(row - 1, row);
          if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {
            lastVisibleRow = row - 2;
            break;
          }
        }
      }
    }
    return lastVisibleRow;
  }
  /**
   * Get first visible column based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getFirstVisibleColumn() {
    const {
      inlineStartOverlay,
      wtTable,
      wtViewport,
      totalColumns,
      rootWindow
    } = this.dataAccessObject;
    let firstVisibleColumn = wtTable.getFirstVisibleColumn();
    if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {
      const rootElementOffset = offset2(wtTable.wtRootElement);
      const totalTableWidth = innerWidth(wtTable.hider);
      const windowWidth = innerWidth(rootWindow);
      const windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));
      if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {
        let columnsWidth = wtViewport.getRowHeaderWidth();
        for (let column = totalColumns; column > 0; column--) {
          columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);
          if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {
            firstVisibleColumn = column;
            break;
          }
        }
      }
    }
    return firstVisibleColumn;
  }
  /**
   * Get last visible column based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getLastVisibleColumn() {
    const {
      wtSettings,
      inlineStartOverlay,
      wtTable,
      wtViewport,
      totalColumns,
      rootWindow
    } = this.dataAccessObject;
    let lastVisibleColumn = wtTable.getLastVisibleColumn();
    if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {
      const isRtl = wtSettings.getSetting("rtlMode");
      let inlineStartRootElementOffset = null;
      if (isRtl) {
        const tableRect = wtTable.TABLE.getBoundingClientRect();
        const rootDocument = this.dataAccessObject.rootWindow.document;
        const docOffsetWidth = rootDocument.documentElement.offsetWidth;
        inlineStartRootElementOffset = Math.abs(tableRect.right - docOffsetWidth);
      } else {
        const rootElementOffset = offset2(wtTable.wtRootElement);
        inlineStartRootElementOffset = rootElementOffset.left;
      }
      const windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));
      if (inlineStartRootElementOffset > windowScrollLeft) {
        const windowWidth = innerWidth(rootWindow);
        let columnsWidth = wtViewport.getRowHeaderWidth();
        for (let column = 1; column <= totalColumns; column++) {
          columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);
          if (inlineStartRootElementOffset + columnsWidth - windowScrollLeft >= windowWidth) {
            lastVisibleColumn = column - 2;
            break;
          }
        }
      }
    }
    return lastVisibleColumn;
  }
};
var scroll_default = Scroll;

// node_modules/handsontable/3rdparty/walkontable/src/core/_base.mjs
function _defineProperty5(obj, key, value) {
  key = _toPropertyKey5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey5(arg) {
  var key = _toPrimitive5(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive5(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var CoreAbstract = class {
  get eventManager() {
    return new eventManager_default(this);
  }
  /**
   * @param {HTMLTableElement} table Main table.
   * @param {Settings} settings The Walkontable settings.
   */
  constructor(table, settings) {
    _defineProperty5(this, "wtTable", void 0);
    _defineProperty5(this, "wtScroll", void 0);
    _defineProperty5(this, "wtViewport", void 0);
    _defineProperty5(this, "wtOverlays", void 0);
    _defineProperty5(this, "selections", void 0);
    _defineProperty5(this, "wtEvent", void 0);
    _defineProperty5(this, "guid", `wt_${randomString()}`);
    _defineProperty5(this, "drawInterrupted", false);
    _defineProperty5(this, "drawn", false);
    _defineProperty5(this, "domBindings", void 0);
    _defineProperty5(this, "wtSettings", void 0);
    this.domBindings = {
      rootTable: table,
      rootDocument: table.ownerDocument,
      rootWindow: table.ownerDocument.defaultView
    };
    this.wtSettings = settings;
    this.wtScroll = new scroll_default(this.createScrollDao());
  }
  findOriginalHeaders() {
    const originalHeaders = [];
    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
      for (let c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {
        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);
      }
      if (!this.wtSettings.getSetting("columnHeaders").length) {
        this.wtSettings.update("columnHeaders", [function(column, TH) {
          fastInnerText(TH, originalHeaders[column]);
        }]);
      }
    }
  }
  /**
   * Creates and returns the CellCoords object.
   *
   * @param {*} row The row index.
   * @param {*} column The column index.
   * @returns {CellCoords}
   */
  createCellCoords(row, column) {
    return new coords_default(row, column, this.wtSettings.getSetting("rtlMode"));
  }
  /**
   * Creates and returns the CellRange object.
   *
   * @param {CellCoords} highlight The highlight coordinates.
   * @param {CellCoords} from The from coordinates.
   * @param {CellCoords} to The to coordinates.
   * @returns {CellRange}
   */
  createCellRange(highlight, from2, to2) {
    return new range_default(highlight, from2, to2, this.wtSettings.getSetting("rtlMode"));
  }
  /**
   * Force rerender of Walkontable.
   *
   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
   *                                   the data. It will only work if Table.draw() does not force
   *                                   rendering anyway.
   * @returns {Walkontable}
   */
  draw() {
    let fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this.drawInterrupted = false;
    if (!fastDraw && !this.wtTable.isVisible()) {
      this.drawInterrupted = true;
    } else {
      this.wtTable.draw(fastDraw);
    }
    return this;
  }
  /**
   * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,
   * if not set or set to false, returns TD from the master table.
   *
   * @param {CellCoords} coords The cell coordinates.
   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,
   *                                  if the wanted cell is in the range of fixed rows, it will return a TD element
   *                                  from the top overlay.
   * @returns {HTMLElement}
   */
  getCell(coords) {
    let topmost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!topmost) {
      return this.wtTable.getCell(coords);
    }
    const totalRows = this.wtSettings.getSetting("totalRows");
    const fixedRowsTop = this.wtSettings.getSetting("fixedRowsTop");
    const fixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
    const fixedColumnsStart = this.wtSettings.getSetting("fixedColumnsStart");
    if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {
      return this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);
    } else if (coords.row < fixedRowsTop) {
      return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);
    } else if (coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) {
      if (this.wtOverlays.bottomInlineStartCornerOverlay && this.wtOverlays.bottomInlineStartCornerOverlay.clone) {
        return this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);
      }
    } else if (coords.col < fixedColumnsStart) {
      return this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);
    } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {
      if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {
        return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);
      }
    }
    return this.wtTable.getCell(coords);
  }
  /**
   * Scrolls the viewport to a cell (rerenders if needed).
   *
   * @param {CellCoords} coords The cell coordinates to scroll to.
   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.
   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.
   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.
   * @returns {boolean}
   */
  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
    if (coords.col < 0 || coords.row < 0) {
      return false;
    }
    return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
  }
  /**
   * Scrolls the viewport to a column (rerenders if needed).
   *
   * @param {number} column Visual column index.
   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.
   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.
   * @returns {boolean}
   */
  scrollViewportHorizontally(column, snapToRight, snapToLeft) {
    if (column < 0) {
      return false;
    }
    return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);
  }
  /**
   * Scrolls the viewport to a row (rerenders if needed).
   *
   * @param {number} row Visual row index.
   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.
   * @returns {boolean}
   */
  scrollViewportVertically(row, snapToTop, snapToBottom) {
    if (row < 0) {
      return false;
    }
    return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);
  }
  /**
   * @returns {Array}
   */
  getViewport() {
    return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];
  }
  /**
   * Destroy instance.
   */
  destroy() {
    this.wtOverlays.destroy();
    this.wtEvent.destroy();
  }
  /**
   * Create data access object for scroll.
   *
   * @protected
   * @returns {ScrollDao}
   */
  createScrollDao() {
    const wot = this;
    return {
      get drawn() {
        return wot.drawn;
      },
      get topOverlay() {
        return wot.wtOverlays.topOverlay;
      },
      get inlineStartOverlay() {
        return wot.wtOverlays.inlineStartOverlay;
      },
      get wtTable() {
        return wot.wtTable;
      },
      get wtViewport() {
        return wot.wtViewport;
      },
      get wtSettings() {
        return wot.wtSettings;
      },
      get rootWindow() {
        return wot.domBindings.rootWindow;
      },
      // TODO refactoring, consider about using injecting wtSettings into scroll (it'll enables remove dao layer)
      get totalRows() {
        return wot.wtSettings.getSetting("totalRows");
      },
      get totalColumns() {
        return wot.wtSettings.getSetting("totalColumns");
      },
      get fixedRowsTop() {
        return wot.wtSettings.getSetting("fixedRowsTop");
      },
      get fixedRowsBottom() {
        return wot.wtSettings.getSetting("fixedRowsBottom");
      },
      get fixedColumnsStart() {
        return wot.wtSettings.getSetting("fixedColumnsStart");
      }
    };
  }
  // TODO refactoring: it will be much better to not use DAO objects. They are needed for now to provide
  // dynamically access to related objects
  /**
   * Create data access object for wtTable.
   *
   * @protected
   * @returns {TableDao}
   */
  getTableDao() {
    const wot = this;
    return {
      get wot() {
        return wot;
      },
      get parentTableOffset() {
        return wot.cloneSource.wtTable.tableOffset;
      },
      get cloneSource() {
        return wot.cloneSource;
      },
      get workspaceWidth() {
        return wot.wtViewport.getWorkspaceWidth();
      },
      get wtViewport() {
        return wot.wtViewport;
      },
      get wtOverlays() {
        return wot.wtOverlays;
      },
      get selections() {
        return wot.selections;
      },
      get drawn() {
        return wot.drawn;
      },
      set drawn(v) {
        wot.drawn = v;
      },
      get wtTable() {
        return wot.wtTable;
      },
      get startColumnRendered() {
        return wot.wtViewport.columnsRenderCalculator.startColumn;
      },
      get startColumnVisible() {
        return wot.wtViewport.columnsVisibleCalculator.startColumn;
      },
      get endColumnRendered() {
        return wot.wtViewport.columnsRenderCalculator.endColumn;
      },
      get endColumnVisible() {
        return wot.wtViewport.columnsVisibleCalculator.endColumn;
      },
      get countColumnsRendered() {
        return wot.wtViewport.columnsRenderCalculator.count;
      },
      get countColumnsVisible() {
        return wot.wtViewport.columnsVisibleCalculator.count;
      },
      get startRowRendered() {
        return wot.wtViewport.rowsRenderCalculator.startRow;
      },
      get startRowVisible() {
        return wot.wtViewport.rowsVisibleCalculator.startRow;
      },
      get endRowRendered() {
        return wot.wtViewport.rowsRenderCalculator.endRow;
      },
      get endRowVisible() {
        return wot.wtViewport.rowsVisibleCalculator.endRow;
      },
      get countRowsRendered() {
        return wot.wtViewport.rowsRenderCalculator.count;
      },
      get countRowsVisible() {
        return wot.wtViewport.rowsVisibleCalculator.count;
      }
    };
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/core/clone.mjs
function _defineProperty6(obj, key, value) {
  key = _toPropertyKey6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey6(arg) {
  var key = _toPrimitive6(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive6(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Clone = class extends CoreAbstract {
  /**
   * @param {HTMLTableElement} table Main table.
   * @param {SettingsPure|Settings} settings The Walkontable settings.
   * @param {WalkontableCloneOptions} clone Clone data.
   */
  constructor(table, settings, clone4) {
    super(table, settings);
    _defineProperty6(this, "cloneSource", void 0);
    _defineProperty6(this, "cloneOverlay", void 0);
    const facadeGetter = this.wtSettings.getSetting("facade", this);
    this.cloneSource = clone4.source;
    this.cloneOverlay = clone4.overlay;
    this.wtTable = this.cloneOverlay.createTable(this.getTableDao(), facadeGetter, this.domBindings, this.wtSettings);
    this.wtViewport = clone4.viewport;
    this.selections = clone4.selections;
    this.wtEvent = new event_default(facadeGetter, this.domBindings, this.wtSettings, this.eventManager, this.wtTable, this.selections, clone4.event);
    this.findOriginalHeaders();
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/overlay/_base.mjs
function _defineProperty7(obj, key, value) {
  key = _toPropertyKey7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey7(arg) {
  var key = _toPrimitive7(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive7(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Overlay = class {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   */
  constructor(wotInstance, facadeGetter, type, wtSettings, domBindings) {
    _defineProperty7(this, "wtSettings", null);
    defineGetter(this, "wot", wotInstance, {
      writable: false
    });
    this.domBindings = domBindings;
    this.facadeGetter = facadeGetter;
    this.wtSettings = wtSettings;
    const {
      TABLE,
      hider,
      spreader,
      holder: holder2,
      wtRootElement
    } = this.wot.wtTable;
    this.instance = this.wot;
    this.type = type;
    this.mainTableScrollableElement = null;
    this.TABLE = TABLE;
    this.hider = hider;
    this.spreader = spreader;
    this.holder = holder2;
    this.wtRootElement = wtRootElement;
    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
    this.updateStateOfRendering();
    this.clone = this.makeClone();
  }
  /**
   * Update internal state of object with an information about the need of full rendering of the overlay.
   *
   * @returns {boolean} Returns `true` if the state has changed since the last check.
   */
  updateStateOfRendering() {
    const previousState = this.needFullRender;
    this.needFullRender = this.shouldBeRendered();
    const changed = previousState !== this.needFullRender;
    if (changed && !this.needFullRender) {
      this.reset();
    }
    return changed;
  }
  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return true;
  }
  /**
   * Update the trimming container.
   */
  updateTrimmingContainer() {
    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
  }
  /**
   * Update the main scrollable element.
   */
  updateMainScrollableElement() {
    const {
      wtTable
    } = this.wot;
    const {
      rootWindow
    } = this.domBindings;
    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue("overflow") === "hidden") {
      this.mainTableScrollableElement = this.wot.wtTable.holder;
    } else {
      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);
    }
  }
  /**
   * Calculates coordinates of the provided element, relative to the root Handsontable element.
   * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.
   *
   * @param {HTMLElement} element The cell element to calculate the position for.
   * @param {number} rowIndex Visual row index.
   * @param {number} columnIndex Visual column index.
   * @returns {{top: number, start: number}|undefined}
   */
  getRelativeCellPosition(element, rowIndex, columnIndex) {
    if (this.clone.wtTable.holder.contains(element) === false) {
      warn2(`The provided element is not a child of the ${this.type} overlay`);
      return;
    }
    const windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;
    const fixedColumnStart = columnIndex < this.wtSettings.getSetting("fixedColumnsStart");
    const fixedRowTop = rowIndex < this.wtSettings.getSetting("fixedRowsTop");
    const fixedRowBottom = rowIndex >= this.wtSettings.getSetting("totalRows") - this.wtSettings.getSetting("fixedRowsBottom");
    const spreader = this.clone.wtTable.spreader;
    const spreaderOffset = {
      start: this.getRelativeStartPosition(spreader),
      top: spreader.offsetTop
    };
    const elementOffset = {
      start: this.getRelativeStartPosition(element),
      top: element.offsetTop
    };
    let offsetObject = null;
    if (windowScroll) {
      offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);
    } else {
      offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);
    }
    return offsetObject;
  }
  /**
   * Get inline start value depending of direction.
   *
   * @param {HTMLElement} el Element.
   * @returns {number}
   */
  getRelativeStartPosition(el) {
    return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;
  }
  /**
   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window
   * as a scrollable element.
   *
   * @private
   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.
   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.
   * @param {number} elementOffset Offset position of the cell element.
   * @param {number} spreaderOffset Offset position of the spreader element.
   * @returns {{top: number, left: number}}
   */
  getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {
    const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();
    let horizontalOffset = 0;
    let verticalOffset = 0;
    if (!onFixedColumn) {
      horizontalOffset = spreaderOffset.start;
    } else {
      let absoluteRootElementStartPosition = absoluteRootElementPosition.left;
      if (this.isRtl()) {
        absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());
      }
      horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;
    }
    if (onFixedRowTop) {
      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();
      verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;
    } else {
      verticalOffset = spreaderOffset.top;
    }
    return {
      start: elementOffset.start + horizontalOffset,
      top: elementOffset.top + verticalOffset
    };
  }
  /**
   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window
   * as a scrollable element.
   *
   * @private
   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.
   * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.
   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.
   * @param {number} elementOffset Offset position of the cell element.
   * @param {number} spreaderOffset Offset position of the spreader element.
   * @returns {{top: number, left: number}}
   */
  getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {
    const tableScrollPosition = {
      horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),
      vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()
    };
    let horizontalOffset = 0;
    let verticalOffset = 0;
    if (!onFixedColumn) {
      horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;
    }
    if (onFixedRowBottom) {
      const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();
      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();
      verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;
    } else if (!onFixedRowTop) {
      verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;
    }
    return {
      start: elementOffset.start - horizontalOffset,
      top: elementOffset.top - verticalOffset
    };
  }
  /**
   * Make a clone of table for overlay.
   *
   * @returns {Clone}
   */
  makeClone() {
    if (CLONE_TYPES.indexOf(this.type) === -1) {
      throw new Error(`Clone type "${this.type}" is not supported.`);
    }
    const {
      wtTable
    } = this.wot;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const clone4 = rootDocument.createElement("DIV");
    const clonedTable = rootDocument.createElement("TABLE");
    const tableParent = wtTable.wtRootElement.parentNode;
    clone4.className = `${CLONE_CLASS_NAMES.get(this.type)} handsontable`;
    clone4.setAttribute("dir", this.isRtl() ? "rtl" : "ltr");
    clone4.style.position = "absolute";
    clone4.style.top = 0;
    clone4.style.overflow = "visible";
    if (this.isRtl()) {
      clone4.style.right = 0;
    } else {
      clone4.style.left = 0;
    }
    clonedTable.className = wtTable.TABLE.className;
    clone4.appendChild(clonedTable);
    tableParent.appendChild(clone4);
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    if (preventOverflow === true || preventOverflow === "horizontal" && this.type === CLONE_TOP || preventOverflow === "vertical" && this.type === CLONE_INLINE_START) {
      this.mainTableScrollableElement = rootWindow;
    } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue("overflow") === "hidden") {
      this.mainTableScrollableElement = wtTable.holder;
    } else {
      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);
    }
    return new Clone(clonedTable, this.wtSettings, {
      // todo ioc factory
      source: this.wot,
      overlay: this,
      viewport: this.wot.wtViewport,
      // todo ioc , or factor func if used only here
      event: this.wot.wtEvent,
      // todo ioc , or factory func if used only here
      selections: this.wot.selections
      // todo ioc , or factory func if used only here
    });
  }
  /**
   * Refresh/Redraw overlay.
   *
   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
   *                                   the data. It will only work if Table.draw() does not force
   *                                   rendering anyway.
   */
  refresh() {
    let fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const nextCycleRenderFlag = this.shouldBeRendered();
    if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {
      this.clone.draw(fastDraw);
    }
    this.needFullRender = nextCycleRenderFlag;
  }
  /**
   * Reset overlay styles to initial values.
   */
  reset() {
    if (!this.clone) {
      return;
    }
    const holder2 = this.clone.wtTable.holder;
    const hider = this.clone.wtTable.hider;
    const holderStyle = holder2.style;
    const hiderStyle = hider.style;
    const rootStyle = holder2.parentNode.style;
    arrayEach([holderStyle, hiderStyle, rootStyle], (style) => {
      style.width = "";
      style.height = "";
    });
  }
  /**
   * Determine if Walkontable is running in RTL mode.
   *
   * @returns {boolean}
   */
  isRtl() {
    return this.wtSettings.getSetting("rtlMode");
  }
  /**
   * Destroy overlay instance.
   */
  destroy() {
    this.clone.eventManager.destroy();
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/overlay/bottomInlineStartCorner.mjs
var BottomInlineStartCornerOverlay = class extends Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   * @param {BottomOverlay} bottomOverlay The instance of the Top overlay.
   * @param {InlineStartOverlay} inlineStartOverlay The instance of the InlineStart overlay.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings, bottomOverlay, inlineStartOverlay) {
    super(wotInstance, facadeGetter, CLONE_BOTTOM_INLINE_START_CORNER, wtSettings, domBindings);
    this.bottomOverlay = bottomOverlay;
    this.inlineStartOverlay = inlineStartOverlay;
  }
  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {BottomInlineStartCornerOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new bottomInlineStartCorner_default(...args);
  }
  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting("shouldRenderBottomOverlay") && this.wtSettings.getSetting("shouldRenderInlineStartOverlay");
  }
  /**
   * Updates the corner overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    const {
      wot
    } = this;
    this.updateTrimmingContainer();
    if (!wot.wtTable.holder.parentNode) {
      return false;
    }
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    overlayRoot.style.top = "";
    if (this.trimmingContainer === this.domBindings.rootWindow) {
      const inlineStartOffset = this.inlineStartOverlay.getOverlayOffset();
      const bottom2 = this.bottomOverlay.getOverlayOffset();
      overlayRoot.style[this.isRtl() ? "right" : "left"] = `${inlineStartOffset}px`;
      overlayRoot.style.bottom = `${bottom2}px`;
    } else {
      resetCssTransform(overlayRoot);
      this.repositionOverlay();
    }
    let tableHeight = outerHeight(this.clone.wtTable.TABLE);
    const tableWidth = outerWidth(this.clone.wtTable.TABLE);
    if (!this.wot.wtTable.hasDefinedSize()) {
      tableHeight = 0;
    }
    overlayRoot.style.height = `${tableHeight}px`;
    overlayRoot.style.width = `${tableWidth}px`;
    return false;
  }
  /**
   * Reposition the overlay.
   */
  repositionOverlay() {
    const {
      wtTable,
      wtViewport
    } = this.wot;
    const {
      rootDocument
    } = this.domBindings;
    const cloneRoot = this.clone.wtTable.holder.parentNode;
    let bottomOffset = 0;
    if (!wtViewport.hasVerticalScroll()) {
      bottomOffset += wtViewport.getWorkspaceHeight() - wtTable.getTotalHeight();
    }
    if (wtViewport.hasVerticalScroll() && wtViewport.hasHorizontalScroll()) {
      bottomOffset += getScrollbarWidth(rootDocument);
    }
    cloneRoot.style.bottom = `${bottomOffset}px`;
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/table/mixin/calculatedColumns.mjs
var MIXIN_NAME3 = "calculatedColumns";
var calculatedColumns = {
  /**
   * Get the source index of the first rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedColumn() {
    const startColumn = this.dataAccessObject.startColumnRendered;
    if (startColumn === null) {
      return -1;
    }
    return startColumn;
  },
  /**
   * Get the source index of the first column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleColumn() {
    const startColumn = this.dataAccessObject.startColumnVisible;
    if (startColumn === null) {
      return -1;
    }
    return startColumn;
  },
  /**
   * Get the source index of the last rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedColumn() {
    const endColumn = this.dataAccessObject.endColumnRendered;
    if (endColumn === null) {
      return -1;
    }
    return endColumn;
  },
  /**
   * Get the source index of the last column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleColumn() {
    const endColumn = this.dataAccessObject.endColumnVisible;
    if (endColumn === null) {
      return -1;
    }
    return endColumn;
  },
  /**
   * Get the number of rendered columns.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedColumnsCount() {
    return this.dataAccessObject.countColumnsRendered;
  },
  /**
   * Get the number of fully visible columns in the viewport.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleColumnsCount() {
    return this.dataAccessObject.countColumnsVisible;
  }
};
defineGetter(calculatedColumns, "MIXIN_NAME", MIXIN_NAME3, {
  writable: false,
  enumerable: false
});
var calculatedColumns_default = calculatedColumns;

// node_modules/handsontable/3rdparty/walkontable/src/table/bottom.mjs
var BottomOverlayTable = class extends table_default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_BOTTOM);
  }
};
mixin(BottomOverlayTable, stickyRowsBottom_default);
mixin(BottomOverlayTable, calculatedColumns_default);
var bottom_default = BottomOverlayTable;

// node_modules/handsontable/3rdparty/walkontable/src/overlay/bottom.mjs
function _defineProperty8(obj, key, value) {
  key = _toPropertyKey8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey8(arg) {
  var key = _toPrimitive8(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive8(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var BottomOverlay = class extends Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {
    super(wotInstance, facadeGetter, CLONE_BOTTOM, wtSettings, domBindings);
    _defineProperty8(this, "cachedFixedRowsBottom", -1);
    this.cachedFixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
  }
  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {BottomOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new bottom_default(...args);
  }
  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting("shouldRenderBottomOverlay");
  }
  /**
   * Updates the top overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
      return false;
    }
    const {
      rootWindow
    } = this.domBindings;
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    overlayRoot.style.top = "";
    let overlayPosition = 0;
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
      overlayPosition = this.getOverlayOffset();
      overlayRoot.style.bottom = `${overlayPosition}px`;
    } else {
      overlayPosition = this.getScrollPosition();
      this.repositionOverlay();
    }
    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition);
    this.adjustElementsSize();
    return positionChanged;
  }
  /**
   * Updates the bottom overlay position.
   */
  repositionOverlay() {
    const {
      wtTable,
      wtViewport
    } = this.wot;
    const {
      rootDocument
    } = this.domBindings;
    const cloneRoot = this.clone.wtTable.holder.parentNode;
    let bottomOffset = 0;
    if (!wtViewport.hasVerticalScroll()) {
      bottomOffset += wtViewport.getWorkspaceHeight() - wtTable.getTotalHeight();
    }
    if (wtViewport.hasVerticalScroll() && wtViewport.hasHorizontalScroll()) {
      bottomOffset += getScrollbarWidth(rootDocument);
    }
    cloneRoot.style.bottom = `${bottomOffset}px`;
  }
  /**
   * Sets the main overlay's vertical scroll position.
   *
   * @param {number} pos The scroll position.
   * @returns {boolean}
   */
  setScrollPosition(pos) {
    const {
      rootWindow
    } = this.domBindings;
    let result = false;
    if (this.mainTableScrollableElement === rootWindow) {
      rootWindow.scrollTo(getWindowScrollLeft(rootWindow), pos);
      result = true;
    } else if (this.mainTableScrollableElement.scrollTop !== pos) {
      this.mainTableScrollableElement.scrollTop = pos;
      result = true;
    }
    return result;
  }
  /**
   * Triggers onScroll hook callback.
   */
  onScroll() {
    this.wtSettings.getSetting("onScrollHorizontally");
  }
  /**
   * Calculates total sum cells height.
   *
   * @param {number} from Row index which calculates started from.
   * @param {number} to Row index where calculation is finished.
   * @returns {number} Height sum.
   */
  sumCellSizes(from2, to2) {
    const {
      wtTable,
      wtSettings
    } = this.wot;
    const defaultRowHeight = wtSettings.getSetting("defaultRowHeight");
    let row = from2;
    let sum = 0;
    while (row < to2) {
      const height = wtTable.getRowHeight(row);
      sum += height === void 0 ? defaultRowHeight : height;
      row += 1;
    }
    return sum;
  }
  /**
   * Adjust overlay root element, childs and master table element sizes (width, height).
   *
   * @param {boolean} [force=false] When `true`, it adjusts the DOM nodes sizes for that overlay.
   */
  adjustElementsSize() {
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this.updateTrimmingContainer();
    if (this.needFullRender || force) {
      this.adjustRootElementSize();
      this.adjustRootChildrenSize();
    }
  }
  /**
   * Adjust overlay root element size (width and height).
   */
  adjustRootElementSize() {
    const {
      wtTable,
      wtViewport
    } = this.wot;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const scrollbarWidth = getScrollbarWidth(rootDocument);
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const overlayRootStyle = overlayRoot.style;
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    if (this.trimmingContainer !== rootWindow || preventOverflow === "horizontal") {
      let width = wtViewport.getWorkspaceWidth();
      if (this.wot.wtOverlays.hasScrollbarRight) {
        width -= scrollbarWidth;
      }
      width = Math.min(width, wtTable.wtRootElement.scrollWidth);
      overlayRootStyle.width = `${width}px`;
    } else {
      overlayRootStyle.width = "";
    }
    this.clone.wtTable.holder.style.width = overlayRootStyle.width;
    let tableHeight = outerHeight(this.clone.wtTable.TABLE);
    if (!this.wot.wtTable.hasDefinedSize()) {
      tableHeight = 0;
    }
    overlayRootStyle.height = `${tableHeight}px`;
  }
  /**
   * Adjust overlay root childs size.
   */
  adjustRootChildrenSize() {
    const {
      holder: holder2
    } = this.clone.wtTable;
    this.clone.wtTable.hider.style.width = this.hider.style.width;
    holder2.style.width = holder2.parentNode.style.width;
    holder2.style.height = holder2.parentNode.style.height;
  }
  /**
   * Adjust the overlay dimensions and position.
   */
  applyToDOM() {
    const total = this.wtSettings.getSetting("totalRows");
    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
      this.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;
    } else if (total === 0) {
      this.spreader.style.top = "0";
    } else {
      throw new Error("Incorrect value of the rowsRenderCalculator");
    }
    this.spreader.style.bottom = "";
    if (this.needFullRender) {
      this.syncOverlayOffset();
    }
  }
  /**
   * Synchronize calculated left position to an element.
   */
  syncOverlayOffset() {
    const styleProperty = this.isRtl() ? "right" : "left";
    const {
      spreader
    } = this.clone.wtTable;
    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
      spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;
    } else {
      spreader.style[styleProperty] = "";
    }
  }
  /**
   * Scrolls vertically to a row.
   *
   * @param {number} sourceRow Row index which you want to scroll to.
   * @param {boolean} [bottomEdge=false] If `true`, scrolls according to the bottom edge (top edge is by default).
   */
  scrollTo(sourceRow, bottomEdge) {
    let newY = this.getTableParentOffset();
    const sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
    const mainHolder = sourceInstance.wtTable.holder;
    let scrollbarCompensation = 0;
    if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
      scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);
    }
    if (bottomEdge) {
      newY += this.sumCellSizes(0, sourceRow + 1);
      newY -= this.wot.wtViewport.getViewportHeight();
      newY += 1;
    } else {
      newY += this.sumCellSizes(this.wtSettings.getSetting("fixedRowsBottom"), sourceRow);
    }
    newY += scrollbarCompensation;
    this.setScrollPosition(newY);
  }
  /**
   * Gets table parent top position.
   *
   * @returns {number}
   */
  getTableParentOffset() {
    if (this.mainTableScrollableElement === this.domBindings.rootWindow) {
      return this.wot.wtTable.holderOffset.top;
    }
    return 0;
  }
  /**
   * Gets the main overlay's vertical scroll position.
   *
   * @returns {number} Main table's vertical scroll position.
   */
  getScrollPosition() {
    return getScrollTop(this.mainTableScrollableElement, this.domBindings.rootWindow);
  }
  /**
   * Gets the main overlay's vertical overlay offset.
   *
   * @returns {number} Main table's vertical overlay offset.
   */
  getOverlayOffset() {
    const {
      rootWindow
    } = this.domBindings;
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    let overlayOffset = 0;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
      const rootHeight = this.wot.wtTable.getTotalHeight();
      const overlayRootHeight = this.clone.wtTable.getTotalHeight();
      const maxOffset = rootHeight - overlayRootHeight;
      const docClientHeight = this.domBindings.rootDocument.documentElement.clientHeight;
      overlayOffset = Math.max(this.getTableParentOffset() - this.getScrollPosition() - docClientHeight + rootHeight, 0);
      if (overlayOffset > maxOffset) {
        overlayOffset = 0;
      }
    }
    return overlayOffset;
  }
  /**
   * Adds css classes to hide the header border's header (cell-selection border hiding issue).
   *
   * @param {number} position Header Y position if trimming container is window or scroll top if not.
   * @returns {boolean}
   */
  adjustHeaderBordersPosition(position) {
    const fixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
    const areFixedRowsBottomChanged = this.cachedFixedRowsBottom !== fixedRowsBottom;
    const columnHeaders = this.wtSettings.getSetting("columnHeaders");
    let positionChanged = false;
    if ((areFixedRowsBottomChanged || fixedRowsBottom === 0) && columnHeaders.length > 0) {
      const masterParent = this.wot.wtTable.holder.parentNode;
      const previousState = hasClass(masterParent, "innerBorderBottom");
      this.cachedFixedRowsBottom = this.wtSettings.getSetting("fixedRowsBottom");
      if (position || this.wtSettings.getSetting("totalRows") === 0) {
        addClass(masterParent, "innerBorderBottom");
        positionChanged = !previousState;
      } else {
        removeClass(masterParent, "innerBorderBottom");
        positionChanged = previousState;
      }
    }
    return positionChanged;
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/table/mixin/calculatedRows.mjs
var MIXIN_NAME4 = "calculatedRows";
var calculatedRows = {
  /**
   * Get the source index of the first rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedRow() {
    const startRow = this.dataAccessObject.startRowRendered;
    if (startRow === null) {
      return -1;
    }
    return startRow;
  },
  /**
   * Get the source index of the first row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleRow() {
    const startRow = this.dataAccessObject.startRowVisible;
    if (startRow === null) {
      return -1;
    }
    return startRow;
  },
  /**
   * Get the source index of the last rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedRow() {
    const endRow = this.dataAccessObject.endRowRendered;
    if (endRow === null) {
      return -1;
    }
    return endRow;
  },
  /**
   * Get the source index of the last row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleRow() {
    const endRow = this.dataAccessObject.endRowVisible;
    if (endRow === null) {
      return -1;
    }
    return endRow;
  },
  /**
   * Get the number of rendered rows.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedRowsCount() {
    return this.dataAccessObject.countRowsRendered;
  },
  /**
   * Get the number of fully visible rows in the viewport.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleRowsCount() {
    return this.dataAccessObject.countRowsVisible;
  }
};
defineGetter(calculatedRows, "MIXIN_NAME", MIXIN_NAME4, {
  writable: false,
  enumerable: false
});
var calculatedRows_default = calculatedRows;

// node_modules/handsontable/3rdparty/walkontable/src/table/inlineStart.mjs
var InlineStartOverlayTable = class extends table_default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_INLINE_START);
  }
};
mixin(InlineStartOverlayTable, calculatedRows_default);
mixin(InlineStartOverlayTable, stickyColumnsStart_default);
var inlineStart_default = InlineStartOverlayTable;

// node_modules/handsontable/3rdparty/walkontable/src/overlay/inlineStart.mjs
var InlineStartOverlay = class extends Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {
    super(wotInstance, facadeGetter, CLONE_INLINE_START, wtSettings, domBindings);
  }
  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {InlineStartOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new inlineStart_default(...args);
  }
  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting("shouldRenderInlineStartOverlay");
  }
  /**
   * Updates the left overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    const {
      wtTable
    } = this.wot;
    if (!this.needFullRender || !wtTable.holder.parentNode) {
      return false;
    }
    const {
      rootWindow
    } = this.domBindings;
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    let overlayPosition = 0;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "horizontal")) {
      overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);
      setOverlayPosition(overlayRoot, `${overlayPosition}px`, "0px");
    } else {
      overlayPosition = this.getScrollPosition();
      resetCssTransform(overlayRoot);
    }
    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition);
    this.adjustElementsSize();
    return positionChanged;
  }
  /**
   * Sets the main overlay's horizontal scroll position.
   *
   * @param {number} pos The scroll position.
   * @returns {boolean}
   */
  setScrollPosition(pos) {
    const {
      rootWindow
    } = this.domBindings;
    let result = false;
    if (this.isRtl()) {
      pos = -pos;
    }
    if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {
      rootWindow.scrollTo(pos, getWindowScrollTop(rootWindow));
      result = true;
    } else if (this.mainTableScrollableElement.scrollLeft !== pos) {
      this.mainTableScrollableElement.scrollLeft = pos;
      result = true;
    }
    return result;
  }
  /**
   * Triggers onScroll hook callback.
   */
  onScroll() {
    this.wtSettings.getSetting("onScrollVertically");
  }
  /**
   * Calculates total sum cells width.
   *
   * @param {number} from Column index which calculates started from.
   * @param {number} to Column index where calculation is finished.
   * @returns {number} Width sum.
   */
  sumCellSizes(from2, to2) {
    const defaultColumnWidth = this.wtSettings.getSetting("defaultColumnWidth");
    let column = from2;
    let sum = 0;
    while (column < to2) {
      sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;
      column += 1;
    }
    return sum;
  }
  /**
   * Adjust overlay root element, childs and master table element sizes (width, height).
   *
   * @param {boolean} [force=false] When `true`, it adjusts the DOM nodes sizes for that overlay.
   */
  adjustElementsSize() {
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this.updateTrimmingContainer();
    if (this.needFullRender || force) {
      this.adjustRootElementSize();
      this.adjustRootChildrenSize();
    }
  }
  /**
   * Adjust overlay root element size (width and height).
   */
  adjustRootElementSize() {
    const {
      wtTable
    } = this.wot;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const scrollbarHeight = getScrollbarWidth(rootDocument);
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const overlayRootStyle = overlayRoot.style;
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    if (this.trimmingContainer !== rootWindow || preventOverflow === "vertical") {
      let height = this.wot.wtViewport.getWorkspaceHeight();
      if (this.wot.wtOverlays.hasScrollbarBottom) {
        height -= scrollbarHeight;
      }
      height = Math.min(height, wtTable.wtRootElement.scrollHeight);
      overlayRootStyle.height = `${height}px`;
    } else {
      overlayRootStyle.height = "";
    }
    this.clone.wtTable.holder.style.height = overlayRootStyle.height;
    const tableWidth = outerWidth(this.clone.wtTable.TABLE);
    overlayRootStyle.width = `${tableWidth}px`;
  }
  /**
   * Adjust overlay root childs size.
   */
  adjustRootChildrenSize() {
    var _selections$getCell$g;
    const {
      holder: holder2
    } = this.clone.wtTable;
    const {
      selections
    } = this.wot;
    const facade = this.facadeGetter();
    const selectionCornerOffset = Math.abs((_selections$getCell$g = selections === null || selections === void 0 ? void 0 : selections.getCell().getBorder(facade).cornerCenterPointOffset) !== null && _selections$getCell$g !== void 0 ? _selections$getCell$g : 0);
    this.clone.wtTable.hider.style.height = this.hider.style.height;
    holder2.style.height = holder2.parentNode.style.height;
    holder2.style.width = `${parseInt(holder2.parentNode.style.width, 10) + selectionCornerOffset}px`;
  }
  /**
   * Adjust the overlay dimensions and position.
   */
  applyToDOM() {
    const total = this.wtSettings.getSetting("totalColumns");
    const styleProperty = this.isRtl() ? "right" : "left";
    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
      this.spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;
    } else if (total === 0) {
      this.spreader.style[styleProperty] = "0";
    } else {
      throw new Error("Incorrect value of the columnsRenderCalculator");
    }
    if (this.isRtl()) {
      this.spreader.style.left = "";
    } else {
      this.spreader.style.right = "";
    }
    if (this.needFullRender) {
      this.syncOverlayOffset();
    }
  }
  /**
   * Synchronize calculated top position to an element.
   */
  syncOverlayOffset() {
    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
      this.clone.wtTable.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;
    } else {
      this.clone.wtTable.spreader.style.top = "";
    }
  }
  /**
   * Scrolls horizontally to a column at the left edge of the viewport.
   *
   * @param {number} sourceCol  Column index which you want to scroll to.
   * @param {boolean} [beyondRendered]  If `true`, scrolls according to the right
   *                                    edge (left edge is by default).
   * @returns {boolean}
   */
  scrollTo(sourceCol, beyondRendered) {
    let newX = this.getTableParentOffset();
    const sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
    const mainHolder = sourceInstance.wtTable.holder;
    let scrollbarCompensation = 0;
    if (beyondRendered) {
      const columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);
      const viewportWidth = this.wot.wtViewport.getViewportWidth();
      if (columnWidth > viewportWidth) {
        beyondRendered = false;
      }
    }
    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {
      scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);
    }
    if (beyondRendered) {
      newX += this.sumCellSizes(0, sourceCol + 1);
      newX -= this.wot.wtViewport.getViewportWidth();
    } else {
      newX += this.sumCellSizes(this.wtSettings.getSetting("fixedColumnsStart"), sourceCol);
    }
    newX += scrollbarCompensation;
    return this.setScrollPosition(newX);
  }
  /**
   * Gets table parent left position.
   *
   * @returns {number}
   */
  getTableParentOffset() {
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    let offset3 = 0;
    if (!preventOverflow && this.trimmingContainer === this.domBindings.rootWindow) {
      offset3 = this.wot.wtTable.holderOffset.left;
    }
    return offset3;
  }
  /**
   * Gets the main overlay's horizontal scroll position.
   *
   * @returns {number} Main table's horizontal scroll position.
   */
  getScrollPosition() {
    return Math.abs(getScrollLeft(this.mainTableScrollableElement, this.domBindings.rootWindow));
  }
  /**
   * Gets the main overlay's horizontal overlay offset.
   *
   * @returns {number} Main table's horizontal overlay offset.
   */
  getOverlayOffset() {
    const {
      rootWindow
    } = this.domBindings;
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    let overlayOffset = 0;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "horizontal")) {
      if (this.isRtl()) {
        overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - this.getScrollPosition(), 0));
      } else {
        overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);
      }
      const rootWidth = this.wot.wtTable.getTotalWidth();
      const overlayRootWidth = this.clone.wtTable.getTotalWidth();
      const maxOffset = rootWidth - overlayRootWidth;
      if (overlayOffset > maxOffset) {
        overlayOffset = 0;
      }
    }
    return overlayOffset;
  }
  /**
   * Adds css classes to hide the header border's header (cell-selection border hiding issue).
   *
   * @param {number} position Header X position if trimming container is window or scroll top if not.
   * @returns {boolean}
   */
  adjustHeaderBordersPosition(position) {
    const masterParent = this.wot.wtTable.holder.parentNode;
    const rowHeaders = this.wtSettings.getSetting("rowHeaders");
    const fixedColumnsStart = this.wtSettings.getSetting("fixedColumnsStart");
    const totalRows = this.wtSettings.getSetting("totalRows");
    if (totalRows) {
      removeClass(masterParent, "emptyRows");
    } else {
      addClass(masterParent, "emptyRows");
    }
    let positionChanged = false;
    if (fixedColumnsStart && !rowHeaders.length) {
      addClass(masterParent, "innerBorderLeft innerBorderInlineStart");
    } else if (!fixedColumnsStart && rowHeaders.length) {
      const previousState = hasClass(masterParent, "innerBorderInlineStart");
      if (position) {
        addClass(masterParent, "innerBorderLeft innerBorderInlineStart");
        positionChanged = !previousState;
      } else {
        removeClass(masterParent, "innerBorderLeft innerBorderInlineStart");
        positionChanged = previousState;
      }
    }
    return positionChanged;
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/table/mixin/stickyRowsTop.mjs
var MIXIN_NAME5 = "stickyRowsTop";
var stickyRowsTop = {
  /**
   * Get the source index of the first rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedRow() {
    const totalRows = this.wtSettings.getSetting("totalRows");
    if (totalRows === 0) {
      return -1;
    }
    return 0;
  },
  /**
   * Get the source index of the first row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleRow() {
    return this.getFirstRenderedRow();
  },
  /**
   * Get the source index of the last rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedRow() {
    return this.getRenderedRowsCount() - 1;
  },
  /**
   * Get the source index of the last row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleRow() {
    return this.getLastRenderedRow();
  },
  /**
   * Get the number of rendered rows.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedRowsCount() {
    const totalRows = this.wtSettings.getSetting("totalRows");
    return Math.min(this.wtSettings.getSetting("fixedRowsTop"), totalRows);
  },
  /**
   * Get the number of fully visible rows in the viewport.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleRowsCount() {
    return this.getRenderedRowsCount();
  }
};
defineGetter(stickyRowsTop, "MIXIN_NAME", MIXIN_NAME5, {
  writable: false,
  enumerable: false
});
var stickyRowsTop_default = stickyRowsTop;

// node_modules/handsontable/3rdparty/walkontable/src/table/topInlineStartCorner.mjs
var TopInlineStartCornerOverlayTable = class extends table_default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_TOP_INLINE_START_CORNER);
  }
};
mixin(TopInlineStartCornerOverlayTable, stickyRowsTop_default);
mixin(TopInlineStartCornerOverlayTable, stickyColumnsStart_default);
var topInlineStartCorner_default = TopInlineStartCornerOverlayTable;

// node_modules/handsontable/3rdparty/walkontable/src/overlay/topInlineStartCorner.mjs
function _defineProperty9(obj, key, value) {
  key = _toPropertyKey9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey9(arg) {
  var key = _toPrimitive9(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive9(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var TopInlineStartCornerOverlay = class extends Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   * @param {TopOverlay} topOverlay The instance of the Top overlay.
   * @param {InlineStartOverlay} inlineStartOverlay The instance of the InlineStart overlay.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings, topOverlay, inlineStartOverlay) {
    super(wotInstance, facadeGetter, CLONE_TOP_INLINE_START_CORNER, wtSettings, domBindings);
    _defineProperty9(this, "topOverlay", void 0);
    _defineProperty9(this, "inlineStartOverlay", void 0);
    this.topOverlay = topOverlay;
    this.inlineStartOverlay = inlineStartOverlay;
  }
  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {TopInlineStartCornerOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new topInlineStartCorner_default(...args);
  }
  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting("shouldRenderTopOverlay") && this.wtSettings.getSetting("shouldRenderInlineStartOverlay");
  }
  /**
   * Updates the corner overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    this.updateTrimmingContainer();
    if (!this.wot.wtTable.holder.parentNode) {
      return false;
    }
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    if (this.trimmingContainer === this.domBindings.rootWindow) {
      const left2 = this.inlineStartOverlay.getOverlayOffset() * (this.isRtl() ? -1 : 1);
      const top2 = this.topOverlay.getOverlayOffset();
      setOverlayPosition(overlayRoot, `${left2}px`, `${top2}px`);
    } else {
      resetCssTransform(overlayRoot);
    }
    let tableHeight = outerHeight(this.clone.wtTable.TABLE);
    const tableWidth = outerWidth(this.clone.wtTable.TABLE);
    if (!this.wot.wtTable.hasDefinedSize()) {
      tableHeight = 0;
    }
    overlayRoot.style.height = `${tableHeight}px`;
    overlayRoot.style.width = `${tableWidth}px`;
    return false;
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/table/top.mjs
var TopOverlayTable = class extends table_default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, CLONE_TOP);
  }
};
mixin(TopOverlayTable, stickyRowsTop_default);
mixin(TopOverlayTable, calculatedColumns_default);
var top_default = TopOverlayTable;

// node_modules/handsontable/3rdparty/walkontable/src/overlay/top.mjs
function _defineProperty10(obj, key, value) {
  key = _toPropertyKey10(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey10(arg) {
  var key = _toPrimitive10(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive10(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var TopOverlay = class extends Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {
    super(wotInstance, facadeGetter, CLONE_TOP, wtSettings, domBindings);
    _defineProperty10(this, "cachedFixedRowsTop", -1);
    this.cachedFixedRowsTop = this.wtSettings.getSetting("fixedRowsTop");
  }
  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {TopOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new top_default(...args);
  }
  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting("shouldRenderTopOverlay");
  }
  /**
   * Updates the top overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
      return false;
    }
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const {
      rootWindow
    } = this.domBindings;
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    let overlayPosition = 0;
    let skipInnerBorderAdjusting = false;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
      const {
        wtTable
      } = this.wot;
      const hiderRect = wtTable.hider.getBoundingClientRect();
      const bottom2 = Math.ceil(hiderRect.bottom);
      const rootHeight = overlayRoot.offsetHeight;
      skipInnerBorderAdjusting = bottom2 === rootHeight;
      overlayPosition = this.getOverlayOffset();
      setOverlayPosition(overlayRoot, "0px", `${overlayPosition}px`);
    } else {
      overlayPosition = this.getScrollPosition();
      resetCssTransform(overlayRoot);
    }
    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition, skipInnerBorderAdjusting);
    this.adjustElementsSize();
    return positionChanged;
  }
  /**
   * Sets the main overlay's vertical scroll position.
   *
   * @param {number} pos The scroll position.
   * @returns {boolean}
   */
  setScrollPosition(pos) {
    const rootWindow = this.domBindings.rootWindow;
    let result = false;
    if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollY !== pos) {
      rootWindow.scrollTo(getWindowScrollLeft(rootWindow), pos);
      result = true;
    } else if (this.mainTableScrollableElement.scrollTop !== pos) {
      this.mainTableScrollableElement.scrollTop = pos;
      result = true;
    }
    return result;
  }
  /**
   * Triggers onScroll hook callback.
   */
  onScroll() {
    this.wtSettings.getSetting("onScrollHorizontally");
  }
  /**
   * Calculates total sum cells height.
   *
   * @param {number} from Row index which calculates started from.
   * @param {number} to Row index where calculation is finished.
   * @returns {number} Height sum.
   */
  sumCellSizes(from2, to2) {
    const defaultRowHeight = this.wtSettings.getSetting("defaultRowHeight");
    let row = from2;
    let sum = 0;
    while (row < to2) {
      const height = this.wot.wtTable.getRowHeight(row);
      sum += height === void 0 ? defaultRowHeight : height;
      row += 1;
    }
    return sum;
  }
  /**
   * Adjust overlay root element, childs and master table element sizes (width, height).
   *
   * @param {boolean} [force=false] When `true`, it adjusts the DOM nodes sizes for that overlay.
   */
  adjustElementsSize() {
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this.updateTrimmingContainer();
    if (this.needFullRender || force) {
      this.adjustRootElementSize();
      this.adjustRootChildrenSize();
    }
  }
  /**
   * Adjust overlay root element size (width and height).
   */
  adjustRootElementSize() {
    const {
      wtTable
    } = this.wot;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const scrollbarWidth = getScrollbarWidth(rootDocument);
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const overlayRootStyle = overlayRoot.style;
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    if (this.trimmingContainer !== rootWindow || preventOverflow === "horizontal") {
      let width = this.wot.wtViewport.getWorkspaceWidth();
      if (this.wot.wtOverlays.hasScrollbarRight) {
        width -= scrollbarWidth;
      }
      width = Math.min(width, wtTable.wtRootElement.scrollWidth);
      overlayRootStyle.width = `${width}px`;
    } else {
      overlayRootStyle.width = "";
    }
    this.clone.wtTable.holder.style.width = overlayRootStyle.width;
    let tableHeight = outerHeight(this.clone.wtTable.TABLE);
    if (!this.wot.wtTable.hasDefinedSize()) {
      tableHeight = 0;
    }
    overlayRootStyle.height = `${tableHeight}px`;
  }
  /**
   * Adjust overlay root childs size.
   */
  adjustRootChildrenSize() {
    var _selections$getCell$g;
    const {
      holder: holder2
    } = this.clone.wtTable;
    const {
      selections
    } = this.wot;
    const facade = this.facadeGetter();
    const selectionCornerOffset = Math.abs((_selections$getCell$g = selections === null || selections === void 0 ? void 0 : selections.getCell().getBorder(facade).cornerCenterPointOffset) !== null && _selections$getCell$g !== void 0 ? _selections$getCell$g : 0);
    this.clone.wtTable.hider.style.width = this.hider.style.width;
    holder2.style.width = holder2.parentNode.style.width;
    holder2.style.height = `${parseInt(holder2.parentNode.style.height, 10) + selectionCornerOffset}px`;
  }
  /**
   * Adjust the overlay dimensions and position.
   */
  applyToDOM() {
    const total = this.wtSettings.getSetting("totalRows");
    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === "number") {
      this.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;
    } else if (total === 0) {
      this.spreader.style.top = "0";
    } else {
      throw new Error("Incorrect value of the rowsRenderCalculator");
    }
    this.spreader.style.bottom = "";
    if (this.needFullRender) {
      this.syncOverlayOffset();
    }
  }
  /**
   * Synchronize calculated left position to an element.
   */
  syncOverlayOffset() {
    const styleProperty = this.isRtl() ? "right" : "left";
    const {
      spreader
    } = this.clone.wtTable;
    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === "number") {
      spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;
    } else {
      spreader.style[styleProperty] = "";
    }
  }
  /**
   * Scrolls vertically to a row.
   *
   * @param {number} sourceRow Row index which you want to scroll to.
   * @param {boolean} [bottomEdge] If `true`, scrolls according to the bottom edge (top edge is by default).
   * @returns {boolean}
   */
  scrollTo(sourceRow, bottomEdge) {
    const {
      wot,
      wtSettings
    } = this;
    const sourceInstance = wot.cloneSource ? wot.cloneSource : wot;
    const mainHolder = sourceInstance.wtTable.holder;
    let newY = this.getTableParentOffset();
    let scrollbarCompensation = 0;
    if (bottomEdge) {
      const rowHeight = this.wot.wtTable.getRowHeight(sourceRow);
      const viewportHeight = this.wot.wtViewport.getViewportHeight();
      if (rowHeight > viewportHeight) {
        bottomEdge = false;
      }
    }
    if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
      scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);
    }
    if (bottomEdge) {
      const fixedRowsBottom = wtSettings.getSetting("fixedRowsBottom");
      const totalRows = wtSettings.getSetting("totalRows");
      newY += this.sumCellSizes(0, sourceRow + 1);
      newY -= wot.wtViewport.getViewportHeight() - this.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
      newY += 1;
    } else {
      newY += this.sumCellSizes(wtSettings.getSetting("fixedRowsTop"), sourceRow);
    }
    newY += scrollbarCompensation;
    return this.setScrollPosition(newY);
  }
  /**
   * Gets table parent top position.
   *
   * @returns {number}
   */
  getTableParentOffset() {
    if (this.mainTableScrollableElement === this.domBindings.rootWindow) {
      return this.wot.wtTable.holderOffset.top;
    }
    return 0;
  }
  /**
   * Gets the main overlay's vertical scroll position.
   *
   * @returns {number} Main table's vertical scroll position.
   */
  getScrollPosition() {
    return getScrollTop(this.mainTableScrollableElement, this.domBindings.rootWindow);
  }
  /**
   * Gets the main overlay's vertical overlay offset.
   *
   * @returns {number} Main table's vertical overlay offset.
   */
  getOverlayOffset() {
    const {
      rootWindow
    } = this.domBindings;
    const preventOverflow = this.wtSettings.getSetting("preventOverflow");
    let overlayOffset = 0;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== "vertical")) {
      const rootHeight = this.wot.wtTable.getTotalHeight();
      const overlayRootHeight = this.clone.wtTable.getTotalHeight();
      const maxOffset = rootHeight - overlayRootHeight;
      overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);
      if (overlayOffset > maxOffset) {
        overlayOffset = 0;
      }
    }
    return overlayOffset;
  }
  /**
   * Adds css classes to hide the header border's header (cell-selection border hiding issue).
   *
   * @param {number} position Header Y position if trimming container is window or scroll top if not.
   * @param {boolean} [skipInnerBorderAdjusting=false] If `true` the inner border adjusting will be skipped.
   * @returns {boolean}
   */
  adjustHeaderBordersPosition(position) {
    let skipInnerBorderAdjusting = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const masterParent = this.wot.wtTable.holder.parentNode;
    const totalColumns = this.wtSettings.getSetting("totalColumns");
    if (totalColumns) {
      removeClass(masterParent, "emptyColumns");
    } else {
      addClass(masterParent, "emptyColumns");
    }
    let positionChanged = false;
    if (!skipInnerBorderAdjusting) {
      const fixedRowsTop = this.wtSettings.getSetting("fixedRowsTop");
      const areFixedRowsTopChanged = this.cachedFixedRowsTop !== fixedRowsTop;
      const columnHeaders = this.wtSettings.getSetting("columnHeaders");
      if ((areFixedRowsTopChanged || fixedRowsTop === 0) && columnHeaders.length > 0) {
        const previousState = hasClass(masterParent, "innerBorderTop");
        this.cachedFixedRowsTop = this.wtSettings.getSetting("fixedRowsTop");
        if (position || this.wtSettings.getSetting("totalRows") === 0) {
          addClass(masterParent, "innerBorderTop");
          positionChanged = !previousState;
        } else {
          removeClass(masterParent, "innerBorderTop");
          positionChanged = previousState;
        }
      }
    }
    return positionChanged;
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/overlays.mjs
function _defineProperty11(obj, key, value) {
  key = _toPropertyKey11(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey11(arg) {
  var key = _toPrimitive11(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive11(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Overlays = class {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @todo refactoring remove.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {EventManager} eventManager The walkontable event manager.
   * @param {MasterTable} wtTable The master table.
   */
  constructor(wotInstance, facadeGetter, domBindings, wtSettings, eventManager, wtTable) {
    _defineProperty11(this, "wot", null);
    _defineProperty11(this, "topOverlay", null);
    _defineProperty11(this, "bottomOverlay", null);
    _defineProperty11(this, "inlineStartOverlay", null);
    _defineProperty11(this, "topInlineStartCornerOverlay", null);
    _defineProperty11(this, "bottomInlineStartCornerOverlay", null);
    _defineProperty11(this, "browserLineHeight", void 0);
    _defineProperty11(this, "wtSettings", null);
    _defineProperty11(this, "resizeObserver", new ResizeObserver((entries) => {
      requestAnimationFrame(() => {
        if (!Array.isArray(entries) || !entries.length) {
          return;
        }
        this.wtSettings.getSetting("onContainerElementResize");
      });
    }));
    this.wot = wotInstance;
    this.wtSettings = wtSettings;
    this.domBindings = domBindings;
    this.facadeGetter = facadeGetter;
    this.wtTable = wtTable;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    this.instance = this.wot;
    this.eventManager = eventManager;
    this.scrollbarSize = getScrollbarWidth(rootDocument);
    const isOverflowHidden = rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue("overflow") === "hidden";
    this.scrollableElement = isOverflowHidden ? wtTable.holder : getScrollableElement(wtTable.TABLE);
    this.initOverlays();
    this.hasScrollbarBottom = false;
    this.hasScrollbarRight = false;
    this.destroyed = false;
    this.keyPressed = false;
    this.spreaderLastSize = {
      width: null,
      height: null
    };
    this.verticalScrolling = false;
    this.horizontalScrolling = false;
    this.initBrowserLineHeight();
    this.registerListeners();
    this.lastScrollX = rootWindow.scrollX;
    this.lastScrollY = rootWindow.scrollY;
  }
  /**
   * Get the list of references to all overlays.
   *
   * @param {boolean} [includeMaster = false] If set to `true`, the list will contain the master table as the last
   * element.
   * @returns {(TopOverlay|TopInlineStartCornerOverlay|InlineStartOverlay|BottomOverlay|BottomInlineStartCornerOverlay)[]}
   */
  getOverlays() {
    let includeMaster = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const overlays = [this.topOverlay, this.topInlineStartCornerOverlay, this.inlineStartOverlay, this.bottomOverlay, this.bottomInlineStartCornerOverlay];
    if (includeMaster) {
      overlays.push(this.wtTable);
    }
    return overlays;
  }
  /**
   * Retrieve browser line height and apply its value to `browserLineHeight`.
   *
   * @private
   */
  initBrowserLineHeight() {
    const {
      rootWindow,
      rootDocument
    } = this.domBindings;
    const computedStyle = rootWindow.getComputedStyle(rootDocument.body);
    const lineHeight = parseInt(computedStyle.lineHeight, 10);
    const lineHeightFalback = parseInt(computedStyle.fontSize, 10) * 1.2;
    this.browserLineHeight = lineHeight || lineHeightFalback;
  }
  /**
   * Prepare overlays based on user settings.
   *
   * @private
   */
  initOverlays() {
    const args = [this.wot, this.facadeGetter, this.wtSettings, this.domBindings];
    this.topOverlay = new TopOverlay(...args);
    this.bottomOverlay = new BottomOverlay(...args);
    this.inlineStartOverlay = new InlineStartOverlay(...args);
    this.topInlineStartCornerOverlay = new TopInlineStartCornerOverlay(...args, this.topOverlay, this.inlineStartOverlay);
    this.bottomInlineStartCornerOverlay = new BottomInlineStartCornerOverlay(...args, this.bottomOverlay, this.inlineStartOverlay);
  }
  /**
   * Update state of rendering, check if changed.
   *
   * @package
   * @returns {boolean} Returns `true` if changes applied to overlay needs scroll synchronization.
   */
  updateStateOfRendering() {
    let syncScroll = this.topOverlay.updateStateOfRendering();
    syncScroll = this.bottomOverlay.updateStateOfRendering() || syncScroll;
    syncScroll = this.inlineStartOverlay.updateStateOfRendering() || syncScroll;
    if (this.inlineStartOverlay.needFullRender) {
      if (this.topOverlay.needFullRender) {
        syncScroll = this.topInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;
      }
      if (this.bottomOverlay.needFullRender) {
        syncScroll = this.bottomInlineStartCornerOverlay.updateStateOfRendering() || syncScroll;
      }
    }
    return syncScroll;
  }
  /**
   * Refresh and redraw table.
   */
  refreshAll() {
    if (!this.wot.drawn) {
      return;
    }
    if (!this.wtTable.holder.parentNode) {
      this.destroy();
      return;
    }
    this.wot.draw(true);
    if (this.verticalScrolling) {
      this.inlineStartOverlay.onScroll();
    }
    if (this.horizontalScrolling) {
      this.topOverlay.onScroll();
    }
    this.verticalScrolling = false;
    this.horizontalScrolling = false;
  }
  /**
   * Register all necessary event listeners.
   */
  registerListeners() {
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const {
      mainTableScrollableElement: topOverlayScrollableElement
    } = this.topOverlay;
    const {
      mainTableScrollableElement: inlineStartOverlayScrollableElement
    } = this.inlineStartOverlay;
    this.eventManager.addEventListener(rootDocument.documentElement, "keydown", (event2) => this.onKeyDown(event2));
    this.eventManager.addEventListener(rootDocument.documentElement, "keyup", () => this.onKeyUp());
    this.eventManager.addEventListener(rootDocument, "visibilitychange", () => this.onKeyUp());
    this.eventManager.addEventListener(topOverlayScrollableElement, "scroll", (event2) => this.onTableScroll(event2), {
      passive: true
    });
    if (topOverlayScrollableElement !== inlineStartOverlayScrollableElement) {
      this.eventManager.addEventListener(inlineStartOverlayScrollableElement, "scroll", (event2) => this.onTableScroll(event2), {
        passive: true
      });
    }
    const isHighPixelRatio = rootWindow.devicePixelRatio && rootWindow.devicePixelRatio > 1;
    const isScrollOnWindow = this.scrollableElement === rootWindow;
    const preventWheel = this.wtSettings.getSetting("preventWheel");
    const wheelEventOptions = {
      passive: isScrollOnWindow
    };
    if (preventWheel || isHighPixelRatio || !isChrome()) {
      this.eventManager.addEventListener(this.wtTable.wtRootElement, "wheel", (event2) => this.onCloneWheel(event2, preventWheel), wheelEventOptions);
    }
    const overlays = [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];
    overlays.forEach((overlay) => {
      if (overlay && overlay.needFullRender) {
        const {
          holder: holder2
        } = overlay.clone.wtTable;
        this.eventManager.addEventListener(holder2, "wheel", (event2) => this.onCloneWheel(event2, preventWheel), wheelEventOptions);
      }
    });
    let resizeTimeout;
    this.eventManager.addEventListener(rootWindow, "resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        this.wtSettings.getSetting("onWindowResize");
      }, 200);
    });
    if (!isScrollOnWindow) {
      this.resizeObserver.observe(this.wtTable.wtRootElement.parentElement);
    }
  }
  /**
   * Deregister all previously registered listeners.
   */
  deregisterListeners() {
    this.eventManager.clearEvents(true);
  }
  /**
   * Scroll listener.
   *
   * @param {Event} event The mouse event object.
   */
  onTableScroll(event2) {
    const rootWindow = this.domBindings.rootWindow;
    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;
    const masterVertical = this.topOverlay.mainTableScrollableElement;
    const target = event2.target;
    if (this.keyPressed) {
      if (masterVertical !== rootWindow && target !== rootWindow && !event2.target.contains(masterVertical) || masterHorizontal !== rootWindow && target !== rootWindow && !event2.target.contains(masterHorizontal)) {
        return;
      }
    }
    this.syncScrollPositions(event2);
  }
  /**
   * Wheel listener for cloned overlays.
   *
   * @param {Event} event The mouse event object.
   * @param {boolean} preventDefault If `true`, the `preventDefault` will be called on event object.
   */
  onCloneWheel(event2, preventDefault) {
    const {
      rootWindow
    } = this.domBindings;
    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;
    const masterVertical = this.topOverlay.mainTableScrollableElement;
    const target = event2.target;
    const shouldNotWheelVertically = masterVertical !== rootWindow && target !== rootWindow && !target.contains(masterVertical);
    const shouldNotWheelHorizontally = masterHorizontal !== rootWindow && target !== rootWindow && !target.contains(masterHorizontal);
    if (this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally)) {
      return;
    }
    const isScrollPossible = this.translateMouseWheelToScroll(event2);
    if (preventDefault || this.scrollableElement !== rootWindow && isScrollPossible) {
      event2.preventDefault();
    }
  }
  /**
   * Key down listener.
   *
   * @param {Event} event The keyboard event object.
   */
  onKeyDown(event2) {
    this.keyPressed = isKey(event2.keyCode, "ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT");
  }
  /**
   * Key up listener.
   */
  onKeyUp() {
    this.keyPressed = false;
  }
  /**
   * Translate wheel event into scroll event and sync scroll overlays position.
   *
   * @private
   * @param {Event} event The mouse event object.
   * @returns {boolean}
   */
  translateMouseWheelToScroll(event2) {
    let deltaY = isNaN(event2.deltaY) ? -1 * event2.wheelDeltaY : event2.deltaY;
    let deltaX = isNaN(event2.deltaX) ? -1 * event2.wheelDeltaX : event2.deltaX;
    if (event2.deltaMode === 1) {
      deltaX += deltaX * this.browserLineHeight;
      deltaY += deltaY * this.browserLineHeight;
    }
    const isScrollVerticallyPossible = this.scrollVertically(deltaY);
    const isScrollHorizontallyPossible = this.scrollHorizontally(deltaX);
    return isScrollVerticallyPossible || isScrollHorizontallyPossible;
  }
  /**
   * Scrolls main scrollable element horizontally.
   *
   * @param {number} delta Relative value to scroll.
   * @returns {boolean}
   */
  scrollVertically(delta) {
    const previousScroll = this.scrollableElement.scrollTop;
    this.scrollableElement.scrollTop += delta;
    return previousScroll !== this.scrollableElement.scrollTop;
  }
  /**
   * Scrolls main scrollable element horizontally.
   *
   * @param {number} delta Relative value to scroll.
   * @returns {boolean}
   */
  scrollHorizontally(delta) {
    const previousScroll = this.scrollableElement.scrollLeft;
    this.scrollableElement.scrollLeft += delta;
    return previousScroll !== this.scrollableElement.scrollLeft;
  }
  /**
   * Synchronize scroll position between master table and overlay table.
   *
   * @private
   */
  syncScrollPositions() {
    if (this.destroyed) {
      return;
    }
    const {
      rootWindow
    } = this.domBindings;
    const topHolder = this.topOverlay.clone.wtTable.holder;
    const leftHolder = this.inlineStartOverlay.clone.wtTable.holder;
    const [scrollLeft, scrollTop] = [this.scrollableElement.scrollLeft, this.scrollableElement.scrollTop];
    this.horizontalScrolling = topHolder.scrollLeft !== scrollLeft || this.lastScrollX !== rootWindow.scrollX;
    this.verticalScrolling = leftHolder.scrollTop !== scrollTop || this.lastScrollY !== rootWindow.scrollY;
    this.lastScrollX = rootWindow.scrollX;
    this.lastScrollY = rootWindow.scrollY;
    if (this.horizontalScrolling) {
      topHolder.scrollLeft = scrollLeft;
      const bottomHolder = this.bottomOverlay.needFullRender ? this.bottomOverlay.clone.wtTable.holder : null;
      if (bottomHolder) {
        bottomHolder.scrollLeft = scrollLeft;
      }
    }
    if (this.verticalScrolling) {
      leftHolder.scrollTop = scrollTop;
    }
    this.refreshAll();
  }
  /**
   * Synchronize overlay scrollbars with the master scrollbar.
   */
  syncScrollWithMaster() {
    const master = this.topOverlay.mainTableScrollableElement;
    const {
      scrollLeft,
      scrollTop
    } = master;
    if (this.topOverlay.needFullRender) {
      this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;
    }
    if (this.bottomOverlay.needFullRender) {
      this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft;
    }
    if (this.inlineStartOverlay.needFullRender) {
      this.inlineStartOverlay.clone.wtTable.holder.scrollTop = scrollTop;
    }
  }
  /**
   * Update the main scrollable elements for all the overlays.
   */
  updateMainScrollableElements() {
    this.deregisterListeners();
    this.inlineStartOverlay.updateMainScrollableElement();
    this.topOverlay.updateMainScrollableElement();
    if (this.bottomOverlay.needFullRender) {
      this.bottomOverlay.updateMainScrollableElement();
    }
    const {
      wtTable
    } = this;
    const {
      rootWindow
    } = this.domBindings;
    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue("overflow") === "hidden") {
      this.scrollableElement = wtTable.holder;
    } else {
      this.scrollableElement = getScrollableElement(wtTable.TABLE);
    }
    this.registerListeners();
  }
  /**
   *
   */
  destroy() {
    this.resizeObserver.disconnect();
    this.eventManager.destroy();
    this.topOverlay.destroy();
    if (this.bottomOverlay.clone) {
      this.bottomOverlay.destroy();
    }
    this.inlineStartOverlay.destroy();
    if (this.topInlineStartCornerOverlay) {
      this.topInlineStartCornerOverlay.destroy();
    }
    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {
      this.bottomInlineStartCornerOverlay.destroy();
    }
    this.destroyed = true;
  }
  /**
   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
   *                                   the data. It will only work if Table.draw() does not force
   *                                   rendering anyway.
   */
  refresh() {
    let fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const wasSpreaderSizeUpdated = this.updateLastSpreaderSize();
    if (wasSpreaderSizeUpdated) {
      this.adjustElementsSize();
    }
    if (this.bottomOverlay.clone) {
      this.bottomOverlay.refresh(fastDraw);
    }
    this.inlineStartOverlay.refresh(fastDraw);
    this.topOverlay.refresh(fastDraw);
    if (this.topInlineStartCornerOverlay) {
      this.topInlineStartCornerOverlay.refresh(fastDraw);
    }
    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {
      this.bottomInlineStartCornerOverlay.refresh(fastDraw);
    }
  }
  /**
   * Update the last cached spreader size with the current size.
   *
   * @returns {boolean} `true` if the lastSpreaderSize cache was updated, `false` otherwise.
   */
  updateLastSpreaderSize() {
    const spreader = this.wtTable.spreader;
    const width = spreader.clientWidth;
    const height = spreader.clientHeight;
    const needsUpdating = width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height;
    if (needsUpdating) {
      this.spreaderLastSize.width = width;
      this.spreaderLastSize.height = height;
    }
    return needsUpdating;
  }
  /**
   * Adjust overlays elements size and master table size.
   *
   * @param {boolean} [force=false] When `true`, it adjust the DOM nodes sizes for all overlays.
   */
  adjustElementsSize() {
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const {
      wtViewport
    } = this.wot;
    const {
      wtTable
    } = this;
    const totalColumns = this.wtSettings.getSetting("totalColumns");
    const totalRows = this.wtSettings.getSetting("totalRows");
    const headerRowSize = wtViewport.getRowHeaderWidth();
    const headerColumnSize = wtViewport.getColumnHeaderHeight();
    const hiderStyle = wtTable.hider.style;
    hiderStyle.width = `${headerRowSize + this.inlineStartOverlay.sumCellSizes(0, totalColumns)}px`;
    hiderStyle.height = `${headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1}px`;
    if (this.scrollbarSize > 0) {
      const {
        scrollHeight: rootElemScrollHeight,
        scrollWidth: rootElemScrollWidth
      } = wtTable.wtRootElement;
      const {
        scrollHeight: holderScrollHeight,
        scrollWidth: holderScrollWidth
      } = wtTable.holder;
      this.hasScrollbarRight = rootElemScrollHeight < holderScrollHeight;
      this.hasScrollbarBottom = rootElemScrollWidth < holderScrollWidth;
      if (this.hasScrollbarRight && wtTable.hider.scrollWidth + this.scrollbarSize > rootElemScrollWidth) {
        this.hasScrollbarBottom = true;
      } else if (this.hasScrollbarBottom && wtTable.hider.scrollHeight + this.scrollbarSize > rootElemScrollHeight) {
        this.hasScrollbarRight = true;
      }
    }
    this.topOverlay.adjustElementsSize(force);
    this.inlineStartOverlay.adjustElementsSize(force);
    this.bottomOverlay.adjustElementsSize(force);
  }
  /**
   *
   */
  applyToDOM() {
    if (!this.wtTable.isVisible()) {
      return;
    }
    this.topOverlay.applyToDOM();
    if (this.bottomOverlay.clone) {
      this.bottomOverlay.applyToDOM();
    }
    this.inlineStartOverlay.applyToDOM();
  }
  /**
   * Get the parent overlay of the provided element.
   *
   * @param {HTMLElement} element An element to process.
   * @returns {object|null}
   */
  getParentOverlay(element) {
    if (!element) {
      return null;
    }
    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];
    let result = null;
    arrayEach(overlays, (overlay) => {
      if (!overlay) {
        return;
      }
      if (overlay.clone && overlay.clone.wtTable.TABLE.contains(element)) {
        result = overlay.clone;
      }
    });
    return result;
  }
  /**
   * Synchronize the class names between the main overlay table and the tables on the other overlays.
   *
   */
  syncOverlayTableClassNames() {
    const masterTable = this.wtTable.TABLE;
    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];
    arrayEach(overlays, (elem) => {
      if (!elem) {
        return;
      }
      elem.clone.wtTable.TABLE.className = masterTable.className;
    });
  }
};
var overlays_default = Overlays;

// node_modules/handsontable/3rdparty/walkontable/src/settings.mjs
function _defineProperty12(obj, key, value) {
  key = _toPropertyKey12(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey12(arg) {
  var key = _toPrimitive12(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive12(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Settings = class {
  /**
   * @param {SettingsPure} settings The user defined settings.
   */
  constructor(settings) {
    _defineProperty12(this, "settings", {});
    _defineProperty12(this, "defaults", Object.freeze(this.getDefaults()));
    objectEach(this.defaults, (value, key) => {
      if (settings[key] !== void 0) {
        this.settings[key] = settings[key];
      } else if (value === void 0) {
        throw new Error(`A required setting "${key}" was not provided`);
      } else {
        this.settings[key] = value;
      }
    });
  }
  /**
   * Generate defaults for a settings.
   * Void 0 means it is required, null means it can be empty.
   *
   * @private
   * @returns {SettingsPure}
   */
  getDefaults() {
    return {
      facade: void 0,
      table: void 0,
      // Determines whether the Walkontable instance is used as dataset viewer. When its instance is used as
      // a context menu, autocomplete list, etc, the returned value is `false`.
      isDataViewInstance: true,
      // presentation mode
      externalRowCalculator: false,
      stretchH: "none",
      // values: all, last, none
      currentRowClassName: null,
      currentColumnClassName: null,
      preventOverflow() {
        return false;
      },
      preventWheel: false,
      // data source
      data: void 0,
      freezeOverlays: false,
      // Number of renderable columns for the left overlay.
      fixedColumnsStart: 0,
      // Number of renderable rows for the top overlay.
      fixedRowsTop: 0,
      // Number of renderable rows for the bottom overlay.
      fixedRowsBottom: 0,
      // Enable the inline start overlay when conditions are met (left for LTR and right for RTL document mode).
      shouldRenderInlineStartOverlay: () => {
        return this.getSetting("fixedColumnsStart") > 0 || this.getSetting("rowHeaders").length > 0;
      },
      // Enable the top overlay when conditions are met.
      shouldRenderTopOverlay: () => {
        return this.getSetting("fixedRowsTop") > 0 || this.getSetting("columnHeaders").length > 0;
      },
      // Enable the bottom overlay when conditions are met.
      shouldRenderBottomOverlay: () => {
        return this.getSetting("fixedRowsBottom") > 0;
      },
      minSpareRows: 0,
      // this must be array of functions: [function (row, TH) {}]
      rowHeaders() {
        return [];
      },
      // this must be array of functions: [function (column, TH) {}]
      columnHeaders() {
        return [];
      },
      totalRows: void 0,
      totalColumns: void 0,
      cellRenderer: (row, column, TD) => {
        const cellData = this.getSetting("data", row, column);
        fastInnerText(TD, cellData === void 0 || cellData === null ? "" : cellData);
      },
      // columnWidth: 50,
      columnWidth() {
      },
      rowHeight() {
      },
      defaultRowHeight: 23,
      defaultColumnWidth: 50,
      selections: null,
      hideBorderOnMouseDownOver: false,
      viewportRowCalculatorOverride: null,
      viewportColumnCalculatorOverride: null,
      // callbacks
      onCellMouseDown: null,
      onCellContextMenu: null,
      onCellMouseOver: null,
      onCellMouseOut: null,
      onCellMouseUp: null,
      //    onCellMouseOut: null,
      onCellDblClick: null,
      onCellCornerMouseDown: null,
      onCellCornerDblClick: null,
      beforeDraw: null,
      onDraw: null,
      onBeforeRemoveCellClassNames: null,
      onAfterDrawSelection: null,
      onBeforeDrawBorders: null,
      onScrollVertically: null,
      onScrollHorizontally: null,
      onBeforeTouchScroll: null,
      onAfterMomentumScroll: null,
      onBeforeStretchingColumnWidth: (width) => width,
      onModifyRowHeaderWidth: null,
      onModifyGetCellCoords: null,
      onBeforeHighlightingRowHeader: (sourceRow) => sourceRow,
      onBeforeHighlightingColumnHeader: (sourceCol) => sourceCol,
      onWindowResize: null,
      onContainerElementResize: null,
      renderAllRows: false,
      groups: false,
      rowHeaderWidth: null,
      columnHeaderHeight: null,
      headerClassName: null,
      rtlMode: false
    };
  }
  /**
   * Update settings.
   *
   * @param {object} settings The singular settings to update or if passed as object to merge with.
   * @param {*} value The value to set if the first argument is passed as string.
   * @returns {Settings}
   */
  update(settings, value) {
    if (value === void 0) {
      objectEach(settings, (settingValue, key) => {
        this.settings[key] = settingValue;
      });
    } else {
      this.settings[settings] = value;
    }
    return this;
  }
  /**
   * Get setting by name.
   *
   * @param {$Keys<SettingsPure>} key The settings key to retrieve.
   * @param {*} [param1] Additional parameter passed to the options defined as function.
   * @param {*} [param2] Additional parameter passed to the options defined as function.
   * @param {*} [param3] Additional parameter passed to the options defined as function.
   * @param {*} [param4] Additional parameter passed to the options defined as function.
   * @returns {*}
   */
  getSetting(key, param1, param2, param3, param4) {
    if (typeof this.settings[key] === "function") {
      return this.settings[key](param1, param2, param3, param4);
    } else if (param1 !== void 0 && Array.isArray(this.settings[key])) {
      return this.settings[key][param1];
    }
    return this.settings[key];
  }
  /**
   * Get a setting value without any evaluation.
   *
   * @param {string} key The settings key to retrieve.
   * @returns {*}
   */
  getSettingPure(key) {
    return this.settings[key];
  }
  /**
   * Checks if setting exists.
   *
   * @param {boolean} key The settings key to check.
   * @returns {boolean}
   */
  has(key) {
    return !!this.settings[key];
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/table/master.mjs
var MasterTable = class extends table_default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, "master");
  }
  alignOverlaysWithTrimmingContainer() {
    const trimmingElement = getTrimmingContainer(this.wtRootElement);
    const {
      rootWindow
    } = this.domBindings;
    if (trimmingElement === rootWindow) {
      const preventOverflow = this.wtSettings.getSetting("preventOverflow");
      if (!preventOverflow) {
        this.holder.style.overflow = "visible";
        this.wtRootElement.style.overflow = "visible";
      }
    } else {
      const trimmingElementParent = trimmingElement.parentElement;
      const trimmingHeight = getStyle(trimmingElement, "height", rootWindow);
      const trimmingOverflow = getStyle(trimmingElement, "overflow", rootWindow);
      const holderStyle = this.holder.style;
      const {
        scrollWidth,
        scrollHeight
      } = trimmingElement;
      let {
        width,
        height
      } = trimmingElement.getBoundingClientRect();
      const overflow = ["auto", "hidden", "scroll"];
      if (trimmingElementParent && overflow.includes(trimmingOverflow)) {
        const cloneNode = trimmingElement.cloneNode(false);
        cloneNode.style.overflow = "auto";
        cloneNode.style.position = "absolute";
        if (trimmingElement.nextElementSibling) {
          trimmingElementParent.insertBefore(cloneNode, trimmingElement.nextElementSibling);
        } else {
          trimmingElementParent.appendChild(cloneNode);
        }
        const cloneHeight = parseInt(getComputedStyle(cloneNode, rootWindow).height, 10);
        trimmingElementParent.removeChild(cloneNode);
        if (cloneHeight === 0) {
          height = 0;
        }
      }
      height = Math.min(height, scrollHeight);
      holderStyle.height = trimmingHeight === "auto" ? "auto" : `${height}px`;
      width = Math.min(width, scrollWidth);
      holderStyle.width = `${width}px`;
      holderStyle.overflow = "";
      this.hasTableHeight = holderStyle.height === "auto" ? true : height > 0;
      this.hasTableWidth = width > 0;
    }
    this.isTableVisible = isVisible(this.TABLE);
  }
  markOversizedColumnHeaders() {
    const {
      wtSettings
    } = this;
    const {
      wtViewport
    } = this.dataAccessObject;
    const overlayName = "master";
    const columnHeaders = wtSettings.getSetting("columnHeaders");
    const columnHeadersCount = columnHeaders.length;
    if (columnHeadersCount && !wtViewport.hasOversizedColumnHeadersMarked[overlayName]) {
      const rowHeaders = wtSettings.getSetting("rowHeaders");
      const rowHeaderCount = rowHeaders.length;
      const columnCount = this.getRenderedColumnsCount();
      for (let i = 0; i < columnHeadersCount; i++) {
        for (let renderedColumnIndex = -1 * rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
          this.markIfOversizedColumnHeader(renderedColumnIndex);
        }
      }
      wtViewport.hasOversizedColumnHeadersMarked[overlayName] = true;
    }
  }
};
mixin(MasterTable, calculatedRows_default);
mixin(MasterTable, calculatedColumns_default);
var master_default = MasterTable;

// node_modules/handsontable/3rdparty/walkontable/src/viewport.mjs
var Viewport = class {
  /**
   * @param {ViewportDao} dataAccessObject The Walkontable instance.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {EventManager} eventManager The instance event manager.
   * @param {Table} wtTable The table.
   */
  constructor(dataAccessObject, domBindings, wtSettings, eventManager, wtTable) {
    this.dataAccessObject = dataAccessObject;
    this.wot = dataAccessObject.wot;
    this.instance = this.wot;
    this.domBindings = domBindings;
    this.wtSettings = wtSettings;
    this.wtTable = wtTable;
    this.oversizedRows = [];
    this.oversizedColumnHeaders = [];
    this.hasOversizedColumnHeadersMarked = {};
    this.clientHeight = 0;
    this.containerWidth = NaN;
    this.rowHeaderWidth = NaN;
    this.rowsVisibleCalculator = null;
    this.columnsVisibleCalculator = null;
    this.eventManager = eventManager;
    this.eventManager.addEventListener(this.domBindings.rootWindow, "resize", () => {
      this.clientHeight = this.getWorkspaceHeight();
    });
  }
  /**
   * @returns {number}
   */
  getWorkspaceHeight() {
    const currentDocument = this.domBindings.rootDocument;
    const trimmingContainer = this.dataAccessObject.topOverlayTrimmingContainer;
    let height = 0;
    if (trimmingContainer === this.domBindings.rootWindow) {
      height = currentDocument.documentElement.clientHeight;
    } else {
      const elemHeight = outerHeight(trimmingContainer);
      height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;
    }
    return height;
  }
  getWorkspaceWidth() {
    const {
      wtSettings
    } = this;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const trimmingContainer = this.dataAccessObject.inlineStartOverlayTrimmingContainer;
    const docOffsetWidth = rootDocument.documentElement.offsetWidth;
    const totalColumns = wtSettings.getSetting("totalColumns");
    const preventOverflow = wtSettings.getSetting("preventOverflow");
    const isRtl = wtSettings.getSetting("rtlMode");
    const tableRect = this.wtTable.TABLE.getBoundingClientRect();
    const inlineStart = isRtl ? tableRect.right - docOffsetWidth : tableRect.left;
    const tableOffset = docOffsetWidth - inlineStart;
    let width;
    let overflow;
    if (preventOverflow) {
      return outerWidth(this.wtTable.wtRootElement);
    }
    if (wtSettings.getSetting("freezeOverlays")) {
      width = Math.min(tableOffset, docOffsetWidth);
    } else {
      width = Math.min(this.getContainerFillWidth(), tableOffset, docOffsetWidth);
    }
    if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {
      return rootDocument.documentElement.clientWidth;
    }
    if (trimmingContainer !== rootWindow) {
      overflow = getStyle(this.dataAccessObject.inlineStartOverlayTrimmingContainer, "overflow", rootWindow);
      if (overflow === "scroll" || overflow === "hidden" || overflow === "auto") {
        return Math.max(width, trimmingContainer.clientWidth);
      }
    }
    const stretchSetting = wtSettings.getSetting("stretchH");
    if (stretchSetting === "none" || !stretchSetting) {
      return Math.max(width, outerWidth(this.wtTable.TABLE));
    }
    return width;
  }
  /**
   * Checks if viewport has vertical scroll.
   *
   * @returns {boolean}
   */
  hasVerticalScroll() {
    return this.wtTable.hider.offsetHeight > this.getWorkspaceHeight();
  }
  /**
   * Checks if viewport has horizontal scroll.
   *
   * @returns {boolean}
   */
  hasHorizontalScroll() {
    return this.wtTable.hider.offsetWidth > this.getWorkspaceWidth();
  }
  /**
   * @param {number} from The visual column index from the width sum is start calculated.
   * @param {number} length The length of the column to traverse.
   * @returns {number}
   */
  sumColumnWidths(from2, length) {
    let sum = 0;
    let column = from2;
    while (column < length) {
      sum += this.wtTable.getColumnWidth(column);
      column += 1;
    }
    return sum;
  }
  /**
   * @returns {number}
   */
  getContainerFillWidth() {
    if (this.containerWidth) {
      return this.containerWidth;
    }
    const mainContainer = this.wtTable.holder;
    const dummyElement = this.domBindings.rootDocument.createElement("div");
    dummyElement.style.width = "100%";
    dummyElement.style.height = "1px";
    mainContainer.appendChild(dummyElement);
    const fillWidth = dummyElement.offsetWidth;
    this.containerWidth = fillWidth;
    mainContainer.removeChild(dummyElement);
    return fillWidth;
  }
  /**
   * @returns {number}
   */
  getWorkspaceOffset() {
    return offset2(this.wtTable.TABLE);
  }
  /**
   * @returns {number}
   */
  getColumnHeaderHeight() {
    const columnHeaders = this.wtSettings.getSetting("columnHeaders");
    if (!columnHeaders.length) {
      this.columnHeaderHeight = 0;
    } else if (isNaN(this.columnHeaderHeight)) {
      this.columnHeaderHeight = outerHeight(this.wtTable.THEAD);
    }
    return this.columnHeaderHeight;
  }
  /**
   * @returns {number}
   */
  getViewportHeight() {
    let containerHeight = this.getWorkspaceHeight();
    if (containerHeight === Infinity) {
      return containerHeight;
    }
    const columnHeaderHeight = this.getColumnHeaderHeight();
    if (columnHeaderHeight > 0) {
      containerHeight -= columnHeaderHeight;
    }
    return containerHeight;
  }
  /**
   * @returns {number}
   */
  getRowHeaderWidth() {
    const rowHeadersWidthSetting = this.wtSettings.getSetting("rowHeaderWidth");
    const rowHeaders = this.wtSettings.getSetting("rowHeaders");
    if (rowHeadersWidthSetting) {
      this.rowHeaderWidth = 0;
      for (let i = 0, len = rowHeaders.length; i < len; i++) {
        this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;
      }
    }
    if (isNaN(this.rowHeaderWidth)) {
      if (rowHeaders.length) {
        let TH = this.wtTable.TABLE.querySelector("TH");
        this.rowHeaderWidth = 0;
        for (let i = 0, len = rowHeaders.length; i < len; i++) {
          if (TH) {
            this.rowHeaderWidth += outerWidth(TH);
            TH = TH.nextSibling;
          } else {
            this.rowHeaderWidth += 50;
          }
        }
      } else {
        this.rowHeaderWidth = 0;
      }
    }
    this.rowHeaderWidth = this.wtSettings.getSetting("onModifyRowHeaderWidth", this.rowHeaderWidth) || this.rowHeaderWidth;
    return this.rowHeaderWidth;
  }
  /**
   * @returns {number}
   */
  getViewportWidth() {
    const containerWidth = this.getWorkspaceWidth();
    if (containerWidth === Infinity) {
      return containerWidth;
    }
    const rowHeaderWidth = this.getRowHeaderWidth();
    if (rowHeaderWidth > 0) {
      return containerWidth - rowHeaderWidth;
    }
    return containerWidth;
  }
  /**
   * Creates:
   * - rowsRenderCalculator (before draw, to qualify rows for rendering)
   * - rowsVisibleCalculator (after draw, to measure which rows are actually visible).
   *
   * @param {number} calculationType The render type ID, which determines for what type of
   *                                 calculation calculator is created.
   * @returns {ViewportRowsCalculator}
   */
  createRowsCalculator() {
    let calculationType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RENDER_TYPE;
    const {
      wtSettings,
      wtTable
    } = this;
    let height;
    let scrollbarHeight;
    let fixedRowsHeight;
    this.rowHeaderWidth = NaN;
    if (wtSettings.getSetting("renderAllRows") && calculationType === RENDER_TYPE) {
      height = Infinity;
    } else {
      height = this.getViewportHeight();
    }
    let pos = this.dataAccessObject.topScrollPosition - this.dataAccessObject.topParentOffset;
    const fixedRowsTop = wtSettings.getSetting("fixedRowsTop");
    const fixedRowsBottom = wtSettings.getSetting("fixedRowsBottom");
    const totalRows = wtSettings.getSetting("totalRows");
    if (fixedRowsTop && pos >= 0) {
      fixedRowsHeight = this.dataAccessObject.topOverlay.sumCellSizes(0, fixedRowsTop);
      pos += fixedRowsHeight;
      height -= fixedRowsHeight;
    }
    if (fixedRowsBottom && this.dataAccessObject.bottomOverlay.clone) {
      fixedRowsHeight = this.dataAccessObject.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
      height -= fixedRowsHeight;
    }
    if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {
      scrollbarHeight = 0;
    } else {
      scrollbarHeight = getScrollbarWidth(this.domBindings.rootDocument);
    }
    return new viewportRows_default({
      viewportSize: height,
      scrollOffset: pos,
      totalItems: wtSettings.getSetting("totalRows"),
      itemSizeFn: (sourceRow) => wtTable.getRowHeight(sourceRow),
      overrideFn: wtSettings.getSettingPure("viewportRowCalculatorOverride"),
      calculationType,
      scrollbarHeight
    });
  }
  /**
   * Creates:
   * - columnsRenderCalculator (before draw, to qualify columns for rendering)
   * - columnsVisibleCalculator (after draw, to measure which columns are actually visible).
   *
   * @param {number} calculationType The render type ID, which determines for what type of
   *                                 calculation calculator is created.
   * @returns {ViewportColumnsCalculator}
   */
  createColumnsCalculator() {
    let calculationType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RENDER_TYPE;
    const {
      wtSettings,
      wtTable
    } = this;
    let width = this.getViewportWidth();
    let pos = Math.abs(this.dataAccessObject.inlineStartScrollPosition) - this.dataAccessObject.inlineStartParentOffset;
    this.columnHeaderHeight = NaN;
    const fixedColumnsStart = wtSettings.getSetting("fixedColumnsStart");
    if (fixedColumnsStart && pos >= 0) {
      const fixedColumnsWidth = this.dataAccessObject.inlineStartOverlay.sumCellSizes(0, fixedColumnsStart);
      pos += fixedColumnsWidth;
      width -= fixedColumnsWidth;
    }
    if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {
      width -= getScrollbarWidth(this.domBindings.rootDocument);
    }
    return new viewportColumns_default({
      viewportSize: width,
      scrollOffset: pos,
      totalItems: wtSettings.getSetting("totalColumns"),
      itemSizeFn: (sourceCol) => wtTable.getColumnWidth(sourceCol),
      overrideFn: wtSettings.getSettingPure("viewportColumnCalculatorOverride"),
      calculationType,
      stretchMode: wtSettings.getSetting("stretchH"),
      stretchingItemWidthFn: (stretchedWidth, column) => {
        return wtSettings.getSetting("onBeforeStretchingColumnWidth", stretchedWidth, column);
      },
      inlineStartOffset: this.dataAccessObject.inlineStartParentOffset
    });
  }
  /**
   * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and
   * cols should be rendered).
   *
   * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.
   *                           If `false` or `undefined`, will perform a full redraw.
   * @returns {boolean} The fastDraw value, possibly modified.
   */
  createRenderCalculators() {
    let fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let runFastDraw = fastDraw;
    if (runFastDraw) {
      const proposedRowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);
      const proposedColumnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);
      if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {
        runFastDraw = false;
      }
    }
    if (!runFastDraw) {
      this.rowsRenderCalculator = this.createRowsCalculator(RENDER_TYPE);
      this.columnsRenderCalculator = this.createColumnsCalculator(RENDER_TYPE);
    }
    this.rowsVisibleCalculator = null;
    this.columnsVisibleCalculator = null;
    return runFastDraw;
  }
  /**
   * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are
   * the actually fully visible rows and columns).
   */
  createVisibleCalculators() {
    this.rowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);
    this.columnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);
  }
  /**
   * Returns information whether proposedRowsVisibleCalculator viewport
   * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).
   *
   * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.
   * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).
   *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).
   */
  areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {
    if (!this.rowsVisibleCalculator) {
      return false;
    }
    const {
      startRow,
      endRow,
      isVisibleInTrimmingContainer
    } = proposedRowsVisibleCalculator;
    if (startRow === null && endRow === null) {
      return !isVisibleInTrimmingContainer;
    }
    const {
      startRow: renderedStartRow,
      endRow: renderedEndRow
    } = this.rowsRenderCalculator;
    if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {
      return false;
    } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wtSettings.getSetting("totalRows") - 1) {
      return false;
    }
    return true;
  }
  /**
   * Returns information whether proposedColumnsVisibleCalculator viewport
   * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).
   *
   * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.
   * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).
   *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).
   */
  areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {
    if (!this.columnsVisibleCalculator) {
      return false;
    }
    const {
      startColumn,
      endColumn,
      isVisibleInTrimmingContainer
    } = proposedColumnsVisibleCalculator;
    if (startColumn === null && endColumn === null) {
      return !isVisibleInTrimmingContainer;
    }
    const {
      startColumn: renderedStartColumn,
      endColumn: renderedEndColumn
    } = this.columnsRenderCalculator;
    if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {
      return false;
    } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wtSettings.getSetting("totalColumns") - 1) {
      return false;
    }
    return true;
  }
  /**
   * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.
   */
  resetHasOversizedColumnHeadersMarked() {
    objectEach(this.hasOversizedColumnHeadersMarked, (value, key, object) => {
      object[key] = void 0;
    });
  }
};
var viewport_default = Viewport;

// node_modules/handsontable/3rdparty/walkontable/src/core/core.mjs
var Walkontable = class extends CoreAbstract {
  /**
   * @param {HTMLTableElement} table Main table.
   * @param {SettingsPure} settings The Walkontable settings.
   */
  constructor(table, settings) {
    super(table, new Settings(settings));
    const facadeGetter = this.wtSettings.getSetting("facade", this);
    this.wtTable = new master_default(this.getTableDao(), facadeGetter, this.domBindings, this.wtSettings);
    this.wtViewport = new viewport_default(this.getViewportDao(), this.domBindings, this.wtSettings, this.eventManager, this.wtTable);
    this.selections = this.wtSettings.getSetting("selections");
    this.wtEvent = new event_default(facadeGetter, this.domBindings, this.wtSettings, this.eventManager, this.wtTable, this.selections);
    this.wtOverlays = new overlays_default(
      // TODO create DAO and remove reference to the Walkontable instance.
      this,
      facadeGetter,
      this.domBindings,
      this.wtSettings,
      this.eventManager,
      this.wtTable
    );
    this.exportSettingsAsClassNames();
    this.findOriginalHeaders();
  }
  /**
   * Export settings as class names added to the parent element of the table.
   */
  exportSettingsAsClassNames() {
    const toExport = {
      rowHeaders: "htRowHeaders",
      columnHeaders: "htColumnHeaders"
    };
    const allClassNames = [];
    const newClassNames = [];
    objectEach(toExport, (className, key) => {
      if (this.wtSettings.getSetting(key).length) {
        newClassNames.push(className);
      }
      allClassNames.push(className);
    });
    removeClass(this.wtTable.wtRootElement.parentNode, allClassNames);
    addClass(this.wtTable.wtRootElement.parentNode, newClassNames);
  }
  /**
   * @returns {ViewportDao}
   */
  getViewportDao() {
    const wot = this;
    return {
      get wot() {
        return wot;
      },
      get topOverlayTrimmingContainer() {
        return wot.wtOverlays.topOverlay.trimmingContainer;
      },
      get inlineStartOverlayTrimmingContainer() {
        return wot.wtOverlays.inlineStartOverlay.trimmingContainer;
      },
      get topScrollPosition() {
        return wot.wtOverlays.topOverlay.getScrollPosition();
      },
      get topParentOffset() {
        return wot.wtOverlays.topOverlay.getTableParentOffset();
      },
      get inlineStartScrollPosition() {
        return wot.wtOverlays.inlineStartOverlay.getScrollPosition();
      },
      get inlineStartParentOffset() {
        return wot.wtOverlays.inlineStartOverlay.getTableParentOffset();
      },
      get topOverlay() {
        return wot.wtOverlays.topOverlay;
      },
      get inlineStartOverlay() {
        return wot.wtOverlays.inlineStartOverlay;
      },
      get bottomOverlay() {
        return wot.wtOverlays.bottomOverlay;
      }
    };
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/facade/core.mjs
var WalkontableFacade = class _WalkontableFacade {
  /**
   * @param {SettingsPure|Walkontable} settingsOrInstance The Walkontable settings.
   */
  constructor(settingsOrInstance) {
    if (settingsOrInstance instanceof CoreAbstract) {
      this._wot = settingsOrInstance;
    } else {
      this._initFromSettings(settingsOrInstance);
    }
  }
  _initFromSettings(settings) {
    settings.facade = (instance) => {
      const facade = new _WalkontableFacade(instance);
      return () => facade;
    };
    this._wot = new Walkontable(settings.table, settings);
  }
  get guid() {
    return this._wot.guid;
  }
  get rootDocument() {
    return this._wot.domBindings.rootDocument;
  }
  get rootWindow() {
    return this._wot.domBindings.rootWindow;
  }
  get wtSettings() {
    return this._wot.wtSettings;
  }
  get cloneSource() {
    return this._wot.cloneSource;
  }
  get cloneOverlay() {
    return this._wot.cloneOverlay;
  }
  get selections() {
    return this._wot.selections;
  }
  get wtViewport() {
    return this._wot.wtViewport;
  }
  get wtOverlays() {
    return this._wot.wtOverlays;
  }
  get wtTable() {
    return this._wot.wtTable;
  }
  get wtEvent() {
    return this._wot.wtEvent;
  }
  get wtScroll() {
    return this._wot.wtScroll;
  }
  get drawn() {
    return this._wot.drawn;
  }
  set drawn(value) {
    this._wot.drawn = value;
  }
  get drawInterrupted() {
    return this._wot.drawInterrupted;
  }
  set drawInterrupted(value) {
    this._wot.drawInterrupted = value;
  }
  get lastMouseOver() {
    return this._wot.lastMouseOver;
  }
  set lastMouseOver(value) {
    this._wot.lastMouseOver = value;
  }
  get momentumScrolling() {
    return this._wot.momentumScrolling;
  }
  set momentumScrolling(value) {
    this._wot.momentumScrolling = value;
  }
  get touchApplied() {
    return this._wot.touchApplied;
  }
  set touchApplied(value) {
    this._wot.touchApplied = value;
  }
  get domBindings() {
    return this._wot.domBindings;
  }
  get eventListeners() {
    return this._wot.eventListeners;
  }
  set eventListeners(value) {
    this._wot.eventListeners = value;
  }
  get eventManager() {
    return this._wot.eventManager;
  }
  createCellCoords(row, column) {
    return this._wot.createCellCoords(row, column);
  }
  createCellRange(highlight, from2, to2) {
    return this._wot.createCellRange(highlight, from2, to2);
  }
  draw() {
    let fastDraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this._wot.draw(fastDraw);
    return this;
  }
  getCell(coords) {
    let topmost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return this._wot.getCell(coords, topmost);
  }
  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
    return this._wot.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
  }
  scrollViewportHorizontally(column, snapToRight, snapToLeft) {
    return this._wot.scrollViewportHorizontally(column, snapToRight, snapToLeft);
  }
  scrollViewportVertically(row, snapToTop, snapToBottom) {
    return this._wot.scrollViewportVertically(row, snapToTop, snapToBottom);
  }
  getViewport() {
    return this._wot.getViewport();
  }
  getOverlayName() {
    return this._wot.cloneOverlay ? this._wot.cloneOverlay.type : "master";
  }
  exportSettingsAsClassNames() {
    return this._wot.exportSettingsAsClassNames();
  }
  update(settings, value) {
    this._wot.wtSettings.update(settings, value);
    return this;
  }
  getSetting(key, param1, param2, param3, param4) {
    return this._wot.wtSettings.getSetting(key, param1, param2, param3, param4);
  }
  hasSetting(key) {
    return this._wot.wtSettings.hasSetting(key);
  }
  destroy() {
    this._wot.destroy();
  }
};

// node_modules/handsontable/3rdparty/walkontable/src/border.mjs
var Border = class {
  // TODO As this is an internal class, should be designed for using {Walkontable}. It uses the facade,
  // TODO Con. Because the class is created on place where the instance reference comes from external origin.
  // TODO Imho, the discrimination for handling both, facade and non-facade should be handled.
  /**
   * @param {WalkontableFacade} wotInstance The Walkontable instance.
   * @param {object} settings The border settings.
   */
  constructor(wotInstance, settings) {
    if (!settings) {
      return;
    }
    this.eventManager = wotInstance.eventManager;
    this.instance = wotInstance;
    this.wot = wotInstance;
    this.settings = settings;
    this.mouseDown = false;
    this.main = null;
    this.top = null;
    this.bottom = null;
    this.start = null;
    this.end = null;
    this.topStyle = null;
    this.bottomStyle = null;
    this.startStyle = null;
    this.endStyle = null;
    this.cornerDefaultStyle = {
      width: "6px",
      height: "6px",
      borderWidth: "1px",
      borderStyle: "solid",
      borderColor: "#FFF"
    };
    this.cornerCenterPointOffset = -(parseInt(this.cornerDefaultStyle.width, 10) / 2);
    this.corner = null;
    this.cornerStyle = null;
    this.createBorders(settings);
    this.registerListeners();
  }
  /**
   * Register all necessary events.
   */
  registerListeners() {
    const documentBody = this.wot.rootDocument.body;
    this.eventManager.addEventListener(documentBody, "mousedown", () => this.onMouseDown());
    this.eventManager.addEventListener(documentBody, "mouseup", () => this.onMouseUp());
    for (let c = 0, len = this.main.childNodes.length; c < len; c++) {
      const element = this.main.childNodes[c];
      this.eventManager.addEventListener(element, "mouseenter", (event2) => this.onMouseEnter(event2, this.main.childNodes[c]));
    }
  }
  /**
   * Mouse down listener.
   *
   * @private
   */
  onMouseDown() {
    this.mouseDown = true;
  }
  /**
   * Mouse up listener.
   *
   * @private
   */
  onMouseUp() {
    this.mouseDown = false;
  }
  /**
   * Mouse enter listener for fragment selection functionality.
   *
   * @private
   * @param {Event} event Dom event.
   * @param {HTMLElement} parentElement Part of border element.
   */
  onMouseEnter(event2, parentElement) {
    if (!this.mouseDown || !this.wot.getSetting("hideBorderOnMouseDownOver")) {
      return;
    }
    event2.preventDefault();
    stopImmediatePropagation(event2);
    const _this = this;
    const documentBody = this.wot.rootDocument.body;
    const bounds = parentElement.getBoundingClientRect();
    parentElement.style.display = "none";
    function isOutside(mouseEvent) {
      if (mouseEvent.clientY < Math.floor(bounds.top)) {
        return true;
      }
      if (mouseEvent.clientY > Math.ceil(bounds.top + bounds.height)) {
        return true;
      }
      if (mouseEvent.clientX < Math.floor(bounds.left)) {
        return true;
      }
      if (mouseEvent.clientX > Math.ceil(bounds.left + bounds.width)) {
        return true;
      }
    }
    function handler(handlerEvent) {
      if (isOutside(handlerEvent)) {
        _this.eventManager.removeEventListener(documentBody, "mousemove", handler);
        parentElement.style.display = "block";
      }
    }
    this.eventManager.addEventListener(documentBody, "mousemove", handler);
  }
  /**
   * Create border elements.
   *
   * @param {object} settings The border settings.
   */
  createBorders(settings) {
    const {
      rootDocument
    } = this.wot;
    this.main = rootDocument.createElement("div");
    const borderDivs = ["top", "start", "bottom", "end", "corner"];
    let style = this.main.style;
    style.position = "absolute";
    style.top = 0;
    style.left = 0;
    for (let i = 0; i < 5; i++) {
      const position = borderDivs[i];
      const div = rootDocument.createElement("div");
      div.className = `wtBorder ${this.settings.className || ""}`;
      if (this.settings[position] && this.settings[position].hide) {
        div.className += " hidden";
      }
      style = div.style;
      style.backgroundColor = this.settings[position] && this.settings[position].color ? this.settings[position].color : settings.border.color;
      style.height = this.settings[position] && this.settings[position].width ? `${this.settings[position].width}px` : `${settings.border.width}px`;
      style.width = this.settings[position] && this.settings[position].width ? `${this.settings[position].width}px` : `${settings.border.width}px`;
      this.main.appendChild(div);
    }
    this.top = this.main.childNodes[0];
    this.start = this.main.childNodes[1];
    this.bottom = this.main.childNodes[2];
    this.end = this.main.childNodes[3];
    this.topStyle = this.top.style;
    this.startStyle = this.start.style;
    this.bottomStyle = this.bottom.style;
    this.endStyle = this.end.style;
    this.corner = this.main.childNodes[4];
    this.corner.className += " corner";
    this.cornerStyle = this.corner.style;
    this.cornerStyle.width = this.cornerDefaultStyle.width;
    this.cornerStyle.height = this.cornerDefaultStyle.height;
    this.cornerStyle.border = [this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(" ");
    if (isMobileBrowser()) {
      this.createMultipleSelectorHandles();
    }
    this.disappear();
    const {
      wtTable
    } = this.wot;
    let bordersHolder = wtTable.bordersHolder;
    if (!bordersHolder) {
      bordersHolder = rootDocument.createElement("div");
      bordersHolder.className = "htBorders";
      wtTable.bordersHolder = bordersHolder;
      wtTable.spreader.appendChild(bordersHolder);
    }
    bordersHolder.appendChild(this.main);
  }
  /**
   * Create multiple selector handler for mobile devices.
   */
  createMultipleSelectorHandles() {
    const {
      rootDocument
    } = this.wot;
    this.selectionHandles = {
      top: rootDocument.createElement("DIV"),
      topHitArea: rootDocument.createElement("DIV"),
      bottom: rootDocument.createElement("DIV"),
      bottomHitArea: rootDocument.createElement("DIV")
    };
    const width = 10;
    const hitAreaWidth = 40;
    this.selectionHandles.top.className = "topSelectionHandle topLeftSelectionHandle";
    this.selectionHandles.topHitArea.className = "topSelectionHandle-HitArea topLeftSelectionHandle-HitArea";
    this.selectionHandles.bottom.className = "bottomSelectionHandle bottomRightSelectionHandle";
    this.selectionHandles.bottomHitArea.className = "bottomSelectionHandle-HitArea bottomRightSelectionHandle-HitArea";
    this.selectionHandles.styles = {
      top: this.selectionHandles.top.style,
      topHitArea: this.selectionHandles.topHitArea.style,
      bottom: this.selectionHandles.bottom.style,
      bottomHitArea: this.selectionHandles.bottomHitArea.style
    };
    const hitAreaStyle = {
      position: "absolute",
      height: `${hitAreaWidth}px`,
      width: `${hitAreaWidth}px`,
      "border-radius": `${parseInt(hitAreaWidth / 1.5, 10)}px`
    };
    objectEach(hitAreaStyle, (value, key) => {
      this.selectionHandles.styles.bottomHitArea[key] = value;
      this.selectionHandles.styles.topHitArea[key] = value;
    });
    const handleStyle = {
      position: "absolute",
      height: `${width}px`,
      width: `${width}px`,
      "border-radius": `${parseInt(width / 1.5, 10)}px`,
      background: "#F5F5FF",
      border: "1px solid #4285c8"
    };
    objectEach(handleStyle, (value, key) => {
      this.selectionHandles.styles.bottom[key] = value;
      this.selectionHandles.styles.top[key] = value;
    });
    this.main.appendChild(this.selectionHandles.top);
    this.main.appendChild(this.selectionHandles.bottom);
    this.main.appendChild(this.selectionHandles.topHitArea);
    this.main.appendChild(this.selectionHandles.bottomHitArea);
  }
  /**
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @returns {boolean}
   */
  isPartRange(row, col) {
    const areaSelection = this.wot.selections.createOrGetArea();
    if (areaSelection.cellRange) {
      if (row !== areaSelection.cellRange.to.row || col !== areaSelection.cellRange.to.col) {
        return true;
      }
    }
    return false;
  }
  /**
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number} top The top position of the handler.
   * @param {number} left The left position of the handler.
   * @param {number} width The width of the handler.
   * @param {number} height The height of the handler.
   */
  updateMultipleSelectionHandlesPosition(row, col, top2, left2, width, height) {
    const isRtl = this.wot.wtSettings.getSetting("rtlMode");
    const inlinePosProperty = isRtl ? "right" : "left";
    const {
      top: topStyles,
      topHitArea: topHitAreaStyles,
      bottom: bottomStyles,
      bottomHitArea: bottomHitAreaStyles
    } = this.selectionHandles.styles;
    const handleBorderSize = parseInt(topStyles.borderWidth, 10);
    const handleSize = parseInt(topStyles.width, 10);
    const hitAreaSize = parseInt(topHitAreaStyles.width, 10);
    const totalTableWidth = this.wot.wtTable.getWidth();
    const totalTableHeight = this.wot.wtTable.getHeight();
    topStyles.top = `${parseInt(top2 - handleSize - 1, 10)}px`;
    topStyles[inlinePosProperty] = `${parseInt(left2 - handleSize - 1, 10)}px`;
    topHitAreaStyles.top = `${parseInt(top2 - hitAreaSize / 4 * 3, 10)}px`;
    topHitAreaStyles[inlinePosProperty] = `${parseInt(left2 - hitAreaSize / 4 * 3, 10)}px`;
    const bottomHandlerInline = Math.min(parseInt(left2 + width, 10), totalTableWidth - handleSize - handleBorderSize * 2);
    const bottomHandlerAreaInline = Math.min(parseInt(left2 + width - hitAreaSize / 4, 10), totalTableWidth - hitAreaSize - handleBorderSize * 2);
    bottomStyles[inlinePosProperty] = `${bottomHandlerInline}px`;
    bottomHitAreaStyles[inlinePosProperty] = `${bottomHandlerAreaInline}px`;
    const bottomHandlerTop = Math.min(parseInt(top2 + height, 10), totalTableHeight - handleSize - handleBorderSize * 2);
    const bottomHandlerAreaTop = Math.min(parseInt(top2 + height - hitAreaSize / 4, 10), totalTableHeight - hitAreaSize - handleBorderSize * 2);
    bottomStyles.top = `${bottomHandlerTop}px`;
    bottomHitAreaStyles.top = `${bottomHandlerAreaTop}px`;
    if (this.settings.border.cornerVisible && this.settings.border.cornerVisible()) {
      topStyles.display = "block";
      topHitAreaStyles.display = "block";
      if (this.isPartRange(row, col)) {
        bottomStyles.display = "none";
        bottomHitAreaStyles.display = "none";
      } else {
        bottomStyles.display = "block";
        bottomHitAreaStyles.display = "block";
      }
    } else {
      topStyles.display = "none";
      bottomStyles.display = "none";
      topHitAreaStyles.display = "none";
      bottomHitAreaStyles.display = "none";
    }
    if (row === this.wot.wtSettings.getSetting("fixedRowsTop") || col === this.wot.wtSettings.getSetting("fixedColumnsStart")) {
      topStyles.zIndex = "9999";
      topHitAreaStyles.zIndex = "9999";
    } else {
      topStyles.zIndex = "";
      topHitAreaStyles.zIndex = "";
    }
  }
  /**
   * Show border around one or many cells.
   *
   * @param {Array} corners The corner coordinates.
   */
  appear(corners) {
    if (this.disabled) {
      return;
    }
    const {
      wtTable,
      rootDocument,
      rootWindow
    } = this.wot;
    let fromRow;
    let toRow;
    let fromColumn;
    let toColumn;
    let rowHeader;
    let columnHeader;
    const rowsCount = wtTable.getRenderedRowsCount();
    for (let i = 0; i < rowsCount; i += 1) {
      const s = wtTable.rowFilter.renderedToSource(i);
      if (s >= corners[0] && s <= corners[2]) {
        fromRow = s;
        rowHeader = corners[0];
        break;
      }
    }
    for (let i = rowsCount - 1; i >= 0; i -= 1) {
      const s = wtTable.rowFilter.renderedToSource(i);
      if (s >= corners[0] && s <= corners[2]) {
        toRow = s;
        break;
      }
    }
    const columnsCount = wtTable.getRenderedColumnsCount();
    for (let i = 0; i < columnsCount; i += 1) {
      const s = wtTable.columnFilter.renderedToSource(i);
      if (s >= corners[1] && s <= corners[3]) {
        fromColumn = s;
        columnHeader = corners[1];
        break;
      }
    }
    for (let i = columnsCount - 1; i >= 0; i -= 1) {
      const s = wtTable.columnFilter.renderedToSource(i);
      if (s >= corners[1] && s <= corners[3]) {
        toColumn = s;
        break;
      }
    }
    if (fromRow === void 0 || fromColumn === void 0) {
      this.disappear();
      return;
    }
    let fromTD = wtTable.getCell(this.wot.createCellCoords(fromRow, fromColumn));
    const isMultiple = fromRow !== toRow || fromColumn !== toColumn;
    const toTD = isMultiple ? wtTable.getCell(this.wot.createCellCoords(toRow, toColumn)) : fromTD;
    const fromOffset = offset2(fromTD);
    const toOffset = isMultiple ? offset2(toTD) : fromOffset;
    const containerOffset = offset2(wtTable.TABLE);
    const containerWidth = outerWidth(wtTable.TABLE);
    const minTop = fromOffset.top;
    const minLeft = fromOffset.left;
    const isRtl = this.wot.wtSettings.getSetting("rtlMode");
    let inlineStartPos = 0;
    let width = 0;
    if (isRtl) {
      const fromWidth = outerWidth(fromTD);
      const gridRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;
      width = minLeft + fromWidth - toOffset.left;
      inlineStartPos = rootWindow.innerWidth - minLeft - fromWidth - gridRightPos - 1;
    } else {
      width = toOffset.left + outerWidth(toTD) - minLeft;
      inlineStartPos = minLeft - containerOffset.left - 1;
    }
    if (this.isEntireColumnSelected(fromRow, toRow)) {
      const modifiedValues = this.getDimensionsFromHeader("columns", fromColumn, toColumn, rowHeader, containerOffset);
      let fromTH = null;
      if (modifiedValues) {
        [fromTH, inlineStartPos, width] = modifiedValues;
      }
      if (fromTH) {
        fromTD = fromTH;
      }
    }
    let top2 = minTop - containerOffset.top - 1;
    let height = toOffset.top + outerHeight(toTD) - minTop;
    if (this.isEntireRowSelected(fromColumn, toColumn)) {
      const modifiedValues = this.getDimensionsFromHeader("rows", fromRow, toRow, columnHeader, containerOffset);
      let fromTH = null;
      if (modifiedValues) {
        [fromTH, top2, height] = modifiedValues;
      }
      if (fromTH) {
        fromTD = fromTH;
      }
    }
    const style = getComputedStyle(fromTD, rootWindow);
    if (parseInt(style.borderTopWidth, 10) > 0) {
      top2 += 1;
      height = height > 0 ? height - 1 : 0;
    }
    if (parseInt(style[isRtl ? "borderRightWidth" : "borderLeftWidth"], 10) > 0) {
      inlineStartPos += 1;
      width = width > 0 ? width - 1 : 0;
    }
    const inlinePosProperty = isRtl ? "right" : "left";
    this.topStyle.top = `${top2}px`;
    this.topStyle[inlinePosProperty] = `${inlineStartPos}px`;
    this.topStyle.width = `${width}px`;
    this.topStyle.display = "block";
    this.startStyle.top = `${top2}px`;
    this.startStyle[inlinePosProperty] = `${inlineStartPos}px`;
    this.startStyle.height = `${height}px`;
    this.startStyle.display = "block";
    const delta = Math.floor(this.settings.border.width / 2);
    this.bottomStyle.top = `${top2 + height - delta}px`;
    this.bottomStyle[inlinePosProperty] = `${inlineStartPos}px`;
    this.bottomStyle.width = `${width}px`;
    this.bottomStyle.display = "block";
    this.endStyle.top = `${top2}px`;
    this.endStyle[inlinePosProperty] = `${inlineStartPos + width - delta}px`;
    this.endStyle.height = `${height + 1}px`;
    this.endStyle.display = "block";
    let cornerVisibleSetting = this.settings.border.cornerVisible;
    cornerVisibleSetting = typeof cornerVisibleSetting === "function" ? cornerVisibleSetting(this.settings.layerLevel) : cornerVisibleSetting;
    const hookResult = this.wot.getSetting("onModifyGetCellCoords", toRow, toColumn);
    let [checkRow, checkCol] = [toRow, toColumn];
    if (hookResult && Array.isArray(hookResult)) {
      [, , checkRow, checkCol] = hookResult;
    }
    if (isMobileBrowser() || !cornerVisibleSetting || this.isPartRange(checkRow, checkCol)) {
      this.cornerStyle.display = "none";
    } else {
      this.cornerStyle.top = `${top2 + height + this.cornerCenterPointOffset - 1}px`;
      this.cornerStyle[inlinePosProperty] = `${inlineStartPos + width + this.cornerCenterPointOffset - 1}px`;
      this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;
      this.cornerStyle.width = this.cornerDefaultStyle.width;
      this.cornerStyle.display = "none";
      let trimmingContainer = getTrimmingContainer(wtTable.TABLE);
      const trimToWindow = trimmingContainer === rootWindow;
      if (trimToWindow) {
        trimmingContainer = rootDocument.documentElement;
      }
      const cornerHalfWidth = parseInt(this.cornerDefaultStyle.width, 10) / 2;
      const cornerHalfHeight = parseInt(this.cornerDefaultStyle.height, 10) / 2;
      if (toColumn === this.wot.getSetting("totalColumns") - 1) {
        const toTdOffsetLeft = trimToWindow ? toTD.getBoundingClientRect().left : toTD.offsetLeft;
        let cornerOverlappingContainer = false;
        let cornerEdge = 0;
        if (isRtl) {
          cornerEdge = toTdOffsetLeft - parseInt(this.cornerDefaultStyle.width, 10) / 2;
          cornerOverlappingContainer = cornerEdge < 0;
        } else {
          cornerEdge = toTdOffsetLeft + outerWidth(toTD) + parseInt(this.cornerDefaultStyle.width, 10) / 2;
          cornerOverlappingContainer = cornerEdge >= innerWidth(trimmingContainer);
        }
        if (cornerOverlappingContainer) {
          this.cornerStyle[inlinePosProperty] = `${Math.floor(inlineStartPos + width + this.cornerCenterPointOffset - cornerHalfWidth)}px`;
          this.cornerStyle[isRtl ? "borderLeftWidth" : "borderRightWidth"] = 0;
        }
      }
      if (toRow === this.wot.getSetting("totalRows") - 1) {
        const toTdOffsetTop = trimToWindow ? toTD.getBoundingClientRect().top : toTD.offsetTop;
        const cornerBottomEdge = toTdOffsetTop + outerHeight(toTD) + parseInt(this.cornerDefaultStyle.height, 10) / 2;
        const cornerOverlappingContainer = cornerBottomEdge >= innerHeight(trimmingContainer);
        if (cornerOverlappingContainer) {
          this.cornerStyle.top = `${Math.floor(top2 + height + this.cornerCenterPointOffset - cornerHalfHeight)}px`;
          this.cornerStyle.borderBottomWidth = 0;
        }
      }
      this.cornerStyle.display = "block";
    }
    if (isMobileBrowser()) {
      this.updateMultipleSelectionHandlesPosition(toRow, toColumn, top2, inlineStartPos, width, height);
    }
  }
  /**
   * Check whether an entire column of cells is selected.
   *
   * @private
   * @param {number} startRowIndex Start row index.
   * @param {number} endRowIndex End row index.
   * @returns {boolean}
   */
  isEntireColumnSelected(startRowIndex, endRowIndex) {
    return startRowIndex === this.wot.wtTable.getFirstRenderedRow() && endRowIndex === this.wot.wtTable.getLastRenderedRow();
  }
  /**
   * Check whether an entire row of cells is selected.
   *
   * @private
   * @param {number} startColumnIndex Start column index.
   * @param {number} endColumnIndex End column index.
   * @returns {boolean}
   */
  isEntireRowSelected(startColumnIndex, endColumnIndex) {
    return startColumnIndex === this.wot.wtTable.getFirstRenderedColumn() && endColumnIndex === this.wot.wtTable.getLastRenderedColumn();
  }
  /**
   * Get left/top index and width/height depending on the `direction` provided.
   *
   * @private
   * @param {string} direction `rows` or `columns`, defines if an entire column or row is selected.
   * @param {number} fromIndex Start index of the selection.
   * @param {number} toIndex End index of the selection.
   * @param {number} headerIndex The header index as negative value.
   * @param {number} containerOffset Offset of the container.
   * @returns {Array|boolean} Returns an array of [headerElement, left, width] or [headerElement, top, height], depending on `direction` (`false` in case of an error getting the headers).
   */
  getDimensionsFromHeader(direction, fromIndex, toIndex, headerIndex, containerOffset) {
    const {
      wtTable
    } = this.wot;
    const rootHotElement = wtTable.wtRootElement.parentNode;
    let getHeaderFn = null;
    let dimensionFn = null;
    let entireSelectionClassname = null;
    let index2 = null;
    let dimension = null;
    let dimensionProperty = null;
    let startHeader = null;
    let endHeader = null;
    switch (direction) {
      case "rows":
        getHeaderFn = function() {
          return wtTable.getRowHeader(...arguments);
        };
        dimensionFn = function() {
          return outerHeight(...arguments);
        };
        entireSelectionClassname = "ht__selection--rows";
        dimensionProperty = "top";
        break;
      case "columns":
        getHeaderFn = function() {
          return wtTable.getColumnHeader(...arguments);
        };
        dimensionFn = function() {
          return outerWidth(...arguments);
        };
        entireSelectionClassname = "ht__selection--columns";
        dimensionProperty = "left";
        break;
      default:
    }
    if (rootHotElement.classList.contains(entireSelectionClassname)) {
      const columnHeaderLevelCount = this.wot.getSetting("columnHeaders").length;
      startHeader = getHeaderFn(fromIndex, columnHeaderLevelCount - headerIndex);
      endHeader = getHeaderFn(toIndex, columnHeaderLevelCount - headerIndex);
      if (!startHeader || !endHeader) {
        return false;
      }
      const startHeaderOffset = offset2(startHeader);
      const endOffset = offset2(endHeader);
      if (startHeader && endHeader) {
        index2 = startHeaderOffset[dimensionProperty] - containerOffset[dimensionProperty] - 1;
        dimension = endOffset[dimensionProperty] + dimensionFn(endHeader) - startHeaderOffset[dimensionProperty];
      }
      return [startHeader, index2, dimension];
    }
    return false;
  }
  /**
   * Change border style.
   *
   * @private
   * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.
   * @param {object} border The border object descriptor.
   */
  changeBorderStyle(borderElement, border) {
    const style = this[borderElement].style;
    const borderStyle = border[borderElement];
    if (!borderStyle || borderStyle.hide) {
      addClass(this[borderElement], "hidden");
    } else {
      if (hasClass(this[borderElement], "hidden")) {
        removeClass(this[borderElement], "hidden");
      }
      style.backgroundColor = borderStyle.color;
      if (borderElement === "top" || borderElement === "bottom") {
        style.height = `${borderStyle.width}px`;
      }
      if (borderElement === "start" || borderElement === "end") {
        style.width = `${borderStyle.width}px`;
      }
    }
  }
  /**
   * Change border style to default.
   *
   * @private
   * @param {string} position The position type ("top", "bottom", "start", "end") to change.
   */
  changeBorderToDefaultStyle(position) {
    const defaultBorder = {
      width: 1,
      color: "#000"
    };
    const style = this[position].style;
    style.backgroundColor = defaultBorder.color;
    style.width = `${defaultBorder.width}px`;
    style.height = `${defaultBorder.width}px`;
  }
  /**
   * Toggle class 'hidden' to element.
   *
   * @private
   * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.
   * @param {boolean} [remove] Defines type of the action to perform.
   */
  toggleHiddenClass(borderElement, remove) {
    this.changeBorderToDefaultStyle(borderElement);
    if (remove) {
      addClass(this[borderElement], "hidden");
    } else {
      removeClass(this[borderElement], "hidden");
    }
  }
  /**
   * Hide border.
   */
  disappear() {
    this.topStyle.display = "none";
    this.bottomStyle.display = "none";
    this.startStyle.display = "none";
    this.endStyle.display = "none";
    this.cornerStyle.display = "none";
    if (isMobileBrowser()) {
      this.selectionHandles.styles.top.display = "none";
      this.selectionHandles.styles.topHitArea.display = "none";
      this.selectionHandles.styles.bottom.display = "none";
      this.selectionHandles.styles.bottomHitArea.display = "none";
    }
  }
  /**
   * Cleans up all the DOM state related to a Border instance. Call this prior to deleting a Border instance.
   */
  destroy() {
    this.eventManager.destroyWithOwnEventsOnly();
    this.main.parentNode.removeChild(this.main);
  }
};
var border_default = Border;

// node_modules/handsontable/3rdparty/walkontable/src/selection.mjs
var Selection = class {
  /**
   * @param {object} settings The selection settings object. @todo type.
   * @param {CellRange} cellRange The cell range instance.
   */
  constructor(settings, cellRange) {
    this.settings = settings;
    this.cellRange = cellRange || null;
    this.instanceBorders = {};
    this.classNames = [this.settings.className];
    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);
  }
  /**
   * Each Walkontable clone requires it's own border for every selection. This method creates and returns selection
   * borders per instance.
   *
   * @param {WalkontableFacade} wotInstance The Walkontable instance.
   * @returns {Border}
   */
  getBorder(wotInstance) {
    if (!this.instanceBorders[wotInstance.guid]) {
      this.instanceBorders[wotInstance.guid] = new border_default(wotInstance, this.settings);
    }
    return this.instanceBorders[wotInstance.guid];
  }
  /**
   * Checks if selection is empty.
   *
   * @returns {boolean}
   */
  isEmpty() {
    return this.cellRange === null;
  }
  /**
   * Adds a cell coords to the selection.
   *
   * @param {CellCoords} coords The cell coordinates to add.
   * @returns {Selection}
   */
  add(coords) {
    if (this.isEmpty()) {
      this.cellRange = this.settings.createCellRange(coords);
    } else {
      this.cellRange.expand(coords);
    }
    return this;
  }
  /**
   * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean
   * information about success.
   *
   * @param {CellCoords} oldCoords An old cell coordinates to replace.
   * @param {CellCoords} newCoords The new cell coordinates.
   * @returns {boolean}
   */
  replace(oldCoords, newCoords) {
    if (!this.isEmpty()) {
      if (this.cellRange.from.isEqual(oldCoords)) {
        this.cellRange.from = newCoords;
        return true;
      }
      if (this.cellRange.to.isEqual(oldCoords)) {
        this.cellRange.to = newCoords;
        return true;
      }
    }
    return false;
  }
  /**
   * Clears selection.
   *
   * @returns {Selection}
   */
  clear() {
    this.cellRange = null;
    return this;
  }
  /**
   * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection coordinates.
   *
   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.
   */
  getCorners() {
    const topStart = this.cellRange.getOuterTopStartCorner();
    const bottomEnd = this.cellRange.getOuterBottomEndCorner();
    return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];
  }
  /**
   * Adds class name to cell element at given coords.
   *
   * @param {WalkontableFacade} wotInstance Walkontable instance.
   * @param {number} sourceRow Cell row coord.
   * @param {number} sourceColumn Cell column coord.
   * @param {string} className Class name.
   * @param {boolean} [markIntersections=false] If `true`, linear className generator will be used to add CSS classes
   *                                            in a continuous way.
   * @returns {Selection}
   */
  addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {
    let markIntersections = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    const TD = wotInstance.wtTable.getCell(this.settings.createCellCoords(sourceRow, sourceColumn));
    if (typeof TD === "object") {
      let cellClassName = className;
      if (markIntersections) {
        cellClassName = this.classNameGenerator(TD);
        if (!this.classNames.includes(cellClassName)) {
          this.classNames.push(cellClassName);
        }
      }
      addClass(TD, cellClassName);
    }
    return this;
  }
  /**
   * Generate helper for calculating classNames based on previously added base className.
   * The generated className is always generated as a continuation of the previous className. For example, when
   * the currently checked element has 'area-2' className the generated new className will be 'area-3'. When
   * the element doesn't have any classNames than the base className will be returned ('area');.
   *
   * @param {string} baseClassName Base className to be used.
   * @param {number} layerLevelOwner Layer level which the instance of the Selection belongs to.
   * @returns {Function}
   */
  linearClassNameGenerator(baseClassName, layerLevelOwner) {
    return function calcClassName(element) {
      let previousIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      if (layerLevelOwner === 0 || previousIndex === 0) {
        return baseClassName;
      }
      let index2 = previousIndex >= 0 ? previousIndex : layerLevelOwner;
      let className = baseClassName;
      index2 -= 1;
      const previousClassName = index2 === 0 ? baseClassName : `${baseClassName}-${index2}`;
      if (hasClass(element, previousClassName)) {
        const currentLayer = index2 + 1;
        className = `${baseClassName}-${currentLayer}`;
      } else {
        className = calcClassName(element, index2);
      }
      return className;
    };
  }
  /**
   * @param {WalkontableFacade} wotInstance The Walkontable instance.
   */
  draw(wotInstance) {
    if (this.isEmpty()) {
      if (this.settings.border) {
        this.getBorder(wotInstance).disappear();
      }
      return;
    }
    const renderedRows = wotInstance.wtTable.getRenderedRowsCount();
    const renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();
    const corners = this.getCorners();
    const [topRow, topColumn, bottomRow, bottomColumn] = corners;
    const {
      highlightHeaderClassName,
      highlightColumnClassName,
      highlightRowClassName,
      highlightOnlyClosestHeader,
      selectionType
    } = this.settings;
    const isHeaderSelectionType = selectionType === void 0 || ["active-header", "header"].includes(selectionType);
    if (isHeaderSelectionType && topColumn !== null && bottomColumn !== null) {
      let selectionColumnCursor = 0;
      for (let column = 0; column < renderedColumns; column += 1) {
        const sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);
        if (sourceCol >= topColumn && sourceCol <= bottomColumn) {
          let THs = wotInstance.wtTable.getColumnHeaders(sourceCol);
          const closestHeaderLevel = THs.length - 1;
          if (highlightOnlyClosestHeader && THs.length > 1) {
            THs = [THs[closestHeaderLevel]];
          }
          for (let headerLevel = 0; headerLevel < THs.length; headerLevel += 1) {
            const newClasses = [];
            let TH = THs[headerLevel];
            if (highlightHeaderClassName) {
              newClasses.push(highlightHeaderClassName);
            }
            if (highlightColumnClassName) {
              newClasses.push(highlightColumnClassName);
            }
            headerLevel = highlightOnlyClosestHeader ? closestHeaderLevel : headerLevel;
            const newSourceCol = wotInstance.getSetting("onBeforeHighlightingColumnHeader", sourceCol, headerLevel, {
              selectionType,
              columnCursor: selectionColumnCursor,
              selectionWidth: bottomColumn - topColumn + 1,
              classNames: newClasses
            });
            if (newSourceCol !== sourceCol) {
              TH = wotInstance.wtTable.getColumnHeader(newSourceCol, headerLevel);
            }
            addClass(TH, newClasses);
          }
          selectionColumnCursor += 1;
        }
      }
    }
    if (topRow !== null && bottomRow !== null) {
      let selectionRowCursor = 0;
      for (let row = 0; row < renderedRows; row += 1) {
        const sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);
        if (isHeaderSelectionType && sourceRow >= topRow && sourceRow <= bottomRow) {
          let THs = wotInstance.wtTable.getRowHeaders(sourceRow);
          const closestHeaderLevel = THs.length - 1;
          if (highlightOnlyClosestHeader && THs.length > 1) {
            THs = [THs[closestHeaderLevel]];
          }
          for (let headerLevel = 0; headerLevel < THs.length; headerLevel += 1) {
            const newClasses = [];
            let TH = THs[headerLevel];
            if (highlightHeaderClassName) {
              newClasses.push(highlightHeaderClassName);
            }
            if (highlightRowClassName) {
              newClasses.push(highlightRowClassName);
            }
            headerLevel = highlightOnlyClosestHeader ? closestHeaderLevel : headerLevel;
            const newSourceRow = wotInstance.getSetting("onBeforeHighlightingRowHeader", sourceRow, headerLevel, {
              selectionType,
              rowCursor: selectionRowCursor,
              selectionHeight: bottomRow - topRow + 1,
              classNames: newClasses
            });
            if (newSourceRow !== sourceRow) {
              TH = wotInstance.wtTable.getRowHeader(newSourceRow, headerLevel);
            }
            addClass(TH, newClasses);
          }
          selectionRowCursor += 1;
        }
        if (topColumn !== null && bottomColumn !== null) {
          for (let column = 0; column < renderedColumns; column += 1) {
            const sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);
            if (sourceRow >= topRow && sourceRow <= bottomRow && sourceCol >= topColumn && sourceCol <= bottomColumn) {
              if (this.settings.className) {
                this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.className, this.settings.markIntersections);
              }
            } else if (sourceRow >= topRow && sourceRow <= bottomRow) {
              if (highlightRowClassName) {
                this.addClassAtCoords(wotInstance, sourceRow, sourceCol, highlightRowClassName);
              }
            } else if (sourceCol >= topColumn && sourceCol <= bottomColumn) {
              if (highlightColumnClassName) {
                this.addClassAtCoords(wotInstance, sourceRow, sourceCol, highlightColumnClassName);
              }
            }
            const additionalSelectionClass = wotInstance.getSetting("onAfterDrawSelection", sourceRow, sourceCol, this.settings.layerLevel);
            if (typeof additionalSelectionClass === "string") {
              this.addClassAtCoords(wotInstance, sourceRow, sourceCol, additionalSelectionClass);
            }
          }
        }
      }
    }
    wotInstance.getSetting("onBeforeDrawBorders", corners, this.settings.className);
    if (this.settings.border) {
      this.getBorder(wotInstance).appear(corners);
    }
  }
  /**
   * Cleans up all the DOM state related to a Selection instance. Call this prior to deleting a Selection instance.
   */
  destroy() {
    Object.values(this.instanceBorders).forEach((border) => border.destroy());
  }
};
var selection_default = Selection;

// node_modules/handsontable/selection/mouseEventHandler.mjs
function mouseDown(_ref2) {
  let {
    isShiftKey,
    isLeftClick: isLeftClick2,
    isRightClick: isRightClick2,
    coords,
    selection,
    controller,
    cellCoordsFactory
  } = _ref2;
  const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;
  const selectedCorner = selection.isSelectedByCorner();
  const selectedRow = selection.isSelectedByRowHeader();
  if (isShiftKey && currentSelection) {
    if (coords.row >= 0 && coords.col >= 0 && !controller.cell) {
      selection.setRangeEnd(coords);
    } else if ((selectedCorner || selectedRow) && coords.row >= 0 && coords.col >= 0 && !controller.cell) {
      selection.setRangeEnd(cellCoordsFactory(coords.row, coords.col));
    } else if (selectedCorner && coords.row < 0 && !controller.column) {
      selection.setRangeEnd(cellCoordsFactory(currentSelection.to.row, coords.col));
    } else if (selectedRow && coords.col < 0 && !controller.row) {
      selection.setRangeEnd(cellCoordsFactory(coords.row, currentSelection.to.col));
    } else if ((!selectedCorner && !selectedRow && coords.col < 0 || selectedCorner && coords.col < 0) && !controller.row) {
      selection.selectRows(Math.max(currentSelection.from.row, 0), coords.row, coords.col);
    } else if ((!selectedCorner && !selectedRow && coords.row < 0 || selectedRow && coords.row < 0) && !controller.column) {
      selection.selectColumns(Math.max(currentSelection.from.col, 0), coords.col, coords.row);
    }
  } else {
    const allowRightClickSelection = !selection.inInSelection(coords);
    const performSelection = isLeftClick2 || isRightClick2 && allowRightClickSelection;
    if (coords.row < 0 && coords.col >= 0 && !controller.column) {
      if (performSelection) {
        selection.selectColumns(coords.col, coords.col, coords.row);
      }
    } else if (coords.col < 0 && coords.row >= 0 && !controller.row) {
      if (performSelection) {
        selection.selectRows(coords.row, coords.row, coords.col);
      }
    } else if (coords.col >= 0 && coords.row >= 0 && !controller.cell) {
      if (performSelection) {
        selection.setRangeStart(coords);
      }
    } else if (coords.col < 0 && coords.row < 0) {
      selection.selectAll(true, true);
    }
  }
}
function mouseOver(_ref2) {
  let {
    isLeftClick: isLeftClick2,
    coords,
    selection,
    controller,
    cellCoordsFactory
  } = _ref2;
  if (!isLeftClick2) {
    return;
  }
  const selectedRow = selection.isSelectedByRowHeader();
  const selectedColumn = selection.isSelectedByColumnHeader();
  const countCols = selection.tableProps.countCols();
  const countRows = selection.tableProps.countRows();
  if (selectedColumn && !controller.column) {
    selection.setRangeEnd(cellCoordsFactory(countRows - 1, coords.col));
  } else if (selectedRow && !controller.row) {
    selection.setRangeEnd(cellCoordsFactory(coords.row, countCols - 1));
  } else if (!controller.cell) {
    selection.setRangeEnd(coords);
  }
}
var handlers = /* @__PURE__ */ new Map([["mousedown", mouseDown], ["mouseover", mouseOver], ["touchstart", mouseDown]]);
function handleMouseEvent(event2, _ref3) {
  let {
    coords,
    selection,
    controller,
    cellCoordsFactory
  } = _ref3;
  handlers.get(event2.type)({
    coords,
    selection,
    controller,
    cellCoordsFactory,
    isShiftKey: event2.shiftKey,
    isLeftClick: isLeftClick(event2) || event2.type === "touchstart",
    isRightClick: isRightClick(event2)
  });
}

// node_modules/handsontable/utils/rootInstance.mjs
var holder = /* @__PURE__ */ new WeakMap();
var rootInstanceSymbol = Symbol("rootInstance");
function registerAsRootInstance(object) {
  holder.set(object, true);
}
function hasValidParameter(rootSymbol) {
  return rootSymbol === rootInstanceSymbol;
}
function isRootInstance(object) {
  return holder.has(object);
}

// node_modules/handsontable/tableView.mjs
function _classPrivateFieldInitSpec3(obj, privateMap, value) {
  _checkPrivateRedeclaration3(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration3(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty13(obj, key, value) {
  key = _toPropertyKey13(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey13(arg) {
  var key = _toPrimitive13(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive13(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldGet3(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "get");
  return _classApplyDescriptorGet3(receiver, descriptor);
}
function _classApplyDescriptorGet3(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet3(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "set");
  _classApplyDescriptorSet3(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor3(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet3(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var privatePool4 = /* @__PURE__ */ new WeakMap();
var _columnHeadersCount = /* @__PURE__ */ new WeakMap();
var _rowHeadersCount = /* @__PURE__ */ new WeakMap();
var TableView = class {
  /**
   * @param {Hanstontable} instance Instance of {@link Handsontable}.
   */
  constructor(instance) {
    _defineProperty13(this, "instance", void 0);
    _defineProperty13(this, "eventManager", void 0);
    _defineProperty13(this, "settings", void 0);
    _defineProperty13(this, "THEAD", void 0);
    _defineProperty13(this, "TBODY", void 0);
    _defineProperty13(this, "_wt", void 0);
    _defineProperty13(this, "activeWt", void 0);
    _classPrivateFieldInitSpec3(this, _columnHeadersCount, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec3(this, _rowHeadersCount, {
      writable: true,
      value: 0
    });
    _defineProperty13(this, "postponedAdjustElementsSize", false);
    this.instance = instance;
    this.eventManager = new eventManager_default(this.instance);
    this.settings = this.instance.getSettings();
    privatePool4.set(this, {
      /**
       * Defines if the text should be selected during mousemove.
       *
       * @private
       * @type {boolean}
       */
      selectionMouseDown: false,
      /**
       * @private
       * @type {boolean}
       */
      mouseDown: void 0,
      /**
       * Main <TABLE> element.
       *
       * @private
       * @type {HTMLTableElement}
       */
      table: void 0,
      /**
       * Cached width of the rootElement.
       *
       * @type {number}
       */
      lastWidth: 0,
      /**
       * Cached height of the rootElement.
       *
       * @type {number}
       */
      lastHeight: 0
    });
    this.createElements();
    this.registerEvents();
    this.initializeWalkontable();
  }
  /**
   * Renders WalkontableUI.
   */
  render() {
    if (!this.instance.isRenderSuspended()) {
      this.instance.runHooks("beforeRender", this.instance.forceFullRender);
      if (this.postponedAdjustElementsSize) {
        this.postponedAdjustElementsSize = false;
        this.adjustElementsSize(true);
      }
      this._wt.draw(!this.instance.forceFullRender);
      this.instance.runHooks("afterRender", this.instance.forceFullRender);
      this.instance.forceFullRender = false;
      this.instance.renderCall = false;
    }
  }
  /**
   * Adjust overlays elements size and master table size.
   *
   * @param {boolean} [force=false] When `true`, it adjust the DOM nodes sizes for all overlays.
   */
  adjustElementsSize() {
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (this.instance.isRenderSuspended()) {
      this.postponedAdjustElementsSize = true;
    } else {
      this._wt.wtOverlays.adjustElementsSize(force);
    }
  }
  /**
   * Returns td object given coordinates.
   *
   * @param {CellCoords} coords Renderable cell coordinates.
   * @param {boolean} topmost Indicates whether the cell should be calculated from the topmost.
   * @returns {HTMLTableCellElement|null}
   */
  getCellAtCoords(coords, topmost) {
    const td = this._wt.getCell(coords, topmost);
    if (td < 0) {
      return null;
    }
    return td;
  }
  /**
   * Scroll viewport to a cell.
   *
   * @param {CellCoords} coords Renderable cell coordinates.
   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.
   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.
   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.
   * @returns {boolean}
   */
  scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {
    return this._wt.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);
  }
  /**
   * Scroll viewport to a column.
   *
   * @param {number} column Renderable column index.
   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right side of the table.
   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left side of the table.
   * @returns {boolean}
   */
  scrollViewportHorizontally(column, snapToRight, snapToLeft) {
    return this._wt.scrollViewportHorizontally(column, snapToRight, snapToLeft);
  }
  /**
   * Scroll viewport to a row.
   *
   * @param {number} row Renderable row index.
   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.
   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom side of the table.
   * @returns {boolean}
   */
  scrollViewportVertically(row, snapToTop, snapToBottom) {
    return this._wt.scrollViewportVertically(row, snapToTop, snapToBottom);
  }
  /**
   * Prepares DOMElements and adds correct className to the root element.
   *
   * @private
   */
  createElements() {
    const priv = privatePool4.get(this);
    const {
      rootElement,
      rootDocument
    } = this.instance;
    const originalStyle = rootElement.getAttribute("style");
    if (originalStyle) {
      rootElement.setAttribute("data-originalstyle", originalStyle);
    }
    addClass(rootElement, "handsontable");
    priv.table = rootDocument.createElement("TABLE");
    addClass(priv.table, "htCore");
    if (this.instance.getSettings().tableClassName) {
      addClass(priv.table, this.instance.getSettings().tableClassName);
    }
    this.THEAD = rootDocument.createElement("THEAD");
    priv.table.appendChild(this.THEAD);
    this.TBODY = rootDocument.createElement("TBODY");
    priv.table.appendChild(this.TBODY);
    this.instance.table = priv.table;
    this.instance.container.insertBefore(priv.table, this.instance.container.firstChild);
  }
  /**
   * Attaches necessary listeners.
   *
   * @private
   */
  registerEvents() {
    const priv = privatePool4.get(this);
    const {
      rootElement,
      rootDocument,
      selection
    } = this.instance;
    const documentElement = rootDocument.documentElement;
    this.eventManager.addEventListener(rootElement, "mousedown", (event2) => {
      priv.selectionMouseDown = true;
      if (!this.isTextSelectionAllowed(event2.target)) {
        const {
          rootWindow
        } = this.instance;
        clearTextSelection(rootWindow);
        event2.preventDefault();
        rootWindow.focus();
      }
    });
    this.eventManager.addEventListener(rootElement, "mouseup", () => {
      priv.selectionMouseDown = false;
    });
    this.eventManager.addEventListener(rootElement, "mousemove", (event2) => {
      if (priv.selectionMouseDown && !this.isTextSelectionAllowed(event2.target)) {
        if (this.settings.fragmentSelection) {
          clearTextSelection(this.instance.rootWindow);
        }
        event2.preventDefault();
      }
    });
    this.eventManager.addEventListener(documentElement, "keyup", (event2) => {
      if (selection.isInProgress() && !event2.shiftKey) {
        selection.finish();
      }
    });
    this.eventManager.addEventListener(documentElement, "mouseup", (event2) => {
      if (selection.isInProgress() && isLeftClick(event2)) {
        selection.finish();
      }
      priv.mouseDown = false;
      if (isOutsideInput(rootDocument.activeElement) || !selection.isSelected() && !selection.isSelectedByAnyHeader() && !rootElement.contains(event2.target) && !isRightClick(event2)) {
        this.instance.unlisten();
      }
    });
    this.eventManager.addEventListener(documentElement, "contextmenu", (event2) => {
      if (selection.isInProgress() && isRightClick(event2)) {
        selection.finish();
        priv.mouseDown = false;
      }
    });
    this.eventManager.addEventListener(documentElement, "touchend", () => {
      if (selection.isInProgress()) {
        selection.finish();
      }
      priv.mouseDown = false;
    });
    this.eventManager.addEventListener(documentElement, "mousedown", (event2) => {
      const originalTarget = event2.target;
      const eventX = event2.x || event2.clientX;
      const eventY = event2.y || event2.clientY;
      let next = event2.target;
      if (priv.mouseDown || !rootElement || !this.instance.view) {
        return;
      }
      const {
        holder: holder2
      } = this.instance.view._wt.wtTable;
      if (next === holder2) {
        const scrollbarWidth = getScrollbarWidth(rootDocument);
        if (rootDocument.elementFromPoint(eventX + scrollbarWidth, eventY) !== holder2 || rootDocument.elementFromPoint(eventX, eventY + scrollbarWidth) !== holder2) {
          return;
        }
      } else {
        while (next !== documentElement) {
          if (next === null) {
            if (event2.isTargetWebComponent) {
              break;
            }
            return;
          }
          if (next === rootElement) {
            return;
          }
          next = next.parentNode;
        }
      }
      const outsideClickDeselects = typeof this.settings.outsideClickDeselects === "function" ? this.settings.outsideClickDeselects(originalTarget) : this.settings.outsideClickDeselects;
      if (outsideClickDeselects) {
        this.instance.deselectCell();
      } else {
        this.instance.destroyEditor(false, false);
      }
    });
    this.eventManager.addEventListener(priv.table, "selectstart", (event2) => {
      if (this.settings.fragmentSelection || isInput(event2.target)) {
        return;
      }
      event2.preventDefault();
    });
  }
  /**
   * Translate renderable cell coordinates to visual coordinates.
   *
   * @param {CellCoords} coords The cell coordinates.
   * @returns {CellCoords}
   */
  translateFromRenderableToVisualCoords(_ref2) {
    let {
      row,
      col
    } = _ref2;
    return this.instance._createCellCoords(...this.translateFromRenderableToVisualIndex(row, col));
  }
  /**
   * Translate renderable row and column indexes to visual row and column indexes.
   *
   * @param {number} renderableRow Renderable row index.
   * @param {number} renderableColumn Renderable columnIndex.
   * @returns {number[]}
   */
  translateFromRenderableToVisualIndex(renderableRow, renderableColumn) {
    let visualRow = renderableRow >= 0 ? this.instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow;
    let visualColumn = renderableColumn >= 0 ? this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn;
    if (visualRow === null) {
      visualRow = renderableRow;
    }
    if (visualColumn === null) {
      visualColumn = renderableColumn;
    }
    return [visualRow, visualColumn];
  }
  /**
   * Returns the number of renderable indexes.
   *
   * @private
   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.
   * @param {number} maxElements Maximum number of elements (rows or columns).
   *
   * @returns {number|*}
   */
  countRenderableIndexes(indexMapper, maxElements) {
    const consideredElements = Math.min(indexMapper.getNotTrimmedIndexesLength(), maxElements);
    const firstNotHiddenIndex = indexMapper.getNearestNotHiddenIndex(consideredElements - 1, -1);
    if (firstNotHiddenIndex === null) {
      return 0;
    }
    return indexMapper.getRenderableFromVisualIndex(firstNotHiddenIndex) + 1;
  }
  /**
   * Returns the number of renderable columns.
   *
   * @returns {number}
   */
  countRenderableColumns() {
    return this.countRenderableIndexes(this.instance.columnIndexMapper, this.settings.maxCols);
  }
  /**
   * Returns the number of renderable rows.
   *
   * @returns {number}
   */
  countRenderableRows() {
    return this.countRenderableIndexes(this.instance.rowIndexMapper, this.settings.maxRows);
  }
  /**
   * Returns number of not hidden row indexes counting from the passed starting index.
   * The counting direction can be controlled by `incrementBy` argument.
   *
   * @param {number} visualIndex The visual index from which the counting begins.
   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.
   * @returns {number}
   */
  countNotHiddenRowIndexes(visualIndex, incrementBy) {
    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.instance.rowIndexMapper, this.countRenderableRows());
  }
  /**
   * Returns number of not hidden column indexes counting from the passed starting index.
   * The counting direction can be controlled by `incrementBy` argument.
   *
   * @param {number} visualIndex The visual index from which the counting begins.
   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.
   * @returns {number}
   */
  countNotHiddenColumnIndexes(visualIndex, incrementBy) {
    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.instance.columnIndexMapper, this.countRenderableColumns());
  }
  /**
   * Returns number of not hidden indexes counting from the passed starting index.
   * The counting direction can be controlled by `incrementBy` argument.
   *
   * @param {number} visualIndex The visual index from which the counting begins.
   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.
   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.
   * @param {number} renderableIndexesCount Total count of renderable indexes for specific axis.
   * @returns {number}
   */
  countNotHiddenIndexes(visualIndex, incrementBy, indexMapper, renderableIndexesCount) {
    if (isNaN(visualIndex) || visualIndex < 0) {
      return 0;
    }
    const firstVisibleIndex = indexMapper.getNearestNotHiddenIndex(visualIndex, incrementBy);
    const renderableIndex = indexMapper.getRenderableFromVisualIndex(firstVisibleIndex);
    if (!Number.isInteger(renderableIndex)) {
      return 0;
    }
    let notHiddenIndexes = 0;
    if (incrementBy < 0) {
      notHiddenIndexes = renderableIndex + 1;
    } else if (incrementBy > 0) {
      notHiddenIndexes = renderableIndexesCount - renderableIndex;
    }
    return notHiddenIndexes;
  }
  /**
   * The function returns the number of not hidden column indexes that fit between the first and
   * last fixed column in the left (or right in RTL mode) overlay.
   *
   * @returns {number}
   */
  countNotHiddenFixedColumnsStart() {
    const countCols = this.instance.countCols();
    const visualFixedColumnsStart = Math.min(parseInt(this.settings.fixedColumnsStart, 10), countCols) - 1;
    return this.countNotHiddenColumnIndexes(visualFixedColumnsStart, -1);
  }
  /**
   * The function returns the number of not hidden row indexes that fit between the first and
   * last fixed row in the top overlay.
   *
   * @returns {number}
   */
  countNotHiddenFixedRowsTop() {
    const countRows = this.instance.countRows();
    const visualFixedRowsTop = Math.min(parseInt(this.settings.fixedRowsTop, 10), countRows) - 1;
    return this.countNotHiddenRowIndexes(visualFixedRowsTop, -1);
  }
  /**
   * The function returns the number of not hidden row indexes that fit between the first and
   * last fixed row in the bottom overlay.
   *
   * @returns {number}
   */
  countNotHiddenFixedRowsBottom() {
    const countRows = this.instance.countRows();
    const visualFixedRowsBottom = Math.max(countRows - parseInt(this.settings.fixedRowsBottom, 10), 0);
    return this.countNotHiddenRowIndexes(visualFixedRowsBottom, 1);
  }
  /**
   * Checks if at least one cell than belongs to the main table is not covered by the top, left or
   * bottom overlay.
   *
   * @returns {boolean}
   */
  isMainTableNotFullyCoveredByOverlays() {
    const fixedAllRows = this.countNotHiddenFixedRowsTop() + this.countNotHiddenFixedRowsBottom();
    const fixedAllColumns = this.countNotHiddenFixedColumnsStart();
    return this.instance.countRenderedRows() > fixedAllRows && this.instance.countRenderedCols() > fixedAllColumns;
  }
  /**
   * Defines default configuration and initializes WalkOnTable instance.
   *
   * @private
   */
  initializeWalkontable() {
    const priv = privatePool4.get(this);
    const walkontableConfig = {
      rtlMode: this.instance.isRtl(),
      externalRowCalculator: this.instance.getPlugin("autoRowSize") && this.instance.getPlugin("autoRowSize").isEnabled(),
      table: priv.table,
      isDataViewInstance: () => isRootInstance(this.instance),
      preventOverflow: () => this.settings.preventOverflow,
      preventWheel: () => this.settings.preventWheel,
      stretchH: () => this.settings.stretchH,
      data: (renderableRow, renderableColumn) => {
        return this.instance.getDataAtCell(...this.translateFromRenderableToVisualIndex(renderableRow, renderableColumn));
      },
      totalRows: () => this.countRenderableRows(),
      totalColumns: () => this.countRenderableColumns(),
      // Number of renderable columns for the left overlay.
      fixedColumnsStart: () => this.countNotHiddenFixedColumnsStart(),
      // Number of renderable rows for the top overlay.
      fixedRowsTop: () => this.countNotHiddenFixedRowsTop(),
      // Number of renderable rows for the bottom overlay.
      fixedRowsBottom: () => this.countNotHiddenFixedRowsBottom(),
      // Enable the inline start overlay when conditions are met.
      shouldRenderInlineStartOverlay: () => {
        return this.settings.fixedColumnsStart > 0 || walkontableConfig.rowHeaders().length > 0;
      },
      // Enable the top overlay when conditions are met.
      shouldRenderTopOverlay: () => {
        return this.settings.fixedRowsTop > 0 || walkontableConfig.columnHeaders().length > 0;
      },
      // Enable the bottom overlay when conditions are met.
      shouldRenderBottomOverlay: () => {
        return this.settings.fixedRowsBottom > 0;
      },
      minSpareRows: () => this.settings.minSpareRows,
      renderAllRows: this.settings.renderAllRows,
      rowHeaders: () => {
        const headerRenderers = [];
        if (this.instance.hasRowHeaders()) {
          headerRenderers.push((renderableRowIndex, TH) => {
            const visualRowIndex = renderableRowIndex >= 0 ? this.instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;
            this.appendRowHeader(visualRowIndex, TH);
          });
        }
        this.instance.runHooks("afterGetRowHeaderRenderers", headerRenderers);
        _classPrivateFieldSet3(this, _rowHeadersCount, headerRenderers.length);
        return headerRenderers;
      },
      columnHeaders: () => {
        const headerRenderers = [];
        if (this.instance.hasColHeaders()) {
          headerRenderers.push((renderedColumnIndex, TH) => {
            const visualColumnsIndex = renderedColumnIndex >= 0 ? this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex) : renderedColumnIndex;
            this.appendColHeader(visualColumnsIndex, TH);
          });
        }
        this.instance.runHooks("afterGetColumnHeaderRenderers", headerRenderers);
        _classPrivateFieldSet3(this, _columnHeadersCount, headerRenderers.length);
        return headerRenderers;
      },
      columnWidth: (renderedColumnIndex) => {
        const visualIndex = this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
        return this.instance.getColWidth(visualIndex === null ? renderedColumnIndex : visualIndex);
      },
      rowHeight: (renderedRowIndex) => {
        const visualIndex = this.instance.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);
        return this.instance.getRowHeight(visualIndex === null ? renderedRowIndex : visualIndex);
      },
      cellRenderer: (renderedRowIndex, renderedColumnIndex, TD) => {
        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(renderedRowIndex, renderedColumnIndex);
        const modifiedCellCoords = this.instance.runHooks("modifyGetCellCoords", visualRowIndex, visualColumnIndex);
        let visualRowToCheck = visualRowIndex;
        let visualColumnToCheck = visualColumnIndex;
        if (Array.isArray(modifiedCellCoords)) {
          [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;
        }
        const cellProperties = this.instance.getCellMeta(visualRowToCheck, visualColumnToCheck);
        const prop = this.instance.colToProp(visualColumnToCheck);
        let value = this.instance.getDataAtRowProp(visualRowToCheck, prop);
        if (this.instance.hasHook("beforeValueRender")) {
          value = this.instance.runHooks("beforeValueRender", value, cellProperties);
        }
        this.instance.runHooks("beforeRenderer", TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
        this.instance.getCellRenderer(cellProperties)(this.instance, TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
        this.instance.runHooks("afterRenderer", TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
      },
      selections: this.instance.selection.highlight,
      hideBorderOnMouseDownOver: () => this.settings.fragmentSelection,
      onWindowResize: () => {
        if (this.instance && !this.instance.isDestroyed) {
          this.instance.refreshDimensions();
        }
      },
      onContainerElementResize: () => {
        if (this.instance && !this.instance.isDestroyed) {
          this.instance.refreshDimensions();
        }
      },
      onCellMouseDown: (event2, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        const controller = {
          row: false,
          column: false,
          cell: false
        };
        this.instance.listen();
        this.activeWt = wt;
        priv.mouseDown = true;
        this.instance.runHooks("beforeOnCellMouseDown", event2, visualCoords, TD, controller);
        if (isImmediatePropagationStopped(event2)) {
          return;
        }
        handleMouseEvent(event2, {
          coords: visualCoords,
          selection: this.instance.selection,
          controller,
          cellCoordsFactory: (row, column) => this.instance._createCellCoords(row, column)
        });
        this.instance.runHooks("afterOnCellMouseDown", event2, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellContextMenu: (event2, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        this.activeWt = wt;
        priv.mouseDown = false;
        if (this.instance.selection.isInProgress()) {
          this.instance.selection.finish();
        }
        this.instance.runHooks("beforeOnCellContextMenu", event2, visualCoords, TD);
        if (isImmediatePropagationStopped(event2)) {
          return;
        }
        this.instance.runHooks("afterOnCellContextMenu", event2, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellMouseOut: (event2, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        this.activeWt = wt;
        this.instance.runHooks("beforeOnCellMouseOut", event2, visualCoords, TD);
        if (isImmediatePropagationStopped(event2)) {
          return;
        }
        this.instance.runHooks("afterOnCellMouseOut", event2, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellMouseOver: (event2, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        const controller = {
          row: false,
          column: false,
          cell: false
        };
        this.activeWt = wt;
        this.instance.runHooks("beforeOnCellMouseOver", event2, visualCoords, TD, controller);
        if (isImmediatePropagationStopped(event2)) {
          return;
        }
        if (priv.mouseDown) {
          handleMouseEvent(event2, {
            coords: visualCoords,
            selection: this.instance.selection,
            controller,
            cellCoordsFactory: (row, column) => this.instance._createCellCoords(row, column)
          });
        }
        this.instance.runHooks("afterOnCellMouseOver", event2, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellMouseUp: (event2, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        this.activeWt = wt;
        this.instance.runHooks("beforeOnCellMouseUp", event2, visualCoords, TD);
        if (isImmediatePropagationStopped(event2) || this.instance.isDestroyed) {
          return;
        }
        this.instance.runHooks("afterOnCellMouseUp", event2, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellCornerMouseDown: (event2) => {
        event2.preventDefault();
        this.instance.runHooks("afterOnCellCornerMouseDown", event2);
      },
      onCellCornerDblClick: (event2) => {
        event2.preventDefault();
        this.instance.runHooks("afterOnCellCornerDblClick", event2);
      },
      beforeDraw: (force, skipRender) => this.beforeRender(force, skipRender),
      onDraw: (force) => this.afterRender(force),
      onScrollVertically: () => this.instance.runHooks("afterScrollVertically"),
      onScrollHorizontally: () => this.instance.runHooks("afterScrollHorizontally"),
      onBeforeRemoveCellClassNames: () => this.instance.runHooks("beforeRemoveCellClassNames"),
      onBeforeHighlightingRowHeader: (renderableRow, headerLevel, highlightMeta) => {
        const rowMapper = this.instance.rowIndexMapper;
        const visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);
        const newVisualRow = this.instance.runHooks("beforeHighlightingRowHeader", visualRow, headerLevel, highlightMeta);
        return rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(newVisualRow, 1));
      },
      onBeforeHighlightingColumnHeader: (renderableColumn, headerLevel, highlightMeta) => {
        const columnMapper = this.instance.columnIndexMapper;
        const visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);
        const newVisualColumn = this.instance.runHooks("beforeHighlightingColumnHeader", visualColumn, headerLevel, highlightMeta);
        return columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(newVisualColumn, 1));
      },
      onAfterDrawSelection: (currentRow, currentColumn, layerLevel) => {
        let cornersOfSelection;
        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(currentRow, currentColumn);
        const selectedRange = this.instance.selection.getSelectedRange();
        const selectionRangeSize = selectedRange.size();
        if (selectionRangeSize > 0) {
          const selectionOffset = (layerLevel !== null && layerLevel !== void 0 ? layerLevel : 0) + 1 - selectionRangeSize;
          const selectionForLayer = selectedRange.peekByIndex(selectionOffset);
          cornersOfSelection = [selectionForLayer.from.row, selectionForLayer.from.col, selectionForLayer.to.row, selectionForLayer.to.col];
        }
        return this.instance.runHooks("afterDrawSelection", visualRowIndex, visualColumnIndex, cornersOfSelection, layerLevel);
      },
      onBeforeDrawBorders: (corners, borderClassName) => {
        const [startRenderableRow, startRenderableColumn, endRenderableRow, endRenderableColumn] = corners;
        const visualCorners = [this.instance.rowIndexMapper.getVisualFromRenderableIndex(startRenderableRow), this.instance.columnIndexMapper.getVisualFromRenderableIndex(startRenderableColumn), this.instance.rowIndexMapper.getVisualFromRenderableIndex(endRenderableRow), this.instance.columnIndexMapper.getVisualFromRenderableIndex(endRenderableColumn)];
        return this.instance.runHooks("beforeDrawBorders", visualCorners, borderClassName);
      },
      onBeforeTouchScroll: () => this.instance.runHooks("beforeTouchScroll"),
      onAfterMomentumScroll: () => this.instance.runHooks("afterMomentumScroll"),
      onBeforeStretchingColumnWidth: (stretchedWidth, renderedColumnIndex) => {
        const visualColumnIndex = this.instance.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
        return this.instance.runHooks("beforeStretchingColumnWidth", stretchedWidth, visualColumnIndex);
      },
      onModifyRowHeaderWidth: (rowHeaderWidth) => this.instance.runHooks("modifyRowHeaderWidth", rowHeaderWidth),
      onModifyGetCellCoords: (renderableRowIndex, renderableColumnIndex, topmost) => {
        const rowMapper = this.instance.rowIndexMapper;
        const columnMapper = this.instance.columnIndexMapper;
        const visualColumnIndex = renderableColumnIndex >= 0 ? columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : renderableColumnIndex;
        const visualRowIndex = renderableRowIndex >= 0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;
        const visualIndexes = this.instance.runHooks("modifyGetCellCoords", visualRowIndex, visualColumnIndex, topmost);
        if (Array.isArray(visualIndexes)) {
          const [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = visualIndexes;
          return [visualRowFrom >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowFrom, 1)) : visualRowFrom, visualColumnFrom >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnFrom, 1)) : visualColumnFrom, visualRowTo >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowTo, -1)) : visualRowTo, visualColumnTo >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnTo, -1)) : visualColumnTo];
        }
      },
      viewportRowCalculatorOverride: (calc) => {
        let viewportOffset = this.settings.viewportRowRenderingOffset;
        if (viewportOffset === "auto" && this.settings.fixedRowsTop) {
          viewportOffset = 10;
        }
        if (viewportOffset > 0 || viewportOffset === "auto") {
          const renderableRows = this.countRenderableRows();
          const firstRenderedRow = calc.startRow;
          const lastRenderedRow = calc.endRow;
          if (typeof viewportOffset === "number") {
            calc.startRow = Math.max(firstRenderedRow - viewportOffset, 0);
            calc.endRow = Math.min(lastRenderedRow + viewportOffset, renderableRows - 1);
          } else if (viewportOffset === "auto") {
            const offset3 = Math.ceil(lastRenderedRow / renderableRows * 12);
            calc.startRow = Math.max(firstRenderedRow - offset3, 0);
            calc.endRow = Math.min(lastRenderedRow + offset3, renderableRows - 1);
          }
        }
        this.instance.runHooks("afterViewportRowCalculatorOverride", calc);
      },
      viewportColumnCalculatorOverride: (calc) => {
        let viewportOffset = this.settings.viewportColumnRenderingOffset;
        if (viewportOffset === "auto" && this.settings.fixedColumnsStart) {
          viewportOffset = 10;
        }
        if (viewportOffset > 0 || viewportOffset === "auto") {
          const renderableColumns = this.countRenderableColumns();
          const firstRenderedColumn = calc.startColumn;
          const lastRenderedColumn = calc.endColumn;
          if (typeof viewportOffset === "number") {
            calc.startColumn = Math.max(firstRenderedColumn - viewportOffset, 0);
            calc.endColumn = Math.min(lastRenderedColumn + viewportOffset, renderableColumns - 1);
          }
          if (viewportOffset === "auto") {
            const offset3 = Math.ceil(lastRenderedColumn / renderableColumns * 6);
            calc.startColumn = Math.max(firstRenderedColumn - offset3, 0);
            calc.endColumn = Math.min(lastRenderedColumn + offset3, renderableColumns - 1);
          }
        }
        this.instance.runHooks("afterViewportColumnCalculatorOverride", calc);
      },
      rowHeaderWidth: () => this.settings.rowHeaderWidth,
      columnHeaderHeight: () => {
        const columnHeaderHeight = this.instance.runHooks("modifyColumnHeaderHeight");
        return this.settings.columnHeaderHeight || columnHeaderHeight;
      }
    };
    this.instance.runHooks("beforeInitWalkontable", walkontableConfig);
    this._wt = new WalkontableFacade(walkontableConfig);
    this.activeWt = this._wt;
    const spreader = this._wt.wtTable.spreader;
    const {
      width,
      height
    } = this.instance.rootElement.getBoundingClientRect();
    this.setLastSize(width, height);
    this.eventManager.addEventListener(spreader, "mousedown", (event2) => {
      if (event2.target === spreader && event2.which === 3) {
        event2.stopPropagation();
      }
    });
    this.eventManager.addEventListener(spreader, "contextmenu", (event2) => {
      if (event2.target === spreader && event2.which === 3) {
        event2.stopPropagation();
      }
    });
    this.eventManager.addEventListener(this.instance.rootDocument.documentElement, "click", () => {
      if (this.settings.observeDOMVisibility) {
        if (this._wt.drawInterrupted) {
          this.instance.forceFullRender = true;
          this.render();
        }
      }
    });
  }
  /**
   * Checks if it's possible to create text selection in element.
   *
   * @private
   * @param {HTMLElement} el The element to check.
   * @returns {boolean}
   */
  isTextSelectionAllowed(el) {
    if (isInput(el)) {
      return true;
    }
    const isChildOfTableBody = isChildOf(el, this.instance.view._wt.wtTable.spreader);
    if (this.settings.fragmentSelection === true && isChildOfTableBody) {
      return true;
    }
    if (this.settings.fragmentSelection === "cell" && this.isSelectedOnlyCell() && isChildOfTableBody) {
      return true;
    }
    if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {
      return true;
    }
    return false;
  }
  /**
   * Checks if user's been called mousedown.
   *
   * @private
   * @returns {boolean}
   */
  isMouseDown() {
    return privatePool4.get(this).mouseDown;
  }
  /**
   * Check if selected only one cell.
   *
   * @private
   * @returns {boolean}
   */
  isSelectedOnlyCell() {
    var _this$instance$getSel, _this$instance$getSel2;
    return (_this$instance$getSel = (_this$instance$getSel2 = this.instance.getSelectedRangeLast()) === null || _this$instance$getSel2 === void 0 ? void 0 : _this$instance$getSel2.isSingle()) !== null && _this$instance$getSel !== void 0 ? _this$instance$getSel : false;
  }
  /**
   * Checks if active cell is editing.
   *
   * @private
   * @returns {boolean}
   */
  isCellEdited() {
    const activeEditor = this.instance.getActiveEditor();
    return activeEditor && activeEditor.isOpened();
  }
  /**
   * `beforeDraw` callback.
   *
   * @private
   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if
   *                        rendering was triggered by scrolling or moving selection.
   * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering
   *                            cycle will be skipped.
   */
  beforeRender(force, skipRender) {
    if (force) {
      this.instance.runHooks("beforeViewRender", this.instance.forceFullRender, skipRender);
    }
  }
  /**
   * `afterRender` callback.
   *
   * @private
   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if
   *                        rendering was triggered by scrolling or moving selection.
   */
  afterRender(force) {
    if (force) {
      this.instance.runHooks("afterViewRender", this.instance.forceFullRender);
    }
  }
  /**
   * Append row header to a TH element.
   *
   * @private
   * @param {number} visualRowIndex The visual row index.
   * @param {HTMLTableHeaderCellElement} TH The table header element.
   */
  appendRowHeader(visualRowIndex, TH) {
    if (TH.firstChild) {
      const container = TH.firstChild;
      if (!hasClass(container, "relative")) {
        empty(TH);
        this.appendRowHeader(visualRowIndex, TH);
        return;
      }
      this.updateCellHeader(container.querySelector(".rowHeader"), visualRowIndex, this.instance.getRowHeader);
    } else {
      const {
        rootDocument,
        getRowHeader
      } = this.instance;
      const div = rootDocument.createElement("div");
      const span = rootDocument.createElement("span");
      div.className = "relative";
      span.className = "rowHeader";
      this.updateCellHeader(span, visualRowIndex, getRowHeader);
      div.appendChild(span);
      TH.appendChild(div);
    }
    this.instance.runHooks("afterGetRowHeader", visualRowIndex, TH);
  }
  /**
   * Append column header to a TH element.
   *
   * @private
   * @param {number} visualColumnIndex Visual column index.
   * @param {HTMLTableCellElement} TH The table header element.
   * @param {Function} [label] The function that returns the header label.
   * @param {number} [headerLevel=0] The index of header level counting from the top (positive
   *                                 values counting from 0 to N).
   */
  appendColHeader(visualColumnIndex, TH) {
    let label = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.instance.getColHeader;
    let headerLevel = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    if (TH.firstChild) {
      const container = TH.firstChild;
      if (hasClass(container, "relative")) {
        this.updateCellHeader(container.querySelector(".colHeader"), visualColumnIndex, label, headerLevel);
      } else {
        empty(TH);
        this.appendColHeader(visualColumnIndex, TH, label, headerLevel);
      }
    } else {
      const {
        rootDocument
      } = this.instance;
      const div = rootDocument.createElement("div");
      const span = rootDocument.createElement("span");
      div.className = "relative";
      span.className = "colHeader";
      this.updateCellHeader(span, visualColumnIndex, label, headerLevel);
      div.appendChild(span);
      TH.appendChild(div);
    }
    this.instance.runHooks("afterGetColHeader", visualColumnIndex, TH, headerLevel);
  }
  /**
   * Updates header cell content.
   *
   * @private
   * @param {HTMLElement} element Element to update.
   * @param {number} index Row index or column index.
   * @param {Function} content Function which should be returns content for this cell.
   * @param {number} [headerLevel=0] The index of header level counting from the top (positive
   *                                 values counting from 0 to N).
   */
  updateCellHeader(element, index2, content) {
    let headerLevel = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let renderedIndex = index2;
    const parentOverlay = this._wt.wtOverlays.getParentOverlay(element) || this._wt;
    if (element.parentNode) {
      if (hasClass(element, "colHeader")) {
        renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index2);
      } else if (hasClass(element, "rowHeader")) {
        renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index2);
      }
    }
    if (renderedIndex > -1) {
      fastInnerHTML(element, content(index2, headerLevel));
    } else {
      fastInnerText(element, String.fromCharCode(160));
      addClass(element, "cornerHeader");
    }
  }
  /**
   * Given a element's left (or right in RTL mode) position relative to the viewport, returns maximum
   * element width until the right (or left) edge of the viewport (before scrollbar).
   *
   * @private
   * @param {number} inlineOffset The left (or right in RTL mode) offset.
   * @returns {number}
   */
  maximumVisibleElementWidth(inlineOffset) {
    const workspaceWidth = this._wt.wtViewport.getWorkspaceWidth();
    const maxWidth = workspaceWidth - inlineOffset;
    return maxWidth > 0 ? maxWidth : 0;
  }
  /**
   * Given a element's top position relative to the viewport, returns maximum element height until the bottom
   * edge of the viewport (before scrollbar).
   *
   * @private
   * @param {number} topOffset The top offset.
   * @returns {number}
   */
  maximumVisibleElementHeight(topOffset) {
    const workspaceHeight = this._wt.wtViewport.getWorkspaceHeight();
    const maxHeight = workspaceHeight - topOffset;
    return maxHeight > 0 ? maxHeight : 0;
  }
  /**
   * Sets new dimensions of the container.
   *
   * @param {number} width The table width.
   * @param {number} height The table height.
   */
  setLastSize(width, height) {
    const priv = privatePool4.get(this);
    [priv.lastWidth, priv.lastHeight] = [width, height];
  }
  /**
   * Returns cached dimensions.
   *
   * @returns {object}
   */
  getLastSize() {
    const priv = privatePool4.get(this);
    return {
      width: priv.lastWidth,
      height: priv.lastHeight
    };
  }
  /**
   * Returns the first fully visible row in the table viewport.
   *
   * @returns {number}
   */
  getFirstFullyVisibleRow() {
    return this.instance.rowIndexMapper.getVisualFromRenderableIndex(this.instance.view._wt.wtScroll.getFirstVisibleRow());
  }
  /**
   * Returns the last fully visible row in the table viewport.
   *
   * @returns {number}
   */
  getLastFullyVisibleRow() {
    return this.instance.rowIndexMapper.getVisualFromRenderableIndex(this.instance.view._wt.wtScroll.getLastVisibleRow());
  }
  /**
   * Returns the first fully visible column in the table viewport.
   *
   * @returns {number}
   */
  getFirstFullyVisibleColumn() {
    return this.instance.columnIndexMapper.getVisualFromRenderableIndex(this.instance.view._wt.wtScroll.getFirstVisibleColumn());
  }
  /**
   * Returns the last fully visible column in the table viewport.
   *
   * @returns {number}
   */
  getLastFullyVisibleColumn() {
    return this.instance.columnIndexMapper.getVisualFromRenderableIndex(this.instance.view._wt.wtScroll.getLastVisibleColumn());
  }
  /**
   * Returns the total count of the rendered column headers.
   *
   * @returns {number}
   */
  getColumnHeadersCount() {
    return _classPrivateFieldGet3(this, _columnHeadersCount);
  }
  /**
   * Returns the total count of the rendered row headers.
   *
   * @returns {number}
   */
  getRowHeadersCount() {
    return _classPrivateFieldGet3(this, _rowHeadersCount);
  }
  /**
   * Destroys internal WalkOnTable's instance. Detaches all of the bonded listeners.
   *
   * @private
   */
  destroy() {
    this._wt.destroy();
    this.eventManager.destroy();
  }
};
var tableView_default = TableView;

// node_modules/handsontable/helpers/data.mjs
var data_exports = {};
__export(data_exports, {
  countFirstRowKeys: () => countFirstRowKeys,
  createEmptySpreadsheetData: () => createEmptySpreadsheetData,
  createSpreadsheetData: () => createSpreadsheetData,
  createSpreadsheetObjectData: () => createSpreadsheetObjectData,
  dataRowToChangesArray: () => dataRowToChangesArray,
  isArrayOfArrays: () => isArrayOfArrays,
  isArrayOfObjects: () => isArrayOfObjects,
  spreadsheetColumnIndex: () => spreadsheetColumnIndex,
  spreadsheetColumnLabel: () => spreadsheetColumnLabel
});
var COLUMN_LABEL_BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;
function spreadsheetColumnLabel(index2) {
  let dividend = index2 + 1;
  let columnLabel = "";
  let modulo;
  while (dividend > 0) {
    modulo = (dividend - 1) % COLUMN_LABEL_BASE_LENGTH;
    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
    dividend = parseInt((dividend - modulo) / COLUMN_LABEL_BASE_LENGTH, 10);
  }
  return columnLabel;
}
function spreadsheetColumnIndex(label) {
  let result = 0;
  if (label) {
    for (let i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {
      result += COLUMN_LABEL_BASE_LENGTH ** j * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);
    }
  }
  result -= 1;
  return result;
}
function createSpreadsheetData() {
  let rows = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
  let columns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
  const _rows = [];
  let i;
  let j;
  for (i = 0; i < rows; i++) {
    const row = [];
    for (j = 0; j < columns; j++) {
      row.push(spreadsheetColumnLabel(j) + (i + 1));
    }
    _rows.push(row);
  }
  return _rows;
}
function createSpreadsheetObjectData() {
  let rows = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
  let colCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
  const _rows = [];
  let i;
  let j;
  for (i = 0; i < rows; i++) {
    const row = {};
    for (j = 0; j < colCount; j++) {
      row[`prop${j}`] = spreadsheetColumnLabel(j) + (i + 1);
    }
    _rows.push(row);
  }
  return _rows;
}
function createEmptySpreadsheetData(rows, columns) {
  const data = [];
  let row;
  for (let i = 0; i < rows; i++) {
    row = [];
    for (let j = 0; j < columns; j++) {
      row.push("");
    }
    data.push(row);
  }
  return data;
}
function dataRowToChangesArray(dataRow) {
  let rowOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let dataRows = dataRow;
  const changesArray = [];
  if (!Array.isArray(dataRow) || !Array.isArray(dataRow[0])) {
    dataRows = [dataRow];
  }
  dataRows.forEach((row, rowIndex) => {
    if (Array.isArray(row)) {
      row.forEach((value, column) => {
        changesArray.push([rowIndex + rowOffset, column, value]);
      });
    } else {
      Object.keys(row).forEach((propName) => {
        changesArray.push([rowIndex + rowOffset, propName, row[propName]]);
      });
    }
  });
  return changesArray;
}
function countFirstRowKeys(data) {
  let result = 0;
  if (Array.isArray(data)) {
    if (data[0] && Array.isArray(data[0])) {
      result = data[0].length;
    } else if (data[0] && isObject2(data[0])) {
      result = deepObjectSize(data[0]);
    }
  }
  return result;
}
function isArrayOfArrays(data) {
  return !!(Array.isArray(data) && data.length && data.every((el) => Array.isArray(el)));
}
function isArrayOfObjects(data) {
  return !!(Array.isArray(data) && data.length && data.every((el) => typeof el === "object" && !Array.isArray(el) && el !== null));
}

// node_modules/handsontable/dataMap/dataSource.mjs
var DataSource = class {
  constructor(hotInstance) {
    let dataSource = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    this.hot = hotInstance;
    this.data = dataSource;
    this.dataType = "array";
    this.colToProp = () => {
    };
    this.propToCol = () => {
    };
  }
  /**
   * Run the `modifyRowData` hook and return either the modified or the source data for the provided row.
   *
   * @private
   * @param {number} rowIndex Row index.
   * @returns {Array|object} Source or modified row of data.
   */
  modifyRowData(rowIndex) {
    let modifyRowData;
    if (this.hot.hasHook("modifyRowData")) {
      modifyRowData = this.hot.runHooks("modifyRowData", rowIndex);
    }
    return modifyRowData !== void 0 && !Number.isInteger(modifyRowData) ? modifyRowData : this.data[rowIndex];
  }
  /**
   * Get all data.
   *
   * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided
   *                                  in another format.
   * @returns {Array}
   */
  getData() {
    let toArray2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!this.data || this.data.length === 0) {
      return this.data;
    }
    return this.getByRange(null, null, toArray2);
  }
  /**
   * Set new data source.
   *
   * @param {Array} data The new data.
   */
  setData(data) {
    this.data = data;
  }
  /**
   * Returns array of column values from the data source. `column` is the index of the row in the data source.
   *
   * @param {number} column Visual column index.
   * @returns {Array}
   */
  getAtColumn(column) {
    const result = [];
    arrayEach(this.data, (row, rowIndex) => {
      const value = this.getAtCell(rowIndex, column);
      result.push(value);
    });
    return result;
  }
  /**
   * Returns a single row of the data or a subset of its columns. If a column range or `toArray` arguments are provided, it
   * operates only on the columns declared by the `columns` setting or the data schema.
   *
   * @param {number} row Physical row index.
   * @param {number} [startColumn] Starting index for the column range (optional).
   * @param {number} [endColumn] Ending index for the column range (optional).
   * @param {boolean} [toArray=false] `true` if the returned value should be forced to be presented as an array.
   * @returns {Array|object}
   */
  getAtRow(row, startColumn, endColumn) {
    let toArray2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const getAllProps = startColumn === void 0 && endColumn === void 0;
    let dataRow = null;
    let newDataRow = null;
    dataRow = this.modifyRowData(row);
    if (Array.isArray(dataRow)) {
      newDataRow = [];
      if (getAllProps) {
        dataRow.forEach((cell, column) => {
          newDataRow[column] = this.getAtPhysicalCell(row, column, dataRow);
        });
      } else {
        rangeEach(startColumn, endColumn, (column) => {
          newDataRow[column - startColumn] = this.getAtPhysicalCell(row, column, dataRow);
        });
      }
    } else if (isObject2(dataRow) || isFunction2(dataRow)) {
      if (toArray2) {
        newDataRow = [];
      } else {
        newDataRow = {};
      }
      if (!getAllProps || toArray2) {
        const rangeStart = 0;
        const rangeEnd = this.countFirstRowKeys() - 1;
        rangeEach(rangeStart, rangeEnd, (column) => {
          const prop = this.colToProp(column);
          if (column >= (startColumn || rangeStart) && column <= (endColumn || rangeEnd) && !Number.isInteger(prop)) {
            const cellValue = this.getAtPhysicalCell(row, prop, dataRow);
            if (toArray2) {
              newDataRow.push(cellValue);
            } else {
              setProperty(newDataRow, prop, cellValue);
            }
          }
        });
      } else {
        objectEach(dataRow, (value, prop) => {
          setProperty(newDataRow, prop, this.getAtPhysicalCell(row, prop, dataRow));
        });
      }
    }
    return newDataRow;
  }
  /**
   * Set the provided value in the source data set at the provided coordinates.
   *
   * @param {number} row Physical row index.
   * @param {number|string} column Property name / physical column index.
   * @param {*} value The value to be set at the provided coordinates.
   */
  setAtCell(row, column, value) {
    if (row >= this.countRows() || column >= this.countFirstRowKeys()) {
      return;
    }
    if (this.hot.hasHook("modifySourceData")) {
      const valueHolder = createObjectPropListener(value);
      this.hot.runHooks("modifySourceData", row, column, valueHolder, "set");
      if (valueHolder.isTouched()) {
        value = valueHolder.value;
      }
    }
    if (!Number.isInteger(column)) {
      setProperty(this.data[row], column, value);
    } else {
      this.data[row][column] = value;
    }
  }
  /**
   * Get data from the source data set using the physical indexes.
   *
   * @private
   * @param {number} row Physical row index.
   * @param {string|number|Function} column Physical column index / property / function.
   * @param {Array|object} dataRow A representation of a data row.
   * @returns {*} Value at the provided coordinates.
   */
  getAtPhysicalCell(row, column, dataRow) {
    let result = null;
    if (dataRow) {
      if (typeof column === "string") {
        result = getProperty(dataRow, column);
      } else if (typeof column === "function") {
        result = column(dataRow);
      } else {
        result = dataRow[column];
      }
    }
    if (this.hot.hasHook("modifySourceData")) {
      const valueHolder = createObjectPropListener(result);
      this.hot.runHooks("modifySourceData", row, column, valueHolder, "get");
      if (valueHolder.isTouched()) {
        result = valueHolder.value;
      }
    }
    return result;
  }
  /**
   * Returns a single value from the data.
   *
   * @param {number} row Physical row index.
   * @param {number} columnOrProp Visual column index or property.
   * @returns {*}
   */
  getAtCell(row, columnOrProp) {
    const dataRow = this.modifyRowData(row);
    return this.getAtPhysicalCell(row, this.colToProp(columnOrProp), dataRow);
  }
  /**
   * Returns source data by passed range.
   *
   * @param {object} [start] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).
   * @param {object} [end] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).
   * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided
   *                                  in another format.
   * @returns {Array}
   */
  getByRange() {
    let start = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let end = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let toArray2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let getAllProps = false;
    let startRow = null;
    let startCol = null;
    let endRow = null;
    let endCol = null;
    if (start === null || end === null) {
      getAllProps = true;
      startRow = 0;
      endRow = this.countRows() - 1;
    } else {
      startRow = Math.min(start.row, end.row);
      startCol = Math.min(start.col, end.col);
      endRow = Math.max(start.row, end.row);
      endCol = Math.max(start.col, end.col);
    }
    const result = [];
    rangeEach(startRow, endRow, (currentRow) => {
      result.push(getAllProps ? this.getAtRow(currentRow, void 0, void 0, toArray2) : this.getAtRow(currentRow, startCol, endCol, toArray2));
    });
    return result;
  }
  /**
   * Count number of rows.
   *
   * @returns {number}
   */
  countRows() {
    if (this.hot.hasHook("modifySourceLength")) {
      const modifiedSourceLength = this.hot.runHooks("modifySourceLength");
      if (Number.isInteger(modifiedSourceLength)) {
        return modifiedSourceLength;
      }
    }
    return this.data.length;
  }
  /**
   * Count number of columns.
   *
   * @returns {number}
   */
  countFirstRowKeys() {
    return countFirstRowKeys(this.data);
  }
  /**
   * Destroy instance.
   */
  destroy() {
    this.data = null;
    this.hot = null;
  }
};
var dataSource_default = DataSource;

// node_modules/handsontable/mixins/localHooks.mjs
var MIXIN_NAME6 = "localHooks";
var localHooks = {
  /**
   * Internal hooks storage.
   */
  _localHooks: /* @__PURE__ */ Object.create(null),
  /**
   * Add hook to the collection.
   *
   * @param {string} key The hook name.
   * @param {Function} callback The hook callback.
   * @returns {object}
   */
  addLocalHook(key, callback) {
    if (!this._localHooks[key]) {
      this._localHooks[key] = [];
    }
    this._localHooks[key].push(callback);
    return this;
  },
  /**
   * Run hooks.
   *
   * @param {string} key The name of the hook to run.
   * @param {*} [arg1] An additional parameter passed to the callback function.
   * @param {*} [arg2] An additional parameter passed to the callback function.
   * @param {*} [arg3] An additional parameter passed to the callback function.
   * @param {*} [arg4] An additional parameter passed to the callback function.
   * @param {*} [arg5] An additional parameter passed to the callback function.
   * @param {*} [arg6] An additional parameter passed to the callback function.
   */
  runLocalHooks(key, arg1, arg2, arg3, arg4, arg5, arg6) {
    if (this._localHooks[key]) {
      const length = this._localHooks[key].length;
      for (let i = 0; i < length; i++) {
        fastCall(this._localHooks[key][i], this, arg1, arg2, arg3, arg4, arg5, arg6);
      }
    }
  },
  /**
   * Clear all added hooks.
   *
   * @returns {object}
   */
  clearLocalHooks() {
    this._localHooks = {};
    return this;
  }
};
defineGetter(localHooks, "MIXIN_NAME", MIXIN_NAME6, {
  writable: false,
  enumerable: false
});
var localHooks_default = localHooks;

// node_modules/handsontable/translations/maps/indexMap.mjs
var IndexMap = class {
  constructor() {
    let initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    this.indexedValues = [];
    this.initValueOrFn = initValueOrFn;
  }
  /**
   * Get full list of values for particular indexes.
   *
   * @returns {Array}
   */
  getValues() {
    return this.indexedValues;
  }
  /**
   * Get value for the particular index.
   *
   * @param {number} index Index for which value is got.
   * @returns {*}
   */
  getValueAtIndex(index2) {
    const values = this.indexedValues;
    if (index2 < values.length) {
      return values[index2];
    }
  }
  /**
   * Set new values for particular indexes.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @param {Array} values List of set values.
   */
  setValues(values) {
    this.indexedValues = values.slice();
    this.runLocalHooks("change");
  }
  /**
   * Set new value for the particular index.
   *
   * @param {number} index The index.
   * @param {*} value The value to save.
   *
   * Note: Please keep in mind that it is not possible to set value beyond the map (not respecting already set
   * map's size). Please use the `setValues` method when you would like to extend the map.
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @returns {boolean}
   */
  setValueAtIndex(index2, value) {
    if (index2 < this.indexedValues.length) {
      this.indexedValues[index2] = value;
      this.runLocalHooks("change");
      return true;
    }
    return false;
  }
  /**
   * Clear all values to the defaults.
   */
  clear() {
    this.setDefaultValues();
  }
  /**
   * Get length of the index map.
   *
   * @returns {number}
   */
  getLength() {
    return this.getValues().length;
  }
  /**
   * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @private
   * @param {number} [length] Length of list.
   */
  setDefaultValues() {
    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.indexedValues.length;
    this.indexedValues.length = 0;
    if (isFunction2(this.initValueOrFn)) {
      rangeEach(length - 1, (index2) => this.indexedValues.push(this.initValueOrFn(index2)));
    } else {
      rangeEach(length - 1, () => this.indexedValues.push(this.initValueOrFn));
    }
    this.runLocalHooks("change");
  }
  /**
   * Initialize list with default values for particular indexes.
   *
   * @private
   * @param {number} length New length of indexed list.
   * @returns {IndexMap}
   */
  init(length) {
    this.setDefaultValues(length);
    this.runLocalHooks("init");
    return this;
  }
  /**
   * Add values to the list.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @private
   */
  insert() {
    this.runLocalHooks("change");
  }
  /**
   * Remove values from the list.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @private
   */
  remove() {
    this.runLocalHooks("change");
  }
  /**
   * Destroys the Map instance.
   */
  destroy() {
    this.clearLocalHooks();
    this.indexedValues = null;
    this.initValueOrFn = null;
  }
};
mixin(IndexMap, localHooks_default);

// node_modules/handsontable/translations/maps/utils/physicallyIndexed.mjs
function getListWithInsertedItems(indexedValues, insertionIndex, insertedIndexes, insertedValuesMapping) {
  const firstInsertedIndex = insertedIndexes.length ? insertedIndexes[0] : void 0;
  return [...indexedValues.slice(0, firstInsertedIndex), ...insertedIndexes.map((insertedIndex, ordinalNumber) => {
    if (isFunction2(insertedValuesMapping)) {
      return insertedValuesMapping(insertedIndex, ordinalNumber);
    }
    return insertedValuesMapping;
  }), ...firstInsertedIndex === void 0 ? [] : indexedValues.slice(firstInsertedIndex)];
}
function getListWithRemovedItems(indexedValues, removedIndexes) {
  return arrayFilter(indexedValues, (_, index2) => removedIndexes.includes(index2) === false);
}

// node_modules/handsontable/translations/maps/physicalIndexToValueMap.mjs
var PhysicalIndexToValueMap = class extends IndexMap {
  /**
   * Add values to list and reorganize.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    this.indexedValues = getListWithInsertedItems(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);
    super.insert(insertionIndex, insertedIndexes);
  }
  /**
   * Remove values from the list and reorganize.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    this.indexedValues = getListWithRemovedItems(this.indexedValues, removedIndexes);
    super.remove(removedIndexes);
  }
};

// node_modules/handsontable/translations/maps/hidingMap.mjs
var HidingMap = class extends PhysicalIndexToValueMap {
  constructor() {
    let initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    super(initValueOrFn);
  }
  /**
   * Get physical indexes which are hidden.
   *
   * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.
   *
   * @returns {Array}
   */
  getHiddenIndexes() {
    return arrayReduce(this.getValues(), (indexesList, isHidden, physicalIndex) => {
      if (isHidden) {
        indexesList.push(physicalIndex);
      }
      return indexesList;
    }, []);
  }
};

// node_modules/handsontable/translations/maps/utils/indexesSequence.mjs
function getListWithInsertedItems2(indexedValues, insertionIndex, insertedIndexes) {
  return [...indexedValues.slice(0, insertionIndex), ...insertedIndexes, ...indexedValues.slice(insertionIndex)];
}
function getListWithRemovedItems2(indexedValues, removedIndexes) {
  return arrayFilter(indexedValues, (index2) => {
    return removedIndexes.includes(index2) === false;
  });
}

// node_modules/handsontable/translations/maps/utils/actionsOnIndexes.mjs
function getDecreasedIndexes(indexedValues, removedIndexes) {
  return arrayMap(indexedValues, (index2) => index2 - removedIndexes.filter((removedIndex) => removedIndex < index2).length);
}
function getIncreasedIndexes(indexedValues, insertedIndexes) {
  const firstInsertedIndex = insertedIndexes[0];
  const amountOfIndexes = insertedIndexes.length;
  return arrayMap(indexedValues, (index2) => {
    if (index2 >= firstInsertedIndex) {
      return index2 + amountOfIndexes;
    }
    return index2;
  });
}

// node_modules/handsontable/translations/maps/linkedPhysicalIndexToValueMap.mjs
function _defineProperty14(obj, key, value) {
  key = _toPropertyKey14(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey14(arg) {
  var key = _toPrimitive14(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive14(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var LinkedPhysicalIndexToValueMap = class extends IndexMap {
  constructor() {
    super(...arguments);
    _defineProperty14(this, "orderOfIndexes", []);
  }
  /**
   * Get full list of ordered values for particular indexes.
   *
   * @returns {Array}
   */
  getValues() {
    return this.orderOfIndexes.map((physicalIndex) => this.indexedValues[physicalIndex]);
  }
  /**
   * Set new values for particular indexes. Entries are linked and stored in a certain order.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @param {Array} values List of set values.
   */
  setValues(values) {
    this.orderOfIndexes = [...Array(values.length).keys()];
    super.setValues(values);
  }
  /**
   * Set value at index and add it to the linked list of entries. Entries are stored in a certain order.
   *
   * Note: Value will be added at the end of the queue.
   *
   * @param {number} index The index.
   * @param {*} value The value to save.
   * @param {number} position Position to which entry will be added.
   *
   * @returns {boolean}
   */
  setValueAtIndex(index2, value) {
    let position = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.orderOfIndexes.length;
    if (index2 < this.indexedValues.length) {
      this.indexedValues[index2] = value;
      if (this.orderOfIndexes.includes(index2) === false) {
        this.orderOfIndexes.splice(position, 0, index2);
      }
      this.runLocalHooks("change");
      return true;
    }
    return false;
  }
  /**
   * Clear value for particular index.
   *
   * @param {number} physicalIndex Physical index.
   */
  clearValue(physicalIndex) {
    this.orderOfIndexes = getListWithRemovedItems2(this.orderOfIndexes, [physicalIndex]);
    if (isFunction2(this.initValueOrFn)) {
      super.setValueAtIndex(physicalIndex, this.initValueOrFn(physicalIndex));
    } else {
      super.setValueAtIndex(physicalIndex, this.initValueOrFn);
    }
  }
  /**
   * Get length of the index map.
   *
   * @returns {number}
   */
  getLength() {
    return this.orderOfIndexes.length;
  }
  /**
   * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @private
   * @param {number} [length] Length of list.
   */
  setDefaultValues() {
    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.indexedValues.length;
    this.orderOfIndexes.length = 0;
    super.setDefaultValues(length);
  }
  /**
   * Add values to list and reorganize. It updates list of indexes related to ordered values.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    this.indexedValues = getListWithInsertedItems(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);
    this.orderOfIndexes = getIncreasedIndexes(this.orderOfIndexes, insertedIndexes);
    super.insert(insertionIndex, insertedIndexes);
  }
  /**
   * Remove values from the list and reorganize. It updates list of indexes related to ordered values.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    this.indexedValues = getListWithRemovedItems(this.indexedValues, removedIndexes);
    this.orderOfIndexes = getListWithRemovedItems2(this.orderOfIndexes, removedIndexes);
    this.orderOfIndexes = getDecreasedIndexes(this.orderOfIndexes, removedIndexes);
    super.remove(removedIndexes);
  }
  /**
   * Get every entry containing index and value, respecting order of indexes.
   *
   * @returns {Array}
   */
  getEntries() {
    return this.orderOfIndexes.map((physicalIndex) => [physicalIndex, this.getValueAtIndex(physicalIndex)]);
  }
};

// node_modules/handsontable/translations/maps/trimmingMap.mjs
var TrimmingMap = class extends PhysicalIndexToValueMap {
  constructor() {
    let initValueOrFn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    super(initValueOrFn);
  }
  /**
   * Get physical indexes which are trimmed.
   *
   * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.
   *
   * @returns {Array}
   */
  getTrimmedIndexes() {
    return arrayReduce(this.getValues(), (indexesList, isTrimmed, physicalIndex) => {
      if (isTrimmed) {
        indexesList.push(physicalIndex);
      }
      return indexesList;
    }, []);
  }
};

// node_modules/handsontable/translations/maps/utils/index.mjs
var alterStrategies = /* @__PURE__ */ new Map([["indexesSequence", {
  getListWithInsertedItems: getListWithInsertedItems2,
  getListWithRemovedItems: getListWithRemovedItems2
}], ["physicallyIndexed", {
  getListWithInsertedItems,
  getListWithRemovedItems
}]]);
var alterUtilsFactory = (indexationStrategy) => {
  if (alterStrategies.has(indexationStrategy) === false) {
    throw new Error(`Alter strategy with ID '${indexationStrategy}' does not exist.`);
  }
  return alterStrategies.get(indexationStrategy);
};

// node_modules/handsontable/translations/maps/indexesSequence.mjs
var IndexesSequence = class extends IndexMap {
  constructor() {
    super((index2) => index2);
  }
  /**
   * Add values to list and reorganize.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    const listAfterUpdate = getIncreasedIndexes(this.indexedValues, insertedIndexes);
    this.indexedValues = getListWithInsertedItems2(listAfterUpdate, insertionIndex, insertedIndexes);
    super.insert(insertionIndex, insertedIndexes);
  }
  /**
   * Remove values from the list and reorganize.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    const listAfterUpdate = getListWithRemovedItems2(this.indexedValues, removedIndexes);
    this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);
    super.remove(removedIndexes);
  }
};

// node_modules/handsontable/translations/maps/index.mjs
var availableIndexMapTypes = /* @__PURE__ */ new Map([["hiding", HidingMap], ["index", IndexMap], ["linkedPhysicalIndexToValue", LinkedPhysicalIndexToValueMap], ["physicalIndexToValue", PhysicalIndexToValueMap], ["trimming", TrimmingMap]]);
function createIndexMap(mapType) {
  let initValueOrFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!availableIndexMapTypes.has(mapType)) {
    throw new Error(`The provided map type ("${mapType}") does not exist.`);
  }
  return new (availableIndexMapTypes.get(mapType))(initValueOrFn);
}

// node_modules/handsontable/translations/mapCollections/mapCollection.mjs
var registeredMaps = 0;
var MapCollection = class {
  constructor() {
    this.collection = /* @__PURE__ */ new Map();
  }
  /**
   * Register custom index map.
   *
   * @param {string} uniqueName Unique name of the index map.
   * @param {IndexMap} indexMap Index map containing miscellaneous (i.e. Meta data, indexes sequence), updated after remove and insert data actions.
   */
  register(uniqueName, indexMap) {
    if (this.collection.has(uniqueName) === false) {
      this.collection.set(uniqueName, indexMap);
      indexMap.addLocalHook("change", () => this.runLocalHooks("change", indexMap));
      registeredMaps += 1;
    }
  }
  /**
   * Unregister custom index map.
   *
   * @param {string} name Name of the index map.
   */
  unregister(name) {
    const indexMap = this.collection.get(name);
    if (isDefined(indexMap)) {
      indexMap.destroy();
      this.collection.delete(name);
      this.runLocalHooks("change", indexMap);
      registeredMaps -= 1;
    }
  }
  /**
   * Unregisters and destroys all collected index map instances.
   */
  unregisterAll() {
    this.collection.forEach((indexMap, name) => this.unregister(name));
    this.collection.clear();
  }
  /**
   * Get index map for the provided name.
   *
   * @param {string} [name] Name of the index map.
   * @returns {Array|IndexMap}
   */
  get(name) {
    if (isUndefined2(name)) {
      return Array.from(this.collection.values());
    }
    return this.collection.get(name);
  }
  /**
   * Get collection size.
   *
   * @returns {number}
   */
  getLength() {
    return this.collection.size;
  }
  /**
   * Remove some indexes and corresponding mappings and update values of the others within all collection's index maps.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  removeFromEvery(removedIndexes) {
    this.collection.forEach((indexMap) => {
      indexMap.remove(removedIndexes);
    });
  }
  /**
   * Insert new indexes and corresponding mapping and update values of the others all collection's index maps.
   *
   * @private
   * @param {number} insertionIndex Position inside the actual list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insertToEvery(insertionIndex, insertedIndexes) {
    this.collection.forEach((indexMap) => {
      indexMap.insert(insertionIndex, insertedIndexes);
    });
  }
  /**
   * Set default values to index maps within collection.
   *
   * @param {number} length Destination length for all stored maps.
   */
  initEvery(length) {
    this.collection.forEach((indexMap) => {
      indexMap.init(length);
    });
  }
};
mixin(MapCollection, localHooks_default);
function getRegisteredMapsCounter() {
  return registeredMaps;
}

// node_modules/handsontable/translations/mapCollections/aggregatedCollection.mjs
var AggregatedCollection = class extends MapCollection {
  constructor(aggregationFunction, fallbackValue) {
    super();
    this.mergedValuesCache = [];
    this.aggregationFunction = aggregationFunction;
    this.fallbackValue = fallbackValue;
  }
  /**
   * Get merged values for all indexes.
   *
   * @param {boolean} [readFromCache=true] Determine if read results from the cache.
   * @returns {Array}
   */
  getMergedValues() {
    let readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (readFromCache === true) {
      return this.mergedValuesCache;
    }
    if (this.getLength() === 0) {
      return [];
    }
    const mapsValuesMatrix = arrayMap(this.get(), (map2) => map2.getValues());
    const indexesValuesMatrix = [];
    const mapsLength = isDefined(mapsValuesMatrix[0]) && mapsValuesMatrix[0].length || 0;
    for (let index2 = 0; index2 < mapsLength; index2 += 1) {
      const valuesForIndex = [];
      for (let mapIndex = 0; mapIndex < this.getLength(); mapIndex += 1) {
        valuesForIndex.push(mapsValuesMatrix[mapIndex][index2]);
      }
      indexesValuesMatrix.push(valuesForIndex);
    }
    return arrayMap(indexesValuesMatrix, this.aggregationFunction);
  }
  /**
   * Get merged value for particular index.
   *
   * @param {number} index Index for which we calculate single result.
   * @param {boolean} [readFromCache=true] Determine if read results from the cache.
   * @returns {*}
   */
  getMergedValueAtIndex(index2, readFromCache) {
    const valueAtIndex = this.getMergedValues(readFromCache)[index2];
    return isDefined(valueAtIndex) ? valueAtIndex : this.fallbackValue;
  }
  /**
   * Rebuild cache for the collection.
   */
  updateCache() {
    this.mergedValuesCache = this.getMergedValues(false);
  }
};

// node_modules/handsontable/translations/changesObservable/observer.mjs
function _classPrivateFieldInitSpec4(obj, privateMap, value) {
  _checkPrivateRedeclaration4(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration4(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet4(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor4(receiver, privateMap, "set");
  _classApplyDescriptorSet4(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet4(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet4(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor4(receiver, privateMap, "get");
  return _classApplyDescriptorGet4(receiver, descriptor);
}
function _classExtractFieldDescriptor4(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet4(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var _currentInitialChanges = /* @__PURE__ */ new WeakMap();
var ChangesObserver = class {
  constructor() {
    _classPrivateFieldInitSpec4(this, _currentInitialChanges, {
      writable: true,
      value: []
    });
  }
  /**
   * Subscribes to the observer.
   *
   * @param {Function} callback A function that will be called when the new changes will appear.
   * @returns {ChangesObserver}
   */
  subscribe(callback) {
    this.addLocalHook("change", callback);
    this._write(_classPrivateFieldGet4(this, _currentInitialChanges));
    return this;
  }
  /**
   * Unsubscribes all subscriptions. After the method call, the observer would not produce
   * any new events.
   *
   * @returns {ChangesObserver}
   */
  unsubscribe() {
    this.runLocalHooks("unsubscribe");
    this.clearLocalHooks();
    return this;
  }
  /**
   * The write method is executed by the ChangesObservable module. The module produces all
   * changes events that are distributed further by the observer.
   *
   * @private
   * @param {object} changes The chunk of changes produced by the ChangesObservable module.
   * @returns {ChangesObserver}
   */
  _write(changes) {
    if (changes.length > 0) {
      this.runLocalHooks("change", changes);
    }
    return this;
  }
  /**
   * The write method is executed by the ChangesObservable module. The module produces initial
   * changes that will be used to notify new subscribers.
   *
   * @private
   * @param {object} initialChanges The chunk of changes produced by the ChangesObservable module.
   */
  _writeInitialChanges(initialChanges) {
    _classPrivateFieldSet4(this, _currentInitialChanges, initialChanges);
  }
};
mixin(ChangesObserver, localHooks_default);

// node_modules/handsontable/translations/changesObservable/utils.mjs
function arrayDiff(baseArray, newArray) {
  const changes = [];
  let i = 0;
  let j = 0;
  for (; i < baseArray.length && j < newArray.length; i++, j++) {
    if (baseArray[i] !== newArray[j]) {
      changes.push({
        op: "replace",
        index: j,
        oldValue: baseArray[i],
        newValue: newArray[j]
      });
    }
  }
  for (; i < newArray.length; i++) {
    changes.push({
      op: "insert",
      index: i,
      oldValue: void 0,
      newValue: newArray[i]
    });
  }
  for (; j < baseArray.length; j++) {
    changes.push({
      op: "remove",
      index: j,
      oldValue: baseArray[j],
      newValue: void 0
    });
  }
  return changes;
}

// node_modules/handsontable/translations/changesObservable/observable.mjs
function _classPrivateFieldInitSpec5(obj, privateMap, value) {
  _checkPrivateRedeclaration5(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration5(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet5(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor5(receiver, privateMap, "get");
  return _classApplyDescriptorGet5(receiver, descriptor);
}
function _classApplyDescriptorGet5(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet5(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor5(receiver, privateMap, "set");
  _classApplyDescriptorSet5(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor5(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet5(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _observers = /* @__PURE__ */ new WeakMap();
var _indexMatrix = /* @__PURE__ */ new WeakMap();
var _currentIndexState = /* @__PURE__ */ new WeakMap();
var _isMatrixIndexesInitialized = /* @__PURE__ */ new WeakMap();
var _initialIndexValue = /* @__PURE__ */ new WeakMap();
var ChangesObservable = class {
  constructor() {
    let {
      initialIndexValue
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classPrivateFieldInitSpec5(this, _observers, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    _classPrivateFieldInitSpec5(this, _indexMatrix, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec5(this, _currentIndexState, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec5(this, _isMatrixIndexesInitialized, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec5(this, _initialIndexValue, {
      writable: true,
      value: false
    });
    _classPrivateFieldSet5(this, _initialIndexValue, initialIndexValue !== null && initialIndexValue !== void 0 ? initialIndexValue : false);
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Creates and returns a new instance of the ChangesObserver object. The resource
   * allows subscribing to the index changes that during the code running may change.
   * Changes are emitted as an array of the index change. Each change is represented
   * separately as an object with `op`, `index`, `oldValue`, and `newValue` props.
   *
   * For example:
   * ```
   * [
   *   { op: 'replace', index: 1, oldValue: false, newValue: true },
   *   { op: 'replace', index: 3, oldValue: false, newValue: true },
   *   { op: 'insert', index: 4, oldValue: false, newValue: true },
   * ]
   * // or when the new index map changes have less indexes
   * [
   *   { op: 'replace', index: 1, oldValue: false, newValue: true },
   *   { op: 'remove', index: 4, oldValue: false, newValue: true },
   * ]
   * ```
   *
   * @returns {ChangesObserver}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  createObserver() {
    const observer = new ChangesObserver();
    _classPrivateFieldGet5(this, _observers).add(observer);
    observer.addLocalHook("unsubscribe", () => {
      _classPrivateFieldGet5(this, _observers).delete(observer);
    });
    observer._writeInitialChanges(arrayDiff(_classPrivateFieldGet5(this, _indexMatrix), _classPrivateFieldGet5(this, _currentIndexState)));
    return observer;
  }
  /**
   * The method is an entry point for triggering new index map changes. Emitting the
   * changes triggers comparing algorithm which compares last saved state with a new
   * state. When there are some differences, the changes are sent to all subscribers.
   *
   * @param {Array} indexesState An array with index map state.
   */
  emit(indexesState) {
    let currentIndexState = _classPrivateFieldGet5(this, _currentIndexState);
    if (!_classPrivateFieldGet5(this, _isMatrixIndexesInitialized) || _classPrivateFieldGet5(this, _indexMatrix).length !== indexesState.length) {
      if (indexesState.length === 0) {
        indexesState = new Array(currentIndexState.length).fill(_classPrivateFieldGet5(this, _initialIndexValue));
      } else {
        _classPrivateFieldSet5(this, _indexMatrix, new Array(indexesState.length).fill(_classPrivateFieldGet5(this, _initialIndexValue)));
      }
      if (!_classPrivateFieldGet5(this, _isMatrixIndexesInitialized)) {
        _classPrivateFieldSet5(this, _isMatrixIndexesInitialized, true);
        currentIndexState = _classPrivateFieldGet5(this, _indexMatrix);
      }
    }
    const changes = arrayDiff(currentIndexState, indexesState);
    _classPrivateFieldGet5(this, _observers).forEach((observer) => observer._write(changes));
    _classPrivateFieldSet5(this, _currentIndexState, indexesState);
  }
};

// node_modules/handsontable/translations/indexMapper.mjs
var IndexMapper = class {
  constructor() {
    this.indexesSequence = new IndexesSequence();
    this.trimmingMapsCollection = new AggregatedCollection((valuesForIndex) => valuesForIndex.some((value) => value === true), false);
    this.hidingMapsCollection = new AggregatedCollection((valuesForIndex) => valuesForIndex.some((value) => value === true), false);
    this.variousMapsCollection = new MapCollection();
    this.hidingChangesObservable = new ChangesObservable({
      initialIndexValue: false
    });
    this.notTrimmedIndexesCache = [];
    this.notHiddenIndexesCache = [];
    this.isBatched = false;
    this.indexesSequenceChanged = false;
    this.indexesChangeSource = void 0;
    this.trimmedIndexesChanged = false;
    this.hiddenIndexesChanged = false;
    this.renderablePhysicalIndexesCache = [];
    this.fromPhysicalToVisualIndexesCache = /* @__PURE__ */ new Map();
    this.fromVisualToRenderableIndexesCache = /* @__PURE__ */ new Map();
    this.indexesSequence.addLocalHook("change", () => {
      this.indexesSequenceChanged = true;
      this.updateCache();
      this.runLocalHooks("indexesSequenceChange", this.indexesChangeSource);
      this.runLocalHooks("change", this.indexesSequence, null);
    });
    this.trimmingMapsCollection.addLocalHook("change", (changedMap) => {
      this.trimmedIndexesChanged = true;
      this.updateCache();
      this.runLocalHooks("change", changedMap, this.trimmingMapsCollection);
    });
    this.hidingMapsCollection.addLocalHook("change", (changedMap) => {
      this.hiddenIndexesChanged = true;
      this.updateCache();
      this.runLocalHooks("change", changedMap, this.hidingMapsCollection);
    });
    this.variousMapsCollection.addLocalHook("change", (changedMap) => {
      this.runLocalHooks("change", changedMap, this.variousMapsCollection);
    });
  }
  /**
   * Suspends the cache update for this map. The method is helpful to group multiple
   * operations, which affects the cache. In this case, the cache will be updated once after
   * calling the `resumeOperations` method.
   */
  suspendOperations() {
    this.isBatched = true;
  }
  /**
   * Resumes the cache update for this map. It recalculates the cache and restores the
   * default behavior where each map modification updates the cache.
   */
  resumeOperations() {
    this.isBatched = false;
    this.updateCache();
  }
  /**
   * It creates and returns the new instance of the ChangesObserver object. The object
   * allows listening to the index changes that happen while the Handsontable is running.
   *
   * @param {string} indexMapType The index map type which we want to observe.
   *                              Currently, only the 'hiding' index map types are observable.
   * @returns {ChangesObserver}
   */
  createChangesObserver(indexMapType) {
    if (indexMapType !== "hiding") {
      throw new Error(`Unsupported index map type "${indexMapType}".`);
    }
    return this.hidingChangesObservable.createObserver();
  }
  /**
   * Creates and registers a new `IndexMap` for a specified `IndexMapper` instance.
   *
   * @param {string} indexName A unique index name.
   * @param {string} mapType The index map type (e.g., "hiding", "trimming", "physicalIndexToValue").
   * @param {*} [initValueOrFn] The initial value for the index map.
   * @returns {IndexMap}
   */
  createAndRegisterIndexMap(indexName, mapType, initValueOrFn) {
    return this.registerMap(indexName, createIndexMap(mapType, initValueOrFn));
  }
  /**
   * Register map which provide some index mappings. Type of map determining to which collection it will be added.
   *
   * @param {string} uniqueName Name of the index map. It should be unique.
   * @param {IndexMap} indexMap Registered index map updated on items removal and insertion.
   * @returns {IndexMap}
   */
  registerMap(uniqueName, indexMap) {
    if (this.trimmingMapsCollection.get(uniqueName) || this.hidingMapsCollection.get(uniqueName) || this.variousMapsCollection.get(uniqueName)) {
      throw Error(`Map with name "${uniqueName}" has been already registered.`);
    }
    if (indexMap instanceof TrimmingMap) {
      this.trimmingMapsCollection.register(uniqueName, indexMap);
    } else if (indexMap instanceof HidingMap) {
      this.hidingMapsCollection.register(uniqueName, indexMap);
    } else {
      this.variousMapsCollection.register(uniqueName, indexMap);
    }
    const numberOfIndexes = this.getNumberOfIndexes();
    if (numberOfIndexes > 0) {
      indexMap.init(numberOfIndexes);
    }
    return indexMap;
  }
  /**
   * Unregister a map with given name.
   *
   * @param {string} name Name of the index map.
   */
  unregisterMap(name) {
    this.trimmingMapsCollection.unregister(name);
    this.hidingMapsCollection.unregister(name);
    this.variousMapsCollection.unregister(name);
  }
  /**
   * Unregisters all collected index map instances from all map collection types.
   */
  unregisterAll() {
    this.trimmingMapsCollection.unregisterAll();
    this.hidingMapsCollection.unregisterAll();
    this.variousMapsCollection.unregisterAll();
  }
  /**
   * Get a physical index corresponding to the given visual index.
   *
   * @param {number} visualIndex Visual index.
   * @returns {number|null} Returns translated index mapped by passed visual index.
   */
  getPhysicalFromVisualIndex(visualIndex) {
    const physicalIndex = this.notTrimmedIndexesCache[visualIndex];
    if (isDefined(physicalIndex)) {
      return physicalIndex;
    }
    return null;
  }
  /**
   * Get a physical index corresponding to the given renderable index.
   *
   * @param {number} renderableIndex Renderable index.
   * @returns {null|number}
   */
  getPhysicalFromRenderableIndex(renderableIndex) {
    const physicalIndex = this.renderablePhysicalIndexesCache[renderableIndex];
    if (isDefined(physicalIndex)) {
      return physicalIndex;
    }
    return null;
  }
  /**
   * Get a visual index corresponding to the given physical index.
   *
   * @param {number} physicalIndex Physical index to search.
   * @returns {number|null} Returns a visual index of the index mapper.
   */
  getVisualFromPhysicalIndex(physicalIndex) {
    const visualIndex = this.fromPhysicalToVisualIndexesCache.get(physicalIndex);
    if (isDefined(visualIndex)) {
      return visualIndex;
    }
    return null;
  }
  /**
   * Get a visual index corresponding to the given renderable index.
   *
   * @param {number} renderableIndex Renderable index.
   * @returns {null|number}
   */
  getVisualFromRenderableIndex(renderableIndex) {
    return this.getVisualFromPhysicalIndex(this.getPhysicalFromRenderableIndex(renderableIndex));
  }
  /**
   * Get a renderable index corresponding to the given visual index.
   *
   * @param {number} visualIndex Visual index.
   * @returns {null|number}
   */
  getRenderableFromVisualIndex(visualIndex) {
    const renderableIndex = this.fromVisualToRenderableIndexesCache.get(visualIndex);
    if (isDefined(renderableIndex)) {
      return renderableIndex;
    }
    return null;
  }
  /**
   * Search for the nearest not-hidden row or column.
   *
   * @param {number} fromVisualIndex The visual index of the row or column from which the search starts.<br><br>
   * If the row or column from which the search starts is not hidden, the method simply returns the `fromVisualIndex` number.
   * @param {number} searchDirection The search direction.<br><br>`1`: search from `fromVisualIndex` to the end of the dataset.<br><br>
   * `-1`: search from `fromVisualIndex` to the beginning of the dataset (i.e., to the row or column at visual index `0`).
   * @param {boolean} searchAlsoOtherWayAround `true`: if a search in a first direction failed, try the opposite direction.<br><br>
   * `false`: search in one direction only.
   *
   * @returns {number|null} A visual index of a row or column, or `null`.
   */
  getNearestNotHiddenIndex(fromVisualIndex, searchDirection) {
    let searchAlsoOtherWayAround = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const physicalIndex = this.getPhysicalFromVisualIndex(fromVisualIndex);
    if (physicalIndex === null) {
      return null;
    }
    if (this.fromVisualToRenderableIndexesCache.has(fromVisualIndex)) {
      return fromVisualIndex;
    }
    const visibleIndexes = Array.from(this.fromVisualToRenderableIndexesCache.keys());
    let index2 = -1;
    if (searchDirection > 0) {
      index2 = visibleIndexes.findIndex((visualIndex) => visualIndex > fromVisualIndex);
    } else {
      index2 = visibleIndexes.reverse().findIndex((visualIndex) => visualIndex < fromVisualIndex);
    }
    if (index2 === -1) {
      if (searchAlsoOtherWayAround) {
        return this.getNearestNotHiddenIndex(fromVisualIndex, -searchDirection, false);
      }
      return null;
    }
    return visibleIndexes[index2];
  }
  /**
   * Set default values for all indexes in registered index maps.
   *
   * @param {number} [length] Destination length for all stored index maps.
   */
  initToLength() {
    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getNumberOfIndexes();
    this.notTrimmedIndexesCache = [...new Array(length).keys()];
    this.notHiddenIndexesCache = [...new Array(length).keys()];
    this.suspendOperations();
    this.indexesChangeSource = "init";
    this.indexesSequence.init(length);
    this.indexesChangeSource = void 0;
    this.trimmingMapsCollection.initEvery(length);
    this.resumeOperations();
    this.suspendOperations();
    this.hidingMapsCollection.initEvery(length);
    this.variousMapsCollection.initEvery(length);
    this.resumeOperations();
    this.runLocalHooks("init");
  }
  /**
   * Trim/extend the mappers to fit the desired length.
   *
   * @param {number} length New mapper length.
   */
  fitToLength(length) {
    const currentIndexCount = this.getNumberOfIndexes();
    if (length < currentIndexCount) {
      const indexesToBeRemoved = [...Array(this.getNumberOfIndexes() - length).keys()].map((i) => i + length);
      this.removeIndexes(indexesToBeRemoved);
    } else {
      this.insertIndexes(currentIndexCount, length - currentIndexCount);
    }
  }
  /**
   * Get sequence of indexes.
   *
   * @returns {Array} Physical indexes.
   */
  getIndexesSequence() {
    return this.indexesSequence.getValues();
  }
  /**
   * Set completely new indexes sequence.
   *
   * @param {Array} indexes Physical indexes.
   */
  setIndexesSequence(indexes) {
    if (this.indexesChangeSource === void 0) {
      this.indexesChangeSource = "update";
    }
    this.indexesSequence.setValues(indexes);
    if (this.indexesChangeSource === "update") {
      this.indexesChangeSource = void 0;
    }
  }
  /**
   * Get all NOT trimmed indexes.
   *
   * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.
   *
   * @param {boolean} [readFromCache=true] Determine if read indexes from cache.
   * @returns {Array} List of physical indexes. Index of this native array is a "visual index",
   * value of this native array is a "physical index".
   */
  getNotTrimmedIndexes() {
    let readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (readFromCache === true) {
      return this.notTrimmedIndexesCache;
    }
    const indexesSequence = this.getIndexesSequence();
    return indexesSequence.filter((physicalIndex) => this.isTrimmed(physicalIndex) === false);
  }
  /**
   * Get length of all NOT trimmed indexes.
   *
   * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.
   *
   * @returns {number}
   */
  getNotTrimmedIndexesLength() {
    return this.getNotTrimmedIndexes().length;
  }
  /**
   * Get all NOT hidden indexes.
   *
   * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.
   *
   * @param {boolean} [readFromCache=true] Determine if read indexes from cache.
   * @returns {Array} List of physical indexes. Please keep in mind that index of this native array IS NOT a "visual index".
   */
  getNotHiddenIndexes() {
    let readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (readFromCache === true) {
      return this.notHiddenIndexesCache;
    }
    const indexesSequence = this.getIndexesSequence();
    return indexesSequence.filter((physicalIndex) => this.isHidden(physicalIndex) === false);
  }
  /**
   * Get length of all NOT hidden indexes.
   *
   * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.
   *
   * @returns {number}
   */
  getNotHiddenIndexesLength() {
    return this.getNotHiddenIndexes().length;
  }
  /**
   * Get list of physical indexes (respecting the sequence of indexes) which may be rendered (when they are in a viewport).
   *
   * @param {boolean} [readFromCache=true] Determine if read indexes from cache.
   * @returns {Array} List of physical indexes. Index of this native array is a "renderable index",
   * value of this native array is a "physical index".
   */
  getRenderableIndexes() {
    let readFromCache = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (readFromCache === true) {
      return this.renderablePhysicalIndexesCache;
    }
    const notTrimmedIndexes = this.getNotTrimmedIndexes();
    return notTrimmedIndexes.filter((physicalIndex) => this.isHidden(physicalIndex) === false);
  }
  /**
   * Get length of all NOT trimmed and NOT hidden indexes.
   *
   * @returns {number}
   */
  getRenderableIndexesLength() {
    return this.getRenderableIndexes().length;
  }
  /**
   * Get number of all indexes.
   *
   * @returns {number}
   */
  getNumberOfIndexes() {
    return this.getIndexesSequence().length;
  }
  /**
   * Move indexes in the index mapper.
   *
   * @param {number|Array} movedIndexes Visual index(es) to move.
   * @param {number} finalIndex Visual index being a start index for the moved elements.
   */
  moveIndexes(movedIndexes, finalIndex) {
    if (typeof movedIndexes === "number") {
      movedIndexes = [movedIndexes];
    }
    const physicalMovedIndexes = arrayMap(movedIndexes, (visualIndex) => this.getPhysicalFromVisualIndex(visualIndex));
    const notTrimmedIndexesLength = this.getNotTrimmedIndexesLength();
    const movedIndexesLength = movedIndexes.length;
    const notMovedIndexes = getListWithRemovedItems2(this.getIndexesSequence(), physicalMovedIndexes);
    const notTrimmedNotMovedItems = notMovedIndexes.filter((index2) => this.isTrimmed(index2) === false);
    let destinationPosition = notMovedIndexes.indexOf(notTrimmedNotMovedItems[notTrimmedNotMovedItems.length - 1]) + 1;
    if (finalIndex + movedIndexesLength < notTrimmedIndexesLength) {
      const physicalIndex = notTrimmedNotMovedItems[finalIndex];
      destinationPosition = notMovedIndexes.indexOf(physicalIndex);
    }
    this.indexesChangeSource = "move";
    this.setIndexesSequence(getListWithInsertedItems2(notMovedIndexes, destinationPosition, physicalMovedIndexes));
    this.indexesChangeSource = void 0;
  }
  /**
   * Get whether index is trimmed. Index marked as trimmed isn't included in a {@link DataMap} and isn't rendered.
   *
   * @param {number} physicalIndex Physical index.
   * @returns {boolean}
   */
  isTrimmed(physicalIndex) {
    return this.trimmingMapsCollection.getMergedValueAtIndex(physicalIndex);
  }
  /**
   * Get whether index is hidden. Index marked as hidden is included in a {@link DataMap}, but isn't rendered.
   *
   * @param {number} physicalIndex Physical index.
   * @returns {boolean}
   */
  isHidden(physicalIndex) {
    return this.hidingMapsCollection.getMergedValueAtIndex(physicalIndex);
  }
  /**
   * Insert new indexes and corresponding mapping and update values of the others, for all stored index maps.
   *
   * @private
   * @param {number} firstInsertedVisualIndex First inserted visual index.
   * @param {number} amountOfIndexes Amount of inserted indexes.
   */
  insertIndexes(firstInsertedVisualIndex, amountOfIndexes) {
    const nthVisibleIndex = this.getNotTrimmedIndexes()[firstInsertedVisualIndex];
    const firstInsertedPhysicalIndex = isDefined(nthVisibleIndex) ? nthVisibleIndex : this.getNumberOfIndexes();
    const insertionIndex = this.getIndexesSequence().includes(nthVisibleIndex) ? this.getIndexesSequence().indexOf(nthVisibleIndex) : this.getNumberOfIndexes();
    const insertedIndexes = arrayMap(new Array(amountOfIndexes).fill(firstInsertedPhysicalIndex), (nextIndex, stepsFromStart) => nextIndex + stepsFromStart);
    this.suspendOperations();
    this.indexesChangeSource = "insert";
    this.indexesSequence.insert(insertionIndex, insertedIndexes);
    this.indexesChangeSource = void 0;
    this.trimmingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
    this.hidingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
    this.variousMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
    this.resumeOperations();
  }
  /**
   * Remove some indexes and corresponding mappings and update values of the others, for all stored index maps.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  removeIndexes(removedIndexes) {
    this.suspendOperations();
    this.indexesChangeSource = "remove";
    this.indexesSequence.remove(removedIndexes);
    this.indexesChangeSource = void 0;
    this.trimmingMapsCollection.removeFromEvery(removedIndexes);
    this.hidingMapsCollection.removeFromEvery(removedIndexes);
    this.variousMapsCollection.removeFromEvery(removedIndexes);
    this.resumeOperations();
  }
  /**
   * Rebuild cache for some indexes. Every action on indexes sequence or indexes skipped in the process of rendering
   * by default reset cache, thus batching some index maps actions is recommended.
   *
   * @private
   * @param {boolean} [force=false] Determine if force cache update.
   */
  updateCache() {
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const anyCachedIndexChanged = this.indexesSequenceChanged || this.trimmedIndexesChanged || this.hiddenIndexesChanged;
    if (force === true || this.isBatched === false && anyCachedIndexChanged === true) {
      this.trimmingMapsCollection.updateCache();
      this.hidingMapsCollection.updateCache();
      this.notTrimmedIndexesCache = this.getNotTrimmedIndexes(false);
      this.notHiddenIndexesCache = this.getNotHiddenIndexes(false);
      this.renderablePhysicalIndexesCache = this.getRenderableIndexes(false);
      this.cacheFromPhysicalToVisualIndexes();
      this.cacheFromVisualToRenderableIndexes();
      if (this.hiddenIndexesChanged) {
        this.hidingChangesObservable.emit(this.hidingMapsCollection.getMergedValues());
      }
      this.runLocalHooks("cacheUpdated", {
        indexesSequenceChanged: this.indexesSequenceChanged,
        trimmedIndexesChanged: this.trimmedIndexesChanged,
        hiddenIndexesChanged: this.hiddenIndexesChanged
      });
      this.indexesSequenceChanged = false;
      this.trimmedIndexesChanged = false;
      this.hiddenIndexesChanged = false;
    }
  }
  /**
   * Update cache for translations from physical to visual indexes.
   *
   * @private
   */
  cacheFromPhysicalToVisualIndexes() {
    const nrOfNotTrimmedIndexes = this.getNotTrimmedIndexesLength();
    this.fromPhysicalToVisualIndexesCache.clear();
    for (let visualIndex = 0; visualIndex < nrOfNotTrimmedIndexes; visualIndex += 1) {
      const physicalIndex = this.getPhysicalFromVisualIndex(visualIndex);
      this.fromPhysicalToVisualIndexesCache.set(physicalIndex, visualIndex);
    }
  }
  /**
   * Update cache for translations from visual to renderable indexes.
   *
   * @private
   */
  cacheFromVisualToRenderableIndexes() {
    const nrOfRenderableIndexes = this.getRenderableIndexesLength();
    this.fromVisualToRenderableIndexesCache.clear();
    for (let renderableIndex = 0; renderableIndex < nrOfRenderableIndexes; renderableIndex += 1) {
      const physicalIndex = this.getPhysicalFromRenderableIndex(renderableIndex);
      const visualIndex = this.getVisualFromPhysicalIndex(physicalIndex);
      this.fromVisualToRenderableIndexesCache.set(visualIndex, renderableIndex);
    }
  }
};
mixin(IndexMapper, localHooks_default);

// node_modules/handsontable/i18n/utils.mjs
function extendNotExistingKeys(target, extension) {
  objectEach(extension, (value, key) => {
    if (isUndefined2(target[key])) {
      target[key] = value;
    }
  });
  return target;
}
function normalizeLanguageCode(languageCode) {
  const languageCodePattern = /^([a-zA-Z]{2})-([a-zA-Z]{2})$/;
  const partsOfLanguageCode = languageCodePattern.exec(languageCode);
  if (partsOfLanguageCode) {
    return `${partsOfLanguageCode[1].toLowerCase()}-${partsOfLanguageCode[2].toUpperCase()}`;
  }
  return languageCode;
}
function warnUserAboutLanguageRegistration(languageCode) {
  if (isDefined(languageCode)) {
    error(toSingleLine`Language with code "${languageCode}" was not found. You should register particular language\x20
    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.`);
  }
}

// node_modules/handsontable/i18n/phraseFormatters/pluralize.mjs
function pluralize(phrasePropositions, pluralForm) {
  const isPluralizable = Array.isArray(phrasePropositions) && Number.isInteger(pluralForm);
  if (isPluralizable) {
    return phrasePropositions[pluralForm];
  }
  return phrasePropositions;
}

// node_modules/handsontable/i18n/phraseFormatters/index.mjs
var {
  register: registerGloballyPhraseFormatter,
  getValues: getGlobalPhraseFormatters
} = staticRegister("phraseFormatters");
function register4(name, formatterFn) {
  registerGloballyPhraseFormatter(name, formatterFn);
}
function getAll() {
  return getGlobalPhraseFormatters();
}
register4("pluralize", pluralize);

// node_modules/handsontable/i18n/constants.mjs
var constants_exports = {};
__export(constants_exports, {
  CONTEXTMENU_ITEMS_ADD_COMMENT: () => CONTEXTMENU_ITEMS_ADD_COMMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT: () => CONTEXTMENU_ITEMS_ALIGNMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM: () => CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM,
  CONTEXTMENU_ITEMS_ALIGNMENT_CENTER: () => CONTEXTMENU_ITEMS_ALIGNMENT_CENTER,
  CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY: () => CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY,
  CONTEXTMENU_ITEMS_ALIGNMENT_LEFT: () => CONTEXTMENU_ITEMS_ALIGNMENT_LEFT,
  CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE: () => CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE,
  CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT: () => CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT,
  CONTEXTMENU_ITEMS_ALIGNMENT_TOP: () => CONTEXTMENU_ITEMS_ALIGNMENT_TOP,
  CONTEXTMENU_ITEMS_BORDERS: () => CONTEXTMENU_ITEMS_BORDERS,
  CONTEXTMENU_ITEMS_BORDERS_BOTTOM: () => CONTEXTMENU_ITEMS_BORDERS_BOTTOM,
  CONTEXTMENU_ITEMS_BORDERS_LEFT: () => CONTEXTMENU_ITEMS_BORDERS_LEFT,
  CONTEXTMENU_ITEMS_BORDERS_RIGHT: () => CONTEXTMENU_ITEMS_BORDERS_RIGHT,
  CONTEXTMENU_ITEMS_BORDERS_TOP: () => CONTEXTMENU_ITEMS_BORDERS_TOP,
  CONTEXTMENU_ITEMS_CLEAR_COLUMN: () => CONTEXTMENU_ITEMS_CLEAR_COLUMN,
  CONTEXTMENU_ITEMS_COPY: () => CONTEXTMENU_ITEMS_COPY,
  CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY: () => CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY,
  CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS: () => CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS,
  CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS: () => CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS,
  CONTEXTMENU_ITEMS_CUT: () => CONTEXTMENU_ITEMS_CUT,
  CONTEXTMENU_ITEMS_EDIT_COMMENT: () => CONTEXTMENU_ITEMS_EDIT_COMMENT,
  CONTEXTMENU_ITEMS_FREEZE_COLUMN: () => CONTEXTMENU_ITEMS_FREEZE_COLUMN,
  CONTEXTMENU_ITEMS_HIDE_COLUMN: () => CONTEXTMENU_ITEMS_HIDE_COLUMN,
  CONTEXTMENU_ITEMS_HIDE_ROW: () => CONTEXTMENU_ITEMS_HIDE_ROW,
  CONTEXTMENU_ITEMS_INSERT_LEFT: () => CONTEXTMENU_ITEMS_INSERT_LEFT,
  CONTEXTMENU_ITEMS_INSERT_RIGHT: () => CONTEXTMENU_ITEMS_INSERT_RIGHT,
  CONTEXTMENU_ITEMS_MERGE_CELLS: () => CONTEXTMENU_ITEMS_MERGE_CELLS,
  CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD: () => CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD,
  CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD: () => CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD,
  CONTEXTMENU_ITEMS_NO_ITEMS: () => CONTEXTMENU_ITEMS_NO_ITEMS,
  CONTEXTMENU_ITEMS_READ_ONLY: () => CONTEXTMENU_ITEMS_READ_ONLY,
  CONTEXTMENU_ITEMS_READ_ONLY_COMMENT: () => CONTEXTMENU_ITEMS_READ_ONLY_COMMENT,
  CONTEXTMENU_ITEMS_REDO: () => CONTEXTMENU_ITEMS_REDO,
  CONTEXTMENU_ITEMS_REMOVE_BORDERS: () => CONTEXTMENU_ITEMS_REMOVE_BORDERS,
  CONTEXTMENU_ITEMS_REMOVE_COLUMN: () => CONTEXTMENU_ITEMS_REMOVE_COLUMN,
  CONTEXTMENU_ITEMS_REMOVE_COMMENT: () => CONTEXTMENU_ITEMS_REMOVE_COMMENT,
  CONTEXTMENU_ITEMS_REMOVE_ROW: () => CONTEXTMENU_ITEMS_REMOVE_ROW,
  CONTEXTMENU_ITEMS_ROW_ABOVE: () => CONTEXTMENU_ITEMS_ROW_ABOVE,
  CONTEXTMENU_ITEMS_ROW_BELOW: () => CONTEXTMENU_ITEMS_ROW_BELOW,
  CONTEXTMENU_ITEMS_SHOW_COLUMN: () => CONTEXTMENU_ITEMS_SHOW_COLUMN,
  CONTEXTMENU_ITEMS_SHOW_ROW: () => CONTEXTMENU_ITEMS_SHOW_ROW,
  CONTEXTMENU_ITEMS_UNDO: () => CONTEXTMENU_ITEMS_UNDO,
  CONTEXTMENU_ITEMS_UNFREEZE_COLUMN: () => CONTEXTMENU_ITEMS_UNFREEZE_COLUMN,
  CONTEXTMENU_ITEMS_UNMERGE_CELLS: () => CONTEXTMENU_ITEMS_UNMERGE_CELLS,
  CONTEXT_MENU_ITEMS_NAMESPACE: () => CONTEXT_MENU_ITEMS_NAMESPACE,
  FILTERS_BUTTONS_CANCEL: () => FILTERS_BUTTONS_CANCEL,
  FILTERS_BUTTONS_CLEAR: () => FILTERS_BUTTONS_CLEAR,
  FILTERS_BUTTONS_OK: () => FILTERS_BUTTONS_OK,
  FILTERS_BUTTONS_PLACEHOLDER_SEARCH: () => FILTERS_BUTTONS_PLACEHOLDER_SEARCH,
  FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE: () => FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE,
  FILTERS_BUTTONS_PLACEHOLDER_VALUE: () => FILTERS_BUTTONS_PLACEHOLDER_VALUE,
  FILTERS_BUTTONS_SELECT_ALL: () => FILTERS_BUTTONS_SELECT_ALL,
  FILTERS_CONDITIONS_AFTER: () => FILTERS_CONDITIONS_AFTER,
  FILTERS_CONDITIONS_BEFORE: () => FILTERS_CONDITIONS_BEFORE,
  FILTERS_CONDITIONS_BEGINS_WITH: () => FILTERS_CONDITIONS_BEGINS_WITH,
  FILTERS_CONDITIONS_BETWEEN: () => FILTERS_CONDITIONS_BETWEEN,
  FILTERS_CONDITIONS_BY_VALUE: () => FILTERS_CONDITIONS_BY_VALUE,
  FILTERS_CONDITIONS_CONTAINS: () => FILTERS_CONDITIONS_CONTAINS,
  FILTERS_CONDITIONS_EMPTY: () => FILTERS_CONDITIONS_EMPTY,
  FILTERS_CONDITIONS_ENDS_WITH: () => FILTERS_CONDITIONS_ENDS_WITH,
  FILTERS_CONDITIONS_EQUAL: () => FILTERS_CONDITIONS_EQUAL,
  FILTERS_CONDITIONS_GREATER_THAN: () => FILTERS_CONDITIONS_GREATER_THAN,
  FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL: () => FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_LESS_THAN: () => FILTERS_CONDITIONS_LESS_THAN,
  FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL: () => FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_NAMESPACE: () => FILTERS_CONDITIONS_NAMESPACE,
  FILTERS_CONDITIONS_NONE: () => FILTERS_CONDITIONS_NONE,
  FILTERS_CONDITIONS_NOT_BETWEEN: () => FILTERS_CONDITIONS_NOT_BETWEEN,
  FILTERS_CONDITIONS_NOT_CONTAIN: () => FILTERS_CONDITIONS_NOT_CONTAIN,
  FILTERS_CONDITIONS_NOT_EMPTY: () => FILTERS_CONDITIONS_NOT_EMPTY,
  FILTERS_CONDITIONS_NOT_EQUAL: () => FILTERS_CONDITIONS_NOT_EQUAL,
  FILTERS_CONDITIONS_TODAY: () => FILTERS_CONDITIONS_TODAY,
  FILTERS_CONDITIONS_TOMORROW: () => FILTERS_CONDITIONS_TOMORROW,
  FILTERS_CONDITIONS_YESTERDAY: () => FILTERS_CONDITIONS_YESTERDAY,
  FILTERS_DIVS_FILTER_BY_CONDITION: () => FILTERS_DIVS_FILTER_BY_CONDITION,
  FILTERS_DIVS_FILTER_BY_VALUE: () => FILTERS_DIVS_FILTER_BY_VALUE,
  FILTERS_LABELS_CONJUNCTION: () => FILTERS_LABELS_CONJUNCTION,
  FILTERS_LABELS_DISJUNCTION: () => FILTERS_LABELS_DISJUNCTION,
  FILTERS_NAMESPACE: () => FILTERS_NAMESPACE,
  FILTERS_VALUES_BLANK_CELLS: () => FILTERS_VALUES_BLANK_CELLS
});
var CONTEXT_MENU_ITEMS_NAMESPACE = "ContextMenu:items";
var CM_ALIAS = CONTEXT_MENU_ITEMS_NAMESPACE;
var CONTEXTMENU_ITEMS_NO_ITEMS = `${CM_ALIAS}.noItems`;
var CONTEXTMENU_ITEMS_ROW_ABOVE = `${CM_ALIAS}.insertRowAbove`;
var CONTEXTMENU_ITEMS_ROW_BELOW = `${CM_ALIAS}.insertRowBelow`;
var CONTEXTMENU_ITEMS_INSERT_LEFT = `${CM_ALIAS}.insertColumnOnTheLeft`;
var CONTEXTMENU_ITEMS_INSERT_RIGHT = `${CM_ALIAS}.insertColumnOnTheRight`;
var CONTEXTMENU_ITEMS_REMOVE_ROW = `${CM_ALIAS}.removeRow`;
var CONTEXTMENU_ITEMS_REMOVE_COLUMN = `${CM_ALIAS}.removeColumn`;
var CONTEXTMENU_ITEMS_UNDO = `${CM_ALIAS}.undo`;
var CONTEXTMENU_ITEMS_REDO = `${CM_ALIAS}.redo`;
var CONTEXTMENU_ITEMS_READ_ONLY = `${CM_ALIAS}.readOnly`;
var CONTEXTMENU_ITEMS_CLEAR_COLUMN = `${CM_ALIAS}.clearColumn`;
var CONTEXTMENU_ITEMS_COPY = `${CM_ALIAS}.copy`;
var CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS = `${CM_ALIAS}.copyWithHeaders`;
var CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS = `${CM_ALIAS}.copyWithGroupHeaders`;
var CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY = `${CM_ALIAS}.copyHeadersOnly`;
var CONTEXTMENU_ITEMS_CUT = `${CM_ALIAS}.cut`;
var CONTEXTMENU_ITEMS_FREEZE_COLUMN = `${CM_ALIAS}.freezeColumn`;
var CONTEXTMENU_ITEMS_UNFREEZE_COLUMN = `${CM_ALIAS}.unfreezeColumn`;
var CONTEXTMENU_ITEMS_MERGE_CELLS = `${CM_ALIAS}.mergeCells`;
var CONTEXTMENU_ITEMS_UNMERGE_CELLS = `${CM_ALIAS}.unmergeCells`;
var CONTEXTMENU_ITEMS_ADD_COMMENT = `${CM_ALIAS}.addComment`;
var CONTEXTMENU_ITEMS_EDIT_COMMENT = `${CM_ALIAS}.editComment`;
var CONTEXTMENU_ITEMS_REMOVE_COMMENT = `${CM_ALIAS}.removeComment`;
var CONTEXTMENU_ITEMS_READ_ONLY_COMMENT = `${CM_ALIAS}.readOnlyComment`;
var CONTEXTMENU_ITEMS_ALIGNMENT = `${CM_ALIAS}.align`;
var CONTEXTMENU_ITEMS_ALIGNMENT_LEFT = `${CM_ALIAS}.align.left`;
var CONTEXTMENU_ITEMS_ALIGNMENT_CENTER = `${CM_ALIAS}.align.center`;
var CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT = `${CM_ALIAS}.align.right`;
var CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY = `${CM_ALIAS}.align.justify`;
var CONTEXTMENU_ITEMS_ALIGNMENT_TOP = `${CM_ALIAS}.align.top`;
var CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE = `${CM_ALIAS}.align.middle`;
var CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM = `${CM_ALIAS}.align.bottom`;
var CONTEXTMENU_ITEMS_BORDERS = `${CM_ALIAS}.borders`;
var CONTEXTMENU_ITEMS_BORDERS_TOP = `${CM_ALIAS}.borders.top`;
var CONTEXTMENU_ITEMS_BORDERS_RIGHT = `${CM_ALIAS}.borders.right`;
var CONTEXTMENU_ITEMS_BORDERS_BOTTOM = `${CM_ALIAS}.borders.bottom`;
var CONTEXTMENU_ITEMS_BORDERS_LEFT = `${CM_ALIAS}.borders.left`;
var CONTEXTMENU_ITEMS_REMOVE_BORDERS = `${CM_ALIAS}.borders.remove`;
var CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD = `${CM_ALIAS}.nestedHeaders.insertChildRow`;
var CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD = `${CM_ALIAS}.nestedHeaders.detachFromParent`;
var CONTEXTMENU_ITEMS_HIDE_COLUMN = `${CM_ALIAS}.hideColumn`;
var CONTEXTMENU_ITEMS_SHOW_COLUMN = `${CM_ALIAS}.showColumn`;
var CONTEXTMENU_ITEMS_HIDE_ROW = `${CM_ALIAS}.hideRow`;
var CONTEXTMENU_ITEMS_SHOW_ROW = `${CM_ALIAS}.showRow`;
var FILTERS_NAMESPACE = "Filters:";
var FILTERS_CONDITIONS_NAMESPACE = `${FILTERS_NAMESPACE}conditions`;
var FILTERS_CONDITIONS_NONE = `${FILTERS_CONDITIONS_NAMESPACE}.none`;
var FILTERS_CONDITIONS_EMPTY = `${FILTERS_CONDITIONS_NAMESPACE}.isEmpty`;
var FILTERS_CONDITIONS_NOT_EMPTY = `${FILTERS_CONDITIONS_NAMESPACE}.isNotEmpty`;
var FILTERS_CONDITIONS_EQUAL = `${FILTERS_CONDITIONS_NAMESPACE}.isEqualTo`;
var FILTERS_CONDITIONS_NOT_EQUAL = `${FILTERS_CONDITIONS_NAMESPACE}.isNotEqualTo`;
var FILTERS_CONDITIONS_BEGINS_WITH = `${FILTERS_CONDITIONS_NAMESPACE}.beginsWith`;
var FILTERS_CONDITIONS_ENDS_WITH = `${FILTERS_CONDITIONS_NAMESPACE}.endsWith`;
var FILTERS_CONDITIONS_CONTAINS = `${FILTERS_CONDITIONS_NAMESPACE}.contains`;
var FILTERS_CONDITIONS_NOT_CONTAIN = `${FILTERS_CONDITIONS_NAMESPACE}.doesNotContain`;
var FILTERS_CONDITIONS_BY_VALUE = `${FILTERS_CONDITIONS_NAMESPACE}.byValue`;
var FILTERS_CONDITIONS_GREATER_THAN = `${FILTERS_CONDITIONS_NAMESPACE}.greaterThan`;
var FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL = `${FILTERS_CONDITIONS_NAMESPACE}.greaterThanOrEqualTo`;
var FILTERS_CONDITIONS_LESS_THAN = `${FILTERS_CONDITIONS_NAMESPACE}.lessThan`;
var FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL = `${FILTERS_CONDITIONS_NAMESPACE}.lessThanOrEqualTo`;
var FILTERS_CONDITIONS_BETWEEN = `${FILTERS_CONDITIONS_NAMESPACE}.isBetween`;
var FILTERS_CONDITIONS_NOT_BETWEEN = `${FILTERS_CONDITIONS_NAMESPACE}.isNotBetween`;
var FILTERS_CONDITIONS_AFTER = `${FILTERS_CONDITIONS_NAMESPACE}.after`;
var FILTERS_CONDITIONS_BEFORE = `${FILTERS_CONDITIONS_NAMESPACE}.before`;
var FILTERS_CONDITIONS_TODAY = `${FILTERS_CONDITIONS_NAMESPACE}.today`;
var FILTERS_CONDITIONS_TOMORROW = `${FILTERS_CONDITIONS_NAMESPACE}.tomorrow`;
var FILTERS_CONDITIONS_YESTERDAY = `${FILTERS_CONDITIONS_NAMESPACE}.yesterday`;
var FILTERS_DIVS_FILTER_BY_CONDITION = `${FILTERS_NAMESPACE}labels.filterByCondition`;
var FILTERS_DIVS_FILTER_BY_VALUE = `${FILTERS_NAMESPACE}labels.filterByValue`;
var FILTERS_LABELS_CONJUNCTION = `${FILTERS_NAMESPACE}labels.conjunction`;
var FILTERS_LABELS_DISJUNCTION = `${FILTERS_NAMESPACE}labels.disjunction`;
var FILTERS_VALUES_BLANK_CELLS = `${FILTERS_NAMESPACE}values.blankCells`;
var FILTERS_BUTTONS_SELECT_ALL = `${FILTERS_NAMESPACE}buttons.selectAll`;
var FILTERS_BUTTONS_CLEAR = `${FILTERS_NAMESPACE}buttons.clear`;
var FILTERS_BUTTONS_OK = `${FILTERS_NAMESPACE}buttons.ok`;
var FILTERS_BUTTONS_CANCEL = `${FILTERS_NAMESPACE}buttons.cancel`;
var FILTERS_BUTTONS_PLACEHOLDER_SEARCH = `${FILTERS_NAMESPACE}buttons.placeholder.search`;
var FILTERS_BUTTONS_PLACEHOLDER_VALUE = `${FILTERS_NAMESPACE}buttons.placeholder.value`;
var FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE = `${FILTERS_NAMESPACE}buttons.placeholder.secondValue`;

// node_modules/handsontable/i18n/languages/en-US.mjs
var dictionary = {
  languageCode: "en-US",
  [CONTEXTMENU_ITEMS_NO_ITEMS]: "No available options",
  [CONTEXTMENU_ITEMS_ROW_ABOVE]: "Insert row above",
  [CONTEXTMENU_ITEMS_ROW_BELOW]: "Insert row below",
  [CONTEXTMENU_ITEMS_INSERT_LEFT]: "Insert column left",
  [CONTEXTMENU_ITEMS_INSERT_RIGHT]: "Insert column right",
  [CONTEXTMENU_ITEMS_REMOVE_ROW]: ["Remove row", "Remove rows"],
  [CONTEXTMENU_ITEMS_REMOVE_COLUMN]: ["Remove column", "Remove columns"],
  [CONTEXTMENU_ITEMS_UNDO]: "Undo",
  [CONTEXTMENU_ITEMS_REDO]: "Redo",
  [CONTEXTMENU_ITEMS_READ_ONLY]: "Read only",
  [CONTEXTMENU_ITEMS_CLEAR_COLUMN]: "Clear column",
  [CONTEXTMENU_ITEMS_ALIGNMENT]: "Alignment",
  [CONTEXTMENU_ITEMS_ALIGNMENT_LEFT]: "Left",
  [CONTEXTMENU_ITEMS_ALIGNMENT_CENTER]: "Center",
  [CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT]: "Right",
  [CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY]: "Justify",
  [CONTEXTMENU_ITEMS_ALIGNMENT_TOP]: "Top",
  [CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE]: "Middle",
  [CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM]: "Bottom",
  [CONTEXTMENU_ITEMS_FREEZE_COLUMN]: "Freeze column",
  [CONTEXTMENU_ITEMS_UNFREEZE_COLUMN]: "Unfreeze column",
  [CONTEXTMENU_ITEMS_BORDERS]: "Borders",
  [CONTEXTMENU_ITEMS_BORDERS_TOP]: "Top",
  [CONTEXTMENU_ITEMS_BORDERS_RIGHT]: "Right",
  [CONTEXTMENU_ITEMS_BORDERS_BOTTOM]: "Bottom",
  [CONTEXTMENU_ITEMS_BORDERS_LEFT]: "Left",
  [CONTEXTMENU_ITEMS_REMOVE_BORDERS]: "Remove border(s)",
  [CONTEXTMENU_ITEMS_ADD_COMMENT]: "Add comment",
  [CONTEXTMENU_ITEMS_EDIT_COMMENT]: "Edit comment",
  [CONTEXTMENU_ITEMS_REMOVE_COMMENT]: "Delete comment",
  [CONTEXTMENU_ITEMS_READ_ONLY_COMMENT]: "Read-only comment",
  [CONTEXTMENU_ITEMS_MERGE_CELLS]: "Merge cells",
  [CONTEXTMENU_ITEMS_UNMERGE_CELLS]: "Unmerge cells",
  [CONTEXTMENU_ITEMS_COPY]: "Copy",
  [CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS]: ["Copy with header", "Copy with headers"],
  [CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS]: ["Copy with group header", "Copy with group headers"],
  [CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY]: ["Copy header only", "Copy headers only"],
  [CONTEXTMENU_ITEMS_CUT]: "Cut",
  [CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD]: "Insert child row",
  [CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD]: "Detach from parent",
  [CONTEXTMENU_ITEMS_HIDE_COLUMN]: ["Hide column", "Hide columns"],
  [CONTEXTMENU_ITEMS_SHOW_COLUMN]: ["Show column", "Show columns"],
  [CONTEXTMENU_ITEMS_HIDE_ROW]: ["Hide row", "Hide rows"],
  [CONTEXTMENU_ITEMS_SHOW_ROW]: ["Show row", "Show rows"],
  [FILTERS_CONDITIONS_NONE]: "None",
  [FILTERS_CONDITIONS_EMPTY]: "Is empty",
  [FILTERS_CONDITIONS_NOT_EMPTY]: "Is not empty",
  [FILTERS_CONDITIONS_EQUAL]: "Is equal to",
  [FILTERS_CONDITIONS_NOT_EQUAL]: "Is not equal to",
  [FILTERS_CONDITIONS_BEGINS_WITH]: "Begins with",
  [FILTERS_CONDITIONS_ENDS_WITH]: "Ends with",
  [FILTERS_CONDITIONS_CONTAINS]: "Contains",
  [FILTERS_CONDITIONS_NOT_CONTAIN]: "Does not contain",
  [FILTERS_CONDITIONS_GREATER_THAN]: "Greater than",
  [FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL]: "Greater than or equal to",
  [FILTERS_CONDITIONS_LESS_THAN]: "Less than",
  [FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL]: "Less than or equal to",
  [FILTERS_CONDITIONS_BETWEEN]: "Is between",
  [FILTERS_CONDITIONS_NOT_BETWEEN]: "Is not between",
  [FILTERS_CONDITIONS_AFTER]: "After",
  [FILTERS_CONDITIONS_BEFORE]: "Before",
  [FILTERS_CONDITIONS_TODAY]: "Today",
  [FILTERS_CONDITIONS_TOMORROW]: "Tomorrow",
  [FILTERS_CONDITIONS_YESTERDAY]: "Yesterday",
  [FILTERS_VALUES_BLANK_CELLS]: "Blank cells",
  [FILTERS_DIVS_FILTER_BY_CONDITION]: "Filter by condition",
  [FILTERS_DIVS_FILTER_BY_VALUE]: "Filter by value",
  [FILTERS_LABELS_CONJUNCTION]: "And",
  [FILTERS_LABELS_DISJUNCTION]: "Or",
  [FILTERS_BUTTONS_SELECT_ALL]: "Select all",
  [FILTERS_BUTTONS_CLEAR]: "Clear",
  [FILTERS_BUTTONS_OK]: "OK",
  [FILTERS_BUTTONS_CANCEL]: "Cancel",
  [FILTERS_BUTTONS_PLACEHOLDER_SEARCH]: "Search",
  [FILTERS_BUTTONS_PLACEHOLDER_VALUE]: "Value",
  [FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE]: "Second value"
};
var en_US_default = dictionary;

// node_modules/handsontable/i18n/registry.mjs
var dictionaryKeys = constants_exports;
var DEFAULT_LANGUAGE_CODE = en_US_default.languageCode;
var {
  register: registerGloballyLanguageDictionary,
  getItem: getGlobalLanguageDictionary,
  hasItem: hasGlobalLanguageDictionary,
  getValues: getGlobalLanguagesDictionaries
} = staticRegister("languagesDictionaries");
registerLanguageDictionary(en_US_default);
function registerLanguageDictionary(languageCodeOrDictionary, dictionary2) {
  let languageCode = languageCodeOrDictionary;
  let dictionaryObject = dictionary2;
  if (isObject2(languageCodeOrDictionary)) {
    dictionaryObject = languageCodeOrDictionary;
    languageCode = dictionaryObject.languageCode;
  }
  extendLanguageDictionary(languageCode, dictionaryObject);
  registerGloballyLanguageDictionary(languageCode, deepClone(dictionaryObject));
  return deepClone(dictionaryObject);
}
function extendLanguageDictionary(languageCode, dictionary2) {
  if (languageCode !== DEFAULT_LANGUAGE_CODE) {
    extendNotExistingKeys(dictionary2, getGlobalLanguageDictionary(DEFAULT_LANGUAGE_CODE));
  }
}
function getLanguageDictionary(languageCode) {
  if (!hasLanguageDictionary(languageCode)) {
    return null;
  }
  return deepClone(getGlobalLanguageDictionary(languageCode));
}
function hasLanguageDictionary(languageCode) {
  return hasGlobalLanguageDictionary(languageCode);
}
function getLanguagesDictionaries() {
  return getGlobalLanguagesDictionaries();
}
function getTranslatedPhrase(languageCode, dictionaryKey, argumentsForFormatters) {
  const languageDictionary = getLanguageDictionary(languageCode);
  if (languageDictionary === null) {
    return null;
  }
  const phrasePropositions = languageDictionary[dictionaryKey];
  if (isUndefined2(phrasePropositions)) {
    return null;
  }
  const formattedPhrase = getFormattedPhrase(phrasePropositions, argumentsForFormatters);
  if (Array.isArray(formattedPhrase)) {
    return formattedPhrase[0];
  }
  return formattedPhrase;
}
function getFormattedPhrase(phrasePropositions, argumentsForFormatters) {
  let formattedPhrasePropositions = phrasePropositions;
  arrayEach(getAll(), (formatter) => {
    formattedPhrasePropositions = formatter(phrasePropositions, argumentsForFormatters);
  });
  return formattedPhrasePropositions;
}
function getValidLanguageCode(languageCode) {
  let normalizedLanguageCode = normalizeLanguageCode(languageCode);
  if (!hasLanguageDictionary(normalizedLanguageCode)) {
    normalizedLanguageCode = DEFAULT_LANGUAGE_CODE;
    warnUserAboutLanguageRegistration(languageCode);
  }
  return normalizedLanguageCode;
}

// node_modules/handsontable/selection/highlight/constants.mjs
var ACTIVE_HEADER_TYPE = "active-header";
var AREA_TYPE = "area";
var CELL_TYPE = "cell";
var FILL_TYPE = "fill";
var HEADER_TYPE = "header";
var CUSTOM_SELECTION_TYPE = "custom-selection";

// node_modules/handsontable/selection/highlight/visualSelection.mjs
function _defineProperty15(obj, key, value) {
  key = _toPropertyKey15(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey15(arg) {
  var key = _toPrimitive15(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive15(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var VisualSelection = class extends selection_default {
  constructor(settings, visualCellRange) {
    super(settings, null);
    _defineProperty15(this, "visualCellRange", null);
    this.visualCellRange = visualCellRange || null;
    this.commit();
  }
  /**
   * Adds a cell coords to the selection.
   *
   * @param {CellCoords} coords Visual coordinates of a cell.
   * @returns {VisualSelection}
   */
  add(coords) {
    if (this.visualCellRange === null) {
      this.visualCellRange = this.settings.createCellRange(coords);
    } else {
      this.visualCellRange.expand(coords);
    }
    return this;
  }
  /**
   * Clears visual and renderable selection.
   *
   * @returns {VisualSelection}
   */
  clear() {
    this.visualCellRange = null;
    return super.clear();
  }
  /**
   * Trims the passed cell range object by removing all coordinates that points to the hidden rows
   * or columns. The result is a new cell range object that points only to the visible indexes or `null`.
   *
   * @private
   * @param {CellRange} cellRange Cells range object to be trimmed.
   * @returns {CellRange} Visual non-hidden cells range coordinates.
   */
  trimToVisibleCellsRangeOnly(_ref2) {
    let {
      from: from2,
      to: to2
    } = _ref2;
    let visibleFromCoords = this.getNearestNotHiddenCoords(from2, 1);
    let visibleToCoords = this.getNearestNotHiddenCoords(to2, -1);
    if (visibleFromCoords === null || visibleToCoords === null) {
      return null;
    }
    if (visibleFromCoords.row > visibleToCoords.row || visibleFromCoords.col > visibleToCoords.col) {
      const isHeaderTypeSelection = this.settings.type === "header" || this.settings.type === "active-header";
      if (!isHeaderTypeSelection) {
        return null;
      }
      visibleFromCoords = from2;
      visibleToCoords = to2;
    }
    return this.settings.createCellRange(visibleFromCoords, visibleFromCoords, visibleToCoords);
  }
  /**
   * Gets nearest coordinates that points to the visible row and column indexes. If there are no visible
   * rows and/or columns the `null` value is returned.
   *
   * @private
   * @param {CellCoords} coords The coords object as starting point for finding the nearest visible coordinates.
   * @param {1|-1} rowSearchDirection The search direction. For value 1, it means searching from top to bottom for
   *                                  rows and from left to right for columns. For -1, it is the other way around.
   * @param {1|-1} columnSearchDirection The same as above but for rows.
   * @returns {CellCoords|null} Visual cell coordinates.
   */
  getNearestNotHiddenCoords(coords, rowSearchDirection) {
    let columnSearchDirection = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rowSearchDirection;
    const nextVisibleRow = this.getNearestNotHiddenIndex(this.settings.rowIndexMapper(), coords.row, rowSearchDirection);
    if (nextVisibleRow === null) {
      return null;
    }
    const nextVisibleColumn = this.getNearestNotHiddenIndex(this.settings.columnIndexMapper(), coords.col, columnSearchDirection);
    if (nextVisibleColumn === null) {
      return null;
    }
    return this.settings.createCellCoords(nextVisibleRow, nextVisibleColumn);
  }
  /**
   * Gets nearest visual index. If there are no visible rows or columns the `null` value is returned.
   *
   * @private
   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.
   * @param {number} visualIndex The index as starting point for finding the nearest visible index.
   * @param {1|-1} searchDirection The search direction. For value 1, it means searching from top to bottom for
   *                               rows and from left to right for columns. For -1, it is the other way around.
   * @returns {number|null} Visual row/column index.
   */
  getNearestNotHiddenIndex(indexMapper, visualIndex, searchDirection) {
    if (visualIndex < 0) {
      return visualIndex;
    }
    const nearestVisualIndex = indexMapper.getNearestNotHiddenIndex(visualIndex, searchDirection);
    const isHeaderSelectionType = this.settings.type === "header" || this.settings.type === "active-header";
    if (isHeaderSelectionType && nearestVisualIndex === null) {
      return -1;
    }
    return nearestVisualIndex;
  }
  /**
   * Override internally stored visual indexes added by the Selection's `add` function. It should be executed
   * at the end of process of adding visual selection coordinates.
   *
   * @returns {VisualSelection}
   */
  commit() {
    if (this.visualCellRange === null) {
      return this;
    }
    const trimmedCellRange = this.trimToVisibleCellsRangeOnly(this.visualCellRange);
    if (trimmedCellRange === null) {
      this.cellRange = null;
    } else {
      this.cellRange = this.createRenderableCellRange(trimmedCellRange.from, trimmedCellRange.to);
    }
    return this;
  }
  /**
   * Some selection may be a part of broader cell range. This function sync coordinates of current selection
   * and the broader cell range when needed (current selection can't be presented visually).
   *
   * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.
   * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.
   *
   * Warn: Please keep in mind that this function may change coordinates of the handled broader range.
   *
   * @returns {VisualSelection}
   */
  syncWith(broaderCellRange) {
    const rowDirection = broaderCellRange.getVerticalDirection() === "N-S" ? 1 : -1;
    const columnDirection = broaderCellRange.getHorizontalDirection() === "W-E" ? 1 : -1;
    const singleCellRangeVisual = this.getNearestNotHiddenCoords(broaderCellRange.from.clone().normalize(), rowDirection, columnDirection);
    if (singleCellRangeVisual !== null && broaderCellRange.overlaps(singleCellRangeVisual)) {
      if (this.cellRange === null) {
        const singleCellRangeRenderable = this.settings.visualToRenderableCoords(singleCellRangeVisual);
        this.cellRange = this.settings.createCellRange(singleCellRangeRenderable);
      }
      broaderCellRange.setHighlight(singleCellRangeVisual);
      return this;
    }
    broaderCellRange.setHighlight(broaderCellRange.from);
    return this;
  }
  /**
   * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).
   * The method overwrites the original method to support header selection for hidden cells.
   * To make the header selection working, the CellCoords and CellRange have to support not
   * complete coordinates (`null` values for example, `row: null`, `col: 2`).
   *
   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.
   */
  getCorners() {
    const {
      from: from2,
      to: to2
    } = this.cellRange;
    const isRowUndefined = from2.row === null || to2.row === null;
    const isColumnUndefined = from2.col === null || to2.col === null;
    const topLeftCorner = this.settings.createCellCoords(isRowUndefined ? null : Math.min(from2.row, to2.row), isColumnUndefined ? null : Math.min(from2.col, to2.col));
    const bottomRightCorner = this.settings.createCellCoords(isRowUndefined ? null : Math.max(from2.row, to2.row), isColumnUndefined ? null : Math.max(from2.col, to2.col));
    return [topLeftCorner.row, topLeftCorner.col, bottomRightCorner.row, bottomRightCorner.col];
  }
  /**
   * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection
   * coordinates (visual indexes).
   *
   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.
   */
  getVisualCorners() {
    const topStart = this.settings.renderableToVisualCoords(this.cellRange.getTopStartCorner());
    const bottomEnd = this.settings.renderableToVisualCoords(this.cellRange.getBottomEndCorner());
    return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];
  }
  /**
   * Creates a new CellRange object based on visual coordinates which before object creation are
   * translated to renderable indexes.
   *
   * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that
   *                                      points to the beginning of the selection.
   * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that
   *                                    points to the end of the selection.
   * @returns {CellRange}
   */
  createRenderableCellRange(visualFromCoords, visualToCoords) {
    const renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);
    const renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);
    return this.settings.createCellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);
  }
};
var visualSelection_default = VisualSelection;

// node_modules/handsontable/selection/highlight/types/activeHeader.mjs
function createHighlight(_ref2) {
  let {
    activeHeaderClassName,
    ...restOptions
  } = _ref2;
  const s = new visualSelection_default({
    highlightHeaderClassName: activeHeaderClassName,
    ...restOptions,
    selectionType: ACTIVE_HEADER_TYPE
  });
  return s;
}
var activeHeader_default = createHighlight;

// node_modules/handsontable/selection/highlight/types/area.mjs
function createHighlight2(_ref2) {
  let {
    layerLevel,
    areaCornerVisible,
    ...restOptions
  } = _ref2;
  const s = new visualSelection_default({
    className: "area",
    markIntersections: true,
    layerLevel: Math.min(layerLevel, 7),
    border: {
      width: 1,
      color: "#4b89ff",
      cornerVisible: areaCornerVisible
    },
    ...restOptions,
    selectionType: AREA_TYPE
  });
  return s;
}
var area_default = createHighlight2;

// node_modules/handsontable/selection/highlight/types/cell.mjs
function createHighlight3(_ref2) {
  let {
    cellCornerVisible,
    ...restOptions
  } = _ref2;
  const s = new visualSelection_default({
    className: "current",
    border: {
      width: 2,
      color: "#4b89ff",
      cornerVisible: cellCornerVisible
    },
    ...restOptions,
    selectionType: CELL_TYPE
  });
  return s;
}
var cell_default = createHighlight3;

// node_modules/handsontable/selection/highlight/types/customSelection.mjs
function createHighlight4(_ref2) {
  let {
    border,
    visualCellRange,
    ...restOptions
  } = _ref2;
  const s = new visualSelection_default({
    ...border,
    ...restOptions,
    selectionType: CUSTOM_SELECTION_TYPE
  }, visualCellRange);
  return s;
}
var customSelection_default = createHighlight4;

// node_modules/handsontable/selection/highlight/types/fill.mjs
function createHighlight5(_ref2) {
  let {
    ...restOptions
  } = _ref2;
  const s = new visualSelection_default({
    className: "fill",
    border: {
      width: 1,
      color: "#ff0000"
    },
    ...restOptions,
    selectionType: FILL_TYPE
  });
  return s;
}
var fill_default = createHighlight5;

// node_modules/handsontable/selection/highlight/types/header.mjs
function createHighlight6(_ref2) {
  let {
    headerClassName,
    rowClassName,
    columnClassName,
    ...restOptions
  } = _ref2;
  const s = new visualSelection_default({
    className: "highlight",
    highlightHeaderClassName: headerClassName,
    highlightRowClassName: rowClassName,
    highlightColumnClassName: columnClassName,
    ...restOptions,
    highlightOnlyClosestHeader: true,
    selectionType: HEADER_TYPE
  });
  return s;
}
var header_default = createHighlight6;

// node_modules/handsontable/selection/highlight/types/index.mjs
var {
  register: register5,
  getItem: getItem4
} = staticRegister("highlight/types");
register5(ACTIVE_HEADER_TYPE, activeHeader_default);
register5(AREA_TYPE, area_default);
register5(CELL_TYPE, cell_default);
register5(CUSTOM_SELECTION_TYPE, customSelection_default);
register5(FILL_TYPE, fill_default);
register5(HEADER_TYPE, header_default);
function createHighlight7(highlightType, options) {
  return getItem4(highlightType)({
    type: highlightType,
    ...options
  });
}

// node_modules/handsontable/selection/highlight/highlight.mjs
var Highlight = class {
  constructor(options) {
    this.options = options;
    this.layerLevel = 0;
    this.cell = createHighlight7(CELL_TYPE, options);
    this.fill = createHighlight7(FILL_TYPE, options);
    this.areas = /* @__PURE__ */ new Map();
    this.headers = /* @__PURE__ */ new Map();
    this.activeHeaders = /* @__PURE__ */ new Map();
    this.customSelections = [];
  }
  /**
   * Check if highlight cell rendering is disabled for specified highlight type.
   *
   * @param {string} highlightType Highlight type. Possible values are: `cell`, `area`, `fill` or `header`.
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {boolean}
   */
  isEnabledFor(highlightType, coords) {
    let type = highlightType;
    if (highlightType === CELL_TYPE) {
      type = "current";
    }
    let disableHighlight = this.options.disabledCellSelection(coords.row, coords.col);
    if (typeof disableHighlight === "string") {
      disableHighlight = [disableHighlight];
    }
    return disableHighlight === false || Array.isArray(disableHighlight) && !disableHighlight.includes(type);
  }
  /**
   * Set a new layer level to make access to the desire `area` and `header` highlights.
   *
   * @param {number} [level=0] Layer level to use.
   * @returns {Highlight}
   */
  useLayerLevel() {
    let level = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    this.layerLevel = level;
    return this;
  }
  /**
   * Get Walkontable Selection instance created for controlling highlight of the currently selected/edited cell.
   *
   * @returns {Selection}
   */
  getCell() {
    return this.cell;
  }
  /**
   * Get Walkontable Selection instance created for controlling highlight of the autofill functionality.
   *
   * @returns {Selection}
   */
  getFill() {
    return this.fill;
  }
  /**
   * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight
   * of the multiple selected cells.
   *
   * @returns {Selection}
   */
  createOrGetArea() {
    const layerLevel = this.layerLevel;
    let area;
    if (this.areas.has(layerLevel)) {
      area = this.areas.get(layerLevel);
    } else {
      area = createHighlight7(AREA_TYPE, {
        layerLevel,
        ...this.options
      });
      this.areas.set(layerLevel, area);
    }
    return area;
  }
  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the cells.
   *
   * @returns {Selection[]}
   */
  getAreas() {
    return [...this.areas.values()];
  }
  /**
   * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight
   * of the multiple selected header cells.
   *
   * @returns {Selection}
   */
  createOrGetHeader() {
    const layerLevel = this.layerLevel;
    let header;
    if (this.headers.has(layerLevel)) {
      header = this.headers.get(layerLevel);
    } else {
      header = createHighlight7(HEADER_TYPE, {
        ...this.options
      });
      this.headers.set(layerLevel, header);
    }
    return header;
  }
  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers.
   *
   * @returns {Selection[]}
   */
  getHeaders() {
    return [...this.headers.values()];
  }
  /**
   * Get or create (if not exist in the cache) Walkontable Selection instance created for controlling highlight
   * of the multiple selected active header cells.
   *
   * @returns {Selection}
   */
  createOrGetActiveHeader() {
    const layerLevel = this.layerLevel;
    let header;
    if (this.activeHeaders.has(layerLevel)) {
      header = this.activeHeaders.get(layerLevel);
    } else {
      header = createHighlight7(ACTIVE_HEADER_TYPE, {
        ...this.options
      });
      this.activeHeaders.set(layerLevel, header);
    }
    return header;
  }
  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the active headers.
   *
   * @returns {Selection[]}
   */
  getActiveHeaders() {
    return [...this.activeHeaders.values()];
  }
  /**
   * Get Walkontable Selection instance created for controlling highlight of the custom selection functionality.
   *
   * @returns {Selection}
   */
  getCustomSelections() {
    return [...this.customSelections.values()];
  }
  /**
   * Add selection to the custom selection instance. The new selection are added to the end of the selection collection.
   *
   * @param {object} selectionInstance The selection instance.
   */
  addCustomSelection(selectionInstance) {
    this.customSelections.push(createHighlight7(CUSTOM_SELECTION_TYPE, {
      ...this.options,
      ...selectionInstance
    }));
  }
  /**
   * Perform cleaning visual highlights for the whole table.
   */
  clear() {
    this.cell.clear();
    this.fill.clear();
    arrayEach(this.areas.values(), (highlight) => void highlight.clear());
    arrayEach(this.headers.values(), (highlight) => void highlight.clear());
    arrayEach(this.activeHeaders.values(), (highlight) => void highlight.clear());
  }
  /**
   * This object can be iterate over using `for of` syntax or using internal `arrayEach` helper.
   *
   * @returns {Selection[]}
   */
  [Symbol.iterator]() {
    return [this.cell, this.fill, ...this.areas.values(), ...this.headers.values(), ...this.activeHeaders.values(), ...this.customSelections][Symbol.iterator]();
  }
};
var highlight_default = Highlight;

// node_modules/handsontable/selection/range.mjs
var SelectionRange = class {
  constructor(createCellRange) {
    this.ranges = [];
    this.createCellRange = createCellRange;
  }
  /**
   * Check if selected range is empty.
   *
   * @returns {boolean}
   */
  isEmpty() {
    return this.size() === 0;
  }
  /**
   * Set coordinates to the class instance. It clears all previously added coordinates and push `coords`
   * to the collection.
   *
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {SelectionRange}
   */
  set(coords) {
    this.clear();
    this.ranges.push(this.createCellRange(coords));
    return this;
  }
  /**
   * Add coordinates to the class instance. The new coordinates are added to the end of the range collection.
   *
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {SelectionRange}
   */
  add(coords) {
    this.ranges.push(this.createCellRange(coords));
    return this;
  }
  /**
   * Removes from the stack the last added coordinates.
   *
   * @returns {SelectionRange}
   */
  pop() {
    this.ranges.pop();
    return this;
  }
  /**
   * Get last added coordinates from ranges, it returns a CellRange instance.
   *
   * @returns {CellRange|undefined}
   */
  current() {
    return this.peekByIndex(0);
  }
  /**
   * Get previously added coordinates from ranges, it returns a CellRange instance.
   *
   * @returns {CellRange|undefined}
   */
  previous() {
    return this.peekByIndex(-1);
  }
  /**
   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if
   * the coords object is within selection range.
   *
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {boolean}
   */
  includes(coords) {
    return this.ranges.some((cellRange) => cellRange.includes(coords));
  }
  /**
   * Clear collection.
   *
   * @returns {SelectionRange}
   */
  clear() {
    this.ranges.length = 0;
    return this;
  }
  /**
   * Get count of added all coordinates added to the selection.
   *
   * @returns {number}
   */
  size() {
    return this.ranges.length;
  }
  /**
   * Peek the coordinates based on the offset where that coordinate resides in the collection.
   *
   * @param {number} [offset=0] An offset where the coordinate will be retrieved from.
   * @returns {CellRange|undefined}
   */
  peekByIndex() {
    let offset3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    const rangeIndex = this.size() + offset3 - 1;
    let cellRange;
    if (rangeIndex >= 0) {
      cellRange = this.ranges[rangeIndex];
    }
    return cellRange;
  }
  [Symbol.iterator]() {
    return this.ranges[Symbol.iterator]();
  }
};
var range_default2 = SelectionRange;

// node_modules/handsontable/selection/transformation.mjs
var Transformation = class {
  constructor(range, options) {
    this.range = range;
    this.options = options;
  }
  /**
   * Selects cell relative to current cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   * @param {boolean} [force=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will
   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.
   * @returns {CellCoords} Visual coordinates after transformation.
   */
  transformStart(rowDelta, colDelta) {
    let force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const delta = this.options.createCellCoords(rowDelta, colDelta);
    const highlightCoords = this.range.current().highlight;
    const {
      row: renderableRow,
      col: renderableColumn
    } = this.options.visualToRenderableCoords(highlightCoords);
    let visualCoords = highlightCoords;
    let rowTransformDir = 0;
    let colTransformDir = 0;
    this.runLocalHooks("beforeTransformStart", delta);
    if (renderableRow !== null && renderableColumn !== null) {
      let totalRows = this.options.countRows();
      let totalCols = this.options.countCols();
      const fixedRowsBottom = this.options.fixedRowsBottom();
      const minSpareRows = this.options.minSpareRows();
      const minSpareCols = this.options.minSpareCols();
      const autoWrapRow = this.options.autoWrapRow();
      const autoWrapCol = this.options.autoWrapCol();
      if (renderableRow + rowDelta > totalRows - 1) {
        if (force && minSpareRows > 0 && !(fixedRowsBottom && renderableRow >= totalRows - fixedRowsBottom - 1)) {
          this.runLocalHooks("insertRowRequire", totalRows);
          totalRows = this.options.countRows();
        } else if (autoWrapCol) {
          delta.row = 1 - totalRows;
          delta.col = renderableColumn + delta.col === totalCols - 1 ? 1 - totalCols : 1;
        }
      } else if (autoWrapCol && renderableRow + delta.row < 0 && renderableColumn + delta.col >= 0) {
        delta.row = totalRows - 1;
        delta.col = renderableColumn + delta.col === 0 ? totalCols - 1 : -1;
      }
      if (renderableColumn + delta.col > totalCols - 1) {
        if (force && minSpareCols > 0) {
          this.runLocalHooks("insertColRequire", totalCols);
          totalCols = this.options.countCols();
        } else if (autoWrapRow) {
          delta.row = renderableRow + delta.row === totalRows - 1 ? 1 - totalRows : 1;
          delta.col = 1 - totalCols;
        }
      } else if (autoWrapRow && renderableColumn + delta.col < 0 && renderableRow + delta.row >= 0) {
        delta.row = renderableRow + delta.row === 0 ? totalRows - 1 : -1;
        delta.col = totalCols - 1;
      }
      const coords = this.options.createCellCoords(renderableRow + delta.row, renderableColumn + delta.col);
      rowTransformDir = 0;
      colTransformDir = 0;
      if (coords.row < 0) {
        rowTransformDir = -1;
        coords.row = 0;
      } else if (coords.row > 0 && coords.row >= totalRows) {
        rowTransformDir = 1;
        coords.row = totalRows - 1;
      }
      if (coords.col < 0) {
        colTransformDir = -1;
        coords.col = 0;
      } else if (coords.col > 0 && coords.col >= totalCols) {
        colTransformDir = 1;
        coords.col = totalCols - 1;
      }
      visualCoords = this.options.renderableToVisualCoords(coords);
    }
    this.runLocalHooks("afterTransformStart", visualCoords, rowTransformDir, colTransformDir);
    return visualCoords;
  }
  /**
   * Sets selection end cell relative to current selection end cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   * @returns {CellCoords} Visual coordinates after transformation.
   */
  transformEnd(rowDelta, colDelta) {
    const delta = this.options.createCellCoords(rowDelta, colDelta);
    const cellRange = this.range.current();
    let visualCoords = cellRange.to;
    let rowTransformDir = 0;
    let colTransformDir = 0;
    this.runLocalHooks("beforeTransformEnd", delta);
    const {
      row: rowHighlight,
      col: colHighlight
    } = this.options.visualToRenderableCoords(cellRange.highlight);
    if (rowHighlight !== null && colHighlight !== null) {
      const totalRows = this.options.countRows();
      const totalCols = this.options.countCols();
      const {
        row: rowTo,
        col: colTo
      } = this.options.visualToRenderableCoords(cellRange.to);
      const coords = this.options.createCellCoords(rowTo + delta.row, colTo + delta.col);
      rowTransformDir = 0;
      colTransformDir = 0;
      if (coords.row < 0) {
        rowTransformDir = -1;
        coords.row = 0;
      } else if (coords.row > 0 && coords.row >= totalRows) {
        rowTransformDir = 1;
        coords.row = totalRows - 1;
      }
      if (coords.col < 0) {
        colTransformDir = -1;
        coords.col = 0;
      } else if (coords.col > 0 && coords.col >= totalCols) {
        colTransformDir = 1;
        coords.col = totalCols - 1;
      }
      visualCoords = this.options.renderableToVisualCoords(coords);
    }
    this.runLocalHooks("afterTransformEnd", visualCoords, rowTransformDir, colTransformDir);
    return visualCoords;
  }
};
mixin(Transformation, localHooks_default);
var transformation_default = Transformation;

// node_modules/handsontable/selection/utils.mjs
var SELECTION_TYPE_UNRECOGNIZED = 0;
var SELECTION_TYPE_EMPTY = 1;
var SELECTION_TYPE_ARRAY = 2;
var SELECTION_TYPE_OBJECT = 3;
var SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];
var ARRAY_TYPE_PATTERN = [["number"], ["number", "string"], ["number", "undefined"], ["number", "string", "undefined"]];
var rootCall = Symbol("root");
var childCall = Symbol("child");
function detectSelectionType(selectionRanges) {
  let _callSymbol = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rootCall;
  if (_callSymbol !== rootCall && _callSymbol !== childCall) {
    throw new Error("The second argument is used internally only and cannot be overwritten.");
  }
  const isArray2 = Array.isArray(selectionRanges);
  const isRootCall = _callSymbol === rootCall;
  let result = SELECTION_TYPE_UNRECOGNIZED;
  if (isArray2) {
    const firstItem = selectionRanges[0];
    if (selectionRanges.length === 0) {
      result = SELECTION_TYPE_EMPTY;
    } else if (isRootCall && firstItem instanceof range_default) {
      result = SELECTION_TYPE_OBJECT;
    } else if (isRootCall && Array.isArray(firstItem)) {
      result = detectSelectionType(firstItem, childCall);
    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {
      const isArrayType = !selectionRanges.some((value, index2) => !ARRAY_TYPE_PATTERN[index2].includes(typeof value));
      if (isArrayType) {
        result = SELECTION_TYPE_ARRAY;
      }
    }
  }
  return result;
}
function normalizeSelectionFactory(type) {
  let {
    keepDirection = false,
    propToCol
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!SELECTION_TYPES.includes(type)) {
    throw new Error("Unsupported selection ranges schema type was provided.");
  }
  return function(selection) {
    const isObjectType = type === SELECTION_TYPE_OBJECT;
    let rowStart = isObjectType ? selection.from.row : selection[0];
    let columnStart = isObjectType ? selection.from.col : selection[1];
    let rowEnd = isObjectType ? selection.to.row : selection[2];
    let columnEnd = isObjectType ? selection.to.col : selection[3];
    if (typeof propToCol === "function") {
      if (typeof columnStart === "string") {
        columnStart = propToCol(columnStart);
      }
      if (typeof columnEnd === "string") {
        columnEnd = propToCol(columnEnd);
      }
    }
    if (isUndefined2(rowEnd)) {
      rowEnd = rowStart;
    }
    if (isUndefined2(columnEnd)) {
      columnEnd = columnStart;
    }
    if (!keepDirection) {
      const origRowStart = rowStart;
      const origColumnStart = columnStart;
      const origRowEnd = rowEnd;
      const origColumnEnd = columnEnd;
      rowStart = Math.min(origRowStart, origRowEnd);
      columnStart = Math.min(origColumnStart, origColumnEnd);
      rowEnd = Math.max(origRowStart, origRowEnd);
      columnEnd = Math.max(origColumnStart, origColumnEnd);
    }
    return [rowStart, columnStart, rowEnd, columnEnd];
  };
}
function transformSelectionToColumnDistance(selectionRanges) {
  const selectionType = detectSelectionType(selectionRanges);
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
  const unorderedIndexes = /* @__PURE__ */ new Set();
  arrayEach(selectionRanges, (selection) => {
    const [, columnStart, , columnEnd] = selectionSchemaNormalizer(selection);
    const columnNonHeaderStart = Math.max(columnStart, 0);
    const amount = columnEnd - columnNonHeaderStart + 1;
    arrayEach(Array.from(new Array(amount), (_, i) => columnNonHeaderStart + i), (index2) => {
      if (!unorderedIndexes.has(index2)) {
        unorderedIndexes.add(index2);
      }
    });
  });
  const orderedIndexes = Array.from(unorderedIndexes).sort((a, b) => a - b);
  const normalizedColumnRanges = arrayReduce(orderedIndexes, (acc, visualColumnIndex, index2, array) => {
    if (index2 !== 0 && visualColumnIndex === array[index2 - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([visualColumnIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedColumnRanges;
}
function transformSelectionToRowDistance(selectionRanges) {
  const selectionType = detectSelectionType(selectionRanges);
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
  const unorderedIndexes = /* @__PURE__ */ new Set();
  arrayEach(selectionRanges, (selection) => {
    const [rowStart, , rowEnd] = selectionSchemaNormalizer(selection);
    const rowNonHeaderStart = Math.max(rowStart, 0);
    const amount = rowEnd - rowNonHeaderStart + 1;
    arrayEach(Array.from(new Array(amount), (_, i) => rowNonHeaderStart + i), (index2) => {
      if (!unorderedIndexes.has(index2)) {
        unorderedIndexes.add(index2);
      }
    });
  });
  const orderedIndexes = Array.from(unorderedIndexes).sort((a, b) => a - b);
  const normalizedRowRanges = arrayReduce(orderedIndexes, (acc, rowIndex, index2, array) => {
    if (index2 !== 0 && rowIndex === array[index2 - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([rowIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedRowRanges;
}
function isValidCoord(coord) {
  let maxTableItemsCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
  return typeof coord === "number" && coord >= 0 && coord < maxTableItemsCount;
}

// node_modules/handsontable/selection/selection.mjs
var Selection2 = class {
  constructor(settings, tableProps) {
    var _this = this;
    this.settings = settings;
    this.tableProps = tableProps;
    this.inProgress = false;
    this.selectedByCorner = false;
    this.selectedByRowHeader = /* @__PURE__ */ new Set();
    this.selectedByColumnHeader = /* @__PURE__ */ new Set();
    this.selectedRange = new range_default2((highlight, from2, to2) => {
      return this.tableProps.createCellRange(highlight, from2, to2);
    });
    this.highlight = new highlight_default({
      headerClassName: settings.currentHeaderClassName,
      activeHeaderClassName: settings.activeHeaderClassName,
      rowClassName: settings.currentRowClassName,
      columnClassName: settings.currentColClassName,
      disabledCellSelection: (row, column) => this.tableProps.isDisabledCellSelection(row, column),
      cellCornerVisible: function() {
        return _this.isCellCornerVisible(...arguments);
      },
      areaCornerVisible: function() {
        return _this.isAreaCornerVisible(...arguments);
      },
      visualToRenderableCoords: (coords) => this.tableProps.visualToRenderableCoords(coords),
      renderableToVisualCoords: (coords) => this.tableProps.renderableToVisualCoords(coords),
      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),
      createCellRange: (highlight, from2, to2) => this.tableProps.createCellRange(highlight, from2, to2),
      rowIndexMapper: () => this.tableProps.rowIndexMapper(),
      columnIndexMapper: () => this.tableProps.columnIndexMapper()
    });
    this.transformation = new transformation_default(this.selectedRange, {
      countRows: () => this.tableProps.countRowsTranslated(),
      countCols: () => this.tableProps.countColsTranslated(),
      visualToRenderableCoords: (coords) => this.tableProps.visualToRenderableCoords(coords),
      renderableToVisualCoords: (coords) => this.tableProps.renderableToVisualCoords(coords),
      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),
      fixedRowsBottom: () => settings.fixedRowsBottom,
      minSpareRows: () => settings.minSpareRows,
      minSpareCols: () => settings.minSpareCols,
      autoWrapRow: () => settings.autoWrapRow,
      autoWrapCol: () => settings.autoWrapCol
    });
    this.transformation.addLocalHook("beforeTransformStart", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _this.runLocalHooks("beforeModifyTransformStart", ...args);
    });
    this.transformation.addLocalHook("afterTransformStart", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.runLocalHooks("afterModifyTransformStart", ...args);
    });
    this.transformation.addLocalHook("beforeTransformEnd", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.runLocalHooks("beforeModifyTransformEnd", ...args);
    });
    this.transformation.addLocalHook("afterTransformEnd", function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.runLocalHooks("afterModifyTransformEnd", ...args);
    });
    this.transformation.addLocalHook("insertRowRequire", function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.runLocalHooks("insertRowRequire", ...args);
    });
    this.transformation.addLocalHook("insertColRequire", function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.runLocalHooks("insertColRequire", ...args);
    });
  }
  /**
   * Get data layer for current selection.
   *
   * @returns {SelectionRange}
   */
  getSelectedRange() {
    return this.selectedRange;
  }
  /**
   * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.
   */
  begin() {
    this.inProgress = true;
  }
  /**
   * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.
   */
  finish() {
    this.runLocalHooks("afterSelectionFinished", Array.from(this.selectedRange));
    this.inProgress = false;
  }
  /**
   * Check if the process of selecting the cell/cells is in progress.
   *
   * @returns {boolean}
   */
  isInProgress() {
    return this.inProgress;
  }
  /**
   * Starts selection range on given coordinate object.
   *
   * @param {CellCoords} coords Visual coords.
   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works
   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined
   *                                      the default trigger will be used.
   * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the
   *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.
   */
  setRangeStart(coords, multipleSelection) {
    let fragment = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const isMultipleMode = this.settings.selectionMode === "multiple";
    const isMultipleSelection = isUndefined2(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;
    const isRowNegative = coords.row < 0;
    const isColumnNegative = coords.col < 0;
    const selectedByCorner = isRowNegative && isColumnNegative;
    const coordsClone = coords.clone();
    this.selectedByCorner = selectedByCorner;
    this.runLocalHooks(`beforeSetRangeStart${fragment ? "Only" : ""}`, coordsClone);
    if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined2(multipleSelection)) {
      this.selectedRange.clear();
    }
    this.selectedRange.add(coordsClone);
    if (this.getLayerLevel() === 0) {
      this.selectedByRowHeader.clear();
      this.selectedByColumnHeader.clear();
    }
    if (!selectedByCorner && isColumnNegative) {
      this.selectedByRowHeader.add(this.getLayerLevel());
    }
    if (!selectedByCorner && isRowNegative) {
      this.selectedByColumnHeader.add(this.getLayerLevel());
    }
    if (!fragment) {
      this.setRangeEnd(coords);
    }
  }
  /**
   * Starts selection range on given coordinate object.
   *
   * @param {CellCoords} coords Visual coords.
   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works
   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined
   *                                      the default trigger will be used.
   */
  setRangeStartOnly(coords, multipleSelection) {
    this.setRangeStart(coords, multipleSelection, true);
  }
  /**
   * Ends selection range on given coordinate object.
   *
   * @param {CellCoords} coords Visual coords.
   */
  setRangeEnd(coords) {
    if (this.selectedRange.isEmpty()) {
      return;
    }
    const coordsClone = coords.clone();
    this.runLocalHooks("beforeSetRangeEnd", coordsClone);
    this.begin();
    const cellRange = this.selectedRange.current();
    if (this.settings.selectionMode !== "single") {
      cellRange.setTo(this.tableProps.createCellCoords(coordsClone.row, coordsClone.col));
    }
    this.highlight.getCell().clear();
    if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {
      this.highlight.getCell().add(this.selectedRange.current().highlight).commit().syncWith(cellRange);
    }
    const layerLevel = this.getLayerLevel();
    if (layerLevel < this.highlight.layerLevel) {
      arrayEach(this.highlight.getAreas(), (highlight) => void highlight.clear());
      arrayEach(this.highlight.getHeaders(), (highlight) => void highlight.clear());
      arrayEach(this.highlight.getActiveHeaders(), (highlight) => void highlight.clear());
    }
    this.highlight.useLayerLevel(layerLevel);
    const areaHighlight = this.highlight.createOrGetArea();
    const headerHighlight = this.highlight.createOrGetHeader();
    const activeHeaderHighlight = this.highlight.createOrGetActiveHeader();
    areaHighlight.clear();
    headerHighlight.clear();
    activeHeaderHighlight.clear();
    if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {
      areaHighlight.add(cellRange.from).add(cellRange.to).commit();
      if (layerLevel === 1) {
        const previousRange = this.selectedRange.previous();
        this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit().syncWith(previousRange);
        this.highlight.useLayerLevel(layerLevel);
      }
    }
    if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {
      const areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;
      const areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;
      let headerCellRange = cellRange;
      if (areAnyRowsRendered || areAnyColumnsRendered) {
        headerCellRange = cellRange.clone();
      }
      if (areAnyRowsRendered) {
        headerCellRange.from.row = -1;
      }
      if (areAnyColumnsRendered) {
        headerCellRange.from.col = -1;
      }
      if (this.settings.selectionMode === "single") {
        if (this.isSelectedByAnyHeader()) {
          headerCellRange.from.normalize();
        }
        headerHighlight.add(headerCellRange.from).commit();
      } else {
        headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();
      }
      if (this.isEntireRowSelected()) {
        const isRowSelected = this.tableProps.countCols() === cellRange.getWidth();
        if (isRowSelected) {
          activeHeaderHighlight.add(this.tableProps.createCellCoords(cellRange.from.row, -1)).add(this.tableProps.createCellCoords(cellRange.to.row, -1)).commit();
        }
      }
      if (this.isEntireColumnSelected()) {
        const isColumnSelected = this.tableProps.countRows() === cellRange.getHeight();
        if (isColumnSelected) {
          activeHeaderHighlight.add(this.tableProps.createCellCoords(-1, cellRange.from.col)).add(this.tableProps.createCellCoords(-1, cellRange.to.col)).commit();
        }
      }
    }
    this.runLocalHooks("afterSetRangeEnd", coords);
  }
  /**
   * Returns information if we have a multiselection. This method check multiselection only on the latest layer of
   * the selection.
   *
   * @returns {boolean}
   */
  isMultiple() {
    const isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());
    this.runLocalHooks("afterIsMultipleSelection", isMultipleListener);
    return isMultipleListener.value;
  }
  /**
   * Selects cell relative to the current cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   * @param {boolean} [force=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will
   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.
   */
  transformStart(rowDelta, colDelta) {
    let force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));
  }
  /**
   * Sets selection end cell relative to the current selection end cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   */
  transformEnd(rowDelta, colDelta) {
    this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));
  }
  /**
   * Returns currently used layer level.
   *
   * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.
   */
  getLayerLevel() {
    return this.selectedRange.size() - 1;
  }
  /**
   * Returns `true` if currently there is a selection on the screen, `false` otherwise.
   *
   * @returns {boolean}
   */
  isSelected() {
    return !this.selectedRange.isEmpty();
  }
  /**
   * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`
   * argument is passed then only that layer will be checked. Otherwise, it checks if any row header
   * was clicked on any selection layer level.
   *
   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
   * @returns {boolean}
   */
  isSelectedByRowHeader() {
    let layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
    return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);
  }
  /**
   * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`
   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.
   *
   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
   * @returns {boolean}
   */
  isEntireRowSelected() {
    let layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
    return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);
  }
  /**
   * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`
   * argument is passed then only that layer will be checked. Otherwise, it checks if any column header
   * was clicked on any selection layer level.
   *
   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
   * @returns {boolean}
   */
  isSelectedByColumnHeader() {
    let layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
    return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);
  }
  /**
   * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`
   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.
   *
   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
   * @returns {boolean}
   */
  isEntireColumnSelected() {
    let layerLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getLayerLevel();
    return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);
  }
  /**
   * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.
   *
   * @returns {boolean}
   */
  isSelectedByAnyHeader() {
    return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();
  }
  /**
   * Returns `true` if the selection was applied by clicking on the left-top corner overlay.
   *
   * @returns {boolean}
   */
  isSelectedByCorner() {
    return this.selectedByCorner;
  }
  /**
   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if
   * the coords object is within selection range.
   *
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {boolean}
   */
  inInSelection(coords) {
    return this.selectedRange.includes(coords);
  }
  /**
   * Returns `true` if the cell corner should be visible.
   *
   * @private
   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.
   */
  isCellCornerVisible() {
    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();
  }
  /**
   * Returns `true` if the area corner should be visible.
   *
   * @param {number} layerLevel The layer level.
   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.
   */
  isAreaCornerVisible(layerLevel) {
    if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {
      return false;
    }
    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();
  }
  /**
   * Clear the selection by resetting the collected ranges and highlights.
   */
  clear() {
    this.selectedRange.clear();
    this.highlight.clear();
  }
  /**
   * Deselects all selected cells.
   */
  deselect() {
    if (!this.isSelected()) {
      return;
    }
    this.inProgress = false;
    this.clear();
    this.runLocalHooks("afterDeselect");
  }
  /**
   * Select all cells.
   *
   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`
   * otherwise.
   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`
   * otherwise.
   */
  selectAll() {
    let includeRowHeaders = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const nrOfRows = this.tableProps.countRows();
    const nrOfColumns = this.tableProps.countCols();
    if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {
      return;
    }
    const startCoords = this.tableProps.createCellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);
    const endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);
    this.clear();
    this.setRangeStartOnly(startCoords);
    this.selectedByRowHeader.add(this.getLayerLevel());
    this.selectedByColumnHeader.add(this.getLayerLevel());
    this.setRangeEnd(endCoords);
    this.finish();
  }
  /**
   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells
   * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such
   * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.
   * If the passed ranges have another format the exception will be thrown.
   *
   * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.
   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.
   */
  selectCells(selectionRanges) {
    const selectionType = detectSelectionType(selectionRanges);
    if (selectionType === SELECTION_TYPE_EMPTY) {
      return false;
    } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {
      throw new Error(toSingleLine`Unsupported format of the selection ranges was passed. To select cells pass\x20
        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\x20
        columnEnd/columnPropEnd]]) or as an array of CellRange objects.`);
    }
    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {
      propToCol: (prop) => this.tableProps.propToCol(prop),
      keepDirection: true
    });
    const nrOfRows = this.tableProps.countRows();
    const nrOfColumns = this.tableProps.countCols();
    const isValid2 = !selectionRanges.some((selection) => {
      const [rowStart, columnStart, rowEnd, columnEnd] = selectionSchemaNormalizer(selection);
      const _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);
      return !_isValid;
    });
    if (isValid2) {
      this.clear();
      arrayEach(selectionRanges, (selection) => {
        const [rowStart, columnStart, rowEnd, columnEnd] = selectionSchemaNormalizer(selection);
        this.setRangeStartOnly(this.tableProps.createCellCoords(rowStart, columnStart), false);
        this.setRangeEnd(this.tableProps.createCellCoords(rowEnd, columnEnd));
        this.finish();
      });
    }
    return isValid2;
  }
  /**
   * Select column specified by `startColumn` visual index or column property or a range of columns finishing at
   * `endColumn`.
   *
   * @param {number|string} startColumn Visual column index or column property from which the selection starts.
   * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.
   * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can
   *                                  take -1 to -N, where -1 means the header closest to the cells.
   *
   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.
   */
  selectColumns(startColumn) {
    let endColumn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startColumn;
    let headerLevel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    const start = typeof startColumn === "string" ? this.tableProps.propToCol(startColumn) : startColumn;
    const end = typeof endColumn === "string" ? this.tableProps.propToCol(endColumn) : endColumn;
    const nrOfColumns = this.tableProps.countCols();
    const nrOfRows = this.tableProps.countRows();
    const isValid2 = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);
    if (isValid2) {
      this.setRangeStartOnly(this.tableProps.createCellCoords(headerLevel, start));
      this.setRangeEnd(this.tableProps.createCellCoords(nrOfRows - 1, end));
      this.finish();
    }
    return isValid2;
  }
  /**
   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.
   *
   * @param {number} startRow Visual row index from which the selection starts.
   * @param {number} [endRow] Visual row index from to the selection finishes.
   * @param {number} [headerLevel=-1] A column header index that triggers the row selection.
   *                                  The value can take -1 to -N, where -1 means the header
   *                                  closest to the cells.
   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.
   */
  selectRows(startRow) {
    let endRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startRow;
    let headerLevel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    const nrOfRows = this.tableProps.countRows();
    const nrOfColumns = this.tableProps.countCols();
    const isValid2 = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);
    if (isValid2) {
      this.setRangeStartOnly(this.tableProps.createCellCoords(startRow, headerLevel));
      this.setRangeEnd(this.tableProps.createCellCoords(endRow, nrOfColumns - 1));
      this.finish();
    }
    return isValid2;
  }
  /**
   * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.
   */
  refresh() {
    const customSelections = this.highlight.getCustomSelections();
    customSelections.forEach((customSelection) => {
      customSelection.commit();
    });
    if (!this.isSelected()) {
      return;
    }
    const cellHighlight = this.highlight.getCell();
    const currentLayer = this.getLayerLevel();
    cellHighlight.commit().syncWith(this.selectedRange.current());
    for (let layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {
      this.highlight.useLayerLevel(layerLevel);
      const areaHighlight = this.highlight.createOrGetArea();
      const headerHighlight = this.highlight.createOrGetHeader();
      const activeHeaderHighlight = this.highlight.createOrGetActiveHeader();
      areaHighlight.commit();
      headerHighlight.commit();
      activeHeaderHighlight.commit();
    }
    this.highlight.useLayerLevel(currentLayer);
  }
};
mixin(Selection2, localHooks_default);
var selection_default2 = Selection2;

// node_modules/handsontable/3rdparty/SheetClip/SheetClip.mjs
var regUniversalNewLine = /^(\r\n|\n\r|\r|\n)/;
var regNextCellNoQuotes = /^[^\t\r\n]+/;
var regNextEmptyCell = /^\t/;
function parse(str) {
  const arr = [[""]];
  if (str.length === 0) {
    return arr;
  }
  let column = 0;
  let row = 0;
  let lastLength;
  while (str.length > 0) {
    if (lastLength === str.length) {
      break;
    }
    lastLength = str.length;
    if (str.match(regNextEmptyCell)) {
      str = str.replace(regNextEmptyCell, "");
      column += 1;
      arr[row][column] = "";
    } else if (str.match(regUniversalNewLine)) {
      str = str.replace(regUniversalNewLine, "");
      column = 0;
      row += 1;
      arr[row] = [""];
    } else {
      let nextCell = "";
      if (str.startsWith('"')) {
        let quoteNo = 0;
        let isStillCell = true;
        while (isStillCell) {
          const nextChar = str.slice(0, 1);
          if (nextChar === '"') {
            quoteNo += 1;
          }
          nextCell += nextChar;
          str = str.slice(1);
          if (str.length === 0 || str.match(/^[\t\r\n]/) && quoteNo % 2 === 0) {
            isStillCell = false;
          }
        }
        nextCell = nextCell.replace(/^"/, "").replace(/"$/, "").replace(/["]*/g, (match) => new Array(Math.floor(match.length / 2)).fill('"').join(""));
      } else {
        const matchedText = str.match(regNextCellNoQuotes);
        nextCell = matchedText ? matchedText[0] : "";
        str = str.slice(nextCell.length);
      }
      arr[row][column] = nextCell;
    }
  }
  return arr;
}
function stringify2(arr) {
  let r;
  let rLen;
  let c;
  let cLen;
  let str = "";
  let val;
  for (r = 0, rLen = arr.length; r < rLen; r += 1) {
    cLen = arr[r].length;
    for (c = 0; c < cLen; c += 1) {
      if (c > 0) {
        str += "	";
      }
      val = arr[r][c];
      if (typeof val === "string") {
        if (val.indexOf("\n") > -1) {
          str += `"${val.replace(/"/g, '""')}"`;
        } else {
          str += val;
        }
      } else if (val === null || val === void 0) {
        str += "";
      } else {
        str += val;
      }
    }
    if (r !== rLen - 1) {
      str += "\n";
    }
  }
  return str;
}

// node_modules/handsontable/dataMap/dataMap.mjs
var DataMap = class _DataMap {
  /**
   * @type {number}
   */
  static get DESTINATION_RENDERER() {
    return 1;
  }
  /**
   * @type {number}
   */
  static get DESTINATION_CLIPBOARD_GENERATOR() {
    return 2;
  }
  /**
   * @param {object} instance Instance of Handsontable.
   * @param {Array} data Array of arrays or array of objects containing data.
   * @param {MetaManager} metaManager The meta manager instance.
   */
  constructor(instance, data, metaManager) {
    this.instance = instance;
    this.metaManager = metaManager;
    this.tableMeta = metaManager.getTableMeta();
    this.dataSource = data;
    this.duckSchema = this.createDuckSchema();
    this.colToPropCache = void 0;
    this.propToColCache = void 0;
    this.createMap();
  }
  /**
   * Generates cache for property to and from column addressation.
   */
  createMap() {
    const schema = this.getSchema();
    if (typeof schema === "undefined") {
      throw new Error("trying to create `columns` definition but you didn't provide `schema` nor `data`");
    }
    const columns = this.tableMeta.columns;
    let i;
    this.colToPropCache = [];
    this.propToColCache = /* @__PURE__ */ new Map();
    if (columns) {
      let columnsLen = 0;
      let filteredIndex = 0;
      let columnsAsFunc = false;
      if (typeof columns === "function") {
        const schemaLen = deepObjectSize(schema);
        columnsLen = schemaLen > 0 ? schemaLen : this.countFirstRowKeys();
        columnsAsFunc = true;
      } else {
        const maxCols = this.tableMeta.maxCols;
        columnsLen = Math.min(maxCols, columns.length);
      }
      for (i = 0; i < columnsLen; i++) {
        const column = columnsAsFunc ? columns(i) : columns[i];
        if (isObject2(column)) {
          if (typeof column.data !== "undefined") {
            const index2 = columnsAsFunc ? filteredIndex : i;
            this.colToPropCache[index2] = column.data;
            this.propToColCache.set(column.data, index2);
          }
          filteredIndex += 1;
        }
      }
    } else {
      this.recursiveDuckColumns(schema);
    }
  }
  /**
   * Get the amount of physical columns in the first data row.
   *
   * @returns {number} Amount of physical columns in the first data row.
   */
  countFirstRowKeys() {
    return countFirstRowKeys(this.dataSource);
  }
  /**
   * Generates columns' translation cache.
   *
   * @param {object} schema An object to generate schema from.
   * @param {number} lastCol The column index.
   * @param {number} parent The property cache for recursive calls.
   * @returns {number}
   */
  recursiveDuckColumns(schema, lastCol, parent) {
    let lastColumn = lastCol;
    let propertyParent = parent;
    let prop;
    if (typeof lastColumn === "undefined") {
      lastColumn = 0;
      propertyParent = "";
    }
    if (typeof schema === "object" && !Array.isArray(schema)) {
      objectEach(schema, (value, key) => {
        if (value === null) {
          prop = propertyParent + key;
          this.colToPropCache.push(prop);
          this.propToColCache.set(prop, lastColumn);
          lastColumn += 1;
        } else {
          lastColumn = this.recursiveDuckColumns(value, lastColumn, `${key}.`);
        }
      });
    }
    return lastColumn;
  }
  /**
   * Returns property name that corresponds with the given column index.
   *
   * @param {string|number} column Visual column index or another passed argument.
   * @returns {string|number} Column property, physical column index or passed argument.
   */
  colToProp(column) {
    if (Number.isInteger(column) === false) {
      return column;
    }
    const physicalColumn = this.instance.toPhysicalColumn(column);
    if (physicalColumn === null) {
      return column;
    }
    if (this.colToPropCache && isDefined(this.colToPropCache[physicalColumn])) {
      return this.colToPropCache[physicalColumn];
    }
    return physicalColumn;
  }
  /**
   * Translates property into visual column index.
   *
   * @param {string|number} prop Column property which may be also a physical column index.
   * @returns {string|number} Visual column index or passed argument.
   */
  propToCol(prop) {
    const cachedPhysicalIndex = this.propToColCache.get(prop);
    if (isDefined(cachedPhysicalIndex)) {
      return this.instance.toVisualColumn(cachedPhysicalIndex);
    }
    const visualColumn = this.instance.toVisualColumn(prop);
    if (visualColumn === null) {
      return prop;
    }
    return visualColumn;
  }
  /**
   * Returns data's schema.
   *
   * @returns {object}
   */
  getSchema() {
    const schema = this.tableMeta.dataSchema;
    if (schema) {
      if (typeof schema === "function") {
        return schema();
      }
      return schema;
    }
    return this.duckSchema;
  }
  /**
   * Creates the duck schema based on the current dataset.
   *
   * @returns {Array|object}
   */
  createDuckSchema() {
    return this.dataSource && this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};
  }
  /**
   * Refresh the data schema.
   */
  refreshDuckSchema() {
    this.duckSchema = this.createDuckSchema();
  }
  /**
   * Creates row at the bottom of the data array.
   *
   * @param {number} [index] Physical index of the row before which the new row will be inserted.
   * @param {number} [amount=1] An amount of rows to add.
   * @param {object} [options] Additional options for created rows.
   * @param {string} [options.source] Source of method call.
   * @param {'above'|'below'} [options.mode] Sets where the row is inserted: above or below the passed index.
   * @fires Hooks#afterCreateRow
   * @returns {number} Returns number of created rows.
   */
  createRow(index2) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let {
      source,
      mode = "above"
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const sourceRowsCount = this.instance.countSourceRows();
    let physicalRowIndex = sourceRowsCount;
    let numberOfCreatedRows = 0;
    let rowIndex = index2;
    if (typeof rowIndex !== "number" || rowIndex >= sourceRowsCount) {
      rowIndex = sourceRowsCount;
    }
    if (rowIndex < this.instance.countRows()) {
      physicalRowIndex = this.instance.toPhysicalRow(rowIndex);
    }
    const continueProcess = this.instance.runHooks("beforeCreateRow", rowIndex, amount, source);
    if (continueProcess === false || physicalRowIndex === null) {
      return {
        delta: 0
      };
    }
    const maxRows = this.tableMeta.maxRows;
    const columnCount = this.getSchema().length;
    const rowsToAdd = [];
    while (numberOfCreatedRows < amount && sourceRowsCount + numberOfCreatedRows < maxRows) {
      let row = null;
      if (this.instance.dataType === "array") {
        if (this.tableMeta.dataSchema) {
          row = deepClone(this.getSchema());
        } else {
          row = [];
          rangeEach(columnCount - 1, () => row.push(null));
        }
      } else if (this.instance.dataType === "function") {
        row = this.tableMeta.dataSchema(rowIndex + numberOfCreatedRows);
      } else {
        row = {};
        deepExtend(row, this.getSchema());
      }
      rowsToAdd.push(row);
      numberOfCreatedRows += 1;
    }
    this.instance.rowIndexMapper.insertIndexes(rowIndex, numberOfCreatedRows);
    if (mode === "below") {
      physicalRowIndex = Math.min(physicalRowIndex + 1, sourceRowsCount);
    }
    this.spliceData(physicalRowIndex, 0, rowsToAdd);
    const newVisualRowIndex = this.instance.toVisualRow(physicalRowIndex);
    if (this.instance.countSourceRows() === rowsToAdd.length) {
      this.instance.columnIndexMapper.initToLength(this.instance.getInitialColumnCount());
    }
    if (numberOfCreatedRows > 0) {
      if (index2 === void 0 || index2 === null) {
        this.metaManager.createRow(null, numberOfCreatedRows);
      } else if (source !== "auto") {
        this.metaManager.createRow(physicalRowIndex, amount);
      }
    }
    this.instance.runHooks("afterCreateRow", newVisualRowIndex, numberOfCreatedRows, source);
    this.instance.forceFullRender = true;
    return {
      delta: numberOfCreatedRows,
      startPhysicalIndex: physicalRowIndex
    };
  }
  /**
   * Creates column at the right of the data array.
   *
   * @param {number} [index] Visual index of the column before which the new column will be inserted.
   * @param {number} [amount=1] An amount of columns to add.
   * @param {object} [options] Additional options for created columns.
   * @param {string} [options.source] Source of method call.
   * @param {'start'|'end'} [options.mode] Sets where the column is inserted: at the start (left in [LTR](@/api/options.md#layoutdirection), right in [RTL](@/api/options.md#layoutdirection)) or at the end (right in LTR, left in LTR)
   * the passed index.
   * @fires Hooks#afterCreateCol
   * @returns {number} Returns number of created columns.
   */
  createCol(index2) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let {
      source,
      mode = "start"
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!this.instance.isColumnModificationAllowed()) {
      throw new Error("Cannot create new column. When data source in an object, you can only have as much columns as defined in first data row, data schema or in the 'columns' setting.If you want to be able to add new columns, you have to use array datasource.");
    }
    const dataSource = this.dataSource;
    const maxCols = this.tableMeta.maxCols;
    const countSourceCols = this.instance.countSourceCols();
    let columnIndex = index2;
    if (typeof columnIndex !== "number" || columnIndex >= countSourceCols) {
      columnIndex = countSourceCols;
    }
    const continueProcess = this.instance.runHooks("beforeCreateCol", columnIndex, amount, source);
    if (continueProcess === false) {
      return {
        delta: 0
      };
    }
    let physicalColumnIndex = countSourceCols;
    if (columnIndex < this.instance.countCols()) {
      physicalColumnIndex = this.instance.toPhysicalColumn(columnIndex);
    }
    const numberOfSourceRows = this.instance.countSourceRows();
    let nrOfColumns = this.instance.countCols();
    let numberOfCreatedCols = 0;
    let currentIndex = physicalColumnIndex;
    if (mode === "end") {
      currentIndex = Math.min(currentIndex + 1, countSourceCols);
    }
    const startPhysicalIndex = currentIndex;
    while (numberOfCreatedCols < amount && nrOfColumns < maxCols) {
      if (typeof columnIndex !== "number" || columnIndex >= nrOfColumns) {
        if (numberOfSourceRows > 0) {
          for (let row = 0; row < numberOfSourceRows; row += 1) {
            if (typeof dataSource[row] === "undefined") {
              dataSource[row] = [];
            }
            dataSource[row].push(null);
          }
        } else {
          dataSource.push([null]);
        }
      } else {
        for (let row = 0; row < numberOfSourceRows; row++) {
          dataSource[row].splice(currentIndex, 0, null);
        }
      }
      numberOfCreatedCols += 1;
      currentIndex += 1;
      nrOfColumns += 1;
    }
    this.instance.columnIndexMapper.insertIndexes(columnIndex, numberOfCreatedCols);
    if (numberOfCreatedCols > 0) {
      if (index2 === void 0 || index2 === null) {
        this.metaManager.createColumn(null, numberOfCreatedCols);
      } else if (source !== "auto") {
        this.metaManager.createColumn(startPhysicalIndex, amount);
      }
    }
    const newVisualColumnIndex = this.instance.toVisualColumn(startPhysicalIndex);
    this.instance.runHooks("afterCreateCol", newVisualColumnIndex, numberOfCreatedCols, source);
    this.instance.forceFullRender = true;
    this.refreshDuckSchema();
    return {
      delta: numberOfCreatedCols,
      startPhysicalIndex
    };
  }
  /**
   * Removes row from the data array.
   *
   * @fires Hooks#beforeRemoveRow
   * @fires Hooks#afterRemoveRow
   * @param {number} [index] Visual index of the row to be removed. If not provided, the last row will be removed.
   * @param {number} [amount=1] Amount of the rows to be removed. If not provided, one row will be removed.
   * @param {string} [source] Source of method call.
   * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.
   */
  removeRow(index2) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let source = arguments.length > 2 ? arguments[2] : void 0;
    let rowIndex = Number.isInteger(index2) ? index2 : -amount;
    const removedPhysicalIndexes = this.visualRowsToPhysical(rowIndex, amount);
    const sourceRowsLength = this.instance.countSourceRows();
    rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength;
    const actionWasNotCancelled = this.instance.runHooks("beforeRemoveRow", rowIndex, removedPhysicalIndexes.length, removedPhysicalIndexes, source);
    if (actionWasNotCancelled === false) {
      return false;
    }
    const numberOfRemovedIndexes = removedPhysicalIndexes.length;
    this.filterData(rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes);
    if (rowIndex < this.instance.countRows()) {
      this.instance.rowIndexMapper.removeIndexes(removedPhysicalIndexes);
      const customDefinedColumns = isDefined(this.tableMeta.columns) || isDefined(this.tableMeta.dataSchema);
      if (this.instance.rowIndexMapper.getNotTrimmedIndexesLength() === 0 && customDefinedColumns === false) {
        this.instance.columnIndexMapper.setIndexesSequence([]);
      }
    }
    const descendingPhysicalRows = removedPhysicalIndexes.slice(0).sort((a, b) => b - a);
    descendingPhysicalRows.forEach((rowPhysicalIndex) => {
      this.metaManager.removeRow(rowPhysicalIndex, 1);
    });
    this.instance.runHooks("afterRemoveRow", rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes, source);
    this.instance.forceFullRender = true;
    return true;
  }
  /**
   * Removes column from the data array.
   *
   * @fires Hooks#beforeRemoveCol
   * @fires Hooks#afterRemoveCol
   * @param {number} [index] Visual index of the column to be removed. If not provided, the last column will be removed.
   * @param {number} [amount=1] Amount of the columns to be removed. If not provided, one column will be removed.
   * @param {string} [source] Source of method call.
   * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.
   */
  removeCol(index2) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let source = arguments.length > 2 ? arguments[2] : void 0;
    if (this.instance.dataType === "object" || this.tableMeta.columns) {
      throw new Error("cannot remove column with object data source or columns option specified");
    }
    let columnIndex = typeof index2 !== "number" ? -amount : index2;
    columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();
    const removedPhysicalIndexes = this.visualColumnsToPhysical(columnIndex, amount);
    const descendingPhysicalColumns = removedPhysicalIndexes.slice(0).sort((a, b) => b - a);
    const actionWasNotCancelled = this.instance.runHooks("beforeRemoveCol", columnIndex, amount, removedPhysicalIndexes, source);
    if (actionWasNotCancelled === false) {
      return false;
    }
    let isTableUniform = true;
    const removedColumnsCount = descendingPhysicalColumns.length;
    const data = this.dataSource;
    for (let c = 0; c < removedColumnsCount; c++) {
      if (isTableUniform && removedPhysicalIndexes[0] !== removedPhysicalIndexes[c] - c) {
        isTableUniform = false;
      }
    }
    if (isTableUniform) {
      for (let r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {
        data[r].splice(removedPhysicalIndexes[0], amount);
        if (r === 0) {
          this.metaManager.removeColumn(removedPhysicalIndexes[0], amount);
        }
      }
    } else {
      for (let r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {
        for (let c = 0; c < removedColumnsCount; c++) {
          data[r].splice(descendingPhysicalColumns[c], 1);
          if (r === 0) {
            this.metaManager.removeColumn(descendingPhysicalColumns[c], 1);
          }
        }
      }
    }
    if (columnIndex < this.instance.countCols()) {
      this.instance.columnIndexMapper.removeIndexes(removedPhysicalIndexes);
      if (this.instance.columnIndexMapper.getNotTrimmedIndexesLength() === 0) {
        this.instance.rowIndexMapper.setIndexesSequence([]);
      }
    }
    this.instance.runHooks("afterRemoveCol", columnIndex, amount, removedPhysicalIndexes, source);
    this.instance.forceFullRender = true;
    this.refreshDuckSchema();
    return true;
  }
  /**
   * Add/Removes data from the column.
   *
   * @param {number} col Physical index of column in which do you want to do splice.
   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.
   * @param {Array} [elements] The new columns to add.
   * @returns {Array} Returns removed portion of columns.
   */
  spliceCol(col, index2, amount) {
    const colData = this.instance.getDataAtCol(col);
    const removed = colData.slice(index2, index2 + amount);
    const after = colData.slice(index2 + amount);
    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      elements[_key - 3] = arguments[_key];
    }
    extendArray(elements, after);
    let i = 0;
    while (i < amount) {
      elements.push(null);
      i += 1;
    }
    to2dArray(elements);
    this.instance.populateFromArray(index2, col, elements, null, null, "spliceCol");
    return removed;
  }
  /**
   * Add/Removes data from the row.
   *
   * @param {number} row Physical index of row in which do you want to do splice.
   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.
   * @param {Array} [elements] The new rows to add.
   * @returns {Array} Returns removed portion of rows.
   */
  spliceRow(row, index2, amount) {
    const rowData = this.instance.getSourceDataAtRow(row);
    const removed = rowData.slice(index2, index2 + amount);
    const after = rowData.slice(index2 + amount);
    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      elements[_key2 - 3] = arguments[_key2];
    }
    extendArray(elements, after);
    let i = 0;
    while (i < amount) {
      elements.push(null);
      i += 1;
    }
    this.instance.populateFromArray(row, index2, [elements], null, null, "spliceRow");
    return removed;
  }
  /**
   * Add/remove row(s) to/from the data source.
   *
   * @param {number} index Physical index of the element to add/remove.
   * @param {number} deleteCount Number of rows to remove.
   * @param {Array<object>} elements Row elements to be added.
   */
  spliceData(index2, deleteCount, elements) {
    const continueSplicing = this.instance.runHooks("beforeDataSplice", index2, deleteCount, elements);
    if (continueSplicing !== false) {
      const newData = [...this.dataSource.slice(0, index2), ...elements, ...this.dataSource.slice(index2)];
      this.dataSource.length = 0;
      newData.forEach((row) => this.dataSource.push(row));
    }
  }
  /**
   * Filter unwanted data elements from the data source.
   *
   * @param {number} index Visual index of the element to remove.
   * @param {number} amount Number of rows to add/remove.
   * @param {number} physicalRows Physical row indexes.
   */
  filterData(index2, amount, physicalRows) {
    let data = this.instance.runHooks("filterData", index2, amount, physicalRows);
    if (Array.isArray(data) === false) {
      data = this.dataSource.filter((row, rowIndex) => physicalRows.indexOf(rowIndex) === -1);
    }
    this.dataSource.length = 0;
    Array.prototype.push.apply(this.dataSource, data);
  }
  /**
   * Returns single value from the data array.
   *
   * @param {number} row Visual row index.
   * @param {number} prop The column property.
   * @returns {*}
   */
  get(row, prop) {
    const physicalRow = this.instance.toPhysicalRow(row);
    let dataRow = this.dataSource[physicalRow];
    const modifiedRowData = this.instance.runHooks("modifyRowData", physicalRow);
    dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
    let value = null;
    if (dataRow && dataRow.hasOwnProperty && hasOwnProperty2(dataRow, prop)) {
      value = dataRow[prop];
    } else if (typeof prop === "string" && prop.indexOf(".") > -1) {
      const sliced = prop.split(".");
      let out = dataRow;
      if (!out) {
        return null;
      }
      for (let i = 0, ilen = sliced.length; i < ilen; i++) {
        out = out[sliced[i]];
        if (typeof out === "undefined") {
          return null;
        }
      }
      value = out;
    } else if (typeof prop === "function") {
      value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);
    }
    if (this.instance.hasHook("modifyData")) {
      const valueHolder = createObjectPropListener(value);
      this.instance.runHooks("modifyData", physicalRow, this.propToCol(prop), valueHolder, "get");
      if (valueHolder.isTouched()) {
        value = valueHolder.value;
      }
    }
    return value;
  }
  /**
   * Returns single value from the data array (intended for clipboard copy to an external application).
   *
   * @param {number} row Physical row index.
   * @param {number} prop The column property.
   * @returns {string}
   */
  getCopyable(row, prop) {
    if (this.instance.getCellMeta(row, this.propToCol(prop)).copyable) {
      return this.get(row, prop);
    }
    return "";
  }
  /**
   * Saves single value to the data array.
   *
   * @param {number} row Visual row index.
   * @param {number} prop The column property.
   * @param {string} value The value to set.
   */
  set(row, prop, value) {
    const physicalRow = this.instance.toPhysicalRow(row);
    let newValue = value;
    let dataRow = this.dataSource[physicalRow];
    const modifiedRowData = this.instance.runHooks("modifyRowData", physicalRow);
    dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
    if (this.instance.hasHook("modifyData")) {
      const valueHolder = createObjectPropListener(newValue);
      this.instance.runHooks("modifyData", physicalRow, this.propToCol(prop), valueHolder, "set");
      if (valueHolder.isTouched()) {
        newValue = valueHolder.value;
      }
    }
    if (dataRow && dataRow.hasOwnProperty && hasOwnProperty2(dataRow, prop)) {
      dataRow[prop] = newValue;
    } else if (typeof prop === "string" && prop.indexOf(".") > -1) {
      const sliced = prop.split(".");
      let out = dataRow;
      let i = 0;
      let ilen;
      for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {
        if (typeof out[sliced[i]] === "undefined") {
          out[sliced[i]] = {};
        }
        out = out[sliced[i]];
      }
      out[sliced[i]] = newValue;
    } else if (typeof prop === "function") {
      prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);
    } else {
      dataRow[prop] = newValue;
    }
  }
  /**
   * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.
   * The trick is, the physical row id (stored in settings.data) is not necessary the same
   * as the visual (displayed) row id (e.g. When sorting is applied).
   *
   * @param {number} index Visual row index.
   * @param {number} amount An amount of rows to translate.
   * @returns {number}
   */
  visualRowsToPhysical(index2, amount) {
    const totalRows = this.instance.countSourceRows();
    const logicRows = [];
    let physicRow = (totalRows + index2) % totalRows;
    let rowsToRemove = amount;
    let row;
    while (physicRow < totalRows && rowsToRemove) {
      row = this.instance.toPhysicalRow(physicRow);
      logicRows.push(row);
      rowsToRemove -= 1;
      physicRow += 1;
    }
    return logicRows;
  }
  /**
   *
   * @param {number} index Visual column index.
   * @param {number} amount An amount of rows to translate.
   * @returns {Array}
   */
  visualColumnsToPhysical(index2, amount) {
    const totalCols = this.instance.countCols();
    const visualCols = [];
    let physicalCol = (totalCols + index2) % totalCols;
    let colsToRemove = amount;
    while (physicalCol < totalCols && colsToRemove) {
      const col = this.instance.toPhysicalColumn(physicalCol);
      visualCols.push(col);
      colsToRemove -= 1;
      physicalCol += 1;
    }
    return visualCols;
  }
  /**
   * Clears the data array.
   */
  clear() {
    for (let r = 0; r < this.instance.countSourceRows(); r++) {
      for (let c = 0; c < this.instance.countCols(); c++) {
        this.set(r, this.colToProp(c), "");
      }
    }
  }
  /**
   * Get data length.
   *
   * @returns {number}
   */
  getLength() {
    const maxRowsFromSettings = this.tableMeta.maxRows;
    let maxRows;
    if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {
      maxRows = 0;
    } else {
      maxRows = maxRowsFromSettings || Infinity;
    }
    const length = this.instance.rowIndexMapper.getNotTrimmedIndexesLength();
    return Math.min(length, maxRows);
  }
  /**
   * Returns the data array.
   *
   * @returns {Array}
   */
  getAll() {
    const start = {
      row: 0,
      col: 0
    };
    const end = {
      row: Math.max(this.instance.countRows() - 1, 0),
      col: Math.max(this.instance.countCols() - 1, 0)
    };
    if (start.row - end.row === 0 && !this.instance.countSourceRows()) {
      return [];
    }
    return this.getRange(start, end, _DataMap.DESTINATION_RENDERER);
  }
  /**
   * Count the number of columns cached in the `colToProp` cache.
   *
   * @returns {number} Amount of cached columns.
   */
  countCachedColumns() {
    return this.colToPropCache.length;
  }
  /**
   * Returns data range as array.
   *
   * @param {object} [start] Start selection position. Visual indexes.
   * @param {object} [end] End selection position. Visual indexes.
   * @param {number} destination Destination of datamap.get.
   * @returns {Array}
   */
  getRange(start, end, destination) {
    const output = [];
    let r;
    let c;
    let row;
    const maxRows = this.tableMeta.maxRows;
    const maxCols = this.tableMeta.maxCols;
    if (maxRows === 0 || maxCols === 0) {
      return [];
    }
    const getFn = destination === _DataMap.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;
    const rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));
    const clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));
    for (r = Math.min(start.row, end.row); r <= rlen; r++) {
      row = [];
      const physicalRow = r >= 0 ? this.instance.toPhysicalRow(r) : r;
      for (c = Math.min(start.col, end.col); c <= clen; c++) {
        if (physicalRow === null) {
          break;
        }
        row.push(getFn.call(this, r, this.colToProp(c)));
      }
      if (physicalRow !== null) {
        output.push(row);
      }
    }
    return output;
  }
  /**
   * Return data as text (tab separated columns).
   *
   * @param {object} [start] Start selection position. Visual indexes.
   * @param {object} [end] End selection position. Visual indexes.
   * @returns {string}
   */
  getText(start, end) {
    return stringify2(this.getRange(start, end, _DataMap.DESTINATION_RENDERER));
  }
  /**
   * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).
   *
   * @param {object} [start] Start selection position. Visual indexes.
   * @param {object} [end] End selection position. Visual indexes.
   * @returns {string}
   */
  getCopyableText(start, end) {
    return stringify2(this.getRange(start, end, _DataMap.DESTINATION_CLIPBOARD_GENERATOR));
  }
  /**
   * Destroy instance.
   */
  destroy() {
    this.instance = null;
    this.metaManager = null;
    this.dataSource = null;
    this.duckSchema = null;
    this.colToPropCache.length = 0;
    this.propToColCache.clear();
    this.propToColCache = void 0;
  }
};
var dataMap_default = DataMap;

// node_modules/handsontable/cellTypes/registry.mjs
var {
  register: register6,
  getItem: getItem5,
  hasItem: hasItem4,
  getNames: getNames4,
  getValues: getValues4
} = staticRegister("cellTypes");
function _getItem4(name) {
  if (!hasItem4(name)) {
    throw Error(`You declared cell type "${name}" as a string that is not mapped to a known object.
                 Cell type must be an object or a string mapped to an object registered by
                 "Handsontable.cellTypes.registerCellType" method`);
  }
  return getItem5(name);
}
function _register4(name, type) {
  if (typeof name !== "string") {
    type = name;
    name = type.CELL_TYPE;
  }
  const {
    editor,
    renderer,
    validator
  } = type;
  if (editor) {
    _register(name, editor);
  }
  if (renderer) {
    _register2(name, renderer);
  }
  if (validator) {
    _register3(name, validator);
  }
  register6(name, type);
}

// node_modules/handsontable/dataMap/metaManager/utils.mjs
function canBeOverwritten(propertyName, metaObject) {
  var _metaObject$_automati;
  if (propertyName === "CELL_TYPE") {
    return false;
  }
  return ((_metaObject$_automati = metaObject._automaticallyAssignedMetaProps) === null || _metaObject$_automati === void 0 ? void 0 : _metaObject$_automati.has(propertyName)) || !hasOwnProperty2(metaObject, propertyName);
}
function extendByMetaType(metaObject, settings) {
  let settingsToCompareWith = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : metaObject;
  const validType = typeof settings.type === "string" ? _getItem4(settings.type) : settings.type;
  if (metaObject._automaticallyAssignedMetaProps) {
    objectEach(settings, (value, key) => void metaObject._automaticallyAssignedMetaProps.delete(key));
  }
  if (!isObject2(validType)) {
    return;
  }
  if (settingsToCompareWith === metaObject && !metaObject._automaticallyAssignedMetaProps) {
    metaObject._automaticallyAssignedMetaProps = /* @__PURE__ */ new Set();
  }
  const expandedType = {};
  objectEach(validType, (value, property) => {
    if (canBeOverwritten(property, settingsToCompareWith)) {
      var _metaObject$_automati2;
      expandedType[property] = value;
      (_metaObject$_automati2 = metaObject._automaticallyAssignedMetaProps) === null || _metaObject$_automati2 === void 0 || _metaObject$_automati2.add(property);
    }
  });
  extend2(metaObject, expandedType);
}
function columnFactory(TableMeta2) {
  let conflictList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  function ColumnMeta2() {
  }
  inherit(ColumnMeta2, TableMeta2);
  for (let i = 0; i < conflictList.length; i++) {
    ColumnMeta2.prototype[conflictList[i]] = void 0;
  }
  return ColumnMeta2;
}
function isUnsignedNumber(value) {
  return Number.isInteger(value) && value >= 0;
}
function assert(condition24, errorMessage) {
  if (!condition24()) {
    throw new Error(`Assertion failed: ${errorMessage}`);
  }
}
function isNullish(variable) {
  return variable === null || variable === void 0;
}

// node_modules/handsontable/dataMap/metaManager/metaSchema.mjs
var metaSchema_default = () => {
  return {
    /* eslint-disable jsdoc/require-description-complete-sentence */
    /**
     * Information on which of the meta properties were added automatically.
     * For example: setting the `renderer` property directly won't extend the `_automaticallyAssignedMetaProps`
     * entry, but setting a `type` will modify it to `Set(3) {'renderer', 'editor', 'validator', ...}`.
     *
     * @private
     * @type {Set}
     * @default undefined
     */
    _automaticallyAssignedMetaProps: void 0,
    /**
     * The `activeHeaderClassName` option lets you add a CSS class name
     * to every currently-active, currently-selected header (when a whole column or row is selected).
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @since 0.38.2
     * @default 'ht__active_highlight'
     * @category Core
     *
     * @example
     * ```js
     * // add an `ht__active_highlight` CSS class name
     * // to every currently-active, currently-selected header
     * activeHeaderClassName: 'ht__active_highlight',
     * ```
     */
    activeHeaderClassName: "ht__active_highlight",
    /**
     * The `allowEmpty` option determines whether Handsontable accepts the following values:
     * - `null`
     * - `undefined`
     * - `''`
     *
     * You can set the `allowEmpty` option to one of the following:
     *
     * | Setting          | Description                                                                                                                          |
     * | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
     * | `true` (default) | - Accept `null`, `undefined` and `''` values<br>- Mark cells that contain `null`, `undefined` or `''` values as `valid`              |
     * | `false`          | - Don't accept `null`, `undefined` and `''` values<br>- Mark cells that contain `null`, `undefined` or `''` values with as `invalid` |
     *
     * ::: tip
     * To use the [`allowEmpty`](#allowempty) option, you need to set the [`validator`](#validator) option (or the [`type`](#type) option).
     * :::
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // allow empty values in each cell of the entire grid
     * allowEmpty: true,
     *
     * // or
     * columns: [
     *   {
     *     type: 'date',
     *     dateFormat: 'DD/MM/YYYY',
     *     // allow empty values in each cell of the 'date' column
     *     allowEmpty: true
     *   }
     * ],
     * ```
     */
    allowEmpty: true,
    /**
     * The `allowHtml` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type.md) cells' [`source`](#source) data
     * is treated as HTML.
     *
     * You can set the `allowHtml` option to one of the following:
     *
     * | Setting           | Description                                         |
     * | ----------------- | --------------------------------------------------- |
     * | `false` (default) | The [`source`](#source) data is not treated as HTML |
     * | `true`            | The [`source`](#source) data is treated as HTML     |
     *
     * __Warning:__ Setting the `allowHtml` option to `true` can cause serious XSS vulnerabilities.
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type.md)
     * - [`source`](#source)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['<strong>foo</strong>', '<strong>bar</strong>']
     *   // use HTML in the `source` list
     *   allowHtml: true,
     *   },
     * ],
     * ```
     */
    allowHtml: false,
    /**
     * If set to `true`, the `allowInsertColumn` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md):
     * - **Insert column left**
     * - **Insert column right**
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Insert column left' and 'Insert column right' menu items from the context menu
     * allowInsertColumn: false,
     * ```
     */
    allowInsertColumn: true,
    /**
     * If set to `true`, the `allowInsertRow` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md):
     * - **Insert row above**
     * - **Insert row below**
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Insert row above' and 'Insert row below' menu items from the context menu
     * allowInsertRow: false,
     * ```
     */
    allowInsertRow: true,
    /**
     * The `allowInvalid` option determines whether Handsontable accepts values
     * that were marked as `invalid` by the [cell validator](@/guides/cell-functions/cell-validator.md).
     *
     * You can set the `allowInvalid` option to one of the following:
     *
     * | Setting          | Description                                                                                                                                                                        |
     * | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | - Accept `invalid` values<br>- Allow the user to close the [cell editor](@/guides/cell-functions/cell-editor.md) with `invalid` values<br>- Save `invalid` values into the data source                   |
     * | `false`          | - Don't accept `invalid` values<br>- Don't allow the user to close the [cell editor](@/guides/cell-functions/cell-editor.md) with `invalid` values<br>- Don't save `invalid` values into the data source |
     *
     * Setting the `allowInvalid` option to `false` can be useful when used with the [Autocomplete strict mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-strict-mode).
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [Cell editor](@/guides/cell-functions/cell-editor.md)
     * - [Autocomplete strict mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-strict-mode)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // don't accept `invalid` values
     * // don't allow the user to close the cell editor
     * // don't save `invalid` values into the data source
     * allowInvalid: false,
     * ```
     */
    allowInvalid: true,
    /**
     * If set to `true`, the `allowRemoveColumn` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md):
     * - **Remove column**
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Remove column' menu item from the context menu
     * allowRemoveColumn: false,
     * ```
     */
    allowRemoveColumn: true,
    /**
     * If set to `true`, the `allowRemoveRow` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md):
     * - **Remove row**
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Remove row' menu item from the context menu
     * allowRemoveRow: false,
     * ```
     */
    allowRemoveRow: true,
    /**
     * The `autoColumnSize` option configures the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin.
     *
     * You can set the `autoColumnSize` option to one of the following:
     *
     * | Setting   | Description                                                                                  |
     * | --------- | -------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin                               |
     * | `true`    | Enable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin with the default configuration |
     * | An object | Enable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin and modify the plugin options  |
     *
     * If you set the `autoColumnSize` option to an object, you can set the following [`AutoColumnSize`](@/api/autoColumnSize.md) plugin options:
     *
     * | Property                | Possible values                 | Description                                                                                                    |
     * | ----------------------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------- |
     * | `syncLimit`             | A number \| A percentage string | The number/percentage of columns to keep in sync<br>(default: `50`)                                            |
     * | `useHeaders`            | `true` \| `false`               | When calculating column widths:<br>`true`: use column headers<br>`false`: don't use column headers          |
     * | `samplingRatio`         | A number                        | The number of samples of the same length to be used in column width calculations                               |
     * | `allowSampleDuplicates` | `true` \| `false`               | When calculating column widths:<br>`true`: Allow duplicate samples<br>`false`: Don't allow duplicate samples |
     *
     * By default, the `autoColumnSize` option is set to `undefined`,
     * but the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin acts as enabled.
     * To disable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin completely,
     * set the `autoColumnSize` option to `false`.
     *
     * Using the [`colWidths`](#colWidths) option forcibly disables the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin.
     *
     * Read more:
     * - [Plugins: `AutoColumnSize`](@/api/autoColumnSize.md)
     *
     * @memberof Options#
     * @type {object|boolean}
     * @default undefined
     * @category AutoColumnSize
     *
     * @example
     * ```js
     * autoColumnSize: {
     *   // keep 40% of columns in sync (the rest of columns: async)
     *   syncLimit: '40%',
     *   // when calculating column widths, use column headers
     *   useHeaders: true,
     *   // when calculating column widths, use 10 samples of the same length
     *   samplingRatio: 10,
     *   // when calculating column widths, allow duplicate samples
     *   allowSampleDuplicates: true
     * },
     * ```
     */
    autoColumnSize: void 0,
    /**
     * The `autoRowSize` option configures the [`AutoRowSize`](@/api/autoRowSize.md) plugin.
     *
     * You can set the `autoRowSize` option to one of the following:
     *
     * | Setting   | Description                                                                            |
     * | --------- | -------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`AutoRowSize`](@/api/autoRowSize.md) plugin                               |
     * | `true`    | Enable the [`AutoRowSize`](@/api/autoRowSize.md) plugin with the default configuration |
     * | An object | Enable the [`AutoRowSize`](@/api/autoRowSize.md) plugin and modify the plugin options  |
     *
     * To give Handsontable's [scrollbar](https://handsontable.com/docs/8.0.0/demo-scrolling.html)
     * a proper size, set the `autoRowSize` option to `true`.
     *
     * If you set the `autoRowSize` option to an object, you can set the following [`AutoRowSize`](@/api/autoRowSize.md) plugin options:
     *
     * | Property    | Possible values                 | Description                                                       |
     * | ----------- | ------------------------------- | ----------------------------------------------------------------- |
     * | `syncLimit` | A number \| A percentage string | The number/percentage of rows to keep in sync<br>(default: `500`) |
     *
     * Using the [`rowHeights`](#rowHeights) option forcibly disables the [`AutoRowSize`](@/api/autoRowSize.md) plugin.
     *
     * Read more:
     * - [Plugins: `AutoRowSize`](@/api/autoRowSize.md)
     *
     * @memberof Options#
     * @type {object|boolean}
     * @default undefined
     * @category AutoRowSize
     *
     * @example
     * ```js
     * autoRowSize: {
     *   // keep 40% of rows in sync (the rest of rows: async)
     *   syncLimit: '40%'
     * },
     * ```
     */
    autoRowSize: void 0,
    /**
     * With [`autoWrapCol`](#autowrapcol) enabled:
     * - When you select a bottom-most cell, pressing <kbd>**↓**</kbd> takes you to the top-most cell of the next column.
     * - When you select a top-most cell, pressing <kbd>**↑**</kbd> takes you to the bottom-most cell of the previous column.
     *
     * You can set the [`autoWrapCol`](#autowrapcol) option to one of the following:
     *
     * | Setting           | Description                                                                                                                                                                                                                                  |
     * | ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`            | When you select a bottom-most cell, pressing <kbd>**↓**</kbd> takes you to the top-most cell of the next column.<br><br>When you select a top-most cell, pressing <kbd>**↑**</kbd> takes you to the bottom-most cell of the previous column. |
     * | `false` (default) | When you select a bottom-most cell, pressing <kbd>**↓**</kbd> doesn't do anything.<br><br>When you select a top-most cell, pressing <kbd>**↑**</kbd> doesn't do anything.                                                                    |
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // when you select a bottom-most cell, pressing ⬇ doesn't do anything
     * // when you select a top-most cell, pressing ⬆ doesn't do anything
     * autoWrapCol: false, // default setting
     *
     * // when you select a bottom-most cell, pressing ⬇ takes you to the top-most cell of the next column
     * // when you select a top-most cell, pressing ⬆ takes you to the bottom-most cell of the previous column
     * autoWrapCol: true,
     * ```
     */
    autoWrapCol: false,
    /**
     * With [`autoWrapRow`](#autoWrapRow) enabled:
     * - When you select the first cell of a row, pressing <kbd>**←**</kbd>* takes you to the last cell of the row above.
     * - When you select the last cell of a row, pressing <kbd>**→**</kbd>* takes you to the first cell of the row below.
     *
     * You can set the [`autoWrapRow`](#autoWrapRow) option to one of the following:
     *
     * | Setting           | Description                                                                                                                                                                                                                              |
     * | ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`            | When you select the first cell of a row, pressing <kbd>**←**</kbd>* takes you to the last cell of the row above.<br><br>When you select the last cell of a row, pressing <kbd>**→**</kbd>* takes you to the first cell of the row below. |
     * | `false` (default) | When you select the first cell of a row, pressing <kbd>**←**</kbd>* doesn't do anything.<br><br>When you select the last cell of a row, pressing <kbd>**→**</kbd>* doesn't do anything.                                                  |
     *
     * \* The exact key depends on your [`layoutDirection`](#layoutdirection) configuration.
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // when you select the first cell of a row, pressing ⬅ doesn't do anything
     * // when you select the last cell of a row, pressing ➡️ doesn't do anything
     * autoWrapRow: false, // default setting
     *
     * // when you select the first cell of a row, pressing ⬅ takes you to the last cell of the row above
     * // when you select the last cell of a row, pressing ➡️ takes you to the first cell of the row below
     * autoWrapRow: true,
     * ```
     */
    autoWrapRow: false,
    /**
     * @description
     * The `bindRowsWithHeaders` option configures the [`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin.
     *
     * You can set the `bindRowsWithHeaders` option to one of the following:
     *
     * | Setting | Description                                                                  |
     * | ------- | ---------------------------------------------------------------------------- |
     * | `false` | Disable the the [`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin |
     * | `true`  | Enable the the [`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin  |
     *
     * Read more:
     * - [Plugins: `BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md)
     *
     * @memberof Options#
     * @type {boolean|string}
     * @default undefined
     * @category BindRowsWithHeaders
     *
     * @example
     * ```js
     * // enable the `BindRowsWithHeaders` plugin
     * bindRowsWithHeaders: true
     * ```
     */
    bindRowsWithHeaders: void 0,
    /**
     * The `cell` option lets you apply [configuration options](@/guides/getting-started/configuration-options.md) to individual cells.
     *
     * The `cell` option overwrites the [top-level grid options](@/guides/getting-started/configuration-options.md#set-grid-options),
     * and the [`columns`](#columns) options.
     *
     * Read more:
     * - [Configuration options: Setting cell options](@/guides/getting-started/configuration-options.md#set-cell-options)
     * - [`columns`](#columns)
     *
     * @memberof Options#
     * @type {Array[]}
     * @default []
     * @category Core
     *
     * @example
     * ```js
     * // set the `cell` option to an array of objects
     * cell: [
     *   // make the cell with coordinates (0, 0) read-only
     *   {
     *     row: 0,
     *     col: 0,
     *     readOnly: true
     *   }
     * ],
     * ```
     */
    cell: [],
    /**
     * @description
     * The `cells` option lets you apply any other [configuration options](@/guides/getting-started/configuration-options.md) to
     * individual grid elements (columns, rows, cells), based on any logic you implement.
     *
     * The `cells` option overwrites all other options (including options set by [`columns`](#columns) and [`cell`](#cell)).
     * It takes the following parameters:
     *
     * | Parameter | Required | Type             | Description                                                                                                                                                                                                                                                                                                                             |
     * | --------- | -------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `row`     | Yes      | Number           | A physical row index                                                                                                                                                                                                                                                                                                                    |
     * | `column`  | Yes      | Number           | A physical column index                                                                                                                                                                                                                                                                                                                 |
     * | `prop`    | No       | String \| Number | If [`data`](#data) is set to an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), `prop` is the same number as `column`.<br><br>If [`data`](#data) is set to an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), `prop` is a property name for the column's data object. |
     *
     * Read more:
     * - [Configuration options: Implementing custom logic](@/guides/getting-started/configuration-options.md#implement-custom-logic)
     * - [Configuration options: Setting row options](@/guides/getting-started/configuration-options.md#set-row-options)
     * - [`columns`](#columns)
     * - [`cell`](#cell)
     *
     * @memberof Options#
     * @type {Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the `cells` option to your custom function
     * cells(row, column, prop) {
     *   const cellProperties = { readOnly: false };
     *   const visualRowIndex = this.instance.toVisualRow(row);
     *   const visualColIndex = this.instance.toVisualColumn(column);
     *
     *   if (visualRowIndex === 0 && visualColIndex === 0) {
     *     cellProperties.readOnly = true;
     *   }
     *
     *   return cellProperties;
     * },
     * ```
     */
    cells: void 0,
    /**
     * The `checkedTemplate` option lets you configure what value
     * a checked [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell has.
     *
     * You can set the `checkedTemplate` option to one of the following:
     *
     * | Setting          | Description                                                                                                                                                                              |
     * | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is checked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns `true`                  |
     * | A string         | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is checked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns a string of your choice |
     *
     * Read more:
     * - [Checkbox cell type: Checkbox template](@/guides/cell-types/checkbox-cell-type.md#checkbox-template)
     * - [`getDataAtCell()`](@/api/core.md#getDataAtCell)
     * - [`uncheckedTemplate`](#uncheckedTemplate)
     *
     * @memberof Options#
     * @type {boolean|string|number}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     // when checked, the cell's value is `true`
     *     // when unchecked, the cell's value is `false`
     *     type: 'checkbox',
     *   },
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     type: 'checkbox',
     *     // when checked, the cell's value is `'Yes'`
     *     checkedTemplate: 'Yes',
     *     // when unchecked, the cell's value is `'No'`
     *     uncheckedTemplate: 'No'
     *  }
     * ],
     * ```
     */
    checkedTemplate: void 0,
    /**
     * The `className` option lets you add CSS class names to every currently-selected element.
     *
     * You can set the `className` option to one of the following:
     *
     * | Setting             | Description                                                      |
     * | ------------------- | ---------------------------------------------------------------- |
     * | A string            | Add a single CSS class name to every currently-selected element  |
     * | An array of strings | Add multiple CSS class names to every currently-selected element |
     *
     * ::: tip
     * Don't change the `className` metadata of the [column summary](@/guides/columns/column-summary.md) row.
     * To style the summary row, use the class name assigned automatically by the [`ColumnSummary`](@/api/columnSummary.md) plugin: `columnSummaryResult`.
     * :::
     *
     * To apply different CSS class names on different levels, use Handsontable's [cascading configuration](@/guides/getting-started/configuration-options.md#cascading-configuration).
     *
     * Read more:
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options.md#cascading-configuration)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`TableClassName`](#TableClassName)
     *
     * @memberof Options#
     * @type {string|string[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to every currently-selected element
     * className: 'your-class-name',
     *
     * // add `first-class-name` and `second-class-name` CSS class names
     * // to every currently-selected element
     * className: ['first-class-name', 'second-class-name'],
     * ```
     */
    className: void 0,
    /**
     * The `colHeaders` option configures your grid's column headers.
     *
     * You can set the `colHeaders` option to one of the following:
     *
     * | Setting  | Description                                                          |
     * | -------- | -------------------------------------------------------------------- |
     * | `true`   | Enable the default column headers ('A', 'B', 'C', ...)               |
     * | `false`  | Disable column headers                                               |
     * | An array | Define your own column headers (e.g. `['One', 'Two', 'Three', ...]`) |
     * | A function | Define your own column headers, using a function                     |
     *
     * Read more:
     * - [Column header](@/guides/columns/column-header.md)
     *
     * @memberof Options#
     * @type {boolean|string[]|Function}
     * @default null
     * @category Core
     *
     * @example
     * ```js
     * // enable the default column headers
     * colHeaders: true,
     *
     * // set your own column headers
     * colHeaders: ['One', 'Two', 'Three'],
     *
     * // set your own column headers, using a function
     * colHeaders: function(visualColumnIndex) {
     *   return `${visualColumnIndex} + : AB`;
     * },
     * ```
     */
    colHeaders: null,
    /**
     * @description
     * The `collapsibleColumns` option configures the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin.
     *
     * You can set the `collapsibleColumns` option to one of the following:
     *
     * | Setting              | Description                                                                                       |
     * | -------------------- | ------------------------------------------------------------------------------------------------- |
     * | `false`              | Disable the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin                            |
     * | `true`               | Enable the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin                             |
     * | An array of objects  | Enable the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin for selected column headers |
     *
     * Read more:
     * - [Plugins: `CollapsibleColumns`](@/api/collapsibleColumns.md)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default undefined
     * @category CollapsibleColumns
     *
     * @example
     * ```js
     * // enable column collapsing for all headers
     * collapsibleColumns: true,
     *
     * // enable column collapsing for selected headers
     * collapsibleColumns: [
     *   {row: -4, col: 1, collapsible: true},
     *   {row: -3, col: 5, collapsible: true}
     * ],
     * ```
     */
    collapsibleColumns: void 0,
    /**
     * @description
     * The `columnHeaderHeight` option configures the height of column headers.
     *
     * You can set the `columnHeaderHeight` option to one of the following:
     *
     * | Setting  | Description                                         |
     * | -------- | --------------------------------------------------- |
     * | A number | Set the same height for every column header         |
     * | An array | Set different heights for individual column headers |
     *
     * @memberof Options#
     * @type {number|number[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the same height for every column header
     * columnHeaderHeight: 25,
     *
     * // set different heights for individual column headers
     * columnHeaderHeight: [25, 30, 55],
     * ```
     */
    columnHeaderHeight: void 0,
    /**
     * @description
     * The `columns` option lets you apply any other [configuration options](@/guides/getting-started/configuration-options.md) to individual columns (or ranges of columns).
     *
     * You can set the `columns` option to one of the following:
     * - An array of objects (each object represents one column)
     * - A function that returns an array of objects
     *
     * The `columns` option overwrites the [top-level grid options](@/guides/getting-started/configuration-options.md#set-grid-options).
     *
     * When you use `columns`, the [`startCols`](#startCols), [`minCols`](#minCols), and [`maxCols`](#maxCols) options are ignored.
     *
     * Read more:
     * - [Configuration options: Setting column options](@/guides/getting-started/configuration-options.md#set-column-options)
     * - [`startCols`](#startCols)
     * - [`minCols`](#minCols)
     * - [`maxCols`](#maxCols)
     * - [`data`](#data)
     *
     * @memberof Options#
     * @type {object[]|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the `columns` option to an array of objects
     * // each object represents one column
     * columns: [
     *   {
     *     // column options for the first (by physical index) column
     *     type: 'numeric',
     *     numericFormat: {
     *       pattern: '0,0.00 $'
     *     }
     *   },
     *   {
     *     // column options for the second (by physical index) column
     *     type: 'text',
     *     readOnly: true
     *   }
     * ],
     *
     * // or set the `columns` option to a function, based on physical indexes
     * columns(index) {
     *   return {
     *     type: index > 0 ? 'numeric' : 'text',
     *     readOnly: index < 1
     *   }
     * }
     * ```
     */
    columns: void 0,
    /**
     * @description
     * The `columnSorting` option configures the [`ColumnSorting`](@/api/columnSorting.md) plugin.
     *
     * You can set the `columnSorting` option to one of the following:
     *
     * | Setting    | Description                                                                                                                            |
     * | ---------- | -------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`     | Enable the [`ColumnSorting`](@/api/columnSorting.md) plugin with the default configuration                                             |
     * | `false`    | Disable the [`ColumnSorting`](@/api/columnSorting.md) plugin                                                                           |
     * | An object  | - Enable the [`ColumnSorting`](@/api/columnSorting.md) plugin<br>- Modify the [`ColumnSorting`](@/api/columnSorting.md) plugin options |
     *
     * If you set the `columnSorting` option to an object,
     * you can set the following [`ColumnSorting`](@/api/columnSorting.md) plugin options:
     *
     * | Option                   | Possible settings                                                                                                                                |
     * | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `indicator`              | `true`: Display the arrow icon in the column header, to indicate a sortable column<br>`false`: Don't display the arrow icon in the column header  |
     * | `headerAction`           | `true`: Enable clicking on the column header to sort the column<br>`false`: Disable clicking on the column header to sort the column             |
     * | `sortEmptyCells`         | `true`: Sort empty cells as well<br>`false`: Place empty cells at the end                                                                        |
     * | `compareFunctionFactory` | A [custom compare function](@/guides/rows/rows-sorting.md#add-a-custom-comparator)                                                                |
     *
     * If you set the `columnSorting` option to an object,
     * you can also sort individual columns at Handsontable's initialization.
     * In the `columnSorting` object, add an object named `initialConfig`,
     * with the following properties:
     *
     * | Option      | Possible settings   | Description                                                      |
     * | ----------- | ------------------- | ---------------------------------------------------------------- |
     * | `column`    | A number            | The index of the column that you want to sort at initialization  |
     * | `sortOrder` | `'asc'` \| `'desc'` | The sorting order:<br>`'asc'`: ascending<br>`'desc'`: descending |
     *
     * Read more:
     * - [Rows sorting](@/guides/rows/rows-sorting.md)
     * - [Rows sorting: Custom compare functions](@/guides/rows/rows-sorting.md#add-a-custom-comparator)
     * - [`multiColumnSorting`](#multiColumnSorting)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category ColumnSorting
     *
     * @example
     * ```js
     * // enable the `ColumnSorting` plugin
     * columnSorting: true
     *
     * // enable the `ColumnSorting` plugin with custom configuration
     * columnSorting: {
     *   // sort empty cells as well
     *   sortEmptyCells: true,
     *   // display the arrow icon in the column header
     *   indicator: true,
     *   // disable clicking on the column header to sort the column
     *   headerAction: false,
     *   // add a custom compare function
     *   compareFunctionFactory(sortOrder, columnMeta) {
     *     return function(value, nextValue) {
     *       // some value comparisons which will return -1, 0 or 1...
     *     }
     *   }
     * }
     *
     * // enable the `ColumnSorting` plugin
     * columnSorting: {
     *   // at initialization, sort column 1 in ascending order
     *   initialConfig: {
     *     column: 1,
     *     sortOrder: 'asc'
     *   },
     *   // at initialization, sort column 2 in descending order
     *   initialConfig: {
     *     column: 2,
     *     sortOrder: 'desc'
     *   }
     * }
     * ```
     */
    columnSorting: void 0,
    /**
     * @description
     * The `columnSummary` option configures the [`ColumnSummary`](@/api/columnSummary.md) plugin.
     *
     * You can set the `columnSummary` option to an array of objects.
     * Each object configures a single column summary, using the following properties:
     *
     * | Property                 | Possible values                                                         | Description                                                                                                                  |
     * | ------------------------ | ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
     * | `sourceColumn`           | A number                                                                | [Column to summarize](@/guides/columns/column-summary.md#step-2-select-cells-that-you-want-to-summarize)                     |
     * | `ranges`                 | An array                                                                | [Ranges of rows to summarize](@/guides/columns/column-summary.md#step-2-select-cells-that-you-want-to-summarize)             |
     * | `type`                   | `'sum'` \| `'min'` \| `'max'` \| `'count'` \| `'average'` \| `'custom'` | [Summary function](@/guides/columns/column-summary.md#step-3-calculate-your-summary)                                         |
     * | `destinationRow`         | A number                                                                | [Destination cell's row coordinate](@/guides/columns/column-summary.md#step-4-provide-the-destination-cell-s-coordinates)    |
     * | `destinationColumn`      | A number                                                                | [Destination cell's column coordinate](@/guides/columns/column-summary.md#step-4-provide-the-destination-cell-s-coordinates) |
     * | `forceNumeric`           | `true`  \| `false`                                                      | [Treat non-numerics as numerics](@/guides/columns/column-summary.md#force-numeric-values)                                  |
     * | `reversedRowCoords`      | `true`  \| `false`                                                      | [Reverse row coordinates](@/guides/columns/column-summary.md#step-5-make-room-for-the-destination-cell)                      |
     * | `suppressDataTypeErrors` | `true`  \| `false`                                                      | [Suppress data type errors](@/guides/columns/column-summary.md#throw-data-type-errors)                                    |
     * | `readOnly`               | `true`  \| `false`                                                      | Make summary cell read-only                                                                                                  |
     * | `roundFloat`             | `true`  \| `false`                                                      | [Round summary result](@/guides/columns/column-summary.md#round-a-column-summary-result)                                  |
     * | `customFunction`         | A function                                                              | [Custom summary function](@/guides/columns/column-summary.md#implement-a-custom-summary-function)                         |
     *
     * Read more:
     * - [Column summary](@/guides/columns/column-summary.md)
     * - [Plugins: `ColumnSummary`](@/api/columnSummary.md)
     *
     * @memberof Options#
     * @type {object[]|Function}
     * @default undefined
     * @category ColumnSummary
     *
     * @example
     * ```js
     * columnSummary: [
     *   {
     *     sourceColumn: 0,
     *     ranges: [
     *       [0, 2], [4], [6, 8]
     *     ],
     *     type: 'custom',
     *     destinationRow: 4,
     *     destinationColumn: 1,
     *     forceNumeric: true,
     *     reversedRowCoords: true,
     *     suppressDataTypeErrors: false,
     *     readOnly: true,
     *     roundFloat: false,
     *     customFunction(endpoint) {
     *        return 100;
     *     }
     *   }
     * ],
     * ```
     */
    columnSummary: void 0,
    /**
     * The `colWidths` option sets columns' widths, in pixels.
     *
     * The default column width is 50px. To change it, set the `colWidths` option to one of the following:
     *
     * | Setting     | Description                                                                                          | Example                                                           |
     * | ----------- | ---------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
     * | A number    | Set the same width for every column                                                                  | `colWidths: 100`                                                  |
     * | A string    | Set the same width for every column                                                                  | `colWidths: '100px'`                                              |
     * | An array    | Set widths separately for each column                                                                | `colWidths: [100, 120, undefined]`                                |
     * | A function  | Set column widths dynamically,<br>on each render                                                     | `colWidths(visualColumnIndex) { return visualColumnIndex * 10; }` |
     * | `undefined` | Used by the [modifyColWidth](@/api/hooks.md#modifyColWidth) hook,<br>to detect column width changes. | `colWidths: undefined`                                            |
     *
     * Setting `colWidths` even for a single column disables the {@link AutoColumnSize} plugin
     * for all columns. For this reason, if you use `colWidths`, we recommend you set a width for each one
     * of your columns. Otherwise, every column with an undefined width defaults back to 50px,
     * which may cut longer columns names.
     *
     * Read more:
     * - [Column width](@/guides/columns/column-width.md)
     * - [Hooks: `modifyColWidth`](@/api/hooks.md#modifyColWidth)
     * - [`autoColumnSize`](#autoColumnSize)
     *
     * @memberof Options#
     * @type {number|number[]|string|string[]|Array<undefined>|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set every column's width to 100px
     * colWidths: 100,
     *
     * // set every column's width to 100px
     * colWidths: '100px',
     *
     * // set the first (by visual index) column's width to 100
     * // set the second (by visual index) column's width to 120
     * // set the third (by visual index) column's width to `undefined`, so that it defaults to 50px
     * // set any other column's width to the default 50px (note that longer cell values and column names can get cut)
     * colWidths: [100, 120, undefined],
     *
     * // set each column's width individually, using a function
     * colWidths(visualColumnIndex) {
     *   return visualColumnIndex * 10;
     * },
     * ```
     */
    colWidths: void 0,
    /**
     * The `commentedCellClassName` option lets you add a CSS class name to cells
     * that have comments.
     *
     * Read more:
     * - [Comments](@/guides/cell-features/comments.md)
     * - [`comments`](#comments)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htCommentCell'
     * @category Core
     *
     * @example
     * ```js
     * // add a `has-comment` CSS class name
     * // to each cell that has a comment
     * commentedCellClassName: 'has-comment',
     * ```
     */
    commentedCellClassName: "htCommentCell",
    /**
     * @description
     * The `comments` option configures the [`Comments`](@/api/comments.md) plugin.
     *
     * You can set the `comments` option to one of the following:
     *
     * | Setting   | Description                                                                                                                                                                           |
     * | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`    | - Enable the [`Comments`](@/api/comments.md) plugin<br>- Add comment menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md)                                 |
     * | `false`   | Disable the [`Comments`](@/api/comments.md) plugin                                                                                                                                    |
     * | An object | - Enable the [`Comments`](@/api/comments.md) plugin<br>- Add comment menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md)<br>- Configure comment settings |
     *
     * If you set the `comments` option to an object, you can configure the following comment options:
     *
     * | Option         | Possible settings           | Description                                         |
     * | -------------- | --------------------------- | --------------------------------------------------- |
     * | `displayDelay` | A number (default: `250`)   | Display comments after a delay (in milliseconds)    |
     * | `readOnly`     | `true` \| `false` (default) | `true`: Make comments read-only                     |
     * | `style`        | An object                   | Set comment boxes' `width` and `height` (in pixels) |
     *
     * Read more:
     * - [Comments](@/guides/cell-features/comments.md)
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     * - [`width`](#width)
     * - [`height`](#height)
     * - [`readOnly`](#readOnly)
     * - [`commentedCellClassName`](#commentedCellClassName)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default false
     * @category Comments
     *
     * @example
     * ```js
     * // enable the `Comments` plugin
     * comments: true,
     *
     * // enable the `Comments` plugin
     * // and configure its settings
     * comments: {
     *   // display all comments with a 1-second delay
     *   displayDelay: 1000,
     *   // make all comments read-only
     *   readOnly: true,
     *   // set the default size of all comment boxes
     *   style: {
     *     width: 300,
     *     height: 100
     *   }
     * }
     * ```
     */
    comments: false,
    /**
     * @description
     * The `contextMenu` option configures the [`ContextMenu`](@/api/contextMenu.md) plugin.
     *
     * You can set the `contextMenu` option to one of the following:
     *
     * | Setting   | Description                                                                                                                                                                                             |
     * | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`ContextMenu`](@/api/contextMenu.md) plugin                                                                                                                                                |
     * | `true`    | - Enable the [`ContextMenu`](@/api/contextMenu.md) plugin<br>- Use the [default context menu options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-default-options)                 |
     * | An array  | - Enable the [`ContextMenu`](@/api/contextMenu.md) plugin<br>- Modify [individual context menu options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-specific-options)              |
     * | An object | - Enable the [`ContextMenu`](@/api/contextMenu.md) plugin<br>- Apply a [custom context menu configuration](@/guides/accessories-and-menus/context-menu.md#context-menu-with-a-fully-custom-configuration) |
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     * - [Context menu: Context menu with default options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-default-options)
     * - [Context menu: Context menu with specific options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-specific-options)
     * - [Context menu: Context menu with fully custom configuration options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-a-fully-custom-configuration)
     * - [Plugins: `ContextMenu`](@/api/contextMenu.md)
     *
     * @memberof Options#
     * @type {boolean|string[]|object}
     * @default undefined
     * @category ContextMenu
     *
     * @example
     * ```js
     * // enable the `ContextMenu` plugin
     * // use the default context menu options
     * contextMenu: true,
     *
     * // enable the `ContextMenu` plugin
     * // and modify individual context menu options
     * contextMenu: ['row_above', 'row_below', '---------', 'undo', 'redo'],
     *
     * // enable the `ContextMenu` plugin
     * // and apply a custom context menu configuration
     * contextMenu: {
     *   items: {
     *     'option1': {
     *       name: 'Option 1'
     *     },
     *     'option2': {
     *       name: 'Option 2',
     *       submenu: {
     *         items: [
     *           {
     *             key: 'option2:suboption1',
     *             name: 'Suboption 1',
     *             callback: function(key, options) {
     *               ...
     *             }
     *           },
     *           ...
     *         ]
     *       }
     *     }
     *   }
     * },
     * ```
     */
    contextMenu: void 0,
    /**
     * @description
     * The `copyable` option determines whether a cell's value can be copied to the clipboard or not.
     *
     * You can set the `copyable` option to one of the following:
     *
     * | Setting                                                                                                        | Description                                                                                                            |
     * | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default)                                                                                               | - On pressing <kbd>**Ctrl**</kbd>/<kbd>**Cmd**</kbd> + <kbd>**C**</kbd>, add the cell's value to the clipboard         |
     * | `false`<br>(default for the [`password`](@/guides/cell-types/password-cell-type.md) [cell type](#type))        | - On pressing <kbd>**Ctrl**</kbd>/<kbd>**Cmd**</kbd> + <kbd>**C**</kbd>, add an empty string (`""`) to the clipboard   |
     *
     * Read more:
     * - [Clipboard](@/guides/cell-features/clipboard.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options.md#cascading-configuration)
     * - [Password cell type](@/guides/cell-types/password-cell-type.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // enable copying for each cell of the entire grid
     * copyable: true,
     *
     * // enable copying for individual columns
     * columns: [
     *   {
     *     // enable copying for each cell of this column
     *     copyable: true
     *   },
     *   {
     *     // disable copying for each cell of this column
     *     copyable: false
     *   }
     * ]
     *
     * // enable copying for specific cells
     * cells: [
     *   {
     *     cell: 0,
     *     row: 0,
     *     // disable copying for cell (0, 0)
     *     copyable: false,
     *   }
     * ],
     * ```
     */
    copyable: true,
    /**
     * The `copyPaste` option configures the [`CopyPaste`](@/api/copyPaste.md) plugin.
     *
     * You can set the `copyPaste` option to one of the following:
     *
     * | Setting           | Description                                                                                                            |
     * | ----------------- | ---------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default)  | Enable the [`CopyPaste`](@/api/copyPaste.md) plugin with the default configuration                                     |
     * | `false`           | Disable the [`CopyPaste`](@/api/copyPaste.md) plugin                                                                   |
     * | An object         | - Enable the [`CopyPaste`](@/api/copyPaste.md) plugin<br>- Modify the [`CopyPaste`](@/api/copyPaste.md) plugin options |
     *
     * ##### copyPaste: Additional options
     *
     * If you set the `copyPaste` option to an object, you can set the following `CopyPaste` plugin options:
     *
     * | Option                   | Possible settings                                  | Description                                                                                                                                                                                         |
     * | ------------------------ | -------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `columnsLimit`           | A number (default: `Infinity`)                     | The maximum number of columns that can be copied                                                                                                                                                    |
     * | `rowsLimit`              | A number (default: `Infinity`)                     | The maximum number of columns that can be copied                                                                                                                                                    |
     * | `pasteMode`              | `'overwrite'` \| `'shift_down'` \| `'shift_right'` | When pasting:<br>`'overwrite'`: overwrite the currently-selected cells<br>`'shift_down'`: move the currently-selected cells down<br>`'shift_right'`: move the currently-selected cells to the right |
     * | `copyColumnHeaders`      | Boolean (default: `false`)                         | `true`: add a context menu option for copying cells along with their nearest column headers                                                                                                         |
     * | `copyColumnGroupHeaders` | Boolean (default: `false`)                         | `true`: add a context menu option for copying cells along with all their related columns headers                                                                                                    |
     * | `copyColumnHeadersOnly`  | Boolean (default: `false`)                         | `true`: add a context menu option for copying column headers nearest to the selected cells (without copying cells)                                                                    |
     * | `uiContainer`            | An HTML element                                    | The UI container for the secondary focusable element                                                                                                                                                |
     *
     * Read more:
     * - [Plugins: `CopyPaste`](@/api/copyPaste.md)
     * - [Guides: Clipboard](@/guides/cell-features/clipboard.md)
     *
     * @memberof Options#
     * @type {object|boolean}
     * @default true
     * @category CopyPaste
     *
     * @example
     * ```js
     * // enable the plugin with the default configuration
     * copyPaste: true // set by default
     *
     * // disable the plugin
     * copyPaste: false,
     *
     * // enable the plugin with a custom configuration
     * copyPaste: {
     *   // set a maximum number of columns that can be copied
     *   columnsLimit: 25,
     *
     *   // set a maximum number of rows that can be copied
     *   rowsLimit: 50,
     *
     *   // set the paste behavior
     *   pasteMode: 'shift_down',
     *
     *   // add the option to copy cells along with their nearest column headers
     *   copyColumnHeaders: true,
     *
     *   // add the option to copy cells along with all their related columns headers
     *   copyColumnGroupHeaders: true,
     *
     *   // add the option to copy just column headers (without copying cells)
     *   copyColumnHeadersOnly: true,
     *
     *   // set a UI container
     *   uiContainer: document.body,
     * },
     * ```
     */
    copyPaste: true,
    /**
     * The `correctFormat` option configures whether incorrectly-formatted times and dates are amended or not.
     *
     * When the user enters dates and times, Handsontable can automatically adjust their format
     * to match the [`dateFormat`](#dateFormat) and [`timeFormat`](@/guides/cell-types/time-cell-type.md) settings.
     *
     * You can set the `correctFormat` option to one of the following:
     *
     * | Setting           | Description                                                                                                                                               |
     * | ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Don't correct the format of the entered date or time (treat the entered date or time as invalid)                                                          |
     * | `true`            | Correct the format of the entered date or time to match the [`dateFormat`](#dateFormat) or [`timeFormat`](@/guides/cell-types/time-cell-type.md) settings |
     *
     * Read more:
     * - [Date cell type](@/guides/cell-types/date-cell-type.md)
     * - [Time cell type](@/guides/cell-types/time-cell-type.md)
     * - [`dateFormat`](#dateFormat)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `date`
     *   type: 'date',
     *   // for every `date` cell of this column, set the date format to `YYYY-MM-DD`
     *   dateFormat: 'YYYY-MM-DD',
     *   // enforce the `YYYY-MM-DD` date format
     *   correctFormat: true
     *   },
     *
     *   {
     *   // set the `type` of each cell in this column to `time`
     *   type: 'time',
     *   // for every `time` cell of this column, set the time format to `h:mm:ss a`
     *   timeFormat: 'h:mm:ss a',
     *   // enforce the `h:mm:ss a` time format
     *   correctFormat: true
     *   },
     * ],
     * ```
     */
    correctFormat: false,
    /**
     * The `currentColClassName` option lets you add a CSS class name
     * to each cell of the currently-visible, currently-selected columns.
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to each cell of the currently-visible, currently-selected columns
     * currentColClassName: 'your-class-name',
     * ```
     */
    currentColClassName: void 0,
    /**
     * The `currentHeaderClassName` option lets you add a CSS class name
     * to every currently-visible, currently-selected header.
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'ht__highlight'
     * @category Core
     *
     * @example
     * ```js
     * // add an `ht__highlight` CSS class name
     * // to every currently-visible, currently-selected header
     * currentHeaderClassName: 'ht__highlight',
     * ```
     */
    currentHeaderClassName: "ht__highlight",
    /**
     * The `currentRowClassName` option lets you add a CSS class name
     * to each cell of the currently-visible, currently-selected rows.
     *
     * Read more:
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to each cell of the currently-visible, currently-selected rows
     * currentRowClassName: 'your-class-name',
     * ```
     */
    currentRowClassName: void 0,
    /**
     * @description
     * The `customBorders` option configures the [`CustomBorders`](@/api/customBorders.md) plugin.
     *
     * To enable the [`CustomBorders`](@/api/customBorders.md) plugin
     * (and add its menu items to the [context menu](@/guides/accessories-and-menus/context-menu.md)),
     * set the `customBorders` option to `true`.
     *
     * To enable the [`CustomBorders`](@/api/customBorders.md) plugin
     * and add a predefined border around a particular cell,
     * set the `customBorders` option to an array of objects.
     * Each object represents a border configuration for one cell, and has the following properties:
     *
     * | Property | Sub-properties     | Types                              | Description                                                       |
     * | -------- | ------------------ | ---------------------------------- | ----------------------------------------------------------------- |
     * | `row`    | -                  | `row`: Number                      | The cell's row coordinate.                                        |
     * | `col`    | -                  | `col`: Number                      | The cell's column coordinate.                                     |
     * | `start`  | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default): `start` sets the width (`width`) and color (`color`) of the left-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: `start` sets the width (`width`) and color (`color`) of the right-hand border. |
     * | `end`    | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default): `end` sets the width (`width`) and color (`color`) of the right-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: `end` sets the width (`width`) and color (`color`) of the left-hand border. |
     * | `top`    | `width`<br>`color` | `width`: Number<br>`color`: String | Sets the width (`width`) and color (`color`) of the top border. |
     * | `bottom` | `width`<br>`color` | `width`: Number<br>`color`: String | Sets the width (`width`) and color (`color`) of the bottom border. |
     *
     * To enable the [`CustomBorders`](@/api/customBorders.md) plugin
     * and add a predefined border around a range of cells,
     * set the `customBorders` option to an array of objects.
     * Each object represents a border configuration for a single range of cells, and has the following properties:
     *
     * | Property | Sub-properties                               | Types                                                            | Description                                                                                  |
     * | -------- | -------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------------------------------- |
     * | `range`  | `from` {`row`, `col`}<br>`to` {`row`, `col`} | `from`: Object<br>`to`: Object<br>`row`: Number<br>`col`: Number | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default):<br>- `from` selects the range's top-left corner.<br>- `to` selects the range's bottom-right corner.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: <br>- `from` selects the range's top-right corner.<br>- `to` selects the range's bottom-left corner. |
     * | `start`  | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default): `start` sets the width (`width`) and color (`color`) of the left-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: `start` sets the width (`width`) and color (`color`) of the right-hand border. |
     * | `end`    | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default): `end` sets the width (`width`) and color (`color`) of the right-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction.md) is RTL: `end` sets the width (`width`) and color (`color`) of the left-hand border. |
     * | `top`    | `width`<br>`color`                           | `width`: Number<br>`color`: String                               | Sets the width (`width`) and color (`color`) of the top border. |
     * | `bottom` | `width`<br>`color`                           | `width`: Number<br>`color`: String                               | Sets the width (`width`) and color (`color`) of the bottom border. |
     *
     * Read more:
     * - [Formatting cells: Custom cell borders](@/guides/cell-features/formatting-cells.md#custom-cell-borders)
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     * - [Plugins: `CustomBorders`](@/api/customBorders.md)
     * - [Layout direction](@/guides/internationalization/layout-direction.md)
     * - [`layoutDirection`](#layoutDirection)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default false
     * @category CustomBorders
     *
     * @example
     * ```js
     * // enable the `CustomBorders` plugin
     * customBorders: true,
     *
     * // enable the `CustomBorders` plugin
     * // and add a predefined border for a particular cell
     * customBorders: [
     *   // add an object with a border configuration for one cell
     *   {
     *     // set the cell's row coordinate
     *     row: 2,
     *     // set the cell's column coordinate
     *     col: 2,
     *     // set the left/right border's width and color
     *     start: {
     *       width: 2,
     *       color: 'red'
     *     },
     *     // set the right/left border's width and color
     *     end: {
     *       width: 1,
     *       color: 'green'
     *     },
     *     // set the top border's width and color
     *     top: '',
     *     // set the bottom border's width and color
     *     bottom: ''
     *   }
     * ],
     *
     * // enable the `CustomBorders` plugin
     * // and add a predefined border for a range of cells
     * customBorders: [
     *   // add an object with a border configuration for one range of cells
     *   {
     *     // select a range of cells
     *     range: {
     *       // set the range's top-left corner
     *       from: {
     *         row: 1,
     *         col: 1
     *       },
     *       // set the range's bottom-right corner
     *       to: {
     *         row: 3,
     *         col: 4
     *       }
     *     },
     *     // set the left/right border's width and color
     *     start: {
     *       width: 2,
     *       color: 'red'
     *     },
     *     // set the right/left border's width and color
     *     end: {},
     *     // set the top border's width and color
     *     top: {},
     *     // set the bottom border's width and color
     *     bottom: {}
     *   }
     * ],
     * ```
     */
    customBorders: false,
    /**
     * @description
     * The `data` option sets the initial [data](@/guides/getting-started/binding-to-data.md) of your Handsontable instance.
     *
     * Handsontable's data is bound to your source data by reference (i.e. when you edit Handsontable's data, your source data alters as well).
     *
     * You can set the `data` option:
     * - Either to an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).
     * - Or to an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects).
     *
     * If you don't set the `data` option (or set it to `null`), Handsontable renders as an empty 5x5 grid by default.
     *
     * Read more:
     * - [Binding to data](@/guides/getting-started/binding-to-data.md)
     * - [`dataSchema`](#dataSchema)
     * - [`startRows`](#startRows)
     * - [`startCols`](#startCols)
     *
     * @memberof Options#
     * @type {Array[]|object[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // as an array of arrays
     * data: [
     *   ['A', 'B', 'C'],
     *   ['D', 'E', 'F'],
     *   ['G', 'H', 'J']
     * ]
     *
     * // as an array of objects
     * data: [
     *   {id: 1, name: 'Ted Right'},
     *   {id: 2, name: 'Frank Honest'},
     *   {id: 3, name: 'Joan Well'},
     *   {id: 4, name: 'Gail Polite'},
     *   {id: 5, name: 'Michael Fair'},
     * ]
     * ```
     */
    data: void 0,
    /**
     * @description
     * When the [`data`](#data) option is set to an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects)
     * (or is empty), the `dataSchema` option defines the structure of new rows.
     *
     * Using the `dataSchema` option, you can start out with an empty grid.
     *
     * You can set the `dataSchema` option to one of the following:
     * - An object
     * - A function
     *
     * Read more:
     * - [Binding to data: Array of objects with custom data schema](@/guides/getting-started/binding-to-data.md#array-of-objects-with-custom-data-schema)
     * - [Binding to data: Function data source and schema](@/guides/getting-started/binding-to-data.md#function-data-source-and-schema)
     * - [`data`](#data)
     *
     * @memberof Options#
     * @type {object|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // with `dataSchema`, you can start with an empty grid
     * data: null,
     * dataSchema: {id: null, name: {first: null, last: null}, address: null},
     * colHeaders: ['ID', 'First Name', 'Last Name', 'Address'],
     * columns: [
     *   {data: 'id'},
     *   {data: 'name.first'},
     *   {data: 'name.last'},
     *   {data: 'address'}
     * ],
     * startRows: 5,
     * minSpareRows: 1
     * ```
     */
    dataSchema: void 0,
    /**
     * The `dateFormat` option configures the date format accepted by [`date`](@/guides/cell-types/date-cell-type.md) cells.
     *
     * You can set the `dateFormat` option to a string with a proper date format. The default value is: `'DD/MM/YYYY'`.
     *
     * To automatically correct dates whose format doesn't match the `dateFormat` setting, use the [`correctFormat`](#correctFormat) option.
     *
     * Read more:
     * - [Date cell type](@/guides/cell-types/date-cell-type.md)
     * - [`correctFormat`](#correctFormat)
     * - [`defaultDate`](#defaultDate)
     *
     * @memberof Options#
     * @type {string}
     * @default 'DD/MM/YYYY'
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `date`
     *   type: 'date',
     *   // for every `date` cell of this column, set the date format to `YYYY-MM-DD`
     *   dateFormat: 'YYYY-MM-DD',
     *   },
     * ],
     * ```
     */
    dateFormat: "DD/MM/YYYY",
    /**
     * The `datePickerConfig` option configures the `date` [cell editor](@/guides/cell-functions/cell-editor.md)'s date picker, which uses an external dependency: [Pikaday](https://github.com/Pikaday/Pikaday/tree/1.8.2).
     *
     * You can set the `datePickerConfig` option to an object with any of the available [Pikaday options](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration),
     * except for the following, which are always overwritten by the `date` [cell editor](@/guides/cell-functions/cell-editor.md):
     * - `bound`
     * - `container`
     * - `field`
     * - `trigger`
     *
     * If the `datePickerConfig` option is not defined, the `date` [cell editor](@/guides/cell-functions/cell-editor.md) overwrites the following [Pikaday options](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration) as well:
     *
     * | Pikaday option       | Handsontable's setting |
     * | -------------------- | ---------------------- |
     * | `format`             | `'DD/MM/YYYY'`         |
     * | `reposition`         | `false`                |
     *
     * Read more:
     * - [`editor`](#editor)
     * - [`dateFormat`](#dateFormat)
     * - [Cell editor](@/guides/cell-functions/cell-editor.md)
     * - [All Pikaday options &#8594;](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration)
     *
     * @memberof Options#
     * @type {object}
     * @default undefined
     * @category Core
     */
    datePickerConfig: void 0,
    /**
     * The `defaultDate` option configures the date displayed
     * in empty [`date`](@/guides/cell-types/date-cell-type.md) cells.
     *
     * You can set the `defaultDate` option to a string.
     *
     * Read more:
     * - [Date cell type](@/guides/cell-types/date-cell-type.md)
     * - [`dateFormat`](#dateFormat)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `date`
     *     type: 'date',
     *     // in every empty `date` cell of this column, display `2015-02-02`
     *     defaultDate: '2015-02-02'
     *   }
     * ],
     * ```
     */
    defaultDate: void 0,
    /**
     * @description
     * The `disableVisualSelection` option configures how
     * [selection](@/guides/cell-features/selection.md) is shown.
     *
     * You can set the `disableVisualSelection` option to one of the following:
     *
     * | Setting           | Description                                                                                         |
     * | ----------------- | --------------------------------------------------------------------------------------------------- |
     * | `false` (default) | - Show single-cell selection<br>- Show range selection<br>- Show header selection                   |
     * | `true`            | - Don't show single-cell selection<br>- Don't show range selection<br>- Don't show header selection |
     * | `'current'`       | - Don't show single-cell selection<br>- Show range selection<br>- Show header selection             |
     * | `'area'`          | - Show single-cell selection<br>- Don't show range selection<br>- Show header selection             |
     * | `'header'`        | - Show single-cell selection<br>- Show range selection<br>- Don't show header selection             |
     * | An array          | A combination of `'current'`, `'area'`, and/or `'header'`                                           |
     *
     * Read more:
     * - [Selection](@/guides/cell-features/selection.md)
     *
     * @memberof Options#
     * @type {boolean|string|string[]}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // don't show single-cell selection
     * // don't show range selection
     * // don't show header selection
     * disableVisualSelection: true,
     *
     * // don't show single-cell selection
     * // show range selection
     * // show header selection
     * disableVisualSelection: 'current',
     *
     * // don't show single-cell selection
     * // don't show range selection
     * // show header selection
     * disableVisualSelection: ['current', 'area'],
     * ```
     */
    disableVisualSelection: false,
    /**
     * @description
     * The `dragToScroll` option configures the [`DragToScroll`](@/api/dragToScroll.md) plugin.
     *
     * You can set the `dragToScroll` option to one of the following:
     *
     * | Setting          | Description                                                                 |
     * | ---------------- | --------------------------------------------------------------------------- |
     * | `true` (default) | When selection reaches the edge of the grid's viewport, scroll the viewport |
     * | `false`          | Don't scroll the viewport                                                   |
     *
     * Read more:
     * - [Plugins: `DragToScroll`](@/api/dragToScroll.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category DragToScroll
     *
     * @example
     * ```js
     * // when selection reaches the edge of the grid's viewport, scroll the viewport
     * dragToScroll: true,
     * ```
     */
    dragToScroll: true,
    /**
     * The `dropdownMenu` option configures the [`DropdownMenu`](@/api/dropdownMenu.md) plugin.
     *
     * You can set the `dropdownMenu` option to one of the following:
     *
     * | Setting   | Description                                                                                                                                                                                  |
     * | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin                                                                                                                                   |
     * | `true`    | - Enable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Use the [default context menu options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-default-options)    |
     * | An array  | - Enable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Modify [individual context menu options](@/guides/accessories-and-menus/context-menu.md#context-menu-with-specific-options) |
     * | An object | - Enable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Apply a custom dropdown menu configuration                                                                                  |
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu.md)
     * - [Plugins: `DropdownMenu`](@/api/dropdownMenu.md)
     *
     * @memberof Options#
     * @type {boolean|object|string[]}
     * @default undefined
     * @category DropdownMenu
     *
     * @example
     * ```js
     * // enable the `DropdownMenu` plugin
     * // use the default context menu options
     * dropdownMenu: true,
     *
     * // enable the `DropdownMenu` plugin
     * // and modify individual context menu options
     * dropdownMenu: ['row_above', 'row_below', '---------', 'undo', 'redo'],
     *
     * // enable the `DropdownMenu` plugin
     * // and apply a custom dropdown menu configuration
     * dropdownMenu: {
     *   items: {
     *     'option1': {
     *       name: 'Option 1'
     *     },
     *     'option2': {
     *       name: 'Option 2',
     *       submenu: {
     *         items: [
     *           {
     *             key: 'option2:suboption1',
     *             name: 'Suboption 1',
     *             callback(key, options) {
     *               ...
     *             }
     *           },
     *           ...
     *         ]
     *       }
     *     }
     *   }
     * },
     * ```
     */
    dropdownMenu: void 0,
    /**
     * The `editor` option sets a [cell editor](@/guides/cell-functions/cell-editor.md) for a cell.
     *
     * You can set the `editor` option to one of the following [cell editor aliases](@/guides/cell-functions/cell-editor.md):
     *
     * | Alias               | Cell editor function                                                       |
     * | ------------------- | -------------------------------------------------------------------------- |
     * | A custom alias      | Your [custom cell editor](@/guides/cell-functions/cell-editor.md) function |
     * | `'autocomplete'`    | `AutocompleteEditor`                                                       |
     * | `'base'`            | `BaseEditor`                                                               |
     * | `'checkbox'`        | `CheckboxEditor`                                                           |
     * | `'date'`            | `DateEditor`                                                               |
     * | `'dropdown'`        | `DropdownEditor`                                                           |
     * | `'handsontable'`    | `HandsontableEditor`                                                       |
     * | `'numeric'`         | `NumericEditor`                                                            |
     * | `'password'`        | `PasswordEditor`                                                           |
     * | `'select'`          | `SelectEditor`                                                             |
     * | `'text'`            | `TextEditor`                                                               |
     * | `'time'`            | `TimeEditor`                                                               |
     *
     * To disable editing cells through cell editors,
     * set the `editor` option to `false`.
     * You'll still be able to change cells' content through Handsontable's API
     * or through plugins (e.g. [`CopyPaste`](@/api/copyPaste.md)), though.
     *
     * To set the [`editor`](#editor), [`renderer`](#renderer), and [`validator`](#validator)
     * options all at once, use the [`type`](#type) option.
     *
     * Read more:
     * - [Cell editor](@/guides/cell-functions/cell-editor.md)
     * - [Cell type](@/guides/cell-types/cell-type.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options.md#cascading-configuration)
     * - [`type`](#type)
     *
     * @memberof Options#
     * @type {string|Function|boolean}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // use the `numeric` editor for each cell of the entire grid
     * editor: 'numeric',
     *
     * // apply the `editor` option to individual columns
     * columns: [
     *   {
     *     // use the `autocomplete` editor for each cell of this column
     *     editor: 'autocomplete'
     *   },
     *   {
     *     // disable editing cells through cell editors for each cell of this column
     *     editor: false
     *   }
     * ]
     * ```
     */
    editor: void 0,
    /**
     * The `enterBeginsEditing` option configures the action of the <kbd>**Enter**</kbd> key.
     *
     * You can set the `enterBeginsEditing` option to one of the following:
     *
     * | Setting          | Description                                                                                                                                                                                               |
     * | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | - On pressing <kbd>**Enter**</kbd> once, enter the editing mode of the active cell<br>- On pressing <kbd>**Enter**</kbd> twice, move to another cell,<br>as configured by the [`enterMoves`](#enterMoves) setting |
     * | `false`          | - On pressing <kbd>**Enter**</kbd> once, move to another cell,<br>as configured by the [`enterMoves`](#enterMoves) setting                                                                                    |
     *
     * Read more:
     * - [`enterMoves`](#enterMoves)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // press Enter once to start editing
     * // press Enter twice to move to another cell
     * enterBeginsEditing: true,
     *
     * // press Enter once to move to another cell
     * enterBeginsEditing: false,
     * ```
     */
    enterBeginsEditing: true,
    /**
     * The `enterMoves` option configures the action of the <kbd>**Enter**</kbd> key.
     *
     * If the [`enterBeginsEditing`](#enterBeginsEditing) option is set to `true`,
     * the `enterMoves` setting applies to the **second** pressing of the <kbd>**Enter**</kbd> key.
     *
     * If the [`enterBeginsEditing`](#enterBeginsEditing) option is set to `false`,
     * the `enterMoves` setting applies to the **first** pressing of the <kbd>**Enter**</kbd> key.
     *
     * You can set the `enterMoves` option to an object with the following properties
     * (or to a function that returns such an object):
     *
     * | Property | Type   | Description                                                                                                                                              |
     * | -------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `col`    | Number | - On pressing <kbd>**Enter**</kbd>, move selection `col` columns right<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Enter**</kbd>, move selection `col` columns left |
     * | `row`    | Number | - On pressing <kbd>**Enter**</kbd>, move selection `row` rows down<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Enter**</kbd>, move selection `row` rows up          |
     *
     * Read more:
     * - [`enterBeginsEditing`](#enterBeginsEditing)
     *
     * @memberof Options#
     * @type {object|Function}
     * @default {col: 0, row: 1}
     * @category Core
     *
     * @example
     * ```js
     * // on pressing Enter, move selection 1 column right and 1 row down
     * // on pressing Shift+Enter, move selection 1 column left and 1 row up
     * enterMoves: {col: 1, row: 1},
     *
     * // the same setting, as a function
     * // `event` is a DOM Event object received on pressing Enter
     * // you can use it to check whether the user pressed Enter or Shift+Enter
     * enterMoves(event) {
     *   return {col: 1, row: 1};
     * },
     * ```
     */
    enterMoves: {
      col: 0,
      row: 1
    },
    /**
     * The `fillHandle` option configures the [Autofill](@/api/autofill.md) plugin.
     *
     * You can set the `fillHandle` option to one the following:
     *
     * | Setting        | Description                                                                |
     * | -------------- | -------------------------------------------------------------------------- |
     * | `true`         | - Enable autofill in all directions<br>- Add the fill handle               |
     * | `false`        | Disable autofill                                                           |
     * | `'vertical'`   | - Enable vertical autofill<br>- Add the fill handle                        |
     * | `'horizontal'` | - Enable horizontal autofill<br>- Add the fill handle                      |
     * | An object      | - Enable autofill<br>- Add the fill handle<br>- Configure autofill options |
     *
     * If you set the `fillHandle` option to an object, you can configure the following autofill options:
     *
     * | Option          | Possible settings              | Description                                                                                               |
     * | --------------- | ------------------------------ | --------------------------------------------------------------------------------------------------------- |
     * | `autoInsertRow` | `true` (default) \| `false`    | `true`: When you reach the grid's bottom, add new rows<br>`false`: When you reach the grid's bottom, stop |
     * | `direction`     | `'vertical'` \| `'horizontal'` | `'vertical'`: Enable vertical autofill<br>`'horizontal'`: Enable horizontal autofill                      |
     *
     * Read more:
     * - [AutoFill values](@/guides/cell-features/autofill-values.md)
     *
     * @memberof Options#
     * @type {boolean|string|object}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // enable autofill in all directions
     * // with `autoInsertRow` enabled
     * fillHandle: true,
     *
     * // enable vertical autofill
     * // with `autoInsertRow` enabled
     * fillHandle: 'vertical',
     *
     * // enable horizontal autofill
     * // with `autoInsertRow` enabled
     * fillHandle: 'horizontal',
     *
     * // enable autofill in all directions
     * // with `autoInsertRow` disabled
     * fillHandle: {
     *   autoInsertRow: false,
     * },
     *
     * // enable vertical autofill
     * // with `autoInsertRow` disabled
     * fillHandle: {
     *   autoInsertRow: false,
     *   direction: 'vertical'
     * },
     * ```
     */
    fillHandle: {
      autoInsertRow: false
    },
    /**
     * The `filter` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells'
     * lists are updated by the end user's input.
     *
     * You can set the `filter` option to one of the following:
     *
     * | Setting          | Description                                                                                                           |
     * | ---------------- | --------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | When the end user types into the input area, only options matching the input are displayed                            |
     * | `false`          | When the end user types into the input area, all options are displayed<br>(options matching the input are put in bold |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [`source`](#source)
     * - [`filteringCaseSensitive`](#filteringCaseSensitive)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['A', 'B', 'C'],
     *   // when the end user types in `A`, display only the A option
     *   // when the end user types in `B`, display only the B option
     *   // when the end user types in `C`, display only the C option
     *   filter: true
     * }],
     * ```
     */
    filter: true,
    /**
     * The `filteringCaseSensitive` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells'
     * input is case-sensitive.
     *
     * You can set the `filteringCaseSensitive` option to one of the following:
     *
     * | Setting           | Description                                                                                        |
     * | ----------------- | -------------------------------------------------------------------------------------------------- |
     * | `false` (default) | [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells' input is not case-sensitive |
     * | `true`            | [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells' input is case-sensitive     |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [`source`](#source)
     * - [`filter`](#filter)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     type: 'autocomplete',
     *     source: [ ... ],
     *     // match case while searching autocomplete options
     *     filteringCaseSensitive: true
     *   }
     * ],
     * ```
     */
    filteringCaseSensitive: false,
    /**
     * The `filters` option configures the [`Filters`](@/api/filters.md) plugin.
     *
     * You can set the `filters` option to one of the following:
     *
     * | Setting | Description                                      |
     * | ------- | ------------------------------------------------ |
     * | `false` | Disable the [`Filters`](@/api/filters.md) plugin |
     * | `true`  | Enable the [`Filters`](@/api/filters.md) plugin  |
     *
     * Read more:
     * - [Column filter](@/guides/columns/column-filter.md)
     * - [Plugins: `Filters`](@/api/filters.md)
     * - [`dropdownMenu`](#dropdownMenu)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category Filters
     *
     * @example
     * ```js
     * // enable the `Filters` plugin
     * filters: true,
     * ```
     */
    filters: void 0,
    /**
     * `fixedColumnsLeft` is a legacy option.
     *
     * If your grid's [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default), `fixedColumnsLeft` acts like the [`fixedColumnsStart`](#fixedColumnsStart) option.
     *
     * If your grid's [layout direction](@/guides/internationalization/layout-direction.md) is RTL, using `fixedColumnsLeft` throws an error.
     *
     * Use [`fixedColumnsStart`](#fixedColumnsStart), which works in any layout direction.
     *
     * Read more:
     * - [`fixedColumnsStart`](#fixedcolumnsstart)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // freeze the first 3 columns from the left
     * fixedColumnsLeft: 3,
     * ```
     */
    fixedColumnsLeft: 0,
    /**
     * If your grid's [layout direction](@/guides/internationalization/layout-direction.md) is LTR (default), the `fixedColumnsStart` option sets the number of [frozen columns](@/guides/columns/column-freezing.md) at the left-hand edge of the grid.
     *
     * If your grid's [layout direction](@/guides/internationalization/layout-direction.md) is RTL, the `fixedColumnsStart` option sets the number of [frozen columns](@/guides/columns/column-freezing.md) at the right-hand edge of the grid.
     *
     * Read more:
     * - [Column freezing](@/guides/columns/column-freezing.md)
     * - [Layout direction](@/guides/internationalization/layout-direction.md)
     * - [`fixedColumnsLeft`](#fixedcolumnsleft)
     * - [`layoutDirection`](#layoutDirection)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // when `layoutDirection` is set to `inherit` (default)
     * // freeze the first 3 columns from the left or from the right
     * // depending on your HTML document's `dir` attribute
     * layoutDirection: 'inherit',
     * fixedColumnsStart: 3,
     *
     * // when `layoutDirection` is set to `rtl`
     * // freeze the first 3 columns from the right
     * // regardless of your HTML document's `dir` attribute
     * layoutDirection: 'rtl',
     * fixedColumnsStart: 3,
     *
     * // when `layoutDirection` is set to `ltr`
     * // freeze the first 3 columns from the left
     * // regardless of your HTML document's `dir` attribute
     * layoutDirection: 'ltr',
     * fixedColumnsStart: 3,
     * ```
     */
    fixedColumnsStart: 0,
    /**
     * The `fixedRowsBottom` option sets the number of [frozen rows](@/guides/rows/row-freezing.md)
     * at the bottom of the grid.
     *
     * Read more:
     * - [Row freezing](@/guides/rows/row-freezing.md)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // freeze the bottom 3 rows
     * fixedRowsBottom: 3,
     * ```
     */
    fixedRowsBottom: 0,
    /**
     * The `fixedRowsTop` option sets the number of [frozen rows](@/guides/rows/row-freezing.md) at the top of the grid.
     *
     * Read more:
     * - [Row freezing](@/guides/rows/row-freezing.md)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // freeze the top 3 rows
     * fixedRowsTop: 3,
     * ```
     */
    fixedRowsTop: 0,
    /**
     * The `formulas` option configures the [`Formulas`](@/api/formulas.md) plugin.
     *
     * The [`Formulas`](@/api/formulas.md) plugin uses the [HyperFormula](https://handsontable.github.io/hyperformula/) calculation engine.
     * To install [HyperFormula](https://handsontable.github.io/hyperformula/), read the following:
     * - [Formula calculation: Initialization methods](@/guides/formulas/formula-calculation.md#initialization-methods)
     *
     * You can set the `formulas` option to an object with the following properties:
     *
     * | Property    | Possible values                                                                                                                                                                                                        |
     * | ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `engine`    | `HyperFormula` \|<br>A [HyperFormula](https://handsontable.github.io/hyperformula/) instance \|<br>A [HyperFormula configuration](https://handsontable.github.io/hyperformula/api/interfaces/configparams.html) object |
     * | `sheetId`   | A number                                                                                                                                                                                                               |
     * | `sheetName` | A string                                                                                                                                                                                                               |
     *
     * Read more:
     * - [Plugins: `Formulas`](@/api/formulas.md)
     * - [Formula calculation](@/guides/formulas/formula-calculation.md)
     * - [HyperFormula documentation: Client-side installation](https://handsontable.github.io/hyperformula/guide/client-side-installation)
     * - [HyperFormula documentation: Configuration options](https://handsontable.github.io/hyperformula/api/interfaces/configparams.html)
     *
     * @memberof Options#
     * @type {object}
     * @default undefined
     * @category Formulas
     *
     * @example
     * ```js
     * // either add the `HyperFormula` class
     * formulas: {
     *   // set `engine` to `HyperFormula`
     *   engine: HyperFormula,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // or, add a HyperFormula instance
     * // initialized with the `'internal-use-in-handsontable'` license key
     * const hyperformulaInstance = HyperFormula.buildEmpty({
     *   licenseKey: 'internal-use-in-handsontable',
     * });
     *
     * formulas: {
     *   // set `engine` to a HyperFormula instance
     *   engine: hyperFormulaInstance,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // or, add a HyperFormula configuration object
     * formulas: {
     *   // set `engine` to a HyperFormula configuration object
     *   engine: {
     *     hyperformula: HyperFormula // or `engine: hyperFormulaInstance`
     *     leapYear1900: false,       // this option comes from HyperFormula
     *     // add more HyperFormula configuration options
     *   },
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // use the same HyperFormula instance in multiple Handsontable instances
     *
     * // a Handsontable instance `hot1`
     * formulas: {
     *   engine: HyperFormula,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // a Handsontable instance `hot2`
     * formulas: {
     *   engine: hot1.getPlugin('formulas').engine,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     * ```
     */
    formulas: void 0,
    /**
     * The `fragmentSelection` option configures text selection settings.
     *
     * You can set the `fragmentSelection` option to one of the following:
     *
     * | Setting           | Decription                                        |
     * | ----------------- | ------------------------------------------------- |
     * | `false` (default) | Disable text selection                            |
     * | `true`            | Enable text selection in multiple cells at a time |
     * | `'cell'`          | Enable text selection in one cell at a time       |
     *
     * @memberof Options#
     * @type {boolean|string}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // enable text selection in multiple cells at a time
     * fragmentSelection: true,
     *
     * // enable text selection in one cell a time
     * fragmentSelection: 'cell',
     * ```
     */
    fragmentSelection: false,
    /**
     * The `height` option configures the height of your grid.
     *
     * You can set `height` option to one of the following:
     *
     * | Setting                                                                    | Example                    |
     * | -------------------------------------------------------------------------- | -------------------------- |
     * | A number of pixels                                                         | `height: 500`              |
     * | A string with a [CSS unit](https://www.w3schools.com/cssref/css_units.asp) | `height: '75vw'`           |
     * | A function that returns a valid number or string                           | `height() { return 500; }` |
     *
     * Read more:
     * - [Grid size](@/guides/getting-started/grid-size.md)
     *
     * @memberof Options#
     * @type {number|string|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the grid's height to 500px
     * height: 500,
     *
     * // set the grid's height to 75vh
     * height: '75vh',
     *
     * // set the grid's height to 500px, using a function
     * height() {
     *   return 500;
     * },
     * ```
     */
    height: void 0,
    /**
     * The `hiddenColumns` option configures the [`HiddenColumns`](@/api/hiddenColumns.md) plugin.
     *
     * You can set the `hiddenColumns` option to one of the following:
     *
     * | Setting   | Description                                                                                  |
     * | --------- | -------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`HiddenColumns`](@/api/hiddenColumns.md) plugin                                 |
     * | `true`    | Enable the [`HiddenColumns`](@/api/hiddenColumns.md) plugin with the default plugin options  |
     * | An object | - Enable the [`HiddenColumns`](@/api/hiddenColumns.md) plugin<br>- Modify the plugin options |
     *
     * If you set the `hiddenColumns` to an object, you can set the following [`HiddenColumns`](@/api/hiddenColumns.md) plugin options:
     *
     * | Property           | Possible values     | Description                                                                                                                                             |
     * | ------------------ | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `columns`          | An array of indexes | An array of indexes of columns that are hidden at initialization                                                                                        |
     * | `copyPasteEnabled` | `true` \| `false`   | `true`: when copying or pasting data, take hidden columns into account<br>`false`: when copying or pasting data, don't take hidden columns into account |
     * | `indicators`       | `true` \| `false`   | `true`: display UI markers to indicate the presence of hidden columns<br>`false`: display UI markers                                                    |
     *
     * Read more:
     * - [Plugins: `HiddenColumns`](@/api/hiddenColumns.md)
     * - [Column hiding](@/guides/columns/column-hiding.md)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category HiddenColumns
     *
     * @example
     * ```js
     * // enable the `HiddenColumns` plugin
     * hiddenColumns: true,
     *
     * // enable `HiddenColumns` plugin, and modify the plugin options
     * hiddenColumns: {
     *   // set columns that are hidden by default
     *   columns: [5, 10, 15],
     *   // when copying or pasting data, take hidden columns into account
     *   copyPasteEnabled: true,
     *   // show where hidden columns are
     *   indicators: true
     * }
     * ```
     */
    hiddenColumns: void 0,
    /**
     * The `hiddenRows` option configures the [`HiddenRows`](@/api/hiddenRows.md) plugin.
     *
     * You can set the `hiddenRows` option to one of the following:
     *
     * | Setting   | Description                                                                            |
     * | --------- | -------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`HiddenRows`](@/api/hiddenRows.md) plugin                                 |
     * | `true`    | Enable the [`HiddenRows`](@/api/hiddenRows.md) plugin with the default plugin options  |
     * | An object | - Enable the [`HiddenRows`](@/api/hiddenRows.md) plugin<br>- Modify the plugin options |
     *
     * If you set the `hiddenRows` to an object, you can set the following [`HiddenRows`](@/api/hiddenRows.md) plugin options:
     *
     * | Property           | Possible values     | Description                                                                                                                                       |
     * | ------------------ | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `rows   `          | An array of indexes | An array of indexes of rows that are hidden at initialization                                                                                     |
     * | `copyPasteEnabled` | `true` \| `false`   | `true`: when copying or pasting data, take hidden rows into account<br>`false`: when copying or pasting data, don't take hidden rows into account |
     * | `indicators`       | `true` \| `false`   | `true`: display UI markers to indicate the presence of hidden rows<br>`false`: display UI markers                                                 |
     *
     * Read more:
     * - [Plugins: `HiddenRows`](@/api/hiddenRows.md)
     * - [Row hiding](@/guides/rows/row-hiding.md)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category HiddenRows
     *
     * @example
     * ```js
     * // enable the `HiddenRows` plugin
     * hiddenRows: true,
     *
     * // enable `HiddenRows` plugin, and modify the plugin options
     * hiddenRows: {
     *   // set rows that are hidden by default
     *   rows: [5, 10, 15],
     *   // when copying or pasting data, take hidden rows into account
     *   copyPasteEnabled: true,
     *   // show where hidden rows are
     *   indicators: true
     * }
     * ```
     */
    hiddenRows: void 0,
    /**
     * The `invalidCellClassName` option lets you add a CSS class name to cells
     * that were marked as `invalid` by the [cell validator](@/guides/cell-functions/cell-validator.md).
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htInvalid'
     * @category Core
     *
     * @example
     * ```js
     * // add a `highlight-error` CSS class name
     * // to every `invalid` cell`
     * invalidCellClassName: 'highlight-error',
     * ```
     */
    invalidCellClassName: "htInvalid",
    /**
     * The `isEmptyCol` option lets you define your own custom method
     * for checking if a column at a given visual index is empty.
     *
     * The `isEmptyCol` setting overwrites the built-in [`isEmptyCol`](@/api/core.md#isEmptyCol) method.
     *
     * @memberof Options#
     * @type {Function}
     * @param {number} col Visual column index.
     * @returns {boolean}
     * @category Core
     *
     * @example
     * ```js
     * // overwrite the built-in `isEmptyCol` method
     * isEmptyCol(visualColumnIndex) {
     *    // your custom method
     *    ...
     * },
     * ```
     */
    isEmptyCol(col) {
      let row;
      let rowLen;
      let value;
      for (row = 0, rowLen = this.countRows(); row < rowLen; row++) {
        value = this.getDataAtCell(row, col);
        if (isEmpty(value) === false) {
          return false;
        }
      }
      return true;
    },
    /**
     * The `isEmptyRow` option lets you define your own custom method
     * for checking if a row at a given visual index is empty.
     *
     * The `isEmptyRow` setting overwrites the built-in [`isEmptyRow`](@/api/core.md#isEmptyRow) method.
     *
     * @memberof Options#
     * @type {Function}
     * @param {number} row Visual row index.
     * @returns {boolean}
     * @category Core
     *
     * @example
     * ```js
     * // overwrite the built-in `isEmptyRow` method
     * isEmptyRow(visualRowIndex) {
     *    // your custom method
     *    ...
     * },
     * ```
     */
    isEmptyRow(row) {
      let col;
      let colLen;
      let value;
      let meta;
      for (col = 0, colLen = this.countCols(); col < colLen; col++) {
        value = this.getDataAtCell(row, col);
        if (isEmpty(value) === false) {
          if (typeof value === "object") {
            meta = this.getCellMeta(row, col);
            return isObjectEqual(this.getSchema()[meta.prop], value);
          }
          return false;
        }
      }
      return true;
    },
    /**
     * @description
     * The `label` option configures [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cells` labels.
     *
     * You can set the `label` option to an object with the following properties:
     *
     * | Property    | Possible values                   | Description                                                                                                                                                                                                             |
     * | ----------- | --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `position`  | `'after'` (default) \| `'before'` | `'after'`: place the label to the right of the checkbox<br>`'before'`: place the label to the left of the checkbox                                                                                                      |
     * | `value`     | A string \| A function            | The label's text                                                                                                                                                                                                        |
     * | `separated` | `false` (default) \| `true`       | `false`: don't separate the label from the checkbox<br>`true`: separate the label from the checkbox                                                                                                                     |
     * | `property`  | A string                          | - A [`data`](#data) object property name that's used as the label's text <br>- Works only when the [`data`](#data) option is set to an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects) |
     *
     * Read more:
     * - [Checkbox cell type: Checkbox labels](@/guides/cell-types/checkbox-cell-type.md#checkbox-labels)
     *
     * @memberof Options#
     * @type {object}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [{
     *   type: 'checkbox',
     *   // add 'My label:' after the checkbox
     *   label: { position: 'after', value: 'My label: ', separated: true }
     * }],
     * ```
     */
    label: void 0,
    /**
     * The `language` option configures Handsontable's [language](@/guides/internationalization/language.md) settings.
     *
     * You can set the `language` option to one of the following:
     *
     * | Setting             | Description                 |
     * | ------------------- | --------------------------- |
     * | `'en-US'` (default) | English - United States     |
     * | `'ar-AR'`           | Arabic - Global.<br><br>To properly render this language, set the [layout direction](@/guides/internationalization/layout-direction.md) to RTL. |
     * | `'cs-CZ'`           | Czech - Czech Republic      |
     * | `'de-CH'`           | German - Switzerland        |
     * | `'de-DE'`           | German - Germany            |
     * | `'es-MX'`           | Spanish - Mexico            |
     * | `'fr-FR'`           | French - France             |
     * | `'it-IT'`           | Italian - Italy             |
     * | `'ja-JP'`           | Japanese - Japan            |
     * | `'ko-KR'`           | Korean - Korea              |
     * | `'lv-LV'`           | Latvian - Latvia            |
     * | `'nb-NO'`           | Norwegian (Bokmål) - Norway |
     * | `'nl-NL'`           | Dutch - Netherlands         |
     * | `'pl-PL'`           | Polish - Poland             |
     * | `'pt-BR'`           | Portuguese - Brazil         |
     * | `'ru-RU'`           | Russian - Russia            |
     * | `'sr-SP'`           | Serbian (Latin) - Serbia    |
     * | `'zh-CN'`           | Chinese - China             |
     * | `'zh-TW'`           | Chinese - Taiwan            |
     *
     * Read more:
     * - [Language](@/guides/internationalization/language.md)
     * - [`locale`](#locale)
     * - [`layoutDirection`](#layoutdirection)
     *
     * @memberof Options#
     * @type {string}
     * @default 'en-US'
     * @category Core
     *
     * @example
     * ```js
     * // set Handsontable's language to Polish
     * language: 'pl-PL',
     * ```
     */
    language: "en-US",
    /**
     * The `layoutDirection` option configures whether Handsontable renders from the left to the right, or from the right to the left.
     *
     * You can set the layout direction only at Handsontable's [initialization](@/guides/getting-started/installation.md#initialize-handsontable). Any change of the `layoutDirection` option after the initialization (e.g. using the [`updateSettings()`](@/api/core.md#updatesettings) method) is ignored.
     *
     * You can set the `layoutDirection` option only [for the entire grid](@/guides/getting-started/configuration-options.md#set-grid-options).
     * You can't set it for individual columns, rows, or cells.
     *
     * You can set the `layoutDirection` option to one of the following strings:
     *
     * | Setting             | Description                                                                                                                                                                                  |
     * | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `inherit` (default) | Set Handsontable's layout direction automatically,<br>based on the value of your HTML document's [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) attribute  |
     * | `rtl`               | Render Handsontable from the right to the left,<br>even when your HTML document's [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) attribute is set to `ltr` |
     * | `ltr`               | Render Handsontable from the left to the right,<br>even when your HTML document's [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) attribute is set to `rtl` |
     *
     * Read more:
     * - [Layout direction](@/guides/internationalization/layout-direction.md)
     * - [Language](@/guides/internationalization/language.md)
     * - [`language`](#language)
     * - [`locale`](#locale)
     * - [`fixedColumnsStart`](#fixedcolumnsstart)
     * - [`customBorders`](#customBorders)
     *
     * @memberof Options#
     * @type {string}
     * @default 'inherit'
     * @category Core
     *
     * @example
     * ```js
     * // inherit Handsontable's layout direction
     * // from the value of your HTML document's `dir` attribute
     * layoutDirection: 'inherit',
     *
     * // render Handsontable from the right to the left
     * // regardless of your HTML document's `dir`
     * layoutDirection: 'rtl',
     *
     * // render Handsontable from the left to the right
     * // regardless of your HTML document's `dir`
     * layoutDirection: 'ltr',
     * ```
     */
    layoutDirection: "inherit",
    /**
     * The `licenseKey` option sets your Handsontable license key.
     *
     * You can set the `licenseKey` option to one of the following:
     *
     * | Setting                                                                                                 | Description                                                                                       |
     * | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
     * | A string with your [commercial license key](@/guides/getting-started/license-key.md#commercial-license) | For [commercial use](@/guides/technical-specification/software-license.md#commercial-use)         |
     * | `'non-commercial-and-evaluation'`                                                                       | For [non-commercial use](@/guides/technical-specification/software-license.md#non-commercial-use) |
     *
     * Read more:
     * - [License key](@/guides/getting-started/license-key.md)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // for commercial use
     * licenseKey: 'xxxxx-xxxxx-xxxxx-xxxxx-xxxxx', // your commercial license key
     *
     * // for non-commercial use
     * licenseKey: 'non-commercial-and-evaluation',
     * ```
     */
    licenseKey: void 0,
    /**
     * The `locale` option configures Handsontable's [locale](@/guides/internationalization/locale.md) settings.
     *
     * You can set the `locale` option to any valid and canonicalized Unicode BCP 47 locale tag,
     * both for the [entire grid](@/guides/internationalization/locale.md#set-the-grid-s-locale),
     * and for [individual columns](@/guides/internationalization/locale.md#set-a-column-s-locale).
     *
     * Read more:
     * - [Locale](@/guides/internationalization/locale.md)
     * - [`language`](#language)
     * - [`layoutDirection`](#layoutdirection)
     *
     * @memberof Options#
     * @type {string}
     * @default 'en-US'
     * @category Core
     *
     * @example
     * ```js
     * // set the entire grid's locale to Polish
     * locale: 'pl-PL',
     *
     * // set individual columns' locales
     * columns: [
     *   {
     *     // set the first column's locale to Polish
     *     locale: 'pl-PL',
     *   },
     *   {
     *     // set the second column's locale to German
     *     locale: 'de-DE',
     *   },
     * ],
     * ```
     */
    locale: "en-US",
    /**
     * The `manualColumnFreeze` option configures the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin.
     *
     * You can set the `manualColumnFreeze` option to one of the following:
     *
     * | Setting  | Description                                                            |
     * | -------- | ---------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin  |
     * | `false`  | Disable the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin |
     *
     * Read more:
     * - [Column freezing](@/guides/columns/column-freezing.md#user-triggered-freeze)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category ManualColumnFreeze
     *
     * @example
     * ```js
     * // enable the `ManualColumnFreeze` plugin
     * manualColumnFreeze: true,
     * ```
     */
    manualColumnFreeze: void 0,
    /**
     * The `manualColumnMove` option configures the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin.
     *
     * You can set the `manualColumnMove` option to one of the following:
     *
     * | Setting  | Description                                                                                                        |
     * | -------- | ------------------------------------------------------------------------------------------------------------------ |
     * | `true`   | Enable the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin                                                  |
     * | `false`  | Disable the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin                                                 |
     * | An array | - Enable the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin<br>- Move individual columns at initialization |
     *
     * Read more:
     * - [Column moving](@/guides/columns/column-moving.md)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualColumnMove
     *
     * @example
     * ```js
     * // enable the `ManualColumnMove` plugin
     * manualColumnMove: true,
     *
     * // enable the `ManualColumnMove` plugin
     * // at initialization, move column 0 to 1
     * // at initialization, move column 1 to 4
     * // at initialization, move column 2 to 6
     * manualColumnMove: [1, 4, 6],
     * ```
     */
    manualColumnMove: void 0,
    /**
     * @description
     * The `manualColumnResize` option configures the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin.
     *
     * You can set the `manualColumnResize` option to one of the following:
     *
     * | Setting  | Description                                                                                                           |
     * | -------- | --------------------------------------------------------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin                                                 |
     * | `false`  | Disable the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin                                                |
     * | An array | - Enable the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin<br>- Set initial widths of individual columns |
     *
     * Read more:
     * - [Column width: Column stretching](@/guides/columns/column-width.md#column-stretching)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualColumnResize
     *
     * @example
     * ```js
     * // enable the `manualColumnResize` plugin
     * manualColumnResize: true,
     *
     * // enable the `manualColumnResize` plugin
     * // set the initial width of column 0 to 40 pixels
     * // set the initial width of column 1 to 50 pixels
     * // set the initial width of column 2 to 60 pixels
     * manualColumnResize: [40, 50, 60],
     * ```
     */
    manualColumnResize: void 0,
    /**
     * @description
     * The `manualRowMove` option configures the [`ManualRowMove`](@/api/manualRowMove.md) plugin.
     *
     * You can set the `manualRowMove` option to one of the following:
     *
     * | Setting  | Description                                                                                               |
     * | -------- | --------------------------------------------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualRowMove`](@/api/manualRowMove.md) plugin                                               |
     * | `false`  | Disable the [`ManualRowMove`](@/api/manualRowMove.md) plugin                                              |
     * | An array | - Enable the [`ManualRowMove`](@/api/manualRowMove.md) plugin<br>- Move individual rows at initialization |
     *
     * Read more:
     * - [Row moving](@/guides/rows/row-moving.md)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualRowMove
     *
     * @example
     * ```js
     * // enable the `ManualRowMove` plugin
     * manualRowMove: true,
     *
     * // enable the `ManualRowMove` plugin
     * // at initialization, move row 0 to 1
     * // at initialization, move row 1 to 4
     * // at initialization, move row 2 to 6
     * manualColumnMove: [1, 4, 6],
     * ```
     */
    manualRowMove: void 0,
    /**
     * @description
     * The `manualRowResize` option configures the [`ManualRowResize`](@/api/manualRowResize.md) plugin.
     *
     * You can set the `manualRowResize` option to one of the following:
     *
     * | Setting  | Description                                                                                                   |
     * | -------- | ------------------------------------------------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualRowResize`](@/api/manualRowResize.md) plugin                                               |
     * | `false`  | Disable the [`ManualRowResize`](@/api/manualRowResize.md) plugin                                              |
     * | An array | - Enable the [`ManualRowResize`](@/api/manualRowResize.md) plugin<br>- Set initial heights of individual rows |
     *
     * Read more:
     * - [Row height: Adjust the row height manually](@/guides/rows/row-height.md#adjust-the-row-height-manually)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualRowResize
     *
     * @example
     * ```js
     * // enable the `ManualRowResize` plugin
     * manualRowResize: true,
     *
     * // enable the `ManualRowResize` plugin
     * // set the initial height of row 0 to 40 pixels
     * // set the initial height of row 1 to 50 pixels
     * // set the initial height of row 2 to 60 pixels
     * manualRowResize: [40, 50, 60],
     * ```
     */
    manualRowResize: void 0,
    /**
     * The `maxCols` option sets a maximum number of columns.
     *
     * The `maxCols` option is used:
     * - At initialization: if the `maxCols` value is lower than the initial number of columns,
     * Handsontable trims columns from the right.
     * - At runtime: for example, when inserting columns.
     *
     * @memberof Options#
     * @type {number}
     * @default Infinity
     * @category Core
     *
     * @example
     * ```js
     * // set the maximum number of columns to 300
     * maxCols: 300,
     * ```
     */
    maxCols: Infinity,
    /**
     * The `maxRows` option sets a maximum number of rows.
     *
     * The `maxRows` option is used:
     * - At initialization: if the `maxRows` value is lower than the initial number of rows,
     * Handsontable trims rows from the bottom.
     * - At runtime: for example, when inserting rows.
     *
     * @memberof Options#
     * @type {number}
     * @default Infinity
     * @category Core
     *
     * @example
     * ```js
     * // set the maximum number of rows to 300
     * maxRows: 300,
     * ```
     */
    maxRows: Infinity,
    /**
     * @description
     * The `mergeCells` option configures the [`MergeCells`](@/api/mergeCells.md) plugin.
     *
     * You can set the `mergeCells` option to one of the following:
     *
     * | Setting             | Description                                                                                         |
     * | ------------------- | --------------------------------------------------------------------------------------------------- |
     * | `true`              | Enable the [`MergeCells`](@/api/mergeCells.md) plugin                                               |
     * | `false`             | Disable the [`MergeCells`](@/api/mergeCells.md) plugin                                              |
     * | An array of objects | - Enable the [`MergeCells`](@/api/mergeCells.md) plugin<br>- Merge specific cells at initialization |
     *
     * To merge specific cells at Handsontable's initialization,
     * set the `mergeCells` option to an array of objects, with the following properties:
     *
     * | Property  | Description                                                |
     * | --------- | ---------------------------------------------------------- |
     * | `row`     | The row index of the merged section's beginning            |
     * | `col`     | The column index of the merged section's beginning         |
     * | `rowspan` | The width (as a number of rows) of the merged section      |
     * | `colspan` | The height (as a number of columns ) of the merged section |
     *
     * Read more:
     * - [Merge cells](@/guides/cell-features/merge-cells.md)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default false
     * @category MergeCells
     *
     * @example
     * ```js
     * // enable the `MergeCells` plugin
     * mergeCells: true,
     *
     * // enable the `MergeCells` plugin
     * // and merge specific cells at initialization
     * mergeCells: [
     *   // merge cells from cell (1,1) to cell (3,3)
     *   {row: 1, col: 1, rowspan: 3, colspan: 3},
     *   // merge cells from cell (3,4) to cell (2,2)
     *   {row: 3, col: 4, rowspan: 2, colspan: 2},
     *   // merge cells from cell (5,6) to cell (3,3)
     *   {row: 5, col: 6, rowspan: 3, colspan: 3}
     * ],
     * ```
     */
    mergeCells: false,
    /**
     * The `minCols` option sets a minimum number of columns.
     *
     * The `minCols` option is used:
     * - At initialization: if the `minCols` value is higher than the initial number of columns,
     * Handsontable adds empty columns to the right.
     * - At runtime: for example, when removing columns.
     *
     * The `minCols` option works only when your [`data`](#data) is an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).
     * When your [`data`](#data) is an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects),
     * you can only have as many columns as defined in:
     * - The first data row
     * - The [`dataSchema`](#dataSchema) option
     * - The [`columns`](#columns) option
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // set the minimum number of columns to 10
     * minCols: 10,
     * ```
     */
    minCols: 0,
    /**
     * The `minRows` option sets a minimum number of rows.
     *
     * The `minRows` option is used:
     * - At initialization: if the `minRows` value is higher than the initial number of rows,
     * Handsontable adds empty rows at the bottom.
     * - At runtime: for example, when removing rows.
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // set the minimum number of rows to 10
     * minRows: 10,
     * ```
     */
    minRows: 0,
    /**
     * The `minSpareCols` option sets a minimum number of empty columns
     * at the grid's right-hand end.
     *
     * If there already are other empty columns at the grid's right-hand end,
     * they are counted into the `minSpareCols` value.
     *
     * The total number of columns can't exceed the [`maxCols`](#maxCols) value.
     *
     * The `minSpareCols` option works only when your [`data`](#data) is an [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays).
     * When your [`data`](#data) is an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects),
     * you can only have as many columns as defined in:
     * - The first data row
     * - The [`dataSchema`](#dataSchema) option
     * - The [`columns`](#columns) option
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // at Handsontable's initialization, add at least 3 empty columns on the right
     * minSpareCols: 3,
     * ```
     */
    minSpareCols: 0,
    /**
     * The `minSpareRows` option sets a minimum number of empty rows
     * at the bottom of the grid.
     *
     * If there already are other empty rows at the bottom,
     * they are counted into the `minSpareRows` value.
     *
     * The total number of rows can't exceed the [`maxRows`](#maxRows) value.
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // at Handsontable's initialization, add at least 3 empty rows at the bottom
     * minSpareRows: 3,
     * ```
     */
    minSpareRows: 0,
    /**
     * @description
     * The `multiColumnSorting` option configures the [`MultiColumnSorting`](@/api/columnSorting.md) plugin.
     *
     * You can set the `multiColumnSorting` option to one of the following:
     *
     * | Setting    | Description                                                                                                                                                |
     * | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`     | Enable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin with the default configuration                                                       |
     * | `false`    | Disable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin                                                                                     |
     * | An object  | - Enable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin<br>- Modify the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin options |
     *
     * If you set the `multiColumnSorting` option to an object,
     * you can set the following [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin options:
     *
     * | Option                   | Possible settings                                                                                                                                |
     * | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `indicator`              | `true`: Display the arrow icon in the column header, to indicate a sortable column<br>`false`: Don't display the arrow icon in the column header |
     * | `headerAction`           | `true`: Enable clicking on the column header to sort the column<br>`false`: Disable clicking on the column header to sort the column             |
     * | `sortEmptyCells`         | `true`: Sort empty cells as well<br>`false`: Place empty cells at the end                                                                        |
     * | `compareFunctionFactory` | A [custom compare function](@/guides/rows/rows-sorting.md#add-a-custom-comparator)                                                               |
     *
     * If you set the `multiColumnSorting` option to an object,
     * you can also sort individual columns at Handsontable's initialization.
     * In the `multiColumnSorting` object, add an object named `initialConfig`,
     * with the following properties:
     *
     * | Option      | Possible settings   | Description                                                      |
     * | ----------- | ------------------- | ---------------------------------------------------------------- |
     * | `column`    | A number            | The index of the column that you want to sort at initialization  |
     * | `sortOrder` | `'asc'` \| `'desc'` | The sorting order:<br>`'asc'`: ascending<br>`'desc'`: descending |
     *
     * Read more:
     * - [Rows sorting](@/guides/rows/rows-sorting.md)
     * - [`columnSorting`](#columnSorting)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category MultiColumnSorting
     *
     * @example
     * ```js
     * // enable the `MultiColumnSorting` plugin
     * multiColumnSorting: true
     *
     * // enable the `MultiColumnSorting` plugin with custom configuration
     * multiColumnSorting: {
     *   // sort empty cells as well
     *   sortEmptyCells: true,
     *   // display the arrow icon in the column header
     *   indicator: true,
     *   // disable clicking on the column header to sort the column
     *   headerAction: false,
     *   // add a custom compare function
     *   compareFunctionFactory(sortOrder, columnMeta) {
     *     return function(value, nextValue) {
     *       // some value comparisons which will return -1, 0 or 1...
     *     }
     *   }
     * }
     *
     * // enable the `MultiColumnSorting` plugin
     * multiColumnSorting: {
     *   // at initialization, sort column 1 in ascending order
     *   initialConfig: {
     *     column: 1,
     *     sortOrder: 'asc'
     *   },
     *   // at initialization, sort column 2 in descending order
     *   initialConfig: {
     *     column: 2,
     *     sortOrder: 'desc'
     *   }
     * }
     * ```
     */
    multiColumnSorting: void 0,
    /**
     * @description
     * The `nestedHeaders` option configures the [`NestedHeaders`](@/api/nestedHeaders.md) plugin.
     *
     * You can set the `nestedHeaders` option to one of the following:
     *
     * | Setting           | Description                                                                                                                           |
     * | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Disable the [`NestedHeaders`](@/api/nestedHeaders.md) plugin                                                                          |
     * | `true`            | - Enable the [`NestedHeaders`](@/api/nestedHeaders.md) plugin<br>- Don't configure any nested headers                                 |
     * | Array of arrays   | - Enable the [`NestedHeaders`](@/api/nestedHeaders.md) plugin<br>- Configure headers that are nested on Handsontable's initialization |
     *
     * If you set the `nestedHeaders` option to an array of arrays, each array configures one set of nested headers.
     *
     * Each array element configures one header, and can be one of the following:
     *
     * | Array element | Description                                                                                  |
     * | ------------- | -------------------------------------------------------------------------------------------- |
     * | A string      | The header's label                                                                           |
     * | An object     | Properties:<br>`label` (string): the header's label<br>`colspan` (integer): the column width |
     *
     * Read more:
     * - [Plugins: `NestedHeaders`](@/api/nestedHeaders.md)
     * - [Column groups: Nested headers](@/guides/columns/column-groups.md#nested-headers)
     *
     * @memberof Options#
     * @type {boolean|Array[]}
     * @default undefined
     * @category NestedHeaders
     *
     * @example
     * ```js
     * nestedHeaders: [
     *   ['A', {label: 'B', colspan: 8}, 'C'],
     *   ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],
     *   ['H', 'I', 'J', 'K', 'L', 'M', 'N', 'R', 'S', 'T']
     * ],
     * ```
     */
    nestedHeaders: void 0,
    /**
     * @description
     * The `nestedRows` option configures the [`NestedRows`](@/api/nestedRows.md) plugin.
     *
     * You can set the `nestedRows` option to one of the following:
     *
     * | Setting           | Description                                            |
     * | ----------------- | ------------------------------------------------------ |
     * | `false` (default) | Disable the [`NestedRows`](@/api/nestedRows.md) plugin |
     * | `true`            | Enable the [`NestedRows`](@/api/nestedRows.md) plugin  |
     *
     * Read more:
     * - [Plugins: `NestedRows`](@/api/nestedRows.md)
     *
     * @example
     * ```js
     * // enable the `NestedRows` plugin
     * nestedRows: true,
     * ```
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category NestedRows
     */
    nestedRows: void 0,
    /**
     * The `noWordWrapClassName` option lets you add a CSS class name
     * to each cell that has the [`wordWrap`](#wordWrap) option set to `false`.
     *
     * Read more:
     * - [`wordWrap`](#wordWrap)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htNoWrap'
     * @category Core
     *
     * @example
     * ```js
     * // add an `is-noWrapCell` CSS class name
     * // to each cell that doesn't wrap content
     * noWordWrapClassName: 'is-noWrapCell',
     * ```
     */
    noWordWrapClassName: "htNoWrap",
    /**
     * The `numericFormat` option configures the number format and the currency format
     * of [`numeric`](@/guides/cell-types/numeric-cell-type.md) cells` displayed output
     * in the numeric cell renderer.
     *
     * You can set the `numericFormat` option to an object with the following properties:
     *
     * | Property    | Possible values                                                               | Description     |
     * | ----------- | ----------------------------------------------------------------------------- | --------------- |
     * | `pattern`   | All [`numbro.js` number formats](https://numbrojs.com/format.html#numbers)    | Number format   |
     * | `culture`   | All [`numbro.js` currency formats](https://numbrojs.com/format.html#currency) | Currency format |
     *
     * The `numericFormat` option as no effect on the numeric cell editor.
     *
     * In the source data, numeric data is stored as JavaScript numbers.
     *
     * Read more:
     * - [Numeric cell type](@/guides/cell-types/numeric-cell-type.md)
     * - [Third-party licenses](@/guides/technical-specification/third-party-licenses.md)
     *
     * @memberof Options#
     * @since 0.35.0
     * @type {object}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `numeric`
     *     type: 'numeric',
     *     // set the `numericFormat` option for every `numeric` cell of this column
     *     numericFormat: {
     *       // set the number format
     *       pattern: '0,00',
     *       // set the currency format
     *       culture: 'en-US'
     *     }
     *   }
     * ],
     * ```
     */
    numericFormat: void 0,
    /**
     * If the `observeDOMVisibility` option is set to `true`,
     * Handsontable rerenders every time it detects that the grid was made visible in the DOM.
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // don't rerender the grid on visibility changes
     * observeDOMVisibility: false,
     * ```
     */
    observeDOMVisibility: true,
    /**
     * The `outsideClickDeselects` option determines what happens to the current [selection](@/guides/cell-features/selection.md)
     * when you click outside of the grid.
     *
     * You can set the `outsideClickDeselects` option to one of the following:
     *
     * | Setting          | Description                                                                                              |
     * | ---------------- | -------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | On a mouse click outside of the grid, clear the current [selection](@/guides/cell-features/selection.md) |
     * | `false`          | On a mouse click outside of the grid, keep the current [selection](@/guides/cell-features/selection.md)  |
     * | A function       | A function that takes the click event target and returns a boolean                                       |
     *
     * @memberof Options#
     * @type {boolean|Function}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // on a mouse click outside of the grid, clear the current selection
     * outsideClickDeselects: true,
     *
     * // on a mouse click outside of the grid, keep the current selection
     * outsideClickDeselects: false,
     *
     * // take the click event target and return `false`
     * outsideClickDeselects(event) {
     *   return false;
     * }
     *
     * // take the click event target and return `true`
     * outsideClickDeselects(event) {
     *   return false;
     * }
     * ```
     */
    outsideClickDeselects: true,
    /**
     * @description
     * The `persistentState` option configures the [`PersistentState`](@/api/persistentState.md) plugin.
     *
     * You can set the `persistentState` to one of the following:
     *
     * | Setting           | Description                                                      |
     * | ----------------- | ---------------------------------------------------------------- |
     * | `false` (default) | Disable the [`PersistentState`](@/api/persistentState.md) plugin |
     * | `true`            | Enable the [`PersistentState`](@/api/persistentState.md) plugin  |
     *
     * Read more:
     * - [Saving data: Saving data locally](@/guides/getting-started/saving-data.md#save-data-locally)
     * - [Plugins: `PersistentState`](@/api/persistentState.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category PersistentState
     *
     * @example
     * ```js
     * // enable the `PersistentState` plugin
     * persistentState: true,
     * ```
     */
    persistentState: void 0,
    /**
     * The `placeholder` option lets you display placeholder text in every empty cell.
     *
     * You can set the `placeholder` option to one of the following:
     *
     * | Setting            | Example        | Description                                                           |
     * | ------------------ | -------------- | --------------------------------------------------------------------- |
     * | A non-empty string | `'Empty cell'` | Display `Empty cell` text in empty cells                              |
     * | A non-string value | `000`          | Display `000` text in empty cells (non-string values get stringified) |
     *
     * Read more:
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // display 'Empty cell' text
     * // in every empty cell of the entire grid
     * placeholder: 'Empty cell',
     *
     * // or
     * columns: [
     *   {
     *     data: 'date',
     *     dateFormat: 'DD/MM/YYYY',
     *     // display 'Empty date cell' text
     *     // in every empty cell of the `date` column
     *     placeholder: 'Empty date cell'
     *   }
     * ],
     * ```
     */
    placeholder: void 0,
    /**
     * The `placeholderCellClassName` option lets you add a CSS class name to cells
     * that contain [`placeholder`](#placeholder) text.
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [`placeholder`](#placeholder)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htPlaceholder'
     * @category Core
     *
     * @example
     * ```js
     * // add a `has-placeholder` CSS class name
     * // to each cell that contains `placeholder` text
     * placeholderCellClassName: 'has-placeholder',
     * ```
     */
    placeholderCellClassName: "htPlaceholder",
    /**
     * The `preventOverflow` option configures preventing Handsontable
     * from overflowing outside of its parent element.
     *
     * You can set the `preventOverflow` option to one of the following:
     *
     * | Setting           | Description                      |
     * | ----------------- | -------------------------------- |
     * | `false` (default) | Don't prevent overflowing        |
     * | `'horizontal'`      | Prevent horizontal overflowing |
     * | `'vertical'`        | Prevent vertical overflowing   |
     *
     * @memberof Options#
     * @type {string|boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // prevent horizontal overflowing
     * preventOverflow: 'horizontal',
     * ```
     */
    preventOverflow: false,
    /**
     * The `preventWheel` option configures preventing the `wheel` event's default action
     * on overlays.
     *
     * You can set the `preventWheel` option to one of the following:
     *
     * | Setting           | Description                                      |
     * | ----------------- | ------------------------------------------------ |
     * | `false` (default) | Don't prevent the `wheel` event's default action |
     * | `true`            | Prevent the `wheel` event's default action       |
     *
     * @memberof Options#
     * @private
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // don't prevent the `wheel` event's default action
     * preventWheel: false,
     * ```
     */
    preventWheel: false,
    /**
     * @description
     * The `readOnly` option determines whether a cell, column or comment is editable or not.
     *
     * You can set the `readOnly` option to one of the following:
     *
     * | Setting           | Decription                                                                                                                |
     * | ----------------- | ------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Set as editable                                                                                                           |
     * | `true`            | - Set as read-only<br>- Add the [`readOnlyCellClassName`](#readOnlyCellClassName) CSS class name (by default: `htDimmed`) |
     *
     * `readOnly` cells can't be changed by the [`populateFromArray()`](@/api/core.md#populatefromarray) method.
     *
     * Read more:
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options.md#cascading-configuration)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // set as read-only
     * readOnly: true,
     * ```
     */
    readOnly: false,
    /**
     * The `readOnlyCellClassName` option lets you add a CSS class name to [read-only](#readOnly) cells.
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`TableClassName`](#TableClassName)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htDimmed'
     * @category Core
     *
     * @example
     * ```js
     * // add a `is-readOnly` CSS class name
     * // to every read-only cell
     * readOnlyCellClassName: 'is-readOnly',
     * ```
     */
    readOnlyCellClassName: "htDimmed",
    /**
     * The `renderAllRows` option configures Handsontable's [row virtualization](@/guides/rows/row-virtualization.md).
     *
     * You can set the `renderAllRows` option to one of the following:
     *
     * | Setting           | Description                                                                                        |
     * | ----------------- | -------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Enable [row virtualization](@/guides/rows/row-virtualization.md)                                   |
     * | `true`            | Disable [row virtualization](@/guides/rows/row-virtualization.md)<br>(render all rows of the grid) |
     *
     * Read more:
     * - [Row virtualization](@/guides/rows/row-virtualization.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // disable row virtualization
     * renderAllRows: true,
     * ```
     */
    renderAllRows: void 0,
    /**
     * @description
     * The `renderer` option sets a [cell renderer](@/guides/cell-functions/cell-renderer.md) for a cell.
     *
     * You can set the `renderer` option to one of the following:
     * - A custom renderer function
     * - One of the following [cell renderer aliases](@/guides/cell-functions/cell-renderer.md):
     *
     * | Alias               | Cell renderer function                                                         |
     * | ------------------- | ------------------------------------------------------------------------------ |
     * | A custom alias      | Your [custom cell renderer](@/guides/cell-functions/cell-renderer.md) function |
     * | `'autocomplete'`    | `AutocompleteRenderer`                                                         |
     * | `'base'`            | `BaseRenderer`                                                                 |
     * | `'checkbox'`        | `CheckboxRenderer`                                                             |
     * | `'date'`            | `DateRenderer`                                                                 |
     * | `'dropdown'`        | `DropdownRenderer`                                                             |
     * | `'html'`            | `HtmlRenderer`                                                                 |
     * | `'numeric'`         | `NumericRenderer`                                                              |
     * | `'password'`        | `PasswordRenderer`                                                             |
     * | `'text'`            | `TextRenderer`                                                                 |
     * | `'time'`            | `TimeRenderer`                                                                 |
     *
     * To set the [`renderer`](#renderer), [`editor`](#editor), and [`validator`](#validator)
     * options all at once, use the [`type`](#type) option.
     *
     * Read more:
     * - [Cell renderer](@/guides/cell-functions/cell-renderer.md)
     * - [Cell type](@/guides/cell-types/cell-type.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options.md#cascading-configuration)
     * - [`type`](#type)
     *
     * @memberof Options#
     * @type {string|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // use the `numeric` renderer for each cell of the entire grid
     * renderer: `'numeric'`,
     *
     * // add a custom renderer function
     * renderer(hotInstance, td, row, column, prop, value, cellProperties) {
     *   // your custom renderer's logic
     *   ...
     * }
     *
     * // apply the `renderer` option to individual columns
     * columns: [
     *   {
     *     // use the `autocomplete` renderer for each cell of this column
     *     renderer: 'autocomplete'
     *   },
     *   {
     *     // use the `myCustomRenderer` renderer for each cell of this column
     *     renderer: 'myCustomRenderer'
     *   }
     * ]
     * ```
     */
    renderer: void 0,
    /**
     * The `rowHeaders` option configures your grid's row headers.
     *
     * You can set the `rowHeaders` option to one of the following:
     *
     * | Setting    | Description                                                       |
     * | ---------- | ----------------------------------------------------------------- |
     * | `true`     | Enable the default row headers ('1', '2', '3', ...)               |
     * | `false`    | Disable row headers                                               |
     * | An array   | Define your own row headers (e.g. `['One', 'Two', 'Three', ...]`) |
     * | A function | Define your own row headers, using a function                     |
     *
     * Read more:
     * - [Row header](@/guides/rows/row-header.md)
     *
     * @memberof Options#
     * @type {boolean|string[]|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // enable the default row headers
     * rowHeaders: true,
     *
     * // set your own row headers
     * rowHeaders: ['One', 'Two', 'Three'],
     *
     * // set your own row headers, using a function
     * rowHeaders: function(visualRowIndex) {
     *   return `${visualRowIndex}: AB`;
     * },
     * ```
     */
    rowHeaders: void 0,
    /**
     * @description
     * The `rowHeaderWidth` option configures the width of row headers.
     *
     * You can set the `rowHeaderWidth` option to one of the following:
     *
     * | Setting  | Description                                     |
     * | -------- | ----------------------------------------------- |
     * | A number | Set the same width for every row header         |
     * | An array | Set different widths for individual row headers |
     *
     * @memberof Options#
     * @type {number|number[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the same width for every row header
     * rowHeaderWidth: 25,
     *
     * // set different widths for individual row headers
     * rowHeaderWidth: [25, 30, 55],
     * ```
     */
    rowHeaderWidth: void 0,
    /**
     * The `rowHeights` option sets rows' heights, in pixels.
     *
     * In the rendering process, the default row height is 23 px (22 px + 1 px of the row's bottom border).
     * You can change it to equal or greater than 23px, by setting the `rowHeights` option to one of the following:
     *
     * | Setting     | Description                                                                                         | Example                                                      |
     * | ----------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
     * | A number    | Set the same height for every row                                                                   | `rowHeights: 100`                                            |
     * | A string    | Set the same height for every row                                                                   | `rowHeights: '100px'`                                        |
     * | An array    | Set heights separately for each row                                                                 | `rowHeights: [100, 120, undefined]`                          |
     * | A function  | Set row heights dynamically,<br>on each render                                                      | `rowHeights(visualRowIndex) { return visualRowIndex * 10; }` |
     * | `undefined` | Used by the [modifyRowHeight](@/api/hooks.md#modifyRowHeight) hook,<br>to detect row height changes | `rowHeights: undefined`                                      |
     *
     * The `rowHeights` option also sets the minimum row height that can be set
     * via the {@link ManualRowResize} and {@link AutoRowSize} plugins (if they are enabled).
     *
     * Read more:
     * - [Row height](@/guides/rows/row-height.md)
     *
     * @memberof Options#
     * @type {number|number[]|string|string[]|Array<undefined>|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set every row's height to 100px
     * rowHeights: 100,
     *
     * // set every row's height to 100px
     * rowHeights: '100px',
     *
     * // set the first (by visual index) row's height to 100
     * // set the second (by visual index) row's height to 120
     * // set the third (by visual index) row's height to `undefined`
     * // set any other row's height to the default 23px
     * rowHeights: [100, 120, undefined],
     *
     * // set each row's height individually, using a function
     * rowHeights(visualRowIndex) {
     *   return visualRowIndex * 10;
     * },
     * ```
     */
    rowHeights: void 0,
    /**
     * @description
     * The `search` option configures the [`Search`](@/api/search.md) plugin.
     *
     * You can set the `search` option to one of the following:
     *
     * | Setting           | Description                                                                          |
     * | ----------------- | ------------------------------------------------------------------------------------ |
     * | `false` (default) | Disable the [`Search`](@/api/search.md) plugin                                       |
     * | `true`            | Enable the [`Search`](@/api/search.md) plugin with the default configuration         |
     * | An object         | - Enable the [`Search`](@/api/search.md) plugin<br>- Apply your custom configuration |
     *
     * If you set the `search` option to an object, you can configure the following search options:
     *
     * | Option              | Possible settings | Description                                                                                          |
     * | ------------------- | ----------------- | ---------------------------------------------------------------------------------------------------- |
     * | `searchResultClass` | A string          | Add a custom CSS class name to search results                                                        |
     * | `queryMethod`       | A function        | Add a [custom query method](@/guides/accessories-and-menus/searching-values.md#custom-query-method)  |
     * | `callback`          | A function        | Add a [custom callback function](@/guides/accessories-and-menus/searching-values.md#custom-callback) |
     *
     * Read more:
     * - [Searching values](@/guides/accessories-and-menus/searching-values.md)
     * - [Searching values: Custom query method](@/guides/accessories-and-menus/searching-values.md#custom-query-method)
     * - [Searching values: Custom callback](@/guides/accessories-and-menus/searching-values.md#custom-callback)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default false
     * @category Search
     *
     * @example
     * ```js
     * // enable the `Search` plugin with the default configuration
     * search: true,
     *
     * // enable the `Search` plugin with a custom configuration
     * search: {
     *   // add a `customClass` CSS class name to search results
     *   searchResultClass: 'customClass',
     *   // add a custom query method
     *   queryMethod(queryStr, value) {
     *     ...
     *   },
     *   // add a custom callback function
     *   callback(instance, row, column, value, result) {
     *     ...
     *   }
     * }
     * ```
     */
    search: false,
    /**
     * @description
     * The `selectionMode` option configures how [selection](@/guides/cell-features/selection.md) works.
     *
     * You can set the `selectionMode` option to one of the following:
     *
     * | Setting      | Description                                                  |
     * | ------------ | ------------------------------------------------------------ |
     * | `'single'`   | Allow the user to select only one cell at a time.            |
     * | `'range'`    | Allow the user to select one range of cells at a time.       |
     * | `'multiple'` | Allow the user to select multiple ranges of cells at a time. |
     *
     * Read more:
     * - [Selection: Selecting ranges](@/guides/cell-features/selection.md#select-ranges)
     *
     * @memberof Options#
     * @type {string}
     * @default 'multiple'
     * @category Core
     *
     * @example
     * ```js
     * // you can only select one cell at at a time
     * selectionMode: 'single',
     *
     * // you can select one range of cells at a time
     * selectionMode: 'range',
     *
     * // you can select multiple ranges of cells at a time
     * selectionMode: 'multiple',
     * ```
     */
    selectionMode: "multiple",
    /**
     * The `selectOptions` option configures options that the end user can choose from in [`select`](@/guides/cell-types/select-cell-type.md) cells.
     *
     * You can set the `selectOptions` option to one of the following:
     *
     * | Setting                         | Description                                                                   |
     * | ------------------------------- | ----------------------------------------------------------------------------- |
     * | An array of strings             | Each string is one option's value and label                                   |
     * | An object with key-string pairs | - Each key is one option's value<br>- The key's string is that option's label |
     * | A function                      | A function that returns an object with key-string pairs                       |
     *
     * Read more:
     * - [Select cell type](@/guides/cell-types/select-cell-type.md)
     *
     * @memberof Options#
     * @type {string[]|object|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `select`
     *     type: 'select',
     *     // set the first option's value and label to `A`
     *     // set the second option's value and label to `B`
     *     // set the third option's value and label to `C`
     *     selectOptions: ['A', 'B', 'C'],
     *   },
     *   {
     *     // set the `type` of each cell in this column to `select`
     *     type: 'select',
     *     selectOptions: {
     *       // set the first option's value to `value1` and label to `Label 1`
     *       value1: 'Label 1',
     *       // set the second option's value to `value2` and label to `Label 2`
     *       value2: 'Label 2',
     *       // set the third option's value to `value3` and label to `Label 3`
     *       value3: 'Label 3',
     *     },
     *   },
     *   {
     *     // set the `type` of each cell in this column to `select`
     *     type: 'select',
     *     // set `selectOption` to a function that returns available options as an object
     *     selectOptions(visualRow, visualColumn, prop) {
     *       return {
     *         value1: 'Label 1',
     *         value2: 'Label 2',
     *         value3: 'Label 3',
     *       };
     *   },
     * ],
     * ```
     */
    selectOptions: void 0,
    /**
     * @description
     * The `skipColumnOnPaste` option determines whether you can paste data into a given column.
     *
     * You can only apply the `skipColumnOnPaste` option to an entire column, using the [`columns`](#columns) option.
     *
     * You can set the `skipColumnOnPaste` option to one of the following:
     *
     * | Setting           | Description                                                                                           |
     * | ----------------- | ----------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Enable pasting data into this column                                                                  |
     * | `true`            | - Disable pasting data into this column<br>- On pasting, paste data into the next column to the right |
     *
     * Read more:
     * - [Configuration options: Setting column options](@/guides/getting-started/configuration-options.md#set-column-options)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // disable pasting data into this column
     *     skipColumnOnPaste: true
     *   }
     * ],
     * ```
     */
    skipColumnOnPaste: false,
    /**
     * @description
     *
     * The `skipRowOnPaste` option determines whether you can paste data into a given row.
     *
     * You can only apply the `skipRowOnPaste` option to an entire row, using the [`cells`](#cells) option.
     *
     * You can set the `skipRowOnPaste` option to one of the following:
     *
     * | Setting           | Description                                                                         |
     * | ----------------- | ----------------------------------------------------------------------------------- |
     * | `false` (default) | Enable pasting data into this row                                                   |
     * | `true`            | - Disable pasting data into this row<br>- On pasting, paste data into the row below |
     *
     * Read more:
     * - [Configuration options: Setting row options](@/guides/getting-started/configuration-options.md#set-row-options)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * cells(row, column) {
     *  const cellProperties = {};
     *
     *  // disable pasting data into row 1
     *  if (row === 1) {
     *    cellProperties.skipRowOnPaste = true;
     *  }
     *
     *  return cellProperties;
     * }
     * ```
     */
    skipRowOnPaste: false,
    /**
     * The `sortByRelevance` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells'
     * lists are sorted in the same order as provided in the [`source`](#source) option.
     *
     * You can set the `sortByRelevance` option to one of the following:
     *
     * | Setting          | Description                                                                  |
     * | ---------------- | ---------------------------------------------------------------------------- |
     * | `true` (default) | Sort options in the same order as provided in the [`source`](#source) option |
     * | `false`          | Sort options alphabetically                                                  |
     *
     * Read more:
     * - [`source`](#source)
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['D', 'C', 'B', 'A'],
     *   // sort the `autocomplete` option in this order: D, C, B, A
     *   sortByRelevance: true
     * }],
     * ```
     */
    sortByRelevance: true,
    /**
     * The `source` option sets options available in [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type.md) cells.
     *
     * You can set the `source` option to one of the following:
     *
     * - An array
     * - A function
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type.md)
     * - [`strict`](#strict)
     * - [`allowHtml`](#allowHtml)
     * - [`filter`](#filter)
     * - [`sortByRelevance`](#sortByRelevance)
     *
     * @memberof Options#
     * @type {Array|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set `source` to an array
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['A', 'B', 'C', 'D']
     * }],
     *
     * // set `source` to a function
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // for every `autocomplete` cell in this column, fetch data from an external source
     *   source(query, callback) {
     *     fetch('https://example.com/query?q=' + query, function(response) {
     *       callback(response.items);
     *     })
     *   }
     * }],
     * ```
     */
    source: void 0,
    /**
     * @description
     * If the [`data`](#data) option is not set, the `startCols` option sets the initial number of empty columns.
     *
     * The `startCols` option works only in Handsontable's constructor.
     *
     * @memberof Options#
     * @type {number}
     * @default 5
     * @category Core
     *
     * @example
     * ```js
     * // start with 15 empty columns
     * startCols: 15,
     * ```
     */
    startCols: 5,
    /**
     * @description
     * If the [`data`](#data) option is not set, the `startRows` option sets the initial number of empty rows.
     *
     * The `startRows` option works only in Handsontable's constructor.
     *
     * @memberof Options#
     * @type {number}
     * @default 5
     * @category Core
     *
     * @example
     * ```js
     * // start with 15 empty rows
     * startRows: 15,
     * ```
     */
    startRows: 5,
    /**
     * @description
     * The `stretchH` option determines what happens when the declared grid width
     * is different from the calculated sum of all column widths.
     *
     * You can set the `stretchH` option to one of the following:
     *
     * | Setting            | Description                                                       |
     * | ------------------ | ----------------------------------------------------------------- |
     * | `'none'` (default) | Don't fit the grid to the container (disable column stretching)   |
     * | `'last'`           | Fit the grid to the container, by stretching only the last column |
     * | `'all'`            | Fit the grid to the container, by stretching all columns evenly   |
     *
     * Read more:
     * - [Column width: Column stretching](@/guides/columns/column-width.md#column-stretching)
     *
     * @memberof Options#
     * @type {string}
     * @default 'none'
     * @category Core
     *
     * @example
     * ```js
     * // fit the grid to the container
     * // by stretching all columns evenly
     * stretchH: 'all',
     * ```
     */
    stretchH: "none",
    /**
     * The `strict` option configures the behavior of [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md) cells.
     *
     * You can set the `strict` option to one of the following:
     *
     * | Setting | Mode                                                                                          | Description                                                                                |
     * | ------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
     * | `true`  | [Strict mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-strict-mode)         | The end user:<br>- Can only choose one of suggested values<br>- Can't enter a custom value |
     * | `false` | [Flexible mode](@/guides/cell-types/autocomplete-cell-type.md#autocomplete-flexible-mode)     | The end user:<br>- Can choose one of suggested values<br>- Can enter a custom value        |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [`source`](#source)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['A', 'B', 'C'],
     *   // values entered must match `A`, `B`, or `C`
     *   strict: true
     *   },
     * ],
     * ```
     */
    strict: void 0,
    /**
     * The `tableClassName` option lets you add CSS class names
     * to every Handsontable instance inside the `container` element.
     *
     * You can set the `tableClassName` option to one of the following:
     *
     * | Setting             | Description                                                                                |
     * | ------------------- | ------------------------------------------------------------------------------------------ |
     * | A string            | Add a single CSS class name to every Handsontable instance inside the `container` element  |
     * | An array of strings | Add multiple CSS class names to every Handsontable instance inside the `container` element |
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string|string[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to every Handsontable instance inside the `container` element
     * tableClassName: 'your-class-name',
     *
     * // add `first-class-name` and `second-class-name` CSS class names
     * // to every Handsontable instance inside the `container` element
     * tableClassName: ['first-class-name', 'second-class-name'],
     * ```
     */
    tableClassName: void 0,
    /**
     * The `tabMoves` option configures the action of the <kbd>**Tab**</kbd> key.
     *
     * You can set the `tabMoves` option to an object with the following properties
     * (or to a function that returns such an object):
     *
     * | Property | Type   | Description                                                                                                                                              |
     * | -------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `row`    | Number | - On pressing <kbd>**Tab**</kbd>, move selection `row` rows down<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Tab**</kbd>, move selection `row` rows up              |
     * | `col`    | Number | - On pressing <kbd>**Tab**</kbd>, move selection `col` columns right<br>- On pressing <kbd>**Shift**</kbd> + <kbd>**Tab**</kbd>, move selection `col` columns left     |
     *
     * @memberof Options#
     * @type {object|Function}
     * @default {row: 0, col: 1}
     * @category Core
     *
     * @example
     * ```js
     * // on pressing Tab, move selection 2 rows down and 2 columns right
     * // on pressing Shift+Tab, move selection 2 rows up and 2 columns left
     * tabMoves: {row: 2, col: 2},
     *
     * // the same setting, as a function
     * // `event` is a DOM Event object received on pressing Tab
     * // you can use it to check whether the user pressed Tab or Shift+Tab
     * tabMoves(event) {
     *   return {row: 2, col: 2};
     * },
     * ```
     */
    tabMoves: {
      row: 0,
      col: 1
    },
    /**
     * @description
     * The `title` option configures [column header](@/guides/columns/column-header.md) names.
     *
     * You can set the `title` option to a string.
     *
     * Read more:
     * - [Column header](@/guides/columns/column-header.md)
     * - [`columns`](#columns)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the first column header name to `First name`
     *     title: 'First name',
     *     type: 'text',
     *   },
     *   {
     *     // set the second column header name to `Last name`
     *     title: 'Last name',
     *     type: 'text',
     *   }
     * ],
     * ```
     */
    title: void 0,
    /**
     * The `trimDropdown` option configures the width of the [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type.md) lists.
     *
     * You can set the `trimDropdown` option to one of the following:
     *
     * | Setting          | Description                                                                     |
     * | ---------------- | ------------------------------------------------------------------------------- |
     * | `true` (default) | Make the dropdown/autocomplete list's width the same as the edited cell's width |
     * | `false`          | Scale the dropdown/autocomplete list's width to the list's content              |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     type: 'autocomplete',
     *     // for each cell of this column
     *     // make the `autocomplete` list's width the same as the edited cell's width
     *     trimDropdown: true,
     *   },
     *   {
     *     type: 'dropdown',
     *     // for each cell of this column
     *     // scale the `dropdown` list's width to the list's content
     *     trimDropdown: false,
     *   }
     * ],
     * ```
     */
    trimDropdown: true,
    /**
     * @description
     * The `trimRows` option configures the [`TrimRows`](@/api/trimRows.md) plugin.
     *
     * You can set the `trimRows` option to one of the following:
     *
     * | Setting                          | Description                                                                                   |
     * | -------------------------------- | --------------------------------------------------------------------------------------------- |
     * | `false`                          | Disable the [`TrimRows`](@/api/trimRows.md) plugin                                            |
     * | `true`                           | Enable the [`TrimRows`](@/api/trimRows.md) plugin                                             |
     * | An array of physical row indexes | - Enable the [`TrimRows`](@/api/trimRows.md) plugin<br>- Trim selected rows at initialization |
     *
     * Read more:
     * - [Plugins: `TrimRows`](@/api/trimRows.md)
     * - [Row trimming](@/guides/rows/row-trimming.md)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category TrimRows
     *
     * @example
     * ```js
     * // enable the `TrimRows` plugin
     * trimRows: true,
     *
     * // enable the `TrimRows` plugin
     * // at Handsontable's initialization, trim rows 5, 10, and 15
     * trimRows: [5, 10, 15],
     * ```
     */
    trimRows: void 0,
    /**
     * The `trimWhitespace` option configures automatic whitespace removal. This option
     * affects the cell renderer and the cell editor.
     *
     * You can set the `trimWhitespace` option to one of the following:
     *
     * | Setting          | Description                                                     |
     * | ---------------- | --------------------------------------------------------------- |
     * | `true` (default) | Remove whitespace at the beginning and at the end of each cell |
     * | `false`          | Don't remove whitespace                                         |
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // don't remove whitespace
     *     // from any cell of this column
     *     trimWhitespace: false
     *   }
     * ]
     * ```
     */
    trimWhitespace: true,
    /**
     * @description
     * The `type` option lets you set the [`renderer`](#renderer), [`editor`](#editor), and [`validator`](#validator)
     * options all at once, by selecting a [cell type](@/guides/cell-types/cell-type.md).
     *
     * You can set the `type` option to one of the following:
     *
     * | Cell type                                                         | Renderer, editor & validator                                                                                                                                                                                                                       |
     * | ----------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | A [custom cell type](@/guides/cell-types/cell-type.md)            | Renderer: your [custom cell renderer](@/guides/cell-functions/cell-renderer.md)<br>Editor: your [custom cell editor](@/guides/cell-functions/cell-editor.md)<br>Validator: your [custom cell validator](@/guides/cell-functions/cell-validator.md) |
     * | [`'autocomplete'`](@/guides/cell-types/autocomplete-cell-type.md) | Renderer: `AutocompleteRenderer`<br>Editor: `AutocompleteEditor`<br>Validator: `AutocompleteValidator`                                                                         |
     * | [`'checkbox'`](@/guides/cell-types/checkbox-cell-type.md)         | Renderer: `CheckboxRenderer`<br>Editor: `CheckboxEditor`<br>Validator: -                                                                                                                               |
     * | [`'date'`](@/guides/cell-types/date-cell-type.md)                 | Renderer: `DateRenderer`<br>Editor: `DateEditor`<br>Validator: `DateValidator`                                                                                                 |
     * | [`'dropdown'`](@/guides/cell-types/dropdown-cell-type.md)         | Renderer: `DropdownRenderer`<br>Editor: `DropdownEditor`<br>Validator: `DropdownValidator`                                                                                     |
     * | [`'handsontable'`](@/guides/cell-types/handsontable-cell-type.md) | Renderer: `AutocompleteRenderer`<br>Editor: `HandsontableEditor`<br>Validator: -                                                                                                                       |
     * | [`'numeric'`](@/guides/cell-types/numeric-cell-type.md)           | Renderer: `NumericRenderer`<br>Editor: `NumericEditor`<br>Validator: `NumericValidator`                                                                                        |
     * | [`'password'`](@/guides/cell-types/password-cell-type.md)         | Renderer: `PasswordRenderer`<br>Editor: `PasswordEditor`<br>Validator: -                                                                                                                               |
     * | `'text'`                                                          | Renderer: `TextRenderer`<br>Editor: `TextEditor`<br>Validator: -                                                                                                                                       |
     * | [`'time`'](@/guides/cell-types/time-cell-type.md)                 | Renderer: `TimeRenderer`<br>Editor: `TimeEditor`<br>Validator: `TimeValidator`                                                                                                 |
     *
     * Read more:
     * - [Cell type](@/guides/cell-types/cell-type.md)
     * - [Cell renderer](@/guides/cell-functions/cell-renderer.md)
     * - [Cell editor](@/guides/cell-functions/cell-editor.md)
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options.md#cascading-configuration)
     * - [`renderer`](#renderer)
     * - [`editor`](#editor)
     * - [`validator`](#validator)
     *
     * @memberof Options#
     * @type {string}
     * @default 'text'
     * @category Core
     *
     * @example
     * ```js
     * // set the `numeric` cell type for each cell of the entire grid
     * type: `'numeric'`,
     *
     * // apply the `type` option to individual columns
     * columns: [
     *   {
     *     // set the `autocomplete` cell type for each cell of this column
     *     type: 'autocomplete'
     *   },
     *   {
     *     // set the `myCustomCellType` cell type for each cell of this column
     *     type: 'myCustomCellType'
     *   }
     * ]
     * ```
     */
    type: "text",
    /**
     * The `uncheckedTemplate` option lets you configure what value
     * an unchecked [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell has.
     *
     * You can set the `uncheckedTemplate` option to one of the following:
     *
     * | Setting           | Description                                                                                                                                                                                |
     * | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `false` (default) | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is unchecked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns `false`                 |
     * | A string          | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type.md) cell is unchecked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns a string of your choice |
     *
     * Read more:
     * - [Checkbox cell type: Checkbox template](@/guides/cell-types/checkbox-cell-type.md#checkbox-template)
     * - [`getDataAtCell()`](@/api/core.md#getDataAtCell)
     * - [`checkedTemplate`](#checkedTemplate)
     *
     * @memberof Options#
     * @type {boolean|string|number}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     // when unchecked, the cell's value is `false`
     *     // when checked, the cell's value is `true`
     *     type: 'checkbox',
     *   },
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     // when unchecked, the cell's value is `'No'`
     *     // when checked, the cell's value is `'Yes'`
     *     type: 'checkbox',
     *     uncheckedTemplate: 'No'
     *     checkedTemplate: 'Yes',
     *  }
     * ],
     * ```
     */
    uncheckedTemplate: void 0,
    /**
     * The `undo` option configures the [`UndoRedo`](@/api/undoRedo.md) plugin.
     *
     * You can set the `undo` option to one of the following:
     *
     * | Setting | Description                                        |
     * | ------- | -------------------------------------------------- |
     * | `true`  | Enable the [`UndoRedo`](@/api/undoRedo.md) plugin  |
     * | `false` | Disable the [`UndoRedo`](@/api/undoRedo.md) plugin |
     *
     * By default, the `undo` option is set to `undefined`,
     * but the [`UndoRedo`](@/api/undoRedo.md) plugin acts as enabled.
     * To disable the [`UndoRedo`](@/api/undoRedo.md) plugin completely,
     * set the `undo` option to `false`.
     *
     * Read more:
     * - [Undo and redo](@/guides/accessories-and-menus/undo-redo.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category UndoRedo
     *
     * @example
     * ```js
     * // enable the `UndoRedo` plugin
     * undo: true,
     * ```
     */
    undo: void 0,
    /**
     * @description
     * The `validator` option sets a [cell validator](@/guides/cell-functions/cell-validator.md) for a cell.
     *
     * You can set the `validator` option to one of the following:
     *
     * | Setting              | Description                                                                      |
     * | -------------------- | -------------------------------------------------------------------------------- |
     * | A string             | A [cell validator alias](@/guides/cell-functions/cell-validator.md)              |
     * | A function           | Your [custom cell validator function](@/guides/cell-functions/cell-validator.md) |
     * | A regular expression | A regular expression used for cell validation                                    |
     *
     * By setting the `validator` option to a string,
     * you can use one of the following [cell validator aliases](@/guides/cell-functions/cell-validator.md):
     *
     * | Alias               | Cell validator function                                                 |
     * | ------------------- | ----------------------------------------------------------------------- |
     * | A custom alias      | Your [custom cell validator](@/guides/cell-functions/cell-validator.md) |
     * | `'autocomplete'`    | `AutocompleteValidator`                                                 |
     * | `'date'`            | `DateValidator`                                                         |
     * | `'dropdown'`        | `DropdownValidator`                                                     |
     * | `'numeric'`         | `NumericValidator`                                                      |
     * | `'time'`            | `TimeValidator`                                                         |
     *
     * To set the [`editor`](#editor), [`renderer`](#renderer), and [`validator`](#validator)
     * options all at once, use the [`type`](#type) option.
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator.md)
     * - [Cell type](@/guides/cell-types/cell-type.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options.md#cascading-configuration)
     * - [`type`](#type)
     *
     * @memberof Options#
     * @type {Function|RegExp|string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *    {
     *      // use a built-in `numeric` cell validator
     *      validator: 'numeric'
     *    },
     *    {
     *      // validate against a regular expression
     *      validator: /^[0-9]$/
     *    },
     *    {
     *      // add a custom cell validator function
     *      validator(value, callback) {
     *          ...
     *      }
     *    },
     * ],
     * ```
     */
    validator: void 0,
    /**
     * @description
     * The `viewportColumnRenderingOffset` option configures the number of columns
     * to be rendered outside of the grid's viewport.
     *
     * You can set the `viewportColumnRenderingOffset` option to one of the following:
     *
     * | Setting            | Description                                             |
     * | ------------------ | ------------------------------------------------------- |
     * | `auto` (default)   | Use the offset calculated automatically by Handsontable |
     * | A number           | Set the offset manually                                 |
     *
     * Read more:
     * - [Performance: Define the number of pre-rendered rows and columns](@/guides/optimization/performance.md#define-the-number-of-pre-rendered-rows-and-columns)
     *
     * @memberof Options#
     * @type {number|string}
     * @default 'auto'
     * @category Core
     *
     * @example
     * ```js
     * // render 70 columns outside of the grid's viewport
     * viewportColumnRenderingOffset: 70,
     * ```
     */
    viewportColumnRenderingOffset: "auto",
    /**
     * @description
     * The `viewportRowRenderingOffset` option configures the number of rows
     * to be rendered outside of the grid's viewport.
     *
     * You can set the `viewportRowRenderingOffset` option to one of the following:
     *
     * | Setting            | Description                                             |
     * | ------------------ | ------------------------------------------------------- |
     * | `auto` (default)   | Use the offset calculated automatically by Handsontable |
     * | A number           | Set the offset manually                                 |
     *
     * Read more:
     * - [Performance: Define the number of pre-rendered rows and columns](@/guides/optimization/performance.md#define-the-number-of-pre-rendered-rows-and-columns)
     * - [Column virtualization](@/guides/columns/column-virtualization.md)
     *
     * @memberof Options#
     * @type {number|string}
     * @default 'auto'
     * @category Core
     *
     * @example
     * ```js
     * // render 70 rows outside of the grid's viewport
     * viewportRowRenderingOffset: 70,
     * ```
     */
    viewportRowRenderingOffset: "auto",
    /**
     * The `visibleRows` option sets the height of the [`autocomplete`](@/guides/cell-types/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type.md) lists.
     *
     * When the number of list options exceeds the `visibleRows` number, a scrollbar appears.
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type.md)
     *
     * @memberof Options#
     * @type {number}
     * @default 10
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     type: 'autocomplete',
     *     // set the `autocomplete` list's height to 15 options
     *     // for each cell of this column
     *     visibleRows: 15,
     *   },
     *   {
     *     type: 'dropdown',
     *     // set the `dropdown` list's height to 5 options
     *     // for each cell of this column
     *     visibleRows: 5,
     *   }
     * ],
     * ```
     */
    visibleRows: 10,
    /**
     * The `width` option configures the width of your grid.
     *
     * You can set the `width` option to one of the following:
     *
     * | Setting                                                                    | Example                   |
     * | -------------------------------------------------------------------------- | ------------------------- |
     * | A number of pixels                                                         | `width: 500`              |
     * | A string with a [CSS unit](https://www.w3schools.com/cssref/css_units.asp) | `width: '75vw'`           |
     * | A function that returns a valid number or string                           | `width() { return 500; }` |
     *
     * Read more:
     * - [Grid size](@/guides/getting-started/grid-size.md)
     *
     * @memberof Options#
     * @type {number|string|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the grid's width to 500px
     * width: 500,
     *
     * // set the grid's width to 75vw
     * width: '75vw',
     *
     * // set the grid's width to 500px, using a function
     * width() {
     *   return 500;
     * },
     * ```
     */
    width: void 0,
    /**
     * The `wordWrap` option configures whether content that exceeds a column's width is wrapped or not.
     *
     * You can set the `wordWrap` option to one of the following:
     *
     * | Setting          | Description                                             |
     * | ---------------- | ------------------------------------------------------- |
     * | `true` (default) | If content exceeds the column's width, wrap the content |
     * | `false`          | Don't wrap content                                      |
     *
     * To style cells that don't wrap content, use the [`noWordWrapClassName`](#noWordWrapClassName) option.
     *
     * Read more:
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // set column width for every column of the entire grid
     * colWidths: 100,
     *
     * columns: [
     *   {
     *     // don't wrap content in this column
     *     wordWrap: false,
     *   },
     *   {
     *     // if content exceeds this column's width, wrap the content
     *     wordWrap: true,
     *   }
     * ],
     * ```
     */
    wordWrap: true
    /* eslint-enable jsdoc/require-description-complete-sentence */
  };
};

// node_modules/handsontable/dataMap/metaManager/metaLayers/globalMeta.mjs
function createTableMetaEmptyClass() {
  return class TableMeta {
  };
}
var GlobalMeta = class {
  constructor(hot) {
    this.metaCtor = createTableMetaEmptyClass();
    this.meta = this.metaCtor.prototype;
    extend2(this.meta, metaSchema_default());
    this.meta.instance = hot;
  }
  /**
   * Gets constructor of the global meta object. Necessary for inheritance for creating the next meta layers.
   *
   * @returns {Function}
   */
  getMetaConstructor() {
    return this.metaCtor;
  }
  /**
   * Gets settings object for this layer.
   *
   * @returns {object}
   */
  getMeta() {
    return this.meta;
  }
  /**
   * Updates global settings object by merging settings with the current state.
   *
   * @param {object} settings An object to merge with.
   */
  updateMeta(settings) {
    var _settings$type;
    extend2(this.meta, settings);
    extendByMetaType(this.meta, {
      ...settings,
      type: (_settings$type = settings.type) !== null && _settings$type !== void 0 ? _settings$type : this.meta.type
    }, settings);
  }
};

// node_modules/handsontable/dataMap/metaManager/metaLayers/tableMeta.mjs
var TableMeta = class {
  constructor(globalMeta) {
    const MetaCtor = globalMeta.getMetaConstructor();
    this.meta = new MetaCtor();
  }
  /**
   * Gets settings object for this layer.
   *
   * @returns {TableMeta}
   */
  getMeta() {
    return this.meta;
  }
  /**
   * Updates table settings object by merging settings with the current state.
   *
   * @param {object} settings An object to merge with.
   */
  updateMeta(settings) {
    extend2(this.meta, settings);
    extendByMetaType(this.meta, settings, settings);
  }
};

// node_modules/handsontable/dataMap/metaManager/lazyFactoryMap.mjs
var LazyFactoryMap = class {
  constructor(valueFactory) {
    this.valueFactory = valueFactory;
    this.data = [];
    this.index = [];
    this.holes = /* @__PURE__ */ new Set();
  }
  /**
   * Gets or if data not exist creates and returns new data.
   *
   * @param {number} key The item key as zero-based index.
   * @returns {*}
   */
  obtain(key) {
    assert(() => isUnsignedNumber(key), "Expecting an unsigned number.");
    const dataIndex = this._getStorageIndexByKey(key);
    let result;
    if (dataIndex >= 0) {
      result = this.data[dataIndex];
      if (result === void 0) {
        result = this.valueFactory(key);
        this.data[dataIndex] = result;
      }
    } else {
      result = this.valueFactory(key);
      if (this.holes.size > 0) {
        const reuseIndex = this.holes.values().next().value;
        this.holes.delete(reuseIndex);
        this.data[reuseIndex] = result;
        this.index[key] = reuseIndex;
      } else {
        this.data.push(result);
        this.index[key] = this.data.length - 1;
      }
    }
    return result;
  }
  /**
   * Inserts an empty data to the map. This method creates an empty space for obtaining
   * new data.
   *
   * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.
   * @param {number} [amount=1] Ammount of data to insert.
   */
  insert(key) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    assert(() => isUnsignedNumber(key) || isNullish(key), "Expecting an unsigned number or null/undefined argument.");
    const newIndexes = [];
    const dataLength = this.data.length;
    for (let i = 0; i < amount; i++) {
      newIndexes.push(dataLength + i);
      this.data.push(void 0);
    }
    const insertionIndex = isNullish(key) ? this.index.length : key;
    this.index = [...this.index.slice(0, insertionIndex), ...newIndexes, ...this.index.slice(insertionIndex)];
  }
  /**
   * Removes (soft remove) data from "index" and according to the amount of data.
   *
   * @param {number} key The key as volatile zero-based index at which to begin removing the data.
   * @param {number} [amount=1] Ammount data to remove.
   */
  remove(key) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    assert(() => isUnsignedNumber(key) || isNullish(key), "Expecting an unsigned number or null/undefined argument.");
    const removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);
    for (let i = 0; i < removed.length; i++) {
      const removedIndex = removed[i];
      if (typeof removedIndex === "number") {
        this.holes.add(removedIndex);
      }
    }
  }
  /**
   * Returns the size of the data which this map holds.
   *
   * @returns {number}
   */
  size() {
    return this.data.length - this.holes.size;
  }
  /**
   * Returns a new Iterator object that contains the values for each item in the LazyMap object.
   *
   * @returns {Iterator}
   */
  values() {
    return arrayFilter(this.data, (_, index2) => !this.holes.has(index2))[Symbol.iterator]();
  }
  /**
   * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.
   *
   * @returns {Iterator}
   */
  entries() {
    const validEntries = [];
    for (let i = 0; i < this.data.length; i++) {
      const keyIndex = this._getKeyByStorageIndex(i);
      if (keyIndex !== -1) {
        validEntries.push([keyIndex, this.data[i]]);
      }
    }
    let dataIndex = 0;
    return {
      next: () => {
        if (dataIndex < validEntries.length) {
          const value = validEntries[dataIndex];
          dataIndex += 1;
          return {
            value,
            done: false
          };
        }
        return {
          done: true
        };
      }
    };
  }
  /**
   * Clears the map.
   */
  clear() {
    this.data = [];
    this.index = [];
    this.holes.clear();
  }
  /**
   * Gets storage index calculated from the key associated with the specified value.
   *
   * @param {number} key Volatile zero-based index.
   * @returns {number} Returns index 0-N or -1 if no storage index found.
   */
  _getStorageIndexByKey(key) {
    return this.index.length > key ? this.index[key] : -1;
  }
  /**
   * Gets the key associated with the specified value calculated from storage index.
   *
   * @param {number} dataIndex Zero-based storage index.
   * @returns {number} Returns index 0-N or -1 if no key found.
   */
  _getKeyByStorageIndex(dataIndex) {
    return this.index.indexOf(dataIndex);
  }
  /**
   * Makes this object iterable.
   *
   * @returns {Iterator}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
};

// node_modules/handsontable/dataMap/metaManager/metaLayers/columnMeta.mjs
var COLUMNS_PROPS_CONFLICTS = ["data", "width"];
var ColumnMeta = class {
  constructor(globalMeta) {
    this.globalMeta = globalMeta;
    this.metas = new LazyFactoryMap(() => this._createMeta());
  }
  /**
   * Updates column meta object by merging settings with the current state.
   *
   * @param {number} physicalColumn The physical column index which points what column meta object is updated.
   * @param {object} settings An object to merge with.
   */
  updateMeta(physicalColumn, settings) {
    const meta = this.getMeta(physicalColumn);
    extend2(meta, settings);
    extendByMetaType(meta, settings);
  }
  /**
   * Creates one or more columns at specific position.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is added.
   * @param {number} amount An amount of columns to add.
   */
  createColumn(physicalColumn, amount) {
    this.metas.insert(physicalColumn, amount);
  }
  /**
   * Removes one or more columns from the collection.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is removed.
   * @param {number} amount An amount columns to remove.
   */
  removeColumn(physicalColumn, amount) {
    this.metas.remove(physicalColumn, amount);
  }
  /**
   * Gets settings object for this layer.
   *
   * @param {number} physicalColumn The physical column index.
   * @returns {object}
   */
  getMeta(physicalColumn) {
    return this.metas.obtain(physicalColumn);
  }
  /**
   * Gets constructor of the column meta object. Necessary for inheritance - creating the next meta layers.
   *
   * @param {number} physicalColumn The physical column index.
   * @returns {Function}
   */
  getMetaConstructor(physicalColumn) {
    return this.metas.obtain(physicalColumn).constructor;
  }
  /**
   * Clears all saved column meta objects.
   */
  clearCache() {
    this.metas.clear();
  }
  /**
   * Creates and returns new column meta object with properties inherited from the global meta layer.
   *
   * @private
   * @returns {object}
   */
  _createMeta() {
    return columnFactory(this.globalMeta.getMetaConstructor(), COLUMNS_PROPS_CONFLICTS).prototype;
  }
};

// node_modules/handsontable/dataMap/metaManager/metaLayers/cellMeta.mjs
var CellMeta = class {
  constructor(columnMeta) {
    this.columnMeta = columnMeta;
    this.metas = new LazyFactoryMap(() => this._createRow());
  }
  /**
   * Updates cell meta object by merging settings with the current state.
   *
   * @param {number} physicalRow The physical row index which points what cell meta object is updated.
   * @param {number} physicalColumn The physical column index which points what cell meta object is updated.
   * @param {object} settings An object to merge with.
   */
  updateMeta(physicalRow, physicalColumn, settings) {
    const meta = this.getMeta(physicalRow, physicalColumn);
    extend2(meta, settings);
    extendByMetaType(meta, settings);
  }
  /**
   * Creates one or more rows at specific position.
   *
   * @param {number} physicalRow The physical row index which points from what position the row is added.
   * @param {number} amount An amount of rows to add.
   */
  createRow(physicalRow, amount) {
    this.metas.insert(physicalRow, amount);
  }
  /**
   * Creates one or more columns at specific position.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is added.
   * @param {number} amount An amount of columns to add.
   */
  createColumn(physicalColumn, amount) {
    for (let i = 0; i < this.metas.size(); i++) {
      this.metas.obtain(i).insert(physicalColumn, amount);
    }
  }
  /**
   * Removes one or more rows from the collection.
   *
   * @param {number} physicalRow The physical row index which points from what position the row is removed.
   * @param {number} amount An amount of rows to remove.
   */
  removeRow(physicalRow, amount) {
    this.metas.remove(physicalRow, amount);
  }
  /**
   * Removes one or more columns from the collection.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is removed.
   * @param {number} amount An amount of columns to remove.
   */
  removeColumn(physicalColumn, amount) {
    for (let i = 0; i < this.metas.size(); i++) {
      this.metas.obtain(i).remove(physicalColumn, amount);
    }
  }
  /**
   * Gets settings object for this layer.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} [key] If the key exists its value will be returned, otherwise the whole cell meta object.
   * @returns {object}
   */
  getMeta(physicalRow, physicalColumn, key) {
    const cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
    if (key === void 0) {
      return cellMeta;
    }
    return cellMeta[key];
  }
  /**
   * Sets settings object for this layer defined by "key" property.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key The property name to set.
   * @param {*} value Value to save.
   */
  setMeta(physicalRow, physicalColumn, key, value) {
    var _cellMeta$_automatica;
    const cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
    (_cellMeta$_automatica = cellMeta._automaticallyAssignedMetaProps) === null || _cellMeta$_automatica === void 0 || _cellMeta$_automatica.delete(key);
    cellMeta[key] = value;
  }
  /**
   * Removes a property defined by the "key" argument from the cell meta object.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key The property name to remove.
   */
  removeMeta(physicalRow, physicalColumn, key) {
    const cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
    delete cellMeta[key];
  }
  /**
   * Returns all cell meta objects that were created during the Handsontable operation. As cell meta
   * objects are created lazy, the length of the returned collection depends on how and when the
   * table has asked for access to that meta objects.
   *
   * @returns {object[]}
   */
  getMetas() {
    const metas = [];
    const rows = Array.from(this.metas.values());
    for (let row = 0; row < rows.length; row++) {
      metas.push(...rows[row].values());
    }
    return metas;
  }
  /**
   * Returns all cell meta objects that were created during the Handsontable operation but for
   * specific row index.
   *
   * @param {number} physicalRow The physical row index.
   * @returns {object[]}
   */
  getMetasAtRow(physicalRow) {
    assert(() => isUnsignedNumber(physicalRow), "Expecting an unsigned number.");
    const rowsMeta = new Map(this.metas);
    return rowsMeta.has(physicalRow) ? Array.from(rowsMeta.get(physicalRow).values()) : [];
  }
  /**
   * Clears all saved cell meta objects.
   */
  clearCache() {
    this.metas.clear();
  }
  /**
   * Creates and returns new structure for cell meta objects stored in columnar axis.
   *
   * @private
   * @returns {object}
   */
  _createRow() {
    return new LazyFactoryMap((physicalColumn) => this._createMeta(physicalColumn));
  }
  /**
   * Creates and returns new cell meta object with properties inherited from the column meta layer.
   *
   * @private
   * @param {number} physicalColumn The physical column index.
   * @returns {object}
   */
  _createMeta(physicalColumn) {
    const ColumnMeta2 = this.columnMeta.getMetaConstructor(physicalColumn);
    return new ColumnMeta2();
  }
};

// node_modules/handsontable/dataMap/metaManager/index.mjs
var MetaManager = class {
  constructor(hot) {
    let customSettings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let metaMods = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    this.hot = hot;
    this.globalMeta = new GlobalMeta(hot);
    this.tableMeta = new TableMeta(this.globalMeta);
    this.columnMeta = new ColumnMeta(this.globalMeta);
    this.cellMeta = new CellMeta(this.columnMeta);
    metaMods.forEach((ModifierClass) => new ModifierClass(this));
    this.globalMeta.updateMeta(customSettings);
  }
  /**
   * Gets the global meta object that is a root of all default settings, which are recognizable by Handsontable.
   * Other layers inherites all properties from this. Adding, removing, or changing property in that
   * object has a direct reflection to all layers.
   *
   * @returns {object}
   */
  getGlobalMeta() {
    return this.globalMeta.getMeta();
  }
  /**
   * Updates global settings object by merging settings with the current state.
   *
   * @param {object} settings An object to merge with.
   */
  updateGlobalMeta(settings) {
    this.globalMeta.updateMeta(settings);
  }
  /**
   * Gets settings object that was passed in the Handsontable constructor. That layer contains all
   * default settings inherited from the GlobalMeta layer merged with settings passed by the developer.
   * Adding, removing, or changing property in that object has no direct reflection on any other layers.
   *
   * @returns {TableMeta}
   */
  getTableMeta() {
    return this.tableMeta.getMeta();
  }
  /**
   * Updates table settings object by merging settings with the current state.
   *
   * @param {object} settings An object to merge with.
   */
  updateTableMeta(settings) {
    this.tableMeta.updateMeta(settings);
  }
  /**
   * Gets column meta object that is a root of all settings defined in the column property of the Handsontable
   * settings. Each column in the Handsontable is associated with a unique meta object which identified by
   * the physical column index. Adding, removing, or changing property in that object has a direct reflection
   * only for the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower
   * layers (prototype lookup).
   *
   * @param {number} physicalColumn The physical column index.
   * @returns {object}
   */
  getColumnMeta(physicalColumn) {
    return this.columnMeta.getMeta(physicalColumn);
  }
  /**
   * Updates column meta object by merging settings with the current state.
   *
   * @param {number} physicalColumn The physical column index which points what column meta object is updated.
   * @param {object} settings An object to merge with.
   */
  updateColumnMeta(physicalColumn, settings) {
    this.columnMeta.updateMeta(physicalColumn, settings);
  }
  /**
   * Gets the cell meta object that is a root of all settings defined for the specific cell rendered by
   * the Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't
   * exist in that layer, it is looked up through a prototype to the highest layer. Starting
   * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,
   * removing, or changing property in that object has no direct reflection on any other layers.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {object} options Additional options that are used to extend the cell meta object.
   * @param {number} options.visualRow The visual row index of the currently requested cell meta object.
   * @param {number} options.visualColumn The visual column index of the currently requested cell meta object.
   * @returns {object}
   */
  getCellMeta(physicalRow, physicalColumn, _ref2) {
    let {
      visualRow,
      visualColumn
    } = _ref2;
    const cellMeta = this.cellMeta.getMeta(physicalRow, physicalColumn);
    cellMeta.visualRow = visualRow;
    cellMeta.visualCol = visualColumn;
    cellMeta.row = physicalRow;
    cellMeta.col = physicalColumn;
    this.runLocalHooks("afterGetCellMeta", cellMeta);
    return cellMeta;
  }
  /**
   * Gets a value (defined by the `key` property) from the cell meta object.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key Defines the value that will be returned from the cell meta object.
   * @returns {*}
   */
  getCellMetaKeyValue(physicalRow, physicalColumn, key) {
    if (typeof key !== "string") {
      throw new Error("The passed cell meta object key is not a string");
    }
    return this.cellMeta.getMeta(physicalRow, physicalColumn, key);
  }
  /**
   * Sets settings object for cell meta object defined by "key" property.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key The property name to set.
   * @param {*} value Value to save.
   */
  setCellMeta(physicalRow, physicalColumn, key, value) {
    this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);
  }
  /**
   * Updates cell meta object by merging settings with the current state.
   *
   * @param {number} physicalRow The physical row index which points what cell meta object is updated.
   * @param {number} physicalColumn The physical column index which points what cell meta object is updated.
   * @param {object} settings An object to merge with.
   */
  updateCellMeta(physicalRow, physicalColumn, settings) {
    this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);
  }
  /**
   * Removes a property defined by the "key" argument from the cell meta object.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key The property name to remove.
   */
  removeCellMeta(physicalRow, physicalColumn, key) {
    this.cellMeta.removeMeta(physicalRow, physicalColumn, key);
  }
  /**
   * Returns all cell meta objects that were created during the Handsontable operation. As cell meta
   * objects are created lazy, the length of the returned collection depends on how and when the
   * table has asked for access to that meta objects.
   *
   * @returns {object[]}
   */
  getCellsMeta() {
    return this.cellMeta.getMetas();
  }
  /**
   * Returns all cell meta objects that were created during the Handsontable operation but for
   * specyfic row index.
   *
   * @param {number} physicalRow The physical row index.
   * @returns {object[]}
   */
  getCellsMetaAtRow(physicalRow) {
    return this.cellMeta.getMetasAtRow(physicalRow);
  }
  /**
   * Creates one or more rows at specific position.
   *
   * @param {number} physicalRow The physical row index which points from what position the row is added.
   * @param {number} [amount=1] An amount of rows to add.
   */
  createRow(physicalRow) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    this.cellMeta.createRow(physicalRow, amount);
  }
  /**
   * Removes one or more rows from the collection.
   *
   * @param {number} physicalRow The physical row index which points from what position the row is removed.
   * @param {number} [amount=1] An amount rows to remove.
   */
  removeRow(physicalRow) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    this.cellMeta.removeRow(physicalRow, amount);
  }
  /**
   * Creates one or more columns at specific position.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is added.
   * @param {number} [amount=1] An amount of columns to add.
   */
  createColumn(physicalColumn) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    this.cellMeta.createColumn(physicalColumn, amount);
    this.columnMeta.createColumn(physicalColumn, amount);
  }
  /**
   * Removes one or more columns from the collection.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is removed.
   * @param {number} [amount=1] An amount of columns to remove.
   */
  removeColumn(physicalColumn) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    this.cellMeta.removeColumn(physicalColumn, amount);
    this.columnMeta.removeColumn(physicalColumn, amount);
  }
  /**
   * Clears all saved cell meta objects. It keeps column meta, table meta, and global meta intact.
   */
  clearCellsCache() {
    this.cellMeta.clearCache();
  }
  /**
   * Clears all saved cell and columns meta objects.
   */
  clearCache() {
    this.cellMeta.clearCache();
    this.columnMeta.clearCache();
  }
};
mixin(MetaManager, localHooks_default);

// node_modules/handsontable/dataMap/replaceData.mjs
function replaceData(data, setDataMapFunction, callbackFunction, config) {
  const {
    hotInstance,
    dataMap,
    dataSource,
    internalSource,
    source,
    metaManager,
    firstRun
  } = config;
  const capitalizedInternalSource = toUpperCaseFirst(internalSource);
  const tableMeta = hotInstance.getSettings();
  if (Array.isArray(tableMeta.dataSchema)) {
    hotInstance.dataType = "array";
  } else if (isFunction2(tableMeta.dataSchema)) {
    hotInstance.dataType = "function";
  } else {
    hotInstance.dataType = "object";
  }
  if (dataMap) {
    dataMap.destroy();
  }
  data = hotInstance.runHooks(`before${capitalizedInternalSource}`, data, firstRun, source);
  const newDataMap = new dataMap_default(hotInstance, data, metaManager);
  setDataMapFunction(newDataMap);
  if (typeof data === "object" && data !== null) {
    if (!(data.push && data.splice)) {
      data = [data];
    }
  } else if (data === null) {
    const dataSchema = newDataMap.getSchema();
    data = [];
    let row;
    let r = 0;
    let rlen = 0;
    for (r = 0, rlen = tableMeta.startRows; r < rlen; r++) {
      if ((hotInstance.dataType === "object" || hotInstance.dataType === "function") && tableMeta.dataSchema) {
        row = deepClone(dataSchema);
        data.push(row);
      } else if (hotInstance.dataType === "array") {
        row = deepClone(dataSchema[0]);
        data.push(row);
      } else {
        row = [];
        for (let c = 0, clen = tableMeta.startCols; c < clen; c++) {
          row.push(null);
        }
        data.push(row);
      }
    }
  } else {
    throw new Error(`${internalSource} only accepts array of objects or array of arrays (${typeof data} given)`);
  }
  if (Array.isArray(data[0])) {
    hotInstance.dataType = "array";
  }
  tableMeta.data = data;
  newDataMap.dataSource = data;
  dataSource.data = data;
  dataSource.dataType = hotInstance.dataType;
  dataSource.colToProp = newDataMap.colToProp.bind(newDataMap);
  dataSource.propToCol = newDataMap.propToCol.bind(newDataMap);
  dataSource.countCachedColumns = newDataMap.countCachedColumns.bind(newDataMap);
  callbackFunction(newDataMap);
  hotInstance.runHooks(`after${capitalizedInternalSource}`, data, firstRun, source);
  if (!firstRun) {
    hotInstance.runHooks("afterChange", null, internalSource);
    hotInstance.render();
  }
}

// node_modules/handsontable/dataMap/metaManager/mods/dynamicCellMeta.mjs
var DynamicCellMetaMod = class {
  constructor(metaManager) {
    this.metaManager = metaManager;
    this.metaSyncMemo = /* @__PURE__ */ new Map();
    metaManager.addLocalHook("afterGetCellMeta", (cellMeta) => this.extendCellMeta(cellMeta));
    pluginHooks_default.getSingleton().add("beforeRender", (forceFullRender) => {
      if (forceFullRender) {
        this.metaSyncMemo.clear();
      }
    }, this.metaManager.hot);
  }
  /**
   * Extends the cell meta object by user-specific properties.
   *
   * The cell meta object can be extended dynamically,
   * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),
   * or by Handsontable's `cells` option.
   *
   * To boost performance, the extending process is triggered only once per one slow Handsontable render cycle.
   *
   * @param {object} cellMeta The cell meta object.
   */
  extendCellMeta(cellMeta) {
    var _this$metaSyncMemo$ge;
    const {
      row: physicalRow,
      col: physicalColumn
    } = cellMeta;
    if ((_this$metaSyncMemo$ge = this.metaSyncMemo.get(physicalRow)) !== null && _this$metaSyncMemo$ge !== void 0 && _this$metaSyncMemo$ge.has(physicalColumn)) {
      return;
    }
    const {
      visualRow,
      visualCol
    } = cellMeta;
    const hot = this.metaManager.hot;
    const prop = hot.colToProp(visualCol);
    cellMeta.prop = prop;
    hot.runHooks("beforeGetCellMeta", visualRow, visualCol, cellMeta);
    const cellType = hasOwnProperty2(cellMeta, "type") ? cellMeta.type : null;
    let cellSettings = isFunction2(cellMeta.cells) ? cellMeta.cells(physicalRow, physicalColumn, prop) : null;
    if (cellType) {
      if (cellSettings) {
        var _cellSettings$type;
        cellSettings.type = (_cellSettings$type = cellSettings.type) !== null && _cellSettings$type !== void 0 ? _cellSettings$type : cellType;
      } else {
        cellSettings = {
          type: cellType
        };
      }
    }
    if (cellSettings) {
      this.metaManager.updateCellMeta(physicalRow, physicalColumn, cellSettings);
    }
    hot.runHooks("afterGetCellMeta", visualRow, visualCol, cellMeta);
    if (!this.metaSyncMemo.has(physicalRow)) {
      this.metaSyncMemo.set(physicalRow, /* @__PURE__ */ new Set());
    }
    this.metaSyncMemo.get(physicalRow).add(physicalColumn);
  }
};

// node_modules/handsontable/dataMap/metaManager/mods/extendMetaProperties.mjs
var ExtendMetaPropertiesMod = class {
  constructor(metaManager) {
    this.metaManager = metaManager;
    this.usageTracker = /* @__PURE__ */ new Set();
    this.propDescriptors = /* @__PURE__ */ new Map([["fixedColumnsLeft", {
      target: "fixedColumnsStart",
      onChange(propName) {
        const isRtl = this.metaManager.hot.isRtl();
        if (isRtl && propName === "fixedColumnsLeft") {
          throw new Error("The `fixedColumnsLeft` is not supported for RTL. Please use option `fixedColumnsStart`.");
        }
        if (this.usageTracker.has("fixedColumnsLeft") && this.usageTracker.has("fixedColumnsStart")) {
          throw new Error("The `fixedColumnsLeft` and `fixedColumnsStart` should not be used together. Please use only the option `fixedColumnsStart`.");
        }
      }
    }], ["layoutDirection", {
      onChange(propName, value, isInitialChange) {
        if (!isInitialChange) {
          throw new Error(`The \`${propName}\` option can not be updated after the Handsontable is initialized.`);
        }
      }
    }]]);
    this.extendMetaProps();
  }
  /**
   * Extends the meta options based on the object descriptors from the `propDescriptors` list.
   */
  extendMetaProps() {
    this.propDescriptors.forEach((descriptor, alias) => {
      const {
        target,
        onChange: onChange2 = () => {
        }
      } = descriptor;
      const hasTarget = typeof target === "string";
      const targetProp = hasTarget ? target : alias;
      const origProp = `_${targetProp}`;
      this.metaManager.globalMeta.meta[origProp] = this.metaManager.globalMeta.meta[targetProp];
      this.installPropWatcher(alias, origProp, onChange2);
      if (hasTarget) {
        this.installPropWatcher(target, origProp, onChange2);
      }
    });
  }
  /**
   * Installs the property watcher to the `propName` option and forwards getter and setter to
   * the new one.
   *
   * @param {string} propName The property to watch.
   * @param {string} origProp The property from/to the value is forwarded.
   * @param {Function} onChange The callback.
   */
  installPropWatcher(propName, origProp, onChange2) {
    const self2 = this;
    Object.defineProperty(this.metaManager.globalMeta.meta, propName, {
      get() {
        return this[origProp];
      },
      set(value) {
        const isInitialChange = !self2.usageTracker.has(propName);
        self2.usageTracker.add(propName);
        onChange2.call(self2, propName, value, isInitialChange);
        this[origProp] = value;
      },
      enumerable: true,
      configurable: true
    });
  }
};

// node_modules/handsontable/shortcuts/utils.mjs
var mappings = /* @__PURE__ */ new Map([
  [" ", "space"],
  // custom mapping
  ["spacebar", "space"],
  ["scroll", "scrolllock"],
  ["del", "delete"],
  ["esc", "escape"],
  ["medianexttrack", "mediatracknext"],
  ["mediaprevioustrack", "mediatrackprevious"],
  ["volumeup", "audiovolumeup"],
  ["volumedown", "audiovolumedown"],
  ["volumemute", "audiovolumemute"],
  ["multiply", "*"],
  ["add", "+"],
  ["divide", "/"],
  ["subtract", "-"],
  ["left", "arrowleft"],
  ["right", "arrowright"],
  ["up", "arrowup"],
  ["down", "arrowdown"]
]);
var normalizeKeys = (keys2) => {
  return keys2.map((key) => {
    const lowercaseKey = key.toLowerCase();
    if (mappings.has(lowercaseKey)) {
      return mappings.get(lowercaseKey);
    }
    return lowercaseKey;
  }).sort().join("+");
};
var getKeysList = (normalizedKeys) => {
  return normalizedKeys.split("+");
};
var normalizeEventKey = (key) => {
  return key.toLowerCase();
};

// node_modules/handsontable/shortcuts/context.mjs
var createContext = (name) => {
  const SHORTCUTS = createUniqueMap({
    errorIdExists: (keys2) => `The "${keys2}" shortcut is already registered in the "${name}" context.`
  });
  const addShortcut = function() {
    let {
      keys: keys2,
      callback,
      group,
      runOnlyIf = () => true,
      captureCtrl = false,
      preventDefault = true,
      stopPropagation = false,
      relativeToGroup,
      position
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (isUndefined2(group)) {
      throw new Error("You need to define the shortcut's group.");
    }
    if (isFunction2(callback) === false) {
      throw new Error("The shortcut's callback needs to be a function.");
    }
    if (Array.isArray(keys2) === false) {
      throw new Error(toSingleLine`Pass the shortcut\'s keys as an array of arrays,\x20
      using the KeyboardEvent.key properties:\x20
      https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values.`);
    }
    const newShortcut = {
      callback,
      group,
      runOnlyIf,
      captureCtrl,
      preventDefault,
      stopPropagation
    };
    if (isDefined(relativeToGroup)) {
      [newShortcut.relativeToGroup, newShortcut.position] = [relativeToGroup, position];
    }
    keys2.forEach((keyCombination) => {
      const normalizedKeys = normalizeKeys(keyCombination);
      const hasKeyCombination = SHORTCUTS.hasItem(normalizedKeys);
      if (hasKeyCombination) {
        const shortcuts = SHORTCUTS.getItem(normalizedKeys);
        let insertionIndex = shortcuts.findIndex((shortcut) => shortcut.group === relativeToGroup);
        if (insertionIndex !== -1) {
          if (position === "before") {
            insertionIndex -= 1;
          } else {
            insertionIndex += 1;
          }
        } else {
          insertionIndex = shortcuts.length;
        }
        shortcuts.splice(insertionIndex, 0, newShortcut);
      } else {
        SHORTCUTS.addItem(normalizedKeys, [newShortcut]);
      }
    });
  };
  const addShortcuts = function(shortcuts) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    shortcuts.forEach((shortcut) => {
      objectEach(options, (value, key) => {
        if (Object.prototype.hasOwnProperty.call(shortcut, key) === false) {
          shortcut[key] = options[key];
        }
      });
      addShortcut(shortcut);
    });
  };
  const removeShortcutsByKeys = (keys2) => {
    const normalizedKeys = normalizeKeys(keys2);
    SHORTCUTS.removeItem(normalizedKeys);
  };
  const removeShortcutsByGroup = (group) => {
    const shortcuts = SHORTCUTS.getItems();
    shortcuts.forEach((_ref2) => {
      let [normalizedKeys, shortcutOptions] = _ref2;
      const leftOptions = shortcutOptions.filter((option) => option.group !== group);
      if (leftOptions.length === 0) {
        removeShortcutsByKeys(getKeysList(normalizedKeys));
      } else {
        shortcutOptions.length = 0;
        shortcutOptions.push(...leftOptions);
      }
    });
  };
  const getShortcuts = (keys2) => {
    const normalizedKeys = normalizeKeys(keys2);
    const shortcuts = SHORTCUTS.getItem(normalizedKeys);
    return isDefined(shortcuts) ? shortcuts.slice() : [];
  };
  const hasShortcut = (keys2) => {
    const normalizedKeys = normalizeKeys(keys2);
    return SHORTCUTS.hasItem(normalizedKeys);
  };
  return {
    addShortcut,
    addShortcuts,
    getShortcuts,
    hasShortcut,
    removeShortcutsByKeys,
    removeShortcutsByGroup
  };
};

// node_modules/handsontable/shortcuts/keyObserver.mjs
function createKeysObserver() {
  const PRESSED_KEYS = /* @__PURE__ */ new Set();
  return {
    /**
     * Press a key.
     *
     * @param {string} key Names of the shortcut's keys,
     * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),
     * in lowercase or uppercase, unified across browsers
     */
    press(key) {
      PRESSED_KEYS.add(key);
    },
    /**
     * Release a pressed key.
     *
     * @param {string} key Names of the shortcut's keys,
     * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),
     * in lowercase or uppercase, unified across browsers
     */
    release(key) {
      PRESSED_KEYS.delete(key);
    },
    /**
     * Release all pressed keys.
     */
    releaseAll() {
      PRESSED_KEYS.clear();
    },
    /**
     * Check if a key is pressed.
     *
     * @param {string} key Names of the shortcut's keys,
     * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),
     * in lowercase or uppercase, unified across browsers
     * @returns {boolean}
     */
    isPressed(key) {
      return PRESSED_KEYS.has(key);
    }
  };
}

// node_modules/handsontable/shortcuts/recorder.mjs
var MODIFIER_KEYS = ["meta", "alt", "shift", "control"];
var modifierKeysObserver = createKeysObserver();
function useRecorder(ownerWindow, handleEvent, beforeKeyDown, afterKeyDown, callback) {
  const isModifierKey = (pressedKey) => {
    return MODIFIER_KEYS.includes(pressedKey);
  };
  const getPressedModifierKeys = function(event2) {
    let mergeMetaKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const pressedModifierKeys = [];
    if (event2.altKey) {
      pressedModifierKeys.push("alt");
    }
    if (mergeMetaKeys && (event2.ctrlKey || event2.metaKey)) {
      pressedModifierKeys.push("control/meta");
    } else {
      if (event2.ctrlKey) {
        pressedModifierKeys.push("control");
      }
      if (event2.metaKey) {
        pressedModifierKeys.push("meta");
      }
    }
    if (event2.shiftKey) {
      pressedModifierKeys.push("shift");
    }
    return pressedModifierKeys;
  };
  const onkeydown = (event2) => {
    if (handleEvent(event2) === false) {
      return;
    }
    const result = beforeKeyDown(event2);
    if (event2.keyCode === 229 || result === false || isImmediatePropagationStopped(event2)) {
      return;
    }
    const pressedKey = normalizeEventKey(event2.key);
    let extraModifierKeys = [];
    if (isModifierKey(pressedKey)) {
      modifierKeysObserver.press(pressedKey);
    } else {
      extraModifierKeys = getPressedModifierKeys(event2);
    }
    const pressedKeys = [pressedKey].concat(extraModifierKeys);
    const isExecutionCancelled = callback(event2, pressedKeys);
    if (!isExecutionCancelled && (isMacOS() && extraModifierKeys.includes("meta") || !isMacOS() && extraModifierKeys.includes("control"))) {
      callback(event2, [pressedKey].concat(getPressedModifierKeys(event2, true)));
    }
    afterKeyDown(event2);
  };
  const onkeyup = (event2) => {
    if (handleEvent(event2) === false) {
      return;
    }
    const pressedKey = normalizeEventKey(event2.key);
    if (isModifierKey(pressedKey) === false) {
      return;
    }
    modifierKeysObserver.release(pressedKey);
  };
  const onblur = () => {
    modifierKeysObserver.releaseAll();
  };
  const mount = () => {
    let eventTarget = ownerWindow;
    while (eventTarget) {
      eventTarget.document.documentElement.addEventListener("keydown", onkeydown);
      eventTarget.document.documentElement.addEventListener("keyup", onkeyup);
      eventTarget.document.documentElement.addEventListener("blur", onblur);
      eventTarget = getParentWindow(eventTarget);
    }
  };
  const unmount = () => {
    let eventTarget = ownerWindow;
    while (eventTarget) {
      eventTarget.document.documentElement.removeEventListener("keydown", onkeydown);
      eventTarget.document.documentElement.removeEventListener("keyup", onkeyup);
      eventTarget.document.documentElement.removeEventListener("blur", onblur);
      eventTarget = getParentWindow(eventTarget);
    }
  };
  return {
    mount,
    unmount,
    isPressed: (key) => modifierKeysObserver.isPressed(key),
    releasePressedKeys: () => modifierKeysObserver.releaseAll()
  };
}

// node_modules/handsontable/shortcuts/manager.mjs
var createShortcutManager = (_ref2) => {
  let {
    ownerWindow,
    handleEvent,
    beforeKeyDown,
    afterKeyDown
  } = _ref2;
  const CONTEXTS = createUniqueMap({
    errorIdExists: (keys2) => `The "${keys2}" context name is already registered.`
  });
  let activeContextName = "grid";
  const addContext = (contextName) => {
    const context = createContext(contextName);
    CONTEXTS.addItem(contextName, context);
    return context;
  };
  const getActiveContextName = () => {
    return activeContextName;
  };
  const getContext = (contextName) => {
    return CONTEXTS.getItem(contextName);
  };
  const setActiveContextName = (contextName) => {
    activeContextName = contextName;
  };
  let isCtrlKeySilenced = false;
  const keyRecorder = useRecorder(ownerWindow, handleEvent, beforeKeyDown, afterKeyDown, (event2, keys2) => {
    const activeContext = getContext(getActiveContextName());
    let isExecutionCancelled = false;
    if (!activeContext.hasShortcut(keys2)) {
      return isExecutionCancelled;
    }
    const shortcuts = activeContext.getShortcuts(keys2);
    for (let index2 = 0; index2 < shortcuts.length; index2++) {
      const {
        callback,
        runOnlyIf,
        preventDefault,
        stopPropagation,
        captureCtrl
      } = shortcuts[index2];
      if (runOnlyIf(event2) !== false) {
        isCtrlKeySilenced = captureCtrl;
        isExecutionCancelled = callback(event2, keys2) === false;
        isCtrlKeySilenced = false;
        if (preventDefault) {
          event2.preventDefault();
        }
        if (stopPropagation) {
          event2.stopPropagation();
        }
        if (isExecutionCancelled) {
          break;
        }
      }
    }
    return isExecutionCancelled;
  });
  keyRecorder.mount();
  return {
    addContext,
    getActiveContextName,
    getContext,
    setActiveContextName,
    /**
     * Returns whether `control` or `meta` keys are pressed.
     *
     * @memberof ShortcutManager#
     * @type {Function}
     * @returns {boolean}
     */
    isCtrlPressed: () => !isCtrlKeySilenced && (keyRecorder.isPressed("control") || keyRecorder.isPressed("meta")),
    /**
     * Release every previously pressed key.
     *
     * @type {Function}
     * @memberof ShortcutManager#
     */
    releasePressedKeys: () => keyRecorder.releasePressedKeys(),
    /**
     * Destroy a context manager instance.
     *
     * @type {Function}
     * @memberof ShortcutManager#
     */
    destroy: () => keyRecorder.unmount()
  };
};

// node_modules/handsontable/core.mjs
var SHORTCUTS_GROUP = "gridDefault";
var activeGuid = null;
function Core(rootElement, userSettings) {
  var _userSettings$layoutD;
  let rootInstanceSymbol2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let preventScrollingToCell = false;
  let instance = this;
  const eventManager = new eventManager_default(instance);
  let datamap;
  let dataSource;
  let grid;
  let editorManager;
  let firstRun = true;
  if (hasValidParameter(rootInstanceSymbol2)) {
    registerAsRootInstance(this);
  }
  this.rootElement = rootElement;
  this.rootDocument = rootElement.ownerDocument;
  this.rootWindow = this.rootDocument.defaultView;
  this.isDestroyed = false;
  this.renderSuspendedCounter = 0;
  this.executionSuspendedCounter = 0;
  const layoutDirection = (_userSettings$layoutD = userSettings === null || userSettings === void 0 ? void 0 : userSettings.layoutDirection) !== null && _userSettings$layoutD !== void 0 ? _userSettings$layoutD : "inherit";
  const rootElementDirection = ["rtl", "ltr"].includes(layoutDirection) ? layoutDirection : this.rootWindow.getComputedStyle(this.rootElement).direction;
  this.rootElement.setAttribute("dir", rootElementDirection);
  this.isRtl = function() {
    return rootElementDirection === "rtl";
  };
  this.isLtr = function() {
    return !instance.isRtl();
  };
  this.getDirectionFactor = function() {
    return instance.isLtr() ? 1 : -1;
  };
  userSettings.language = getValidLanguageCode(userSettings.language);
  const metaManager = new MetaManager(instance, userSettings, [DynamicCellMetaMod, ExtendMetaPropertiesMod]);
  const tableMeta = metaManager.getTableMeta();
  const globalMeta = metaManager.getGlobalMeta();
  const pluginsRegistry = createUniqueMap();
  this.container = this.rootDocument.createElement("div");
  this.renderCall = false;
  rootElement.insertBefore(this.container, rootElement.firstChild);
  if (isRootInstance(this)) {
    _injectProductInfo(userSettings.licenseKey, rootElement);
  }
  this.guid = `ht_${randomString()}`;
  this.columnIndexMapper = new IndexMapper();
  this.rowIndexMapper = new IndexMapper();
  this.columnIndexMapper.addLocalHook("indexesSequenceChange", (source) => {
    instance.runHooks("afterColumnSequenceChange", source);
  });
  this.rowIndexMapper.addLocalHook("indexesSequenceChange", (source) => {
    instance.runHooks("afterRowSequenceChange", source);
  });
  dataSource = new dataSource_default(instance);
  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === "ht_") {
    this.rootElement.id = this.guid;
  }
  const visualToRenderableCoords = (coords) => {
    const {
      row: visualRow,
      col: visualColumn
    } = coords;
    return instance._createCellCoords(
      // We just store indexes for rows and columns without headers.
      visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow,
      visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn
    );
  };
  const renderableToVisualCoords = (coords) => {
    const {
      row: renderableRow,
      col: renderableColumn
    } = coords;
    return instance._createCellCoords(
      // We just store indexes for rows and columns without headers.
      renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow,
      renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn
      // eslint-disable-line max-len
    );
  };
  let selection = new selection_default2(tableMeta, {
    rowIndexMapper: () => instance.rowIndexMapper,
    columnIndexMapper: () => instance.columnIndexMapper,
    countCols: () => instance.countCols(),
    countRows: () => instance.countRows(),
    propToCol: (prop) => datamap.propToCol(prop),
    isEditorOpened: () => instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false,
    countColsTranslated: () => this.view.countRenderableColumns(),
    countRowsTranslated: () => this.view.countRenderableRows(),
    getShortcutManager: () => instance.getShortcutManager(),
    createCellCoords: (row, column) => instance._createCellCoords(row, column),
    createCellRange: (highlight, from2, to2) => instance._createCellRange(highlight, from2, to2),
    visualToRenderableCoords,
    renderableToVisualCoords,
    isDisabledCellSelection: (visualRow, visualColumn) => instance.getCellMeta(visualRow, visualColumn).disableVisualSelection
  });
  this.selection = selection;
  const onIndexMapperCacheUpdate = (_ref2) => {
    let {
      hiddenIndexesChanged
    } = _ref2;
    if (hiddenIndexesChanged) {
      this.selection.refresh();
    }
  };
  this.columnIndexMapper.addLocalHook("cacheUpdated", onIndexMapperCacheUpdate);
  this.rowIndexMapper.addLocalHook("cacheUpdated", onIndexMapperCacheUpdate);
  this.selection.addLocalHook("beforeSetRangeStart", (cellCoords) => {
    this.runHooks("beforeSetRangeStart", cellCoords);
  });
  this.selection.addLocalHook("beforeSetRangeStartOnly", (cellCoords) => {
    this.runHooks("beforeSetRangeStartOnly", cellCoords);
  });
  this.selection.addLocalHook("beforeSetRangeEnd", (cellCoords) => {
    this.runHooks("beforeSetRangeEnd", cellCoords);
    if (cellCoords.row < 0) {
      cellCoords.row = this.view._wt.wtTable.getFirstVisibleRow();
    }
    if (cellCoords.col < 0) {
      cellCoords.col = this.view._wt.wtTable.getFirstVisibleColumn();
    }
  });
  this.selection.addLocalHook("afterSetRangeEnd", (cellCoords) => {
    const preventScrolling = createObjectPropListener(false);
    const selectionRange = this.selection.getSelectedRange();
    const {
      from: from2,
      to: to2
    } = selectionRange.current();
    const selectionLayerLevel = selectionRange.size() - 1;
    this.runHooks("afterSelection", from2.row, from2.col, to2.row, to2.col, preventScrolling, selectionLayerLevel);
    this.runHooks("afterSelectionByProp", from2.row, instance.colToProp(from2.col), to2.row, instance.colToProp(to2.col), preventScrolling, selectionLayerLevel);
    const isSelectedByAnyHeader = this.selection.isSelectedByAnyHeader();
    const currentSelectedRange = this.selection.selectedRange.current();
    let scrollToCell = true;
    if (preventScrollingToCell) {
      scrollToCell = false;
    }
    if (preventScrolling.isTouched()) {
      scrollToCell = !preventScrolling.value;
    }
    const isSelectedByRowHeader = this.selection.isSelectedByRowHeader();
    const isSelectedByColumnHeader = this.selection.isSelectedByColumnHeader();
    if (scrollToCell !== false) {
      if (!isSelectedByAnyHeader) {
        if (currentSelectedRange && !this.selection.isMultiple()) {
          this.view.scrollViewport(visualToRenderableCoords(currentSelectedRange.from));
        } else {
          this.view.scrollViewport(visualToRenderableCoords(cellCoords));
        }
      } else if (isSelectedByRowHeader) {
        this.view.scrollViewportVertically(instance.rowIndexMapper.getRenderableFromVisualIndex(cellCoords.row));
      } else if (isSelectedByColumnHeader) {
        this.view.scrollViewportHorizontally(instance.columnIndexMapper.getRenderableFromVisualIndex(cellCoords.col));
      }
    }
    if (isSelectedByRowHeader && isSelectedByColumnHeader) {
      addClass(this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    } else if (isSelectedByRowHeader) {
      removeClass(this.rootElement, "ht__selection--columns");
      addClass(this.rootElement, "ht__selection--rows");
    } else if (isSelectedByColumnHeader) {
      removeClass(this.rootElement, "ht__selection--rows");
      addClass(this.rootElement, "ht__selection--columns");
    } else {
      removeClass(this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    }
    this._refreshBorders(null);
  });
  this.selection.addLocalHook("afterSelectionFinished", (cellRanges) => {
    const selectionLayerLevel = cellRanges.length - 1;
    const {
      from: from2,
      to: to2
    } = cellRanges[selectionLayerLevel];
    this.runHooks("afterSelectionEnd", from2.row, from2.col, to2.row, to2.col, selectionLayerLevel);
    this.runHooks("afterSelectionEndByProp", from2.row, instance.colToProp(from2.col), to2.row, instance.colToProp(to2.col), selectionLayerLevel);
  });
  this.selection.addLocalHook("afterIsMultipleSelection", (isMultiple) => {
    const changedIsMultiple = this.runHooks("afterIsMultipleSelection", isMultiple.value);
    if (isMultiple.value) {
      isMultiple.value = changedIsMultiple;
    }
  });
  this.selection.addLocalHook("beforeModifyTransformStart", (cellCoordsDelta) => {
    this.runHooks("modifyTransformStart", cellCoordsDelta);
  });
  this.selection.addLocalHook("afterModifyTransformStart", (coords, rowTransformDir, colTransformDir) => {
    this.runHooks("afterModifyTransformStart", coords, rowTransformDir, colTransformDir);
  });
  this.selection.addLocalHook("beforeModifyTransformEnd", (cellCoordsDelta) => {
    this.runHooks("modifyTransformEnd", cellCoordsDelta);
  });
  this.selection.addLocalHook("afterModifyTransformEnd", (coords, rowTransformDir, colTransformDir) => {
    this.runHooks("afterModifyTransformEnd", coords, rowTransformDir, colTransformDir);
  });
  this.selection.addLocalHook("afterDeselect", () => {
    editorManager.destroyEditor();
    this._refreshBorders();
    removeClass(this.rootElement, ["ht__selection--rows", "ht__selection--columns"]);
    this.runHooks("afterDeselect");
  });
  this.selection.addLocalHook("insertRowRequire", (totalRows) => {
    this.alter("insert_row_above", totalRows, 1, "auto");
  });
  this.selection.addLocalHook("insertColRequire", (totalCols) => {
    this.alter("insert_col_start", totalCols, 1, "auto");
  });
  grid = {
    /**
     * Inserts or removes rows and columns.
     *
     * @private
     * @param {string} action Possible values: "insert_row_above", "insert_row_below", "insert_col_start", "insert_col_end",
     *                        "remove_row", "remove_col".
     * @param {number|Array} index Row or column visual index which from the alter action will be triggered.
     *                             Alter actions such as "remove_row" and "remove_col" support array indexes in the
     *                             format `[[index, amount], [index, amount]...]` this can be used to remove
     *                             non-consecutive columns or rows in one call.
     * @param {number} [amount=1] Amount of rows or columns to remove.
     * @param {string} [source] Optional. Source of hook runner.
     * @param {boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.
     */
    alter(action, index2) {
      var _index, _index2;
      let amount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      let source = arguments.length > 3 ? arguments[3] : void 0;
      let keepEmptyRows = arguments.length > 4 ? arguments[4] : void 0;
      const normalizeIndexesGroup = (indexes) => {
        if (indexes.length === 0) {
          return [];
        }
        const sortedIndexes = [...indexes];
        sortedIndexes.sort((_ref2, _ref3) => {
          let [indexA] = _ref2;
          let [indexB] = _ref3;
          if (indexA === indexB) {
            return 0;
          }
          return indexA > indexB ? 1 : -1;
        });
        const normalizedIndexes = arrayReduce(sortedIndexes, (acc, _ref4) => {
          let [groupIndex, groupAmount] = _ref4;
          const previousItem = acc[acc.length - 1];
          const [prevIndex, prevAmount] = previousItem;
          const prevLastIndex = prevIndex + prevAmount;
          if (groupIndex <= prevLastIndex) {
            const amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);
            previousItem[1] += amountToAdd;
          } else {
            acc.push([groupIndex, groupAmount]);
          }
          return acc;
        }, [sortedIndexes[0]]);
        return normalizedIndexes;
      };
      switch (action) {
        case "insert_row_below":
        case "insert_row_above":
          const numberOfSourceRows = instance.countSourceRows();
          if (tableMeta.maxRows === numberOfSourceRows) {
            return;
          }
          const insertRowMode = action === "insert_row_below" ? "below" : "above";
          index2 = (_index = index2) !== null && _index !== void 0 ? _index : insertRowMode === "below" ? numberOfSourceRows : 0;
          const {
            delta: rowDelta,
            startPhysicalIndex: startRowPhysicalIndex
          } = datamap.createRow(index2, amount, {
            source,
            mode: insertRowMode
          });
          if (rowDelta) {
            const currentSelectedRange = selection.selectedRange.current();
            const currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;
            const currentFromRow = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.row;
            const startVisualRowIndex = instance.toVisualRow(startRowPhysicalIndex);
            if (selection.isSelectedByCorner()) {
              instance.selectAll();
            } else if (isDefined(currentFromRow) && currentFromRow >= startVisualRowIndex) {
              const {
                row: currentToRow,
                col: currentToColumn
              } = currentSelectedRange.to;
              let currentFromColumn = currentFromRange.col;
              if (selection.isSelectedByRowHeader()) {
                currentFromColumn = -1;
              }
              selection.getSelectedRange().pop();
              selection.setRangeStartOnly(instance._createCellCoords(currentFromRow + rowDelta, currentFromColumn), true);
              selection.setRangeEnd(instance._createCellCoords(currentToRow + rowDelta, currentToColumn));
            } else {
              instance._refreshBorders();
            }
          }
          break;
        case "insert_col_start":
        case "insert_col_end":
          const insertColumnMode = action === "insert_col_end" ? "end" : "start";
          index2 = (_index2 = index2) !== null && _index2 !== void 0 ? _index2 : insertColumnMode === "end" ? instance.countSourceCols() : 0;
          const {
            delta: colDelta,
            startPhysicalIndex: startColumnPhysicalIndex
          } = datamap.createCol(index2, amount, {
            source,
            mode: insertColumnMode
          });
          if (colDelta) {
            if (Array.isArray(tableMeta.colHeaders)) {
              const spliceArray = [instance.toVisualColumn(startColumnPhysicalIndex), 0];
              spliceArray.length += colDelta;
              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray);
            }
            const currentSelectedRange = selection.selectedRange.current();
            const currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;
            const currentFromColumn = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.col;
            const startVisualColumnIndex = instance.toVisualColumn(startColumnPhysicalIndex);
            if (selection.isSelectedByCorner()) {
              instance.selectAll();
            } else if (isDefined(currentFromColumn) && currentFromColumn >= startVisualColumnIndex) {
              const {
                row: currentToRow,
                col: currentToColumn
              } = currentSelectedRange.to;
              let currentFromRow = currentFromRange.row;
              if (selection.isSelectedByColumnHeader()) {
                currentFromRow = -1;
              }
              selection.getSelectedRange().pop();
              selection.setRangeStartOnly(instance._createCellCoords(currentFromRow, currentFromColumn + colDelta), true);
              selection.setRangeEnd(instance._createCellCoords(currentToRow, currentToColumn + colDelta));
            } else {
              instance._refreshBorders();
            }
          }
          break;
        case "remove_row":
          const removeRow = (indexes) => {
            let offset3 = 0;
            arrayEach(indexes, (_ref5) => {
              let [groupIndex, groupAmount] = _ref5;
              const calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset3, 0);
              if (Number.isInteger(groupIndex)) {
                groupIndex = Math.max(groupIndex - offset3, 0);
              }
              const wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);
              if (!wasRemoved) {
                return;
              }
              const totalRows = instance.countRows();
              const fixedRowsTop = tableMeta.fixedRowsTop;
              if (fixedRowsTop >= calcIndex + 1) {
                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);
              }
              const fixedRowsBottom = tableMeta.fixedRowsBottom;
              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {
                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);
              }
              offset3 += groupAmount;
            });
          };
          if (Array.isArray(index2)) {
            removeRow(normalizeIndexesGroup(index2));
          } else {
            removeRow([[index2, amount]]);
          }
          grid.adjustRowsAndCols();
          instance._refreshBorders();
          break;
        case "remove_col":
          const removeCol = (indexes) => {
            let offset3 = 0;
            arrayEach(indexes, (_ref6) => {
              let [groupIndex, groupAmount] = _ref6;
              const calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset3, 0);
              let physicalColumnIndex = instance.toPhysicalColumn(calcIndex);
              if (Number.isInteger(groupIndex)) {
                groupIndex = Math.max(groupIndex - offset3, 0);
              }
              const wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);
              if (!wasRemoved) {
                return;
              }
              const fixedColumnsStart = tableMeta.fixedColumnsStart;
              if (fixedColumnsStart >= calcIndex + 1) {
                tableMeta.fixedColumnsStart -= Math.min(groupAmount, fixedColumnsStart - calcIndex);
              }
              if (Array.isArray(tableMeta.colHeaders)) {
                if (typeof physicalColumnIndex === "undefined") {
                  physicalColumnIndex = -1;
                }
                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);
              }
              offset3 += groupAmount;
            });
          };
          if (Array.isArray(index2)) {
            removeCol(normalizeIndexesGroup(index2));
          } else {
            removeCol([[index2, amount]]);
          }
          grid.adjustRowsAndCols();
          instance._refreshBorders();
          break;
        default:
          throw new Error(`There is no such action "${action}"`);
      }
      if (!keepEmptyRows) {
        grid.adjustRowsAndCols();
      }
    },
    /**
     * Makes sure there are empty rows at the bottom of the table.
     *
     * @private
     */
    adjustRowsAndCols() {
      const minRows = tableMeta.minRows;
      const minSpareRows = tableMeta.minSpareRows;
      const minCols = tableMeta.minCols;
      const minSpareCols = tableMeta.minSpareCols;
      if (instance.countRows() === 0 && instance.countCols() === 0) {
        selection.deselect();
      }
      if (minRows) {
        const nrOfRows = instance.countRows();
        if (nrOfRows < minRows) {
          datamap.createRow(nrOfRows, minRows - nrOfRows, {
            source: "auto"
          });
        }
      }
      if (minSpareRows) {
        const emptyRows = instance.countEmptyRows(true);
        if (emptyRows < minSpareRows) {
          const emptyRowsMissing = minSpareRows - emptyRows;
          const rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows());
          datamap.createRow(instance.countRows(), rowsToCreate, {
            source: "auto"
          });
        }
      }
      {
        let emptyCols;
        if (minCols || minSpareCols) {
          emptyCols = instance.countEmptyCols(true);
        }
        let nrOfColumns = instance.countCols();
        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {
          const colsToCreate = minCols - nrOfColumns;
          emptyCols += colsToCreate;
          datamap.createCol(nrOfColumns, colsToCreate, {
            source: "auto"
          });
        }
        if (minSpareCols && !tableMeta.columns && instance.dataType === "array" && emptyCols < minSpareCols) {
          nrOfColumns = instance.countCols();
          const emptyColsMissing = minSpareCols - emptyCols;
          const colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns);
          datamap.createCol(nrOfColumns, colsToCreate, {
            source: "auto"
          });
        }
      }
      if (selection.isSelected()) {
        const rowCount = instance.countRows();
        const colCount = instance.countCols();
        arrayEach(selection.selectedRange, (range) => {
          let selectionChanged = false;
          let fromRow = range.from.row;
          let fromCol = range.from.col;
          let toRow = range.to.row;
          let toCol = range.to.col;
          if (fromRow > rowCount - 1) {
            fromRow = rowCount - 1;
            selectionChanged = true;
            if (toRow > fromRow) {
              toRow = fromRow;
            }
          } else if (toRow > rowCount - 1) {
            toRow = rowCount - 1;
            selectionChanged = true;
            if (fromRow > toRow) {
              fromRow = toRow;
            }
          }
          if (fromCol > colCount - 1) {
            fromCol = colCount - 1;
            selectionChanged = true;
            if (toCol > fromCol) {
              toCol = fromCol;
            }
          } else if (toCol > colCount - 1) {
            toCol = colCount - 1;
            selectionChanged = true;
            if (fromCol > toCol) {
              fromCol = toCol;
            }
          }
          if (selectionChanged) {
            instance.selectCell(fromRow, fromCol, toRow, toCol);
          }
        });
      }
      if (instance.view) {
        instance.view.adjustElementsSize();
      }
    },
    /**
     * Populate the data from the provided 2d array from the given cell coordinates.
     *
     * @private
     * @param {object} start Start selection position. Visual indexes.
     * @param {Array} input 2d data array.
     * @param {object} [end] End selection position (only for drag-down mode). Visual indexes.
     * @param {string} [source="populateFromArray"] Source information string.
     * @param {string} [method="overwrite"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.
     * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).
     */
    populateFromArray(start, input, end, source, method) {
      let r;
      let rlen;
      let c;
      let clen;
      const setData = [];
      const current = {};
      const newDataByColumns = [];
      const startRow = start.row;
      const startColumn = start.col;
      rlen = input.length;
      if (rlen === 0) {
        return false;
      }
      let columnsPopulationEnd = 0;
      let rowsPopulationEnd = 0;
      if (isObject2(end)) {
        columnsPopulationEnd = end.col - startColumn + 1;
        rowsPopulationEnd = end.row - startRow + 1;
      }
      switch (method) {
        case "shift_down":
          const populatedDataByColumns = pivot(input);
          const numberOfDataColumns = populatedDataByColumns.length;
          const numberOfColumnsToPopulate = Math.max(numberOfDataColumns, columnsPopulationEnd);
          const pushedDownDataByRows = instance.getData().slice(startRow);
          const pushedDownDataByColumns = pivot(pushedDownDataByRows).slice(startColumn, startColumn + numberOfColumnsToPopulate);
          for (c = 0; c < numberOfColumnsToPopulate; c += 1) {
            if (c < numberOfDataColumns) {
              for (r = 0, rlen = populatedDataByColumns[c].length; r < rowsPopulationEnd - rlen; r += 1) {
                populatedDataByColumns[c].push(populatedDataByColumns[c][r % rlen]);
              }
              if (c < pushedDownDataByColumns.length) {
                newDataByColumns.push(populatedDataByColumns[c].concat(pushedDownDataByColumns[c]));
              } else {
                newDataByColumns.push(populatedDataByColumns[c].concat(new Array(pushedDownDataByRows.length).fill(null)));
              }
            } else {
              newDataByColumns.push(populatedDataByColumns[c % numberOfDataColumns].concat(pushedDownDataByColumns[c]));
            }
          }
          instance.populateFromArray(startRow, startColumn, pivot(newDataByColumns));
          break;
        case "shift_right":
          const numberOfDataRows = input.length;
          const numberOfRowsToPopulate = Math.max(numberOfDataRows, rowsPopulationEnd);
          const pushedRightDataByRows = instance.getData().slice(startRow).map((rowData) => rowData.slice(startColumn));
          for (r = 0; r < numberOfRowsToPopulate; r += 1) {
            if (r < numberOfDataRows) {
              for (c = 0, clen = input[r].length; c < columnsPopulationEnd - clen; c += 1) {
                input[r].push(input[r][c % clen]);
              }
              if (r < pushedRightDataByRows.length) {
                for (let i = 0; i < pushedRightDataByRows[r].length; i += 1) {
                  input[r].push(pushedRightDataByRows[r][i]);
                }
              } else {
                input[r].push(...new Array(pushedRightDataByRows[0].length).fill(null));
              }
            } else {
              input.push(input[r % rlen].slice(0, numberOfRowsToPopulate).concat(pushedRightDataByRows[r]));
            }
          }
          instance.populateFromArray(startRow, startColumn, input);
          break;
        case "overwrite":
        default:
          current.row = start.row;
          current.col = start.col;
          let skippedRow = 0;
          let skippedColumn = 0;
          let pushData = true;
          let cellMeta;
          const getInputValue = function getInputValue2(row) {
            let col = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            const rowValue = input[row % input.length];
            if (col !== null) {
              return rowValue[col % rowValue.length];
            }
            return rowValue;
          };
          const rowInputLength = input.length;
          const rowSelectionLength = end ? end.row - start.row + 1 : 0;
          if (end) {
            rlen = rowSelectionLength;
          } else {
            rlen = Math.max(rowInputLength, rowSelectionLength);
          }
          for (r = 0; r < rlen; r++) {
            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {
              break;
            }
            const visualRow = r - skippedRow;
            const colInputLength = getInputValue(visualRow).length;
            const colSelectionLength = end ? end.col - start.col + 1 : 0;
            if (end) {
              clen = colSelectionLength;
            } else {
              clen = Math.max(colInputLength, colSelectionLength);
            }
            current.col = start.col;
            cellMeta = instance.getCellMeta(current.row, current.col);
            if ((source === "CopyPaste.paste" || source === "Autofill.fill") && cellMeta.skipRowOnPaste) {
              skippedRow += 1;
              current.row += 1;
              rlen += 1;
              continue;
            }
            skippedColumn = 0;
            for (c = 0; c < clen; c++) {
              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {
                break;
              }
              cellMeta = instance.getCellMeta(current.row, current.col);
              if ((source === "CopyPaste.paste" || source === "Autofill.fill") && cellMeta.skipColumnOnPaste) {
                skippedColumn += 1;
                current.col += 1;
                clen += 1;
                continue;
              }
              if (cellMeta.readOnly && source !== "UndoRedo.undo") {
                current.col += 1;
                continue;
              }
              const visualColumn = c - skippedColumn;
              let value = getInputValue(visualRow, visualColumn);
              let orgValue = instance.getDataAtCell(current.row, current.col);
              if (value !== null && typeof value === "object") {
                if (Array.isArray(value) && orgValue === null)
                  orgValue = [];
                if (orgValue === null || typeof orgValue !== "object") {
                  pushData = false;
                } else {
                  const orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);
                  const valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);
                  if (isObjectEqual(orgValueSchema, valueSchema) || Array.isArray(orgValueSchema) && Array.isArray(valueSchema)) {
                    value = deepClone(value);
                  } else {
                    pushData = false;
                  }
                }
              } else if (orgValue !== null && typeof orgValue === "object") {
                pushData = false;
              }
              if (pushData) {
                setData.push([current.row, current.col, value]);
              }
              pushData = true;
              current.col += 1;
            }
            current.row += 1;
          }
          instance.setDataAtCell(setData, null, null, source || "populateFromArray");
          break;
      }
    }
  };
  function setLanguage(languageCode) {
    const normalizedLanguageCode = normalizeLanguageCode(languageCode);
    if (hasLanguageDictionary(normalizedLanguageCode)) {
      instance.runHooks("beforeLanguageChange", normalizedLanguageCode);
      globalMeta.language = normalizedLanguageCode;
      instance.runHooks("afterLanguageChange", normalizedLanguageCode);
    } else {
      warnUserAboutLanguageRegistration(languageCode);
    }
  }
  function setClassName(className, classSettings) {
    const element = className === "className" ? instance.rootElement : instance.table;
    if (firstRun) {
      addClass(element, classSettings);
    } else {
      let globalMetaSettingsArray = [];
      let settingsArray = [];
      if (globalMeta[className]) {
        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : stringToArray(globalMeta[className]);
      }
      if (classSettings) {
        settingsArray = Array.isArray(classSettings) ? classSettings : stringToArray(classSettings);
      }
      const classNameToRemove = getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);
      const classNameToAdd = getDifferenceOfArrays(settingsArray, globalMetaSettingsArray);
      if (classNameToRemove.length) {
        removeClass(element, classNameToRemove);
      }
      if (classNameToAdd.length) {
        addClass(element, classNameToAdd);
      }
    }
    globalMeta[className] = classSettings;
  }
  this.init = function() {
    dataSource.setData(tableMeta.data);
    instance.runHooks("beforeInit");
    if (isMobileBrowser() || isIpadOS()) {
      addClass(instance.rootElement, "mobile");
    }
    this.updateSettings(tableMeta, true);
    this.view = new tableView_default(this);
    editorManager = editorManager_default.getInstance(instance, tableMeta, selection);
    instance.runHooks("init");
    this.forceFullRender = true;
    this.view.render();
    if (!!firstRun && instance.rootElement.offsetParent === null) {
      observeVisibilityChangeOnce(instance.rootElement, () => {
        instance.view._wt.wtOverlays.updateLastSpreaderSize();
        instance.render();
        instance.view.adjustElementsSize();
      });
    }
    if (typeof firstRun === "object") {
      instance.runHooks("afterChange", firstRun[0], firstRun[1]);
      firstRun = false;
    }
    instance.runHooks("afterInit");
  };
  function ValidatorsQueue() {
    let resolved = false;
    return {
      validatorsInQueue: 0,
      valid: true,
      addValidatorToQueue() {
        this.validatorsInQueue += 1;
        resolved = false;
      },
      removeValidatorFormQueue() {
        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;
        this.checkIfQueueIsEmpty();
      },
      onQueueEmpty() {
      },
      checkIfQueueIsEmpty() {
        if (this.validatorsInQueue === 0 && resolved === false) {
          resolved = true;
          this.onQueueEmpty(this.valid);
        }
      }
    };
  }
  function getParsedNumber(numericData) {
    const unifiedNumericData = numericData.replace(",", ".");
    if (isNaN(parseFloat(unifiedNumericData)) === false) {
      return parseFloat(unifiedNumericData);
    }
    return numericData;
  }
  function validateChanges(changes, source, callback) {
    if (!changes.length) {
      return;
    }
    const activeEditor = instance.getActiveEditor();
    const waitingForValidator = new ValidatorsQueue();
    let shouldBeCanceled = true;
    waitingForValidator.onQueueEmpty = (isValid2) => {
      if (activeEditor && shouldBeCanceled) {
        activeEditor.cancelChanges();
      }
      callback(isValid2);
    };
    for (let i = changes.length - 1; i >= 0; i--) {
      const [row, prop, , newValue] = changes[i];
      const col = datamap.propToCol(prop);
      const cellProperties = instance.getCellMeta(row, col);
      if (cellProperties.type === "numeric" && typeof newValue === "string" && isNumericLike(newValue)) {
        changes[i][3] = getParsedNumber(newValue);
      }
      if (instance.getCellValidator(cellProperties)) {
        waitingForValidator.addValidatorToQueue();
        instance.validateCell(changes[i][3], cellProperties, function(index2, cellPropertiesReference) {
          return function(result) {
            if (typeof result !== "boolean") {
              throw new Error("Validation error: result is not boolean");
            }
            if (result === false && cellPropertiesReference.allowInvalid === false) {
              shouldBeCanceled = false;
              changes.splice(index2, 1);
              cellPropertiesReference.valid = true;
              const cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);
              if (cell !== null) {
                removeClass(cell, tableMeta.invalidCellClassName);
              }
            }
            waitingForValidator.removeValidatorFormQueue();
          };
        }(i, cellProperties), source);
      }
    }
    waitingForValidator.checkIfQueueIsEmpty();
  }
  function applyChanges(changes, source) {
    let i = changes.length - 1;
    if (i < 0) {
      return;
    }
    for (; i >= 0; i--) {
      let skipThisChange = false;
      if (changes[i] === null) {
        changes.splice(i, 1);
        continue;
      }
      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {
        continue;
      }
      if (tableMeta.allowInsertRow) {
        while (changes[i][0] > instance.countRows() - 1) {
          const {
            delta: numberOfCreatedRows
          } = datamap.createRow(void 0, void 0, {
            source
          });
          if (numberOfCreatedRows === 0) {
            skipThisChange = true;
            break;
          }
        }
      }
      if (instance.dataType === "array" && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {
        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {
          const {
            delta: numberOfCreatedColumns
          } = datamap.createCol(void 0, void 0, {
            source
          });
          if (numberOfCreatedColumns === 0) {
            skipThisChange = true;
            break;
          }
        }
      }
      if (skipThisChange) {
        continue;
      }
      datamap.set(changes[i][0], changes[i][1], changes[i][3]);
    }
    instance.forceFullRender = true;
    grid.adjustRowsAndCols();
    instance.runHooks("beforeChangeRender", changes, source);
    editorManager.lockEditor();
    instance._refreshBorders(null);
    editorManager.unlockEditor();
    instance.view.adjustElementsSize();
    instance.runHooks("afterChange", changes, source || "edit");
    const activeEditor = instance.getActiveEditor();
    if (activeEditor && isDefined(activeEditor.refreshValue)) {
      activeEditor.refreshValue();
    }
  }
  this._createCellCoords = function(row, column) {
    return instance.view._wt.createCellCoords(row, column);
  };
  this._createCellRange = function(highlight, from2, to2) {
    return instance.view._wt.createCellRange(highlight, from2, to2);
  };
  this.validateCell = function(value, cellProperties, callback, source) {
    let validator = instance.getCellValidator(cellProperties);
    function done(valid) {
      let canBeValidated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (!canBeValidated || cellProperties.hidden === true) {
        callback(valid);
        return;
      }
      const col = cellProperties.visualCol;
      const row = cellProperties.visualRow;
      const td = instance.getCell(row, col, true);
      if (td && td.nodeName !== "TH") {
        const renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);
        const renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);
        instance.view._wt.getSetting("cellRenderer", renderableRow, renderableColumn, td);
      }
      callback(valid);
    }
    if (isRegExp(validator)) {
      validator = function(expression) {
        return function(cellValue, validatorCallback) {
          validatorCallback(expression.test(cellValue));
        };
      }(validator);
    }
    if (isFunction2(validator)) {
      value = instance.runHooks("beforeValidate", value, cellProperties.visualRow, cellProperties.prop, source);
      instance._registerImmediate(() => {
        validator.call(cellProperties, value, (valid) => {
          if (!instance) {
            return;
          }
          valid = instance.runHooks("afterValidate", valid, value, cellProperties.visualRow, cellProperties.prop, source);
          cellProperties.valid = valid;
          done(valid);
          instance.runHooks("postAfterValidate", valid, value, cellProperties.visualRow, cellProperties.prop, source);
        });
      });
    } else {
      instance._registerImmediate(() => {
        cellProperties.valid = true;
        done(cellProperties.valid, false);
      });
    }
  };
  function setDataInputToArray(row, propOrCol, value) {
    if (Array.isArray(row)) {
      return row;
    }
    return [[row, propOrCol, value]];
  }
  function processChanges(changes, source) {
    const activeEditor = instance.getActiveEditor();
    const beforeChangeResult = instance.runHooks("beforeChange", changes, source || "edit");
    const filteredChanges = changes.filter((change) => change !== null);
    if (beforeChangeResult === false || filteredChanges.length === 0) {
      if (activeEditor) {
        activeEditor.cancelChanges();
      }
      return [];
    }
    return filteredChanges;
  }
  this.setDataAtCell = function(row, column, value, source) {
    const input = setDataInputToArray(row, column, value);
    const changes = [];
    let changeSource = source;
    let i;
    let ilen;
    let prop;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      if (typeof input[i] !== "object") {
        throw new Error("Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter");
      }
      if (typeof input[i][1] !== "number") {
        throw new Error("Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`");
      }
      if (input[i][1] >= this.countCols()) {
        prop = input[i][1];
      } else {
        prop = datamap.colToProp(input[i][1]);
      }
      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }
    if (!changeSource && typeof row === "object") {
      changeSource = column;
    }
    const processedChanges = processChanges(changes, source);
    instance.runHooks("afterSetDataAtCell", processedChanges, changeSource);
    validateChanges(processedChanges, changeSource, () => {
      applyChanges(processedChanges, changeSource);
    });
  };
  this.setDataAtRowProp = function(row, prop, value, source) {
    const input = setDataInputToArray(row, prop, value);
    const changes = [];
    let changeSource = source;
    let i;
    let ilen;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }
    if (!changeSource && typeof row === "object") {
      changeSource = prop;
    }
    const processedChanges = processChanges(changes, source);
    instance.runHooks("afterSetDataAtRowProp", processedChanges, changeSource);
    validateChanges(processedChanges, changeSource, () => {
      applyChanges(processedChanges, changeSource);
    });
  };
  this.listen = function() {
    if (instance && !instance.isListening()) {
      activeGuid = instance.guid;
      instance.runHooks("afterListen");
    }
  };
  this.unlisten = function() {
    if (this.isListening()) {
      activeGuid = null;
      instance.runHooks("afterUnlisten");
    }
  };
  this.isListening = function() {
    return activeGuid === instance.guid;
  };
  this.destroyEditor = function() {
    let revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);
  };
  this.populateFromArray = function(row, column, input, endRow, endCol, source, method) {
    if (!(typeof input === "object" && typeof input[0] === "object")) {
      throw new Error("populateFromArray parameter `input` must be an array of arrays");
    }
    const c = typeof endRow === "number" ? instance._createCellCoords(endRow, endCol) : null;
    return grid.populateFromArray(instance._createCellCoords(row, column), input, c, source, method);
  };
  this.spliceCol = function(column, index2, amount) {
    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      elements[_key - 3] = arguments[_key];
    }
    return datamap.spliceCol(column, index2, amount, ...elements);
  };
  this.spliceRow = function(row, index2, amount) {
    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      elements[_key2 - 3] = arguments[_key2];
    }
    return datamap.spliceRow(row, index2, amount, ...elements);
  };
  this.getSelected = function() {
    if (selection.isSelected()) {
      return arrayMap(selection.getSelectedRange(), (_ref7) => {
        let {
          from: from2,
          to: to2
        } = _ref7;
        return [from2.row, from2.col, to2.row, to2.col];
      });
    }
  };
  this.getSelectedLast = function() {
    const selected = this.getSelected();
    let result;
    if (selected && selected.length > 0) {
      result = selected[selected.length - 1];
    }
    return result;
  };
  this.getSelectedRange = function() {
    if (selection.isSelected()) {
      return Array.from(selection.getSelectedRange());
    }
  };
  this.getSelectedRangeLast = function() {
    const selectedRange = this.getSelectedRange();
    let result;
    if (selectedRange && selectedRange.length > 0) {
      result = selectedRange[selectedRange.length - 1];
    }
    return result;
  };
  this.emptySelectedCells = function(source) {
    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {
      return;
    }
    const changes = [];
    arrayEach(selection.getSelectedRange(), (cellRange) => {
      const topStart = cellRange.getTopStartCorner();
      const bottomEnd = cellRange.getBottomEndCorner();
      rangeEach(topStart.row, bottomEnd.row, (row) => {
        rangeEach(topStart.col, bottomEnd.col, (column) => {
          if (!this.getCellMeta(row, column).readOnly) {
            changes.push([row, column, null]);
          }
        });
      });
    });
    if (changes.length > 0) {
      this.setDataAtCell(changes, source);
    }
  };
  this.isRenderSuspended = function() {
    return this.renderSuspendedCounter > 0;
  };
  this.suspendRender = function() {
    this.renderSuspendedCounter += 1;
  };
  this.resumeRender = function() {
    const nextValue = this.renderSuspendedCounter - 1;
    this.renderSuspendedCounter = Math.max(nextValue, 0);
    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {
      if (this.renderCall) {
        this.render();
      } else {
        this._refreshBorders(null);
      }
    }
  };
  this.render = function() {
    if (this.view) {
      this.renderCall = true;
      this.forceFullRender = true;
      if (!this.isRenderSuspended()) {
        editorManager.lockEditor();
        this._refreshBorders(null);
        editorManager.unlockEditor();
      }
    }
  };
  this.batchRender = function(wrappedOperations) {
    this.suspendRender();
    const result = wrappedOperations();
    this.resumeRender();
    return result;
  };
  this.isExecutionSuspended = function() {
    return this.executionSuspendedCounter > 0;
  };
  this.suspendExecution = function() {
    this.executionSuspendedCounter += 1;
    this.columnIndexMapper.suspendOperations();
    this.rowIndexMapper.suspendOperations();
  };
  this.resumeExecution = function() {
    let forceFlushChanges = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const nextValue = this.executionSuspendedCounter - 1;
    this.executionSuspendedCounter = Math.max(nextValue, 0);
    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {
      this.columnIndexMapper.resumeOperations();
      this.rowIndexMapper.resumeOperations();
    }
  };
  this.batchExecution = function(wrappedOperations) {
    let forceFlushChanges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    this.suspendExecution();
    const result = wrappedOperations();
    this.resumeExecution(forceFlushChanges);
    return result;
  };
  this.batch = function(wrappedOperations) {
    this.suspendRender();
    this.suspendExecution();
    const result = wrappedOperations();
    this.resumeExecution();
    this.resumeRender();
    return result;
  };
  this.refreshDimensions = function() {
    if (!instance.view) {
      return;
    }
    const {
      width: lastWidth,
      height: lastHeight
    } = instance.view.getLastSize();
    const {
      width,
      height
    } = instance.rootElement.getBoundingClientRect();
    const isSizeChanged = width !== lastWidth || height !== lastHeight;
    const isResizeBlocked = instance.runHooks("beforeRefreshDimensions", {
      width: lastWidth,
      height: lastHeight
    }, {
      width,
      height
    }, isSizeChanged) === false;
    if (isResizeBlocked) {
      return;
    }
    if (isSizeChanged || instance.view._wt.wtOverlays.scrollableElement === instance.rootWindow) {
      instance.view.setLastSize(width, height);
      instance.render();
    }
    instance.runHooks("afterRefreshDimensions", {
      width: lastWidth,
      height: lastHeight
    }, {
      width,
      height
    }, isSizeChanged);
  };
  this.updateData = function(data, source) {
    replaceData(data, (newDataMap) => {
      datamap = newDataMap;
    }, (newDataMap) => {
      datamap = newDataMap;
      instance.columnIndexMapper.fitToLength(this.getInitialColumnCount());
      instance.rowIndexMapper.fitToLength(this.countSourceRows());
      grid.adjustRowsAndCols();
    }, {
      hotInstance: instance,
      dataMap: datamap,
      dataSource,
      internalSource: "updateData",
      source,
      metaManager,
      firstRun
    });
  };
  this.loadData = function(data, source) {
    replaceData(data, (newDataMap) => {
      datamap = newDataMap;
    }, () => {
      metaManager.clearCellsCache();
      instance.initIndexMappers();
      grid.adjustRowsAndCols();
      if (firstRun) {
        firstRun = [null, "loadData"];
      }
    }, {
      hotInstance: instance,
      dataMap: datamap,
      dataSource,
      internalSource: "loadData",
      source,
      metaManager,
      firstRun
    });
  };
  this.getInitialColumnCount = function() {
    const columnsSettings = tableMeta.columns;
    let finalNrOfColumns = 0;
    if (Array.isArray(columnsSettings)) {
      finalNrOfColumns = columnsSettings.length;
    } else if (isFunction2(columnsSettings)) {
      if (instance.dataType === "array") {
        const nrOfSourceColumns = this.countSourceCols();
        for (let columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {
          if (columnsSettings(columnIndex)) {
            finalNrOfColumns += 1;
          }
        }
      } else if (instance.dataType === "object" || instance.dataType === "function") {
        finalNrOfColumns = datamap.colToPropCache.length;
      }
    } else if (isDefined(tableMeta.dataSchema)) {
      const schema = datamap.getSchema();
      finalNrOfColumns = Array.isArray(schema) ? schema.length : deepObjectSize(schema);
    } else {
      finalNrOfColumns = this.countSourceCols();
    }
    return finalNrOfColumns;
  };
  this.initIndexMappers = function() {
    this.columnIndexMapper.initToLength(this.getInitialColumnCount());
    this.rowIndexMapper.initToLength(this.countSourceRows());
  };
  this.getData = function(row, column, row2, column2) {
    if (isUndefined2(row)) {
      return datamap.getAll();
    }
    return datamap.getRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), datamap.DESTINATION_RENDERER);
  };
  this.getCopyableText = function(startRow, startCol, endRow, endCol) {
    return datamap.getCopyableText(instance._createCellCoords(startRow, startCol), instance._createCellCoords(endRow, endCol));
  };
  this.getCopyableData = function(row, column) {
    return datamap.getCopyable(row, datamap.colToProp(column));
  };
  this.getSchema = function() {
    return datamap.getSchema();
  };
  this.updateSettings = function(settings) {
    let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const dataUpdateFunction = (firstRun ? instance.loadData : instance.updateData).bind(this);
    let columnsAsFunc = false;
    let i;
    let j;
    if (isDefined(settings.rows)) {
      throw new Error('The "rows" setting is no longer supported. Do you mean startRows, minRows or maxRows?');
    }
    if (isDefined(settings.cols)) {
      throw new Error('The "cols" setting is no longer supported. Do you mean startCols, minCols or maxCols?');
    }
    if (isDefined(settings.ganttChart)) {
      throw new Error('Since 8.0.0 the "ganttChart" setting is no longer supported.');
    }
    for (i in settings) {
      if (i === "data") {
      } else if (i === "language") {
        setLanguage(settings.language);
      } else if (i === "className") {
        setClassName("className", settings.className);
      } else if (i === "tableClassName" && instance.table) {
        setClassName("tableClassName", settings.tableClassName);
        instance.view._wt.wtOverlays.syncOverlayTableClassNames();
      } else if (pluginHooks_default.getSingleton().isRegistered(i) || pluginHooks_default.getSingleton().isDeprecated(i)) {
        if (isFunction2(settings[i]) || Array.isArray(settings[i])) {
          settings[i].initialHook = true;
          instance.addHook(i, settings[i]);
        }
      } else if (!init && hasOwnProperty2(settings, i)) {
        globalMeta[i] = settings[i];
      }
    }
    if (settings.data === void 0 && tableMeta.data === void 0) {
      dataUpdateFunction(null, "updateSettings");
    } else if (settings.data !== void 0) {
      dataUpdateFunction(settings.data, "updateSettings");
    } else if (settings.columns !== void 0) {
      datamap.createMap();
      instance.initIndexMappers();
    }
    const clen = instance.countCols();
    const columnSetting = tableMeta.columns;
    if (columnSetting && isFunction2(columnSetting)) {
      columnsAsFunc = true;
    }
    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {
      metaManager.clearCache();
    }
    if (clen > 0) {
      for (i = 0, j = 0; i < clen; i++) {
        if (columnSetting) {
          const column = columnsAsFunc ? columnSetting(i) : columnSetting[j];
          if (column) {
            metaManager.updateColumnMeta(j, column);
          }
        }
        j += 1;
      }
    }
    if (isDefined(settings.cell)) {
      objectEach(settings.cell, (cell) => {
        instance.setCellMetaObject(cell.row, cell.col, cell);
      });
    }
    instance.runHooks("afterCellMetaReset");
    let currentHeight = instance.rootElement.style.height;
    if (currentHeight !== "") {
      currentHeight = parseInt(instance.rootElement.style.height, 10);
    }
    let height = settings.height;
    if (isFunction2(height)) {
      height = height();
    }
    if (init) {
      const initialStyle = instance.rootElement.getAttribute("style");
      if (initialStyle) {
        instance.rootElement.setAttribute("data-initialstyle", instance.rootElement.getAttribute("style"));
      }
    }
    if (height === null) {
      const initialStyle = instance.rootElement.getAttribute("data-initialstyle");
      if (initialStyle && (initialStyle.indexOf("height") > -1 || initialStyle.indexOf("overflow") > -1)) {
        instance.rootElement.setAttribute("style", initialStyle);
      } else {
        instance.rootElement.style.height = "";
        instance.rootElement.style.overflow = "";
      }
    } else if (height !== void 0) {
      instance.rootElement.style.height = isNaN(height) ? `${height}` : `${height}px`;
      instance.rootElement.style.overflow = "hidden";
    }
    if (typeof settings.width !== "undefined") {
      let width = settings.width;
      if (isFunction2(width)) {
        width = width();
      }
      instance.rootElement.style.width = isNaN(width) ? `${width}` : `${width}px`;
    }
    if (!init) {
      if (instance.view) {
        instance.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();
        instance.view._wt.exportSettingsAsClassNames();
      }
      instance.runHooks("afterUpdateSettings", settings);
    }
    grid.adjustRowsAndCols();
    if (instance.view && !firstRun) {
      instance.forceFullRender = true;
      editorManager.lockEditor();
      instance._refreshBorders(null);
      instance.view._wt.wtOverlays.adjustElementsSize();
      editorManager.unlockEditor();
    }
    if (!init && instance.view && (currentHeight === "" || height === "" || height === void 0) && currentHeight !== height) {
      instance.view._wt.wtOverlays.updateMainScrollableElements();
    }
  };
  this.getValue = function() {
    const sel = instance.getSelectedLast();
    if (tableMeta.getValue) {
      if (isFunction2(tableMeta.getValue)) {
        return tableMeta.getValue.call(instance);
      } else if (sel) {
        return instance.getData()[sel[0][0]][tableMeta.getValue];
      }
    } else if (sel) {
      return instance.getDataAtCell(sel[0], sel[1]);
    }
  };
  this.getSettings = function() {
    return tableMeta;
  };
  this.clear = function() {
    this.selectAll();
    this.emptySelectedCells();
  };
  this.alter = function(action, index2, amount, source, keepEmptyRows) {
    grid.alter(action, index2, amount, source, keepEmptyRows);
  };
  this.getCell = function(row, column) {
    let topmost = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let renderableColumnIndex = column;
    let renderableRowIndex = row;
    if (column >= 0) {
      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {
        return null;
      }
      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);
    }
    if (row >= 0) {
      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {
        return null;
      }
      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);
    }
    if (renderableRowIndex === null || renderableColumnIndex === null) {
      return null;
    }
    return instance.view.getCellAtCoords(instance._createCellCoords(renderableRowIndex, renderableColumnIndex), topmost);
  };
  this.getCoords = function(element) {
    const renderableCoords = this.view._wt.wtTable.getCoords(element);
    if (renderableCoords === null) {
      return null;
    }
    const {
      row: renderableRow,
      col: renderableColumn
    } = renderableCoords;
    let visualRow = renderableRow;
    let visualColumn = renderableColumn;
    if (renderableRow >= 0) {
      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);
    }
    if (renderableColumn >= 0) {
      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);
    }
    return instance._createCellCoords(visualRow, visualColumn);
  };
  this.colToProp = function(column) {
    return datamap.colToProp(column);
  };
  this.propToCol = function(prop) {
    return datamap.propToCol(prop);
  };
  this.toVisualRow = (row) => this.rowIndexMapper.getVisualFromPhysicalIndex(row);
  this.toVisualColumn = (column) => this.columnIndexMapper.getVisualFromPhysicalIndex(column);
  this.toPhysicalRow = (row) => this.rowIndexMapper.getPhysicalFromVisualIndex(row);
  this.toPhysicalColumn = (column) => this.columnIndexMapper.getPhysicalFromVisualIndex(column);
  this.getDataAtCell = function(row, column) {
    return datamap.get(row, datamap.colToProp(column));
  };
  this.getDataAtRowProp = function(row, prop) {
    return datamap.get(row, prop);
  };
  this.getDataAtCol = function(column) {
    const columnData = [];
    const dataByRows = datamap.getRange(instance._createCellCoords(0, column), instance._createCellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER);
    for (let i = 0; i < dataByRows.length; i += 1) {
      for (let j = 0; j < dataByRows[i].length; j += 1) {
        columnData.push(dataByRows[i][j]);
      }
    }
    return columnData;
  };
  this.getDataAtProp = function(prop) {
    const columnData = [];
    const dataByRows = datamap.getRange(instance._createCellCoords(0, datamap.propToCol(prop)), instance._createCellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);
    for (let i = 0; i < dataByRows.length; i += 1) {
      for (let j = 0; j < dataByRows[i].length; j += 1) {
        columnData.push(dataByRows[i][j]);
      }
    }
    return columnData;
  };
  this.getSourceData = function(row, column, row2, column2) {
    let data;
    if (row === void 0) {
      data = dataSource.getData();
    } else {
      data = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2));
    }
    return data;
  };
  this.getSourceDataArray = function(row, column, row2, column2) {
    let data;
    if (row === void 0) {
      data = dataSource.getData(true);
    } else {
      data = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), true);
    }
    return data;
  };
  this.getSourceDataAtCol = function(column) {
    return dataSource.getAtColumn(column);
  };
  this.setSourceDataAtCell = function(row, column, value, source) {
    const input = setDataInputToArray(row, column, value);
    const isThereAnySetSourceListener = this.hasHook("afterSetSourceDataAtCell");
    const changesForHook = [];
    if (isThereAnySetSourceListener) {
      arrayEach(input, (_ref8) => {
        let [changeRow, changeProp, changeValue] = _ref8;
        changesForHook.push([
          changeRow,
          changeProp,
          dataSource.getAtCell(changeRow, changeProp),
          // The previous value.
          changeValue
        ]);
      });
    }
    arrayEach(input, (_ref9) => {
      let [changeRow, changeProp, changeValue] = _ref9;
      dataSource.setAtCell(changeRow, changeProp, changeValue);
    });
    if (isThereAnySetSourceListener) {
      this.runHooks("afterSetSourceDataAtCell", changesForHook, source);
    }
    this.render();
    const activeEditor = instance.getActiveEditor();
    if (activeEditor && isDefined(activeEditor.refreshValue)) {
      activeEditor.refreshValue();
    }
  };
  this.getSourceDataAtRow = function(row) {
    return dataSource.getAtRow(row);
  };
  this.getSourceDataAtCell = function(row, column) {
    return dataSource.getAtCell(row, column);
  };
  this.getDataAtRow = function(row) {
    const data = datamap.getRange(instance._createCellCoords(row, 0), instance._createCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);
    return data[0] || [];
  };
  this.getDataType = function(rowFrom, columnFrom, rowTo, columnTo) {
    const coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];
    const [rowStart, columnStart] = coords;
    let [, , rowEnd, columnEnd] = coords;
    let previousType = null;
    let currentType = null;
    if (rowEnd === void 0) {
      rowEnd = rowStart;
    }
    if (columnEnd === void 0) {
      columnEnd = columnStart;
    }
    let type = "mixed";
    rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), (row) => {
      let isTypeEqual = true;
      rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), (column) => {
        const cellType = this.getCellMeta(row, column);
        currentType = cellType.type;
        if (previousType) {
          isTypeEqual = previousType === currentType;
        } else {
          previousType = currentType;
        }
        return isTypeEqual;
      });
      type = isTypeEqual ? currentType : "mixed";
      return isTypeEqual;
    });
    return type;
  };
  this.removeCellMeta = function(row, column, key) {
    const [physicalRow, physicalColumn] = [this.toPhysicalRow(row), this.toPhysicalColumn(column)];
    let cachedValue = metaManager.getCellMetaKeyValue(physicalRow, physicalColumn, key);
    const hookResult = instance.runHooks("beforeRemoveCellMeta", row, column, key, cachedValue);
    if (hookResult !== false) {
      metaManager.removeCellMeta(physicalRow, physicalColumn, key);
      instance.runHooks("afterRemoveCellMeta", row, column, key, cachedValue);
    }
    cachedValue = null;
  };
  this.spliceCellsMeta = function(visualIndex) {
    let deleteAmount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (var _len3 = arguments.length, cellMetaRows = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      cellMetaRows[_key3 - 2] = arguments[_key3];
    }
    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {
      throw new Error("The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.");
    }
    if (deleteAmount > 0) {
      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);
    }
    if (cellMetaRows.length > 0) {
      arrayEach(cellMetaRows.reverse(), (cellMetaRow) => {
        metaManager.createRow(this.toPhysicalRow(visualIndex));
        arrayEach(cellMetaRow, (cellMeta, columnIndex) => this.setCellMetaObject(visualIndex, columnIndex, cellMeta));
      });
    }
    instance.render();
  };
  this.setCellMetaObject = function(row, column, prop) {
    if (typeof prop === "object") {
      objectEach(prop, (value, key) => {
        this.setCellMeta(row, column, key, value);
      });
    }
  };
  this.setCellMeta = function(row, column, key, value) {
    const allowSetCellMeta = instance.runHooks("beforeSetCellMeta", row, column, key, value);
    if (allowSetCellMeta === false) {
      return;
    }
    let physicalRow = row;
    let physicalColumn = column;
    if (row < this.countRows()) {
      physicalRow = this.toPhysicalRow(row);
    }
    if (column < this.countCols()) {
      physicalColumn = this.toPhysicalColumn(column);
    }
    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);
    instance.runHooks("afterSetCellMeta", row, column, key, value);
  };
  this.getCellsMeta = function() {
    return metaManager.getCellsMeta();
  };
  this.getCellMeta = function(row, column) {
    let physicalRow = this.toPhysicalRow(row);
    let physicalColumn = this.toPhysicalColumn(column);
    if (physicalRow === null) {
      physicalRow = row;
    }
    if (physicalColumn === null) {
      physicalColumn = column;
    }
    return metaManager.getCellMeta(physicalRow, physicalColumn, {
      visualRow: row,
      visualColumn: column
    });
  };
  this.getCellMetaAtRow = function(row) {
    return metaManager.getCellsMetaAtRow(row);
  };
  this.isColumnModificationAllowed = function() {
    return !(instance.dataType === "object" || tableMeta.columns);
  };
  this.getCellRenderer = function(rowOrMeta, column) {
    const cellRenderer = typeof rowOrMeta === "number" ? instance.getCellMeta(rowOrMeta, column).renderer : rowOrMeta.renderer;
    if (typeof cellRenderer === "string") {
      return _getItem2(cellRenderer);
    }
    return isUndefined2(cellRenderer) ? _getItem2("text") : cellRenderer;
  };
  this.getCellEditor = function(rowOrMeta, column) {
    const cellEditor = typeof rowOrMeta === "number" ? instance.getCellMeta(rowOrMeta, column).editor : rowOrMeta.editor;
    if (typeof cellEditor === "string") {
      return _getItem(cellEditor);
    }
    return isUndefined2(cellEditor) ? _getItem("text") : cellEditor;
  };
  this.getCellValidator = function(rowOrMeta, column) {
    const cellValidator = typeof rowOrMeta === "number" ? instance.getCellMeta(rowOrMeta, column).validator : rowOrMeta.validator;
    if (typeof cellValidator === "string") {
      return _getItem3(cellValidator);
    }
    return cellValidator;
  };
  this.validateCells = function(callback) {
    this._validateCells(callback);
  };
  this.validateRows = function(rows, callback) {
    if (!Array.isArray(rows)) {
      throw new Error("validateRows parameter `rows` must be an array");
    }
    this._validateCells(callback, rows);
  };
  this.validateColumns = function(columns, callback) {
    if (!Array.isArray(columns)) {
      throw new Error("validateColumns parameter `columns` must be an array");
    }
    this._validateCells(callback, void 0, columns);
  };
  this._validateCells = function(callback, rows, columns) {
    const waitingForValidator = new ValidatorsQueue();
    if (callback) {
      waitingForValidator.onQueueEmpty = callback;
    }
    let i = instance.countRows() - 1;
    while (i >= 0) {
      if (rows !== void 0 && rows.indexOf(i) === -1) {
        i -= 1;
        continue;
      }
      let j = instance.countCols() - 1;
      while (j >= 0) {
        if (columns !== void 0 && columns.indexOf(j) === -1) {
          j -= 1;
          continue;
        }
        waitingForValidator.addValidatorToQueue();
        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), (result) => {
          if (typeof result !== "boolean") {
            throw new Error("Validation error: result is not boolean");
          }
          if (result === false) {
            waitingForValidator.valid = false;
          }
          waitingForValidator.removeValidatorFormQueue();
        }, "validateCells");
        j -= 1;
      }
      i -= 1;
    }
    waitingForValidator.checkIfQueueIsEmpty();
  };
  this.getRowHeader = function(row) {
    let rowHeader = tableMeta.rowHeaders;
    let physicalRow = row;
    if (physicalRow !== void 0) {
      physicalRow = instance.runHooks("modifyRowHeader", physicalRow);
    }
    if (physicalRow === void 0) {
      rowHeader = [];
      rangeEach(instance.countRows() - 1, (i) => {
        rowHeader.push(instance.getRowHeader(i));
      });
    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {
      rowHeader = rowHeader[physicalRow];
    } else if (isFunction2(rowHeader)) {
      rowHeader = rowHeader(physicalRow);
    } else if (rowHeader && typeof rowHeader !== "string" && typeof rowHeader !== "number") {
      rowHeader = physicalRow + 1;
    }
    return rowHeader;
  };
  this.hasRowHeaders = function() {
    return !!tableMeta.rowHeaders;
  };
  this.hasColHeaders = function() {
    if (tableMeta.colHeaders !== void 0 && tableMeta.colHeaders !== null) {
      return !!tableMeta.colHeaders;
    }
    for (let i = 0, ilen = instance.countCols(); i < ilen; i++) {
      if (instance.getColHeader(i)) {
        return true;
      }
    }
    return false;
  };
  this.getColHeader = function(column) {
    let headerLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    const columnIndex = instance.runHooks("modifyColHeader", column);
    if (columnIndex === void 0) {
      const out = [];
      const ilen = instance.countCols();
      for (let i = 0; i < ilen; i++) {
        out.push(instance.getColHeader(i));
      }
      return out;
    }
    let result = tableMeta.colHeaders;
    const translateVisualIndexToColumns = function(visualColumnIndex) {
      const arr = [];
      const columnsLen = instance.countCols();
      let index2 = 0;
      for (; index2 < columnsLen; index2++) {
        if (isFunction2(tableMeta.columns) && tableMeta.columns(index2)) {
          arr.push(index2);
        }
      }
      return arr[visualColumnIndex];
    };
    const physicalColumn = instance.toPhysicalColumn(columnIndex);
    const prop = translateVisualIndexToColumns(physicalColumn);
    if (tableMeta.colHeaders === false) {
      result = null;
    } else if (tableMeta.columns && isFunction2(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {
      result = tableMeta.columns(prop).title;
    } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {
      result = tableMeta.columns[physicalColumn].title;
    } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== void 0) {
      result = tableMeta.colHeaders[physicalColumn];
    } else if (isFunction2(tableMeta.colHeaders)) {
      result = tableMeta.colHeaders(physicalColumn);
    } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== "string" && typeof tableMeta.colHeaders !== "number") {
      result = spreadsheetColumnLabel(columnIndex);
    }
    result = instance.runHooks("modifyColumnHeaderValue", result, column, headerLevel);
    return result;
  };
  this._getColWidthFromSettings = function(col) {
    let width;
    if (col >= 0) {
      const cellProperties = instance.getCellMeta(0, col);
      width = cellProperties.width;
    }
    if (width === void 0 || width === tableMeta.width) {
      width = tableMeta.colWidths;
    }
    if (width !== void 0 && width !== null) {
      switch (typeof width) {
        case "object":
          width = width[col];
          break;
        case "function":
          width = width(col);
          break;
        default:
          break;
      }
      if (typeof width === "string") {
        width = parseInt(width, 10);
      }
    }
    return width;
  };
  this.getColWidth = function(column) {
    let width = instance._getColWidthFromSettings(column);
    width = instance.runHooks("modifyColWidth", width, column);
    if (width === void 0) {
      width = viewportColumns_default.DEFAULT_WIDTH;
    }
    return width;
  };
  this._getRowHeightFromSettings = function(row) {
    let height = tableMeta.rowHeights;
    if (height !== void 0 && height !== null) {
      switch (typeof height) {
        case "object":
          height = height[row];
          break;
        case "function":
          height = height(row);
          break;
        default:
          break;
      }
      if (typeof height === "string") {
        height = parseInt(height, 10);
      }
    }
    return height;
  };
  this.getRowHeight = function(row) {
    let height = instance._getRowHeightFromSettings(row);
    height = instance.runHooks("modifyRowHeight", height, row);
    return height;
  };
  this.countSourceRows = function() {
    return dataSource.countRows();
  };
  this.countSourceCols = function() {
    return dataSource.countFirstRowKeys();
  };
  this.countRows = function() {
    return datamap.getLength();
  };
  this.countCols = function() {
    const maxCols = tableMeta.maxCols;
    const dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();
    return Math.min(maxCols, dataLen);
  };
  this.countRenderedRows = function() {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedRowsCount() : -1;
  };
  this.countVisibleRows = function() {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleRowsCount() : -1;
  };
  this.countRenderedCols = function() {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedColumnsCount() : -1;
  };
  this.countVisibleCols = function() {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleColumnsCount() : -1;
  };
  this.countEmptyRows = function() {
    let ending = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let emptyRows = 0;
    rangeEachReverse(instance.countRows() - 1, (visualIndex) => {
      if (instance.isEmptyRow(visualIndex)) {
        emptyRows += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyRows;
  };
  this.countEmptyCols = function() {
    let ending = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let emptyColumns = 0;
    rangeEachReverse(instance.countCols() - 1, (visualIndex) => {
      if (instance.isEmptyCol(visualIndex)) {
        emptyColumns += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyColumns;
  };
  this.isEmptyRow = function(row) {
    return tableMeta.isEmptyRow.call(instance, row);
  };
  this.isEmptyCol = function(column) {
    return tableMeta.isEmptyCol.call(instance, column);
  };
  this.selectCell = function(row, column, endRow, endColumn) {
    let scrollToCell = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    let changeListener = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    if (isUndefined2(row) || isUndefined2(column)) {
      return false;
    }
    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);
  };
  this.selectCells = function() {
    let coords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [[]];
    let scrollToCell = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let changeListener = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (scrollToCell === false) {
      preventScrollingToCell = true;
    }
    const wasSelected = selection.selectCells(coords);
    if (wasSelected && changeListener) {
      instance.listen();
    }
    preventScrollingToCell = false;
    return wasSelected;
  };
  this.selectColumns = function(startColumn) {
    let endColumn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startColumn;
    return selection.selectColumns(startColumn, endColumn);
  };
  this.selectRows = function(startRow) {
    let endRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startRow;
    return selection.selectRows(startRow, endRow);
  };
  this.deselectCell = function() {
    selection.deselect();
  };
  this.selectAll = function() {
    let includeHeaders = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    const includeRowHeaders = includeHeaders && this.hasRowHeaders();
    const includeColumnHeaders = includeHeaders && this.hasColHeaders();
    preventScrollingToCell = true;
    selection.selectAll(includeRowHeaders, includeColumnHeaders);
    preventScrollingToCell = false;
  };
  const getIndexToScroll = (indexMapper, visualIndex) => {
    return indexMapper.getNearestNotHiddenIndex(visualIndex, 1, true);
  };
  this.scrollViewportTo = function(row, column) {
    let snapToBottom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let snapToRight = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let considerHiddenIndexes = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    const snapToTop = !snapToBottom;
    const snapToLeft = !snapToRight;
    let renderableRow = row;
    let renderableColumn = column;
    if (considerHiddenIndexes) {
      const isRowInteger2 = Number.isInteger(row);
      const isColumnInteger2 = Number.isInteger(column);
      const visualRowToScroll = isRowInteger2 ? getIndexToScroll(this.rowIndexMapper, row) : void 0;
      const visualColumnToScroll = isColumnInteger2 ? getIndexToScroll(this.columnIndexMapper, column) : void 0;
      if (visualRowToScroll === null || visualColumnToScroll === null) {
        return false;
      }
      renderableRow = isRowInteger2 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : void 0;
      renderableColumn = isColumnInteger2 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : void 0;
    }
    const isRowInteger = Number.isInteger(renderableRow);
    const isColumnInteger = Number.isInteger(renderableColumn);
    if (isRowInteger && isColumnInteger) {
      return instance.view.scrollViewport(instance._createCellCoords(renderableRow, renderableColumn), snapToTop, snapToRight, snapToBottom, snapToLeft);
    }
    if (isRowInteger && isColumnInteger === false) {
      return instance.view.scrollViewportVertically(renderableRow, snapToTop, snapToBottom);
    }
    if (isColumnInteger && isRowInteger === false) {
      return instance.view.scrollViewportHorizontally(renderableColumn, snapToRight, snapToLeft);
    }
    return false;
  };
  this.destroy = function() {
    instance._clearTimeouts();
    instance._clearImmediates();
    if (instance.view) {
      instance.view.destroy();
    }
    if (dataSource) {
      dataSource.destroy();
    }
    dataSource = null;
    this.getShortcutManager().destroy();
    metaManager.clearCache();
    if (isRootInstance(instance)) {
      const licenseInfo = this.rootDocument.querySelector(".hot-display-license-info");
      if (licenseInfo) {
        licenseInfo.parentNode.removeChild(licenseInfo);
      }
    }
    empty(instance.rootElement);
    eventManager.destroy();
    if (editorManager) {
      editorManager.destroy();
    }
    instance.batchExecution(() => {
      instance.rowIndexMapper.unregisterAll();
      instance.columnIndexMapper.unregisterAll();
      pluginsRegistry.getItems().forEach((_ref10) => {
        let [, plugin] = _ref10;
        plugin.destroy();
      });
      pluginsRegistry.clear();
      instance.runHooks("afterDestroy");
    }, true);
    pluginHooks_default.getSingleton().destroy(instance);
    objectEach(instance, (property, key, obj) => {
      if (isFunction2(property)) {
        obj[key] = postMortem(key);
      } else if (key !== "guid") {
        obj[key] = null;
      }
    });
    instance.isDestroyed = true;
    if (datamap) {
      datamap.destroy();
    }
    datamap = null;
    grid = null;
    selection = null;
    editorManager = null;
    instance = null;
  };
  function postMortem(method) {
    return () => {
      throw new Error(`The "${method}" method cannot be called because this Handsontable instance has been destroyed`);
    };
  }
  this.getActiveEditor = function() {
    return editorManager.getActiveEditor();
  };
  this.getPlugin = function(pluginName) {
    const unifiedPluginName = toUpperCaseFirst(pluginName);
    if (unifiedPluginName === "UndoRedo") {
      return this.undoRedo;
    }
    return pluginsRegistry.getItem(unifiedPluginName);
  };
  this.getPluginName = function(plugin) {
    if (plugin === this.undoRedo) {
      return this.undoRedo.constructor.PLUGIN_KEY;
    }
    return pluginsRegistry.getId(plugin);
  };
  this.getInstance = function() {
    return instance;
  };
  this.addHook = function(key, callback) {
    pluginHooks_default.getSingleton().add(key, callback, instance);
  };
  this.hasHook = function(key) {
    return pluginHooks_default.getSingleton().has(key, instance) || pluginHooks_default.getSingleton().has(key);
  };
  this.addHookOnce = function(key, callback) {
    pluginHooks_default.getSingleton().once(key, callback, instance);
  };
  this.removeHook = function(key, callback) {
    pluginHooks_default.getSingleton().remove(key, callback, instance);
  };
  this.runHooks = function(key, p1, p2, p3, p4, p5, p6) {
    return pluginHooks_default.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);
  };
  this.getTranslatedPhrase = function(dictionaryKey, extraArguments) {
    return getTranslatedPhrase(tableMeta.language, dictionaryKey, extraArguments);
  };
  this.toHTML = () => instanceToHTML(this);
  this.toTableElement = () => {
    const tempElement = this.rootDocument.createElement("div");
    tempElement.insertAdjacentHTML("afterbegin", instanceToHTML(this));
    return tempElement.firstElementChild;
  };
  this.timeouts = [];
  this._registerTimeout = function(handle) {
    let delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let handleFunc = handle;
    if (typeof handleFunc === "function") {
      handleFunc = setTimeout(handleFunc, delay);
    }
    this.timeouts.push(handleFunc);
  };
  this._clearTimeouts = function() {
    arrayEach(this.timeouts, (handler) => {
      clearTimeout(handler);
    });
  };
  this.immediates = [];
  this._registerImmediate = function(callback) {
    this.immediates.push(setImmediate(callback));
  };
  this._clearImmediates = function() {
    arrayEach(this.immediates, (handler) => {
      clearImmediate(handler);
    });
  };
  this._refreshBorders = function() {
    let revertOriginal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    editorManager.destroyEditor(revertOriginal);
    instance.view.render();
    if (prepareEditorIfNeeded && selection.isSelected()) {
      editorManager.prepareEditor();
    }
  };
  this.isRtl = function() {
    return instance.rootWindow.getComputedStyle(instance.rootElement).direction === "rtl";
  };
  this.isLtr = function() {
    return !instance.isRtl();
  };
  this.getDirectionFactor = function() {
    return instance.isLtr() ? 1 : -1;
  };
  const shortcutManager = createShortcutManager({
    handleEvent(event2) {
      const isListening = instance.isListening();
      const isKeyboardEventWithKey = (event2 === null || event2 === void 0 ? void 0 : event2.key) !== void 0;
      return isListening && isKeyboardEventWithKey;
    },
    beforeKeyDown: (event2) => {
      return this.runHooks("beforeKeyDown", event2);
    },
    afterKeyDown: (event2) => {
      if (this.isDestroyed) {
        return;
      }
      instance.runHooks("afterDocumentKeyDown", event2);
    },
    ownerWindow: this.rootWindow
  });
  this.addHook("beforeOnCellMouseDown", (event2) => {
    if (event2.ctrlKey === false && event2.metaKey === false) {
      shortcutManager.releasePressedKeys();
    }
  });
  this.getShortcutManager = function() {
    return shortcutManager;
  };
  const gridContext = shortcutManager.addContext("grid");
  const gridConfig = {
    runOnlyIf: () => {
      return isDefined(instance.getSelected()) && instance.countRenderedRows() > 0 && instance.countRenderedCols() > 0;
    },
    group: SHORTCUTS_GROUP
  };
  shortcutManager.setActiveContextName("grid");
  gridContext.addShortcuts([{
    keys: [["Control/Meta", "A"]],
    callback: () => {
      instance.selectAll();
    }
  }, {
    keys: [["Control/Meta", "Enter"]],
    callback: () => {
      const selectedRange = instance.getSelectedRange();
      const {
        row: highlightRow,
        col: highlightColumn
      } = selectedRange[selectedRange.length - 1].highlight;
      const valueToPopulate = instance.getDataAtCell(highlightRow, highlightColumn);
      const cellValues = /* @__PURE__ */ new Map();
      for (let i = 0; i < selectedRange.length; i++) {
        selectedRange[i].forAll((row, column) => {
          if (row >= 0 && column >= 0 && (row !== highlightRow || column !== highlightColumn)) {
            const {
              readOnly
            } = instance.getCellMeta(row, column);
            if (!readOnly) {
              cellValues.set(`${row}x${column}`, [row, column, valueToPopulate]);
            }
          }
        });
      }
      instance.setDataAtCell(Array.from(cellValues.values()));
    },
    runOnlyIf: () => instance.getSelectedRangeLast().getCellsCount() > 1
  }, {
    keys: [["ArrowUp"]],
    callback: () => {
      selection.transformStart(-1, 0);
    }
  }, {
    keys: [["ArrowUp", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      selection.setRangeStart(instance._createCellCoords(instance.rowIndexMapper.getNearestNotHiddenIndex(0, 1), instance.getSelectedRangeLast().highlight.col));
    }
  }, {
    keys: [["ArrowUp", "Shift"]],
    callback: () => {
      selection.transformEnd(-1, 0);
    }
  }, {
    keys: [["ArrowUp", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      const {
        from: from2,
        to: to2
      } = instance.getSelectedRangeLast();
      const row = instance.rowIndexMapper.getNearestNotHiddenIndex(0, 1);
      selection.setRangeStart(from2.clone());
      selection.setRangeEnd(instance._createCellCoords(row, to2.col));
    },
    runOnlyIf: () => !(instance.selection.isSelectedByCorner() || instance.selection.isSelectedByColumnHeader())
  }, {
    keys: [["ArrowDown"]],
    callback: () => {
      selection.transformStart(1, 0);
    }
  }, {
    keys: [["ArrowDown", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      selection.setRangeStart(instance._createCellCoords(instance.rowIndexMapper.getNearestNotHiddenIndex(instance.countRows() - 1, -1), instance.getSelectedRangeLast().highlight.col));
    }
  }, {
    keys: [["ArrowDown", "Shift"]],
    callback: () => {
      selection.transformEnd(1, 0);
    }
  }, {
    keys: [["ArrowDown", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      const {
        from: from2,
        to: to2
      } = instance.getSelectedRangeLast();
      const row = instance.rowIndexMapper.getNearestNotHiddenIndex(instance.countRows() - 1, -1);
      selection.setRangeStart(from2.clone());
      selection.setRangeEnd(instance._createCellCoords(row, to2.col));
    },
    runOnlyIf: () => !(instance.selection.isSelectedByCorner() || instance.selection.isSelectedByColumnHeader())
  }, {
    keys: [["ArrowLeft"]],
    callback: () => {
      selection.transformStart(0, -1 * instance.getDirectionFactor());
    }
  }, {
    keys: [["ArrowLeft", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      const row = instance.getSelectedRangeLast().highlight.row;
      const column = instance.columnIndexMapper.getNearestNotHiddenIndex(...instance.isRtl() ? [instance.countCols() - 1, -1] : [0, 1]);
      selection.setRangeStart(instance._createCellCoords(row, column));
    }
  }, {
    keys: [["ArrowLeft", "Shift"]],
    callback: () => {
      selection.transformEnd(0, -1 * instance.getDirectionFactor());
    }
  }, {
    keys: [["ArrowLeft", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      const {
        from: from2,
        to: to2
      } = instance.getSelectedRangeLast();
      const column = instance.columnIndexMapper.getNearestNotHiddenIndex(...instance.isRtl() ? [instance.countCols() - 1, -1] : [0, 1]);
      selection.setRangeStart(from2.clone());
      selection.setRangeEnd(instance._createCellCoords(to2.row, column));
    },
    runOnlyIf: () => !(instance.selection.isSelectedByCorner() || instance.selection.isSelectedByRowHeader())
  }, {
    keys: [["ArrowRight"]],
    callback: () => {
      selection.transformStart(0, instance.getDirectionFactor());
    }
  }, {
    keys: [["ArrowRight", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      const row = instance.getSelectedRangeLast().highlight.row;
      const column = instance.columnIndexMapper.getNearestNotHiddenIndex(...instance.isRtl() ? [0, 1] : [instance.countCols() - 1, -1]);
      selection.setRangeStart(instance._createCellCoords(row, column));
    }
  }, {
    keys: [["ArrowRight", "Shift"]],
    callback: () => {
      selection.transformEnd(0, instance.getDirectionFactor());
    }
  }, {
    keys: [["ArrowRight", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      const {
        from: from2,
        to: to2
      } = instance.getSelectedRangeLast();
      const column = instance.columnIndexMapper.getNearestNotHiddenIndex(...instance.isRtl() ? [0, 1] : [instance.countCols() - 1, -1]);
      selection.setRangeStart(from2.clone());
      selection.setRangeEnd(instance._createCellCoords(to2.row, column));
    },
    runOnlyIf: () => !(instance.selection.isSelectedByCorner() || instance.selection.isSelectedByRowHeader())
  }, {
    keys: [["Home"]],
    captureCtrl: true,
    callback: () => {
      const fixedColumns = parseInt(instance.getSettings().fixedColumnsStart, 10);
      const row = instance.getSelectedRangeLast().highlight.row;
      const column = instance.columnIndexMapper.getNearestNotHiddenIndex(fixedColumns, 1);
      selection.setRangeStart(instance._createCellCoords(row, column));
    },
    runOnlyIf: () => instance.view.isMainTableNotFullyCoveredByOverlays()
  }, {
    keys: [["Home", "Shift"]],
    callback: () => {
      selection.setRangeEnd(instance._createCellCoords(selection.selectedRange.current().from.row, instance.columnIndexMapper.getNearestNotHiddenIndex(0, 1)));
    }
  }, {
    keys: [["Home", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      const fixedRows = parseInt(instance.getSettings().fixedRowsTop, 10);
      const fixedColumns = parseInt(instance.getSettings().fixedColumnsStart, 10);
      const row = instance.rowIndexMapper.getNearestNotHiddenIndex(fixedRows, 1);
      const column = instance.columnIndexMapper.getNearestNotHiddenIndex(fixedColumns, 1);
      selection.setRangeStart(instance._createCellCoords(row, column));
    },
    runOnlyIf: () => instance.view.isMainTableNotFullyCoveredByOverlays()
  }, {
    keys: [["End"]],
    captureCtrl: true,
    callback: () => {
      selection.setRangeStart(instance._createCellCoords(instance.getSelectedRangeLast().highlight.row, instance.columnIndexMapper.getNearestNotHiddenIndex(instance.countCols() - 1, -1)));
    },
    runOnlyIf: () => instance.view.isMainTableNotFullyCoveredByOverlays()
  }, {
    keys: [["End", "Shift"]],
    callback: () => {
      selection.setRangeEnd(instance._createCellCoords(selection.selectedRange.current().from.row, instance.columnIndexMapper.getNearestNotHiddenIndex(instance.countCols() - 1, -1)));
    }
  }, {
    keys: [["End", "Control/Meta"]],
    captureCtrl: true,
    callback: () => {
      const fixedRows = parseInt(instance.getSettings().fixedRowsBottom, 10);
      const row = instance.rowIndexMapper.getNearestNotHiddenIndex(instance.countRows() - fixedRows - 1, -1);
      const column = instance.columnIndexMapper.getNearestNotHiddenIndex(instance.countCols() - 1, -1);
      selection.setRangeStart(instance._createCellCoords(row, column));
    },
    runOnlyIf: () => instance.view.isMainTableNotFullyCoveredByOverlays()
  }, {
    keys: [["PageUp"]],
    callback: () => {
      selection.transformStart(-instance.countVisibleRows(), 0);
    }
  }, {
    keys: [["PageUp", "Shift"]],
    callback: () => {
      const {
        to: to2
      } = instance.getSelectedRangeLast();
      const nextRowIndexToSelect = Math.max(to2.row - instance.countVisibleRows(), 0);
      const row = instance.rowIndexMapper.getNearestNotHiddenIndex(nextRowIndexToSelect, 1);
      if (row !== null) {
        const coords = instance._createCellCoords(row, to2.col);
        const scrollPadding = to2.row - instance.view.getFirstFullyVisibleRow();
        const nextVerticalScroll = Math.max(coords.row - scrollPadding, 0);
        selection.setRangeEnd(coords);
        instance.scrollViewportTo(nextVerticalScroll);
      }
    }
  }, {
    keys: [["PageDown"]],
    callback: () => {
      selection.transformStart(instance.countVisibleRows(), 0);
    }
  }, {
    keys: [["PageDown", "Shift"]],
    callback: () => {
      const {
        to: to2
      } = instance.getSelectedRangeLast();
      const nextRowIndexToSelect = Math.min(to2.row + instance.countVisibleRows(), instance.countRows() - 1);
      const row = instance.rowIndexMapper.getNearestNotHiddenIndex(nextRowIndexToSelect, -1);
      if (row !== null) {
        const coords = instance._createCellCoords(row, to2.col);
        const scrollPadding = to2.row - instance.view.getFirstFullyVisibleRow();
        const nextVerticalScroll = Math.min(coords.row - scrollPadding, instance.countRows() - 1);
        selection.setRangeEnd(coords);
        instance.scrollViewportTo(nextVerticalScroll);
      }
    }
  }, {
    keys: [["Tab"]],
    callback: (event2) => {
      const tabMoves = typeof tableMeta.tabMoves === "function" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;
      selection.transformStart(tabMoves.row, tabMoves.col, true);
    }
  }, {
    keys: [["Shift", "Tab"]],
    callback: (event2) => {
      const tabMoves = typeof tableMeta.tabMoves === "function" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;
      selection.transformStart(-tabMoves.row, -tabMoves.col);
    }
  }], gridConfig);
  getPluginsNames().forEach((pluginName) => {
    const PluginClass = getPlugin(pluginName);
    pluginsRegistry.addItem(pluginName, new PluginClass(this));
  });
  pluginHooks_default.getSingleton().run(instance, "construct");
}

// node_modules/handsontable/mixins/hooksRefRegisterer.mjs
var MIXIN_NAME7 = "hooksRefRegisterer";
var hooksRefRegisterer = {
  /**
   * Internal hooks storage.
   */
  _hooksStorage: /* @__PURE__ */ Object.create(null),
  /**
   * Add hook to the collection.
   *
   * @param {string} key The hook name.
   * @param {Function} callback The hook callback.
   * @returns {object}
   */
  addHook(key, callback) {
    if (!this._hooksStorage[key]) {
      this._hooksStorage[key] = [];
    }
    this.hot.addHook(key, callback);
    this._hooksStorage[key].push(callback);
    return this;
  },
  /**
   * Remove all hooks listeners by hook name.
   *
   * @param {string} key The hook name.
   */
  removeHooksByKey(key) {
    arrayEach(this._hooksStorage[key] || [], (callback) => {
      this.hot.removeHook(key, callback);
    });
  },
  /**
   * Clear all added hooks.
   */
  clearHooks() {
    objectEach(this._hooksStorage, (callbacks, name) => this.removeHooksByKey(name));
    this._hooksStorage = {};
  }
};
defineGetter(hooksRefRegisterer, "MIXIN_NAME", MIXIN_NAME7, {
  writable: false,
  enumerable: false
});
var hooksRefRegisterer_default = hooksRefRegisterer;

// node_modules/handsontable/editors/baseEditor/baseEditor.mjs
var EDITOR_TYPE = "base";
var EDITOR_STATE = Object.freeze({
  VIRGIN: "STATE_VIRGIN",
  // before editing
  EDITING: "STATE_EDITING",
  WAITING: "STATE_WAITING",
  // waiting for async validation
  FINISHED: "STATE_FINISHED"
});
var SHORTCUTS_GROUP_EDITOR2 = "baseEditor";
var BaseEditor = class {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE;
  }
  /**
   * @param {Handsontable} instance A reference to the source instance of the Handsontable.
   */
  constructor(instance) {
    this.hot = instance;
    this.instance = instance;
    this.state = EDITOR_STATE.VIRGIN;
    this._opened = false;
    this._fullEditMode = false;
    this._closeCallback = null;
    this.TD = null;
    this.row = null;
    this.col = null;
    this.prop = null;
    this.originalValue = null;
    this.cellProperties = null;
    this.init();
  }
  /**
   * Fires callback after closing editor.
   *
   * @private
   * @param {boolean} result The editor value.
   */
  _fireCallbacks(result) {
    if (this._closeCallback) {
      this._closeCallback(result);
      this._closeCallback = null;
    }
  }
  /**
   * Initializes an editor's intance.
   */
  init() {
  }
  /**
   * Required method to get current value from editable element.
   */
  getValue() {
    throw Error("Editor getValue() method unimplemented");
  }
  /**
   * Required method to set new value into editable element.
   */
  setValue() {
    throw Error("Editor setValue() method unimplemented");
  }
  /**
   * Required method to open editor.
   */
  open() {
    throw Error("Editor open() method unimplemented");
  }
  /**
   * Required method to close editor.
   */
  close() {
    throw Error("Editor close() method unimplemented");
  }
  /**
   * Prepares editor's meta data.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    this.TD = td;
    this.row = row;
    this.col = col;
    this.prop = prop;
    this.originalValue = value;
    this.cellProperties = cellProperties;
    this.state = EDITOR_STATE.VIRGIN;
  }
  /**
   * Fallback method to provide extendable editors in ES5.
   *
   * @returns {Function}
   */
  extend() {
    return class Editor extends this.constructor {
    };
  }
  /**
   * Saves value from editor into data storage.
   *
   * @param {*} value The editor value.
   * @param {boolean} ctrlDown If `true`, applies value to each cell in the last selected range.
   */
  saveValue(value, ctrlDown) {
    let visualRowFrom;
    let visualColumnFrom;
    let visualRowTo;
    let visualColumnTo;
    if (ctrlDown) {
      const selectedLast = this.hot.getSelectedLast();
      visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0);
      visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0);
      visualRowTo = Math.max(selectedLast[0], selectedLast[2]);
      visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);
    } else {
      [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = [this.row, this.col, null, null];
    }
    const modifiedCellCoords = this.hot.runHooks("modifyGetCellCoords", visualRowFrom, visualColumnFrom);
    if (Array.isArray(modifiedCellCoords)) {
      [visualRowFrom, visualColumnFrom] = modifiedCellCoords;
    }
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    const contextConfig = {
      runOnlyIf: () => isDefined(this.hot.getSelected()),
      group: SHORTCUTS_GROUP_EDITOR2
    };
    if (this.isInFullEditMode()) {
      editorContext.addShortcuts([{
        keys: [["ArrowUp"]],
        callback: () => {
          this.hot.selection.transformStart(-1, 0);
        }
      }, {
        keys: [["ArrowDown"]],
        callback: () => {
          this.hot.selection.transformStart(1, 0);
        }
      }, {
        keys: [["ArrowLeft"]],
        callback: () => {
          this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());
        }
      }, {
        keys: [["ArrowRight"]],
        callback: () => {
          this.hot.selection.transformStart(0, this.hot.getDirectionFactor());
        }
      }], contextConfig);
    }
    this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, "edit");
  }
  /**
   * Begins editing on a highlighted cell and hides fillHandle corner if was present.
   *
   * @param {*} newInitialValue The initial editor value.
   * @param {Event} event The keyboard event object.
   */
  beginEditing(newInitialValue, event2) {
    if (this.state !== EDITOR_STATE.VIRGIN) {
      return;
    }
    const hotInstance = this.hot;
    const renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);
    const renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);
    hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIndex, renderableColumnIndex));
    this.state = EDITOR_STATE.EDITING;
    if (this.isInFullEditMode()) {
      const stringifiedInitialValue = typeof newInitialValue === "string" ? newInitialValue : stringify(this.originalValue);
      this.setValue(stringifiedInitialValue);
    }
    this.open(event2);
    this._opened = true;
    this.focus();
    hotInstance.view.render();
    hotInstance.runHooks("afterBeginEditing", this.row, this.col);
  }
  /**
   * Finishes editing and start saving or restoring process for editing cell or last selected range.
   *
   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
   * @param {Function} callback The callback function, fired after editor closing.
   */
  finishEditing(restoreOriginalValue, ctrlDown, callback) {
    let val;
    if (callback) {
      const previousCloseCallback = this._closeCallback;
      this._closeCallback = (result) => {
        if (previousCloseCallback) {
          previousCloseCallback(result);
        }
        callback(result);
        this.hot.view.render();
      };
    }
    if (this.isWaiting()) {
      return;
    }
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR2);
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);
    if (this.state === EDITOR_STATE.VIRGIN) {
      this.hot._registerTimeout(() => {
        this._fireCallbacks(true);
      });
      return;
    }
    if (this.state === EDITOR_STATE.EDITING) {
      if (restoreOriginalValue) {
        this.cancelChanges();
        this.hot.view.render();
        return;
      }
      const value = this.getValue();
      if (this.cellProperties.trimWhitespace) {
        val = [[typeof value === "string" ? String.prototype.trim.call(value || "") : value]];
      } else {
        val = [[value]];
      }
      this.state = EDITOR_STATE.WAITING;
      this.saveValue(val, ctrlDown);
      if (this.hot.getCellValidator(this.cellProperties)) {
        this.hot.addHookOnce("postAfterValidate", (result) => {
          this.state = EDITOR_STATE.FINISHED;
          this.discardEditor(result);
        });
      } else {
        this.state = EDITOR_STATE.FINISHED;
        this.discardEditor(true);
      }
    }
  }
  /**
   * Finishes editing without singout saving value.
   */
  cancelChanges() {
    this.state = EDITOR_STATE.FINISHED;
    this.discardEditor();
  }
  /**
   * Verifies result of validation or closes editor if user's cancelled changes.
   *
   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,
   *                                   then an editor won't be closed until validation is passed.
   */
  discardEditor(result) {
    if (this.state !== EDITOR_STATE.FINISHED) {
      return;
    }
    if (result === false && this.cellProperties.allowInvalid !== true) {
      this.hot.selectCell(this.row, this.col);
      this.focus();
      this.state = EDITOR_STATE.EDITING;
      this._fireCallbacks(false);
    } else {
      this.close();
      this._opened = false;
      this._fullEditMode = false;
      this.state = EDITOR_STATE.VIRGIN;
      this._fireCallbacks(true);
      const shortcutManager = this.hot.getShortcutManager();
      shortcutManager.setActiveContextName("grid");
    }
  }
  /**
   * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated
   * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.
   */
  enableFullEditMode() {
    this._fullEditMode = true;
  }
  /**
   * Checks if editor is in full edit mode.
   *
   * @returns {boolean}
   */
  isInFullEditMode() {
    return this._fullEditMode;
  }
  /**
   * Returns information whether the editor is open.
   *
   * @returns {boolean}
   */
  isOpened() {
    return this._opened;
  }
  /**
   * Returns information whether the editor is waiting, eg.: for async validation.
   *
   * @returns {boolean}
   */
  isWaiting() {
    return this.state === EDITOR_STATE.WAITING;
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Gets the object that provides information about the edited cell size and its position
   * relative to the table viewport.
   *
   * The rectangle has six integer properties:
   *  - `top` The top position relative to the table viewport
   *  - `start` The left (or right in RTL) position relative to the table viewport
   *  - `width` The cell's current width;
   *  - `maxWidth` The maximum cell's width after which the editor goes out of the table viewport
   *  - `height` The cell's current height;
   *  - `maxHeight` The maximum cell's height after which the editor goes out of the table viewport
   *
   * @returns {{top: number, start: number, width: number, maxWidth: number, height: number, maxHeight: number} | undefined}
   */
  getEditedCellRect() {
    var _wtOverlays$getParent;
    const TD = this.getEditedCell();
    if (!TD) {
      return;
    }
    const {
      wtOverlays,
      wtViewport
    } = this.hot.view._wt;
    const rootWindow = this.hot.rootWindow;
    const currentOffset = offset2(TD);
    const cellWidth = outerWidth(TD);
    const containerOffset = offset2(this.hot.rootElement);
    const containerWidth = outerWidth(this.hot.rootElement);
    const scrollableContainerTop = wtOverlays.topOverlay.holder;
    const scrollableContainerLeft = wtOverlays.inlineStartOverlay.holder;
    const containerScrollTop = scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : 0;
    const containerScrollLeft = scrollableContainerLeft !== rootWindow ? scrollableContainerLeft.scrollLeft : 0;
    const gridMostRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;
    const {
      wtTable: overlayTable
    } = (_wtOverlays$getParent = wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 ? _wtOverlays$getParent : this.hot.view._wt;
    const overlayName = overlayTable.name;
    const scrollTop = ["master", "inline_start"].includes(overlayName) ? containerScrollTop : 0;
    const scrollLeft = ["master", "top", "bottom"].includes(overlayName) ? containerScrollLeft : 0;
    const editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;
    let topPos = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;
    let inlineStartPos = 0;
    if (this.hot.isRtl()) {
      inlineStartPos = rootWindow.innerWidth - currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;
    } else {
      inlineStartPos = currentOffset.left - containerOffset.left - 1 - scrollLeft;
    }
    if (["top", "top_inline_start_corner"].includes(overlayName)) {
      topPos += wtOverlays.topOverlay.getOverlayOffset();
    }
    if (["inline_start", "top_inline_start_corner"].includes(overlayName)) {
      inlineStartPos += Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());
    }
    const hasColumnHeaders = this.hot.hasColHeaders();
    const renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);
    const renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);
    const nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();
    const firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view._wt.getSetting("fixedRowsBottom");
    if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {
      topPos += 1;
    }
    if (renderableColumn <= 0) {
      inlineStartPos += 1;
    }
    const firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;
    const firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;
    const horizontalScrollPosition = Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());
    const verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();
    const scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);
    const cellTopOffset = TD.offsetTop + firstRowOffset - verticalScrollPosition;
    let cellStartOffset = 0;
    if (this.hot.isRtl()) {
      const cellOffset = TD.offsetLeft;
      if (cellOffset >= 0) {
        cellStartOffset = overlayTable.getWidth() - TD.offsetLeft;
      } else {
        cellStartOffset = Math.abs(cellOffset);
      }
      cellStartOffset += firstColumnOffset - horizontalScrollPosition - cellWidth;
    } else {
      cellStartOffset = TD.offsetLeft + firstColumnOffset - horizontalScrollPosition;
    }
    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);
    const borderPhysicalWidthProp = this.hot.isRtl() ? "borderRightWidth" : "borderLeftWidth";
    const inlineStartBorderCompensation = parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;
    const topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) > 0 ? 0 : 1;
    const width = outerWidth(TD) + inlineStartBorderCompensation;
    const height = outerHeight(TD) + topBorderCompensation;
    const actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;
    const actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;
    const maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - actualVerticalScrollbarWidth + inlineStartBorderCompensation;
    const maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth + topBorderCompensation, 23);
    return {
      top: topPos,
      start: inlineStartPos,
      height,
      maxHeight,
      width,
      maxWidth
    };
  }
  /* eslint-enable jsdoc/require-description-complete-sentence */
  /**
   * Gets className of the edited cell if exist.
   *
   * @returns {string}
   */
  getEditedCellsLayerClass() {
    const editorSection = this.checkEditorSection();
    switch (editorSection) {
      case "inline-start":
        return "ht_clone_left ht_clone_inline_start";
      case "bottom":
        return "ht_clone_bottom";
      case "bottom-inline-start-corner":
        return "ht_clone_bottom_left_corner ht_clone_bottom_inline_start_corner";
      case "top":
        return "ht_clone_top";
      case "top-inline-start-corner":
        return "ht_clone_top_left_corner ht_clone_top_inline_start_corner";
      default:
        return "ht_clone_master";
    }
  }
  /**
   * Gets HTMLTableCellElement of the edited cell if exist.
   *
   * @returns {HTMLTableCellElement|null}
   */
  getEditedCell() {
    return this.hot.getCell(this.row, this.col, true);
  }
  /**
   * Returns name of the overlay, where editor is placed.
   *
   * @private
   * @returns {string}
   */
  checkEditorSection() {
    const totalRows = this.hot.countRows();
    let section = "";
    if (this.row < this.hot.getSettings().fixedRowsTop) {
      if (this.col < this.hot.getSettings().fixedColumnsStart) {
        section = "top-inline-start-corner";
      } else {
        section = "top";
      }
    } else if (this.hot.getSettings().fixedRowsBottom && this.row >= totalRows - this.hot.getSettings().fixedRowsBottom) {
      if (this.col < this.hot.getSettings().fixedColumnsStart) {
        section = "bottom-inline-start-corner";
      } else {
        section = "bottom";
      }
    } else if (this.col < this.hot.getSettings().fixedColumnsStart) {
      section = "inline-start";
    }
    return section;
  }
};
mixin(BaseEditor, hooksRefRegisterer_default);

// node_modules/handsontable/3rdparty/autoResize/autoResize.mjs
function autoResize() {
  var defaults2 = {
    minHeight: 200,
    maxHeight: 300,
    minWidth: 100,
    maxWidth: 300
  }, el, body = document.body, text2 = document.createTextNode(""), span = document.createElement("SPAN"), observe = function(element, event2, handler) {
    element.addEventListener(event2, handler, false);
  }, unObserve = function(element, event2, handler) {
    element.removeEventListener(event2, handler, false);
  }, resize = function(newChar) {
    var width, scrollHeight;
    if (!newChar) {
      newChar = "";
    } else if (!/^[a-zA-Z \.,\\\/\|0-9]$/.test(newChar)) {
      newChar = ".";
    }
    if (text2.textContent !== void 0) {
      text2.textContent = el.value + newChar;
    } else {
      text2.data = el.value + newChar;
    }
    span.style.position = "absolute";
    span.style.fontSize = getComputedStyle2(el).fontSize;
    span.style.fontFamily = getComputedStyle2(el).fontFamily;
    span.style.whiteSpace = "pre";
    body.appendChild(span);
    width = span.clientWidth + 2;
    body.removeChild(span);
    el.style.height = defaults2.minHeight + "px";
    if (defaults2.minWidth > width) {
      el.style.width = defaults2.minWidth + "px";
    } else if (width > defaults2.maxWidth) {
      el.style.width = defaults2.maxWidth + "px";
    } else {
      el.style.width = width + "px";
    }
    scrollHeight = el.scrollHeight ? el.scrollHeight - 1 : 0;
    if (defaults2.minHeight > scrollHeight) {
      el.style.height = defaults2.minHeight + "px";
    } else if (defaults2.maxHeight < scrollHeight) {
      el.style.height = defaults2.maxHeight + "px";
      el.style.overflowY = "visible";
    } else {
      el.style.height = scrollHeight + "px";
    }
  }, delayedResize = function() {
    window.setTimeout(resize, 0);
  }, extendDefaults = function(config) {
    if (config && config.minHeight) {
      if (config.minHeight == "inherit") {
        defaults2.minHeight = el.clientHeight;
      } else {
        var minHeight = parseInt(config.minHeight);
        if (!isNaN(minHeight)) {
          defaults2.minHeight = minHeight;
        }
      }
    }
    if (config && config.maxHeight) {
      if (config.maxHeight == "inherit") {
        defaults2.maxHeight = el.clientHeight;
      } else {
        var maxHeight = parseInt(config.maxHeight);
        if (!isNaN(maxHeight)) {
          defaults2.maxHeight = maxHeight;
        }
      }
    }
    if (config && config.minWidth) {
      if (config.minWidth == "inherit") {
        defaults2.minWidth = el.clientWidth;
      } else {
        var minWidth = parseInt(config.minWidth);
        if (!isNaN(minWidth)) {
          defaults2.minWidth = minWidth;
        }
      }
    }
    if (config && config.maxWidth) {
      if (config.maxWidth == "inherit") {
        defaults2.maxWidth = el.clientWidth;
      } else {
        var maxWidth = parseInt(config.maxWidth);
        if (!isNaN(maxWidth)) {
          defaults2.maxWidth = maxWidth;
        }
      }
    }
    if (!span.firstChild) {
      span.className = "autoResize";
      span.style.display = "inline-block";
      span.appendChild(text2);
    }
  }, init = function(el_, config, doObserve) {
    el = el_;
    extendDefaults(config);
    if (el.nodeName == "TEXTAREA") {
      el.style.resize = "none";
      el.style.overflowY = "";
      el.style.height = defaults2.minHeight + "px";
      el.style.minWidth = defaults2.minWidth + "px";
      el.style.maxWidth = defaults2.maxWidth + "px";
      el.style.overflowY = "hidden";
    }
    if (doObserve) {
      observe(el, "change", resize);
      observe(el, "cut", delayedResize);
      observe(el, "paste", delayedResize);
      observe(el, "drop", delayedResize);
      observe(el, "keydown", delayedResize);
      observe(el, "focus", resize);
      observe(el, "compositionstart", delayedResize);
      observe(el, "compositionupdate", delayedResize);
      observe(el, "compositionend", delayedResize);
    }
    resize();
  };
  function getComputedStyle2(element) {
    return element.currentStyle || document.defaultView.getComputedStyle(element);
  }
  return {
    init: function(el_, config, doObserve) {
      init(el_, config, doObserve);
    },
    unObserve: function() {
      unObserve(el, "change", resize);
      unObserve(el, "cut", delayedResize);
      unObserve(el, "paste", delayedResize);
      unObserve(el, "drop", delayedResize);
      unObserve(el, "keydown", delayedResize);
      unObserve(el, "focus", resize);
      unObserve(el, "compositionstart", delayedResize);
      unObserve(el, "compositionupdate", delayedResize);
      unObserve(el, "compositionend", delayedResize);
    },
    resize
  };
}

// node_modules/handsontable/editors/textEditor/caretPositioner.mjs
function updateCaretPosition(actionName, textareaElement) {
  const caretPosition = getCaretPosition(textareaElement);
  const textLines = textareaElement.value.split("\n");
  let newCaretPosition = caretPosition;
  let lineStartIndex = 0;
  for (let i = 0; i < textLines.length; i++) {
    const textLine = textLines[i];
    if (i !== 0) {
      lineStartIndex += textLines[i - 1].length + 1;
    }
    const lineEndIndex = lineStartIndex + textLine.length;
    if (actionName === "home") {
      newCaretPosition = lineStartIndex;
    } else if (actionName === "end") {
      newCaretPosition = lineEndIndex;
    }
    if (caretPosition <= lineEndIndex) {
      break;
    }
  }
  setCaretPosition(textareaElement, newCaretPosition);
}

// node_modules/handsontable/editors/textEditor/textEditor.mjs
var EDITOR_VISIBLE_CLASS_NAME = "ht_editor_visible";
var EDITOR_HIDDEN_CLASS_NAME = "ht_editor_hidden";
var SHORTCUTS_GROUP2 = "textEditor";
var EDITOR_TYPE2 = "text";
var TextEditor = class extends BaseEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE2;
  }
  /**
   * @param {Core} instance The Handsontable instance.
   */
  constructor(instance) {
    super(instance);
    this.eventManager = new eventManager_default(this);
    this.autoResize = autoResize();
    this.TEXTAREA = void 0;
    this.textareaStyle = void 0;
    this.TEXTAREA_PARENT = void 0;
    this.textareaParentStyle = void 0;
    this.layerClass = void 0;
    this.createElements();
    this.bindEvents();
    this.hot.addHookOnce("afterDestroy", () => this.destroy());
  }
  /**
   * Gets current value from editable element.
   *
   * @returns {number}
   */
  getValue() {
    return this.TEXTAREA.value;
  }
  /**
   * Sets new value into editable element.
   *
   * @param {*} newValue The editor value.
   */
  setValue(newValue) {
    this.TEXTAREA.value = newValue;
  }
  /**
   * Opens the editor and adjust its size.
   */
  open() {
    this.refreshDimensions();
    this.showEditableElement();
    const shortcutManager = this.hot.getShortcutManager();
    shortcutManager.setActiveContextName("editor");
    this.addHook("afterDocumentKeyDown", (event2) => this.onAfterDocumentKeyDown(event2));
    this.registerShortcuts();
  }
  /**
   * Closes the editor.
   */
  close() {
    this.autoResize.unObserve();
    if (this.hot.rootDocument.activeElement === this.TEXTAREA) {
      this.hot.listen();
    }
    this.hideEditableElement();
    this.unregisterShortcuts();
    this.removeHooksByKey("afterDocumentKeyDown");
  }
  /**
   * Prepares editor's meta data.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    const previousState = this.state;
    super.prepare(row, col, prop, td, value, cellProperties);
    if (!cellProperties.readOnly) {
      this.refreshDimensions(true);
      const {
        allowInvalid,
        fragmentSelection
      } = cellProperties;
      if (allowInvalid) {
        this.TEXTAREA.value = "";
      }
      if (previousState !== EDITOR_STATE.FINISHED) {
        this.hideEditableElement();
      }
      const restoreFocus = !fragmentSelection;
      if (restoreFocus && !isMobileBrowser()) {
        this.focus();
      }
    }
  }
  /**
   * Begins editing on a highlighted cell and hides fillHandle corner if was present.
   *
   * @param {*} newInitialValue The editor initial value.
   * @param {Event} event The keyboard event object.
   */
  beginEditing(newInitialValue, event2) {
    if (this.state !== EDITOR_STATE.VIRGIN) {
      return;
    }
    this.TEXTAREA.value = "";
    super.beginEditing(newInitialValue, event2);
  }
  /**
   * Sets focus state on the select element.
   */
  focus() {
    this.TEXTAREA.select();
    setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
  }
  /**
   * Creates an editor's elements and adds necessary CSS classnames.
   */
  createElements() {
    const {
      rootDocument
    } = this.hot;
    this.TEXTAREA = rootDocument.createElement("TEXTAREA");
    this.TEXTAREA.setAttribute("data-hot-input", "");
    this.TEXTAREA.tabIndex = -1;
    addClass(this.TEXTAREA, "handsontableInput");
    this.textareaStyle = this.TEXTAREA.style;
    this.textareaStyle.width = 0;
    this.textareaStyle.height = 0;
    this.textareaStyle.overflowY = "visible";
    this.TEXTAREA_PARENT = rootDocument.createElement("DIV");
    addClass(this.TEXTAREA_PARENT, "handsontableInputHolder");
    if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {
      removeClass(this.TEXTAREA_PARENT, this.layerClass);
    }
    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
    this.textareaParentStyle = this.TEXTAREA_PARENT.style;
    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
    this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);
  }
  /**
   * Moves an editable element out of the viewport, but element must be able to hold focus for IME support.
   *
   * @private
   */
  hideEditableElement() {
    if (isEdge()) {
      this.textareaStyle.textIndent = "-99999px";
    }
    this.textareaStyle.overflowY = "visible";
    this.textareaParentStyle.opacity = "0";
    this.textareaParentStyle.height = "1px";
    removeClass(this.TEXTAREA_PARENT, this.layerClass);
    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
  }
  /**
   * Resets an editable element position.
   *
   * @private
   */
  showEditableElement() {
    this.textareaParentStyle.height = "";
    this.textareaParentStyle.overflow = "";
    this.textareaParentStyle.position = "";
    this.textareaParentStyle[this.hot.isRtl() ? "left" : "right"] = "auto";
    this.textareaParentStyle.opacity = "1";
    this.textareaStyle.textIndent = "";
    this.textareaStyle.overflowY = "hidden";
    const childNodes = this.TEXTAREA_PARENT.childNodes;
    let hasClassHandsontableEditor = false;
    rangeEach(childNodes.length - 1, (index2) => {
      const childNode = childNodes[index2];
      if (hasClass(childNode, "handsontableEditor")) {
        hasClassHandsontableEditor = true;
        return false;
      }
    });
    if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {
      removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
    }
    if (hasClassHandsontableEditor) {
      this.layerClass = EDITOR_VISIBLE_CLASS_NAME;
      addClass(this.TEXTAREA_PARENT, this.layerClass);
    } else {
      this.layerClass = this.getEditedCellsLayerClass();
      addClass(this.TEXTAREA_PARENT, this.layerClass);
    }
  }
  /**
   * Refreshes editor's value using source data.
   *
   * @private
   */
  refreshValue() {
    const physicalRow = this.hot.toPhysicalRow(this.row);
    const sourceData = this.hot.getSourceDataAtCell(physicalRow, this.col);
    this.originalValue = sourceData;
    this.setValue(sourceData);
    this.refreshDimensions();
  }
  /**
   * Refreshes editor's size and position.
   *
   * @private
   * @param {boolean} force Indicates if the refreshing editor dimensions should be triggered.
   */
  refreshDimensions() {
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (this.state !== EDITOR_STATE.EDITING && !force) {
      return;
    }
    this.TD = this.getEditedCell();
    if (!this.TD) {
      if (!force) {
        this.close();
      }
      return;
    }
    const {
      top: top2,
      start,
      width,
      maxWidth,
      height,
      maxHeight
    } = this.getEditedCellRect();
    this.textareaParentStyle.top = `${top2}px`;
    this.textareaParentStyle[this.hot.isRtl() ? "right" : "left"] = `${start}px`;
    this.showEditableElement();
    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);
    this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;
    this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;
    this.TEXTAREA.style.backgroundColor = this.TD.style.backgroundColor;
    const textareaComputedStyle = getComputedStyle(this.TEXTAREA);
    const horizontalPadding = parseInt(textareaComputedStyle.paddingLeft, 10) + parseInt(textareaComputedStyle.paddingRight, 10);
    const verticalPadding = parseInt(textareaComputedStyle.paddingTop, 10) + parseInt(textareaComputedStyle.paddingBottom, 10);
    const finalWidth = width - horizontalPadding;
    const finalHeight = height - verticalPadding;
    const finalMaxWidth = maxWidth - horizontalPadding;
    const finalMaxHeight = maxHeight - verticalPadding;
    this.autoResize.init(this.TEXTAREA, {
      minWidth: Math.min(finalWidth, finalMaxWidth),
      minHeight: Math.min(finalHeight, finalMaxHeight),
      // TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
      maxWidth: finalMaxWidth,
      maxHeight: finalMaxHeight
    }, true);
  }
  /**
   * Binds events and hooks.
   *
   * @private
   */
  bindEvents() {
    this.eventManager.addEventListener(this.TEXTAREA, "cut", (event2) => event2.stopPropagation());
    this.eventManager.addEventListener(this.TEXTAREA, "paste", (event2) => event2.stopPropagation());
    if (isIOS()) {
      this.eventManager.addEventListener(this.TEXTAREA, "focusout", () => this.finishEditing(false));
    }
    this.addHook("afterScrollHorizontally", () => this.refreshDimensions());
    this.addHook("afterScrollVertically", () => this.refreshDimensions());
    this.addHook("afterColumnResize", () => {
      this.refreshDimensions();
      this.focus();
    });
    this.addHook("afterRowResize", () => {
      this.refreshDimensions();
      this.focus();
    });
  }
  /**
   * Ugly hack for autocompleteEditor.
   *
   * @private
   */
  allowKeyEventPropagation() {
  }
  /**
   * Destroys the internal event manager and clears attached hooks.
   *
   * @private
   */
  destroy() {
    this.eventManager.destroy();
    this.clearHooks();
  }
  /**
   * Register shortcuts responsible for handling editor.
   *
   * @private
   */
  registerShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    const contextConfig = {
      runOnlyIf: () => isDefined(this.hot.getSelected()),
      group: SHORTCUTS_GROUP2
    };
    const insertNewLine = () => {
      this.hot.rootDocument.execCommand("insertText", false, "\n");
    };
    editorContext.addShortcuts([{
      keys: [["Tab"]],
      // TODO: Duplicated part of code (callback to shortcut).
      callback: (event2) => {
        const tableMeta = this.hot.getSettings();
        const tabMoves = typeof tableMeta.tabMoves === "function" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;
        this.hot.selection.transformStart(tabMoves.row, tabMoves.col, true);
      }
    }, {
      keys: [["Shift", "Tab"]],
      // TODO: Duplicated part of code (callback to shortcut).
      callback: (event2) => {
        const tableMeta = this.hot.getSettings();
        const tabMoves = typeof tableMeta.tabMoves === "function" ? tableMeta.tabMoves(event2) : tableMeta.tabMoves;
        this.hot.selection.transformStart(-tabMoves.row, -tabMoves.col);
      }
    }, {
      keys: [["Control", "Enter"]],
      callback: () => {
        insertNewLine();
        return false;
      },
      runOnlyIf: (event2) => !this.hot.selection.isMultiple() && // We trigger a data population for multiple selection.
      // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)
      !event2.altKey,
      relativeToGroup: SHORTCUTS_GROUP_EDITOR,
      position: "before"
    }, {
      keys: [["Meta", "Enter"]],
      callback: () => {
        insertNewLine();
        return false;
      },
      runOnlyIf: () => !this.hot.selection.isMultiple(),
      // We trigger a data population for multiple selection.
      relativeToGroup: SHORTCUTS_GROUP_EDITOR,
      position: "before"
    }, {
      keys: [["Alt", "Enter"]],
      callback: () => {
        insertNewLine();
        return false;
      },
      relativeToGroup: SHORTCUTS_GROUP_EDITOR,
      position: "before"
    }, {
      // TODO: Duplicated part of code (callback to shortcut)
      keys: [["PageUp"]],
      callback: () => {
        this.hot.selection.transformStart(-this.hot.countVisibleRows(), 0);
      }
    }, {
      // TODO: Duplicated part of code (callback to shortcut)
      keys: [["PageDown"]],
      callback: () => {
        this.hot.selection.transformStart(this.hot.countVisibleRows(), 0);
      }
    }, {
      keys: [["Home"]],
      callback: (event2, _ref2) => {
        let [keyName] = _ref2;
        updateCaretPosition(keyName, this.TEXTAREA);
      }
    }, {
      keys: [["End"]],
      callback: (event2, _ref2) => {
        let [keyName] = _ref2;
        updateCaretPosition(keyName, this.TEXTAREA);
      }
    }, {
      keys: [["Control/Meta", "Z"]],
      preventDefault: false,
      callback: () => {
        this.hot._registerTimeout(() => {
          this.autoResize.resize();
        }, 10);
      }
    }, {
      keys: [["Control/Meta", "Shift", "Z"]],
      preventDefault: false,
      callback: () => {
        this.hot._registerTimeout(() => {
          this.autoResize.resize();
        }, 10);
      }
    }], contextConfig);
  }
  /**
   * Unregister shortcuts responsible for handling editor.
   *
   * @private
   */
  unregisterShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP2);
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR2);
  }
  /**
   * OnAfterDocumentKeyDown callback.
   *
   * @private
   * @param {KeyboardEvent} event The keyboard event object.
   */
  onAfterDocumentKeyDown(event2) {
    const arrowKeyCodes = [KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_LEFT];
    if (arrowKeyCodes.indexOf(event2.keyCode) === -1) {
      this.autoResize.resize(String.fromCharCode(event2.keyCode));
    }
  }
};

// node_modules/handsontable/renderers/baseRenderer/baseRenderer.mjs
var RENDERER_TYPE = "base";
function baseRenderer(instance, TD, row, col, prop, value, cellProperties) {
  const classesToAdd = [];
  const classesToRemove = [];
  if (cellProperties.className) {
    addClass(TD, cellProperties.className);
  }
  if (cellProperties.readOnly) {
    classesToAdd.push(cellProperties.readOnlyCellClassName);
  }
  if (cellProperties.valid === false && cellProperties.invalidCellClassName) {
    classesToAdd.push(cellProperties.invalidCellClassName);
  } else {
    classesToRemove.push(cellProperties.invalidCellClassName);
  }
  if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {
    classesToAdd.push(cellProperties.noWordWrapClassName);
  }
  if (!value && cellProperties.placeholder) {
    classesToAdd.push(cellProperties.placeholderCellClassName);
  }
  removeClass(TD, classesToRemove);
  addClass(TD, classesToAdd);
}
baseRenderer.RENDERER_TYPE = RENDERER_TYPE;

// node_modules/handsontable/renderers/textRenderer/textRenderer.mjs
var RENDERER_TYPE2 = "text";
function textRenderer(instance, TD, row, col, prop, value, cellProperties) {
  baseRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  let escaped = value;
  if (!escaped && cellProperties.placeholder) {
    escaped = cellProperties.placeholder;
  }
  escaped = stringify(escaped);
  if (cellProperties.trimWhitespace) {
    escaped = escaped.trim();
  }
  if (cellProperties.rendererTemplate) {
    empty(TD);
    const TEMPLATE = instance.rootDocument.createElement("TEMPLATE");
    TEMPLATE.setAttribute("bind", "{{}}");
    TEMPLATE.innerHTML = cellProperties.rendererTemplate;
    HTMLTemplateElement.decorate(TEMPLATE);
    TEMPLATE.model = instance.getSourceDataAtRow(row);
    TD.appendChild(TEMPLATE);
  } else {
    fastInnerText(TD, escaped);
  }
}
textRenderer.RENDERER_TYPE = RENDERER_TYPE2;

// node_modules/handsontable/cellTypes/textType/textType.mjs
var CELL_TYPE2 = "text";
var TextCellType = {
  CELL_TYPE: CELL_TYPE2,
  editor: TextEditor,
  renderer: textRenderer
};

// node_modules/handsontable/base.mjs
_register4(TextCellType);
Handsontable.editors = {
  BaseEditor
};
function Handsontable(rootElement, userSettings) {
  const instance = new Core(rootElement, userSettings || {}, rootInstanceSymbol);
  instance.init();
  return instance;
}
Handsontable.Core = function(rootElement) {
  let userSettings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Core(rootElement, userSettings, rootInstanceSymbol);
};
Handsontable.DefaultSettings = metaSchema_default();
Handsontable.hooks = pluginHooks_default.getSingleton();
Handsontable.CellCoords = coords_default;
Handsontable.CellRange = range_default;
Handsontable.packageName = "handsontable";
Handsontable.buildDate = "31/08/2023 08:23:33";
Handsontable.version = "13.1.0";
Handsontable.languages = {
  dictionaryKeys,
  getLanguageDictionary,
  getLanguagesDictionaries,
  registerLanguageDictionary,
  getTranslatedPhrase
};
var base_default = Handsontable;

// node_modules/handsontable/editors/handsontableEditor/handsontableEditor.mjs
var SHORTCUTS_GROUP3 = "handsontableEditor";
var EDITOR_TYPE3 = "handsontable";
var HandsontableEditor = class extends TextEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE3;
  }
  /**
   * Opens the editor and adjust its size.
   */
  open() {
    super.open();
    if (this.htEditor) {
      this.htEditor.destroy();
    }
    if (this.htContainer.style.display === "none") {
      this.htContainer.style.display = "";
    }
    this.htEditor = new this.hot.constructor(this.htContainer, this.htOptions);
    this.htEditor.init();
    this.htEditor.rootElement.style.display = "";
    if (this.cellProperties.strict) {
      this.htEditor.selectCell(0, 0);
    } else {
      this.htEditor.deselectCell();
    }
    setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);
    this.refreshDimensions();
  }
  /**
   * Closes the editor.
   */
  close() {
    if (this.htEditor) {
      this.htEditor.rootElement.style.display = "none";
    }
    this.removeHooksByKey("beforeKeyDown");
    super.close();
  }
  /**
   * Prepares editor's meta data and configuration of the internal Handsontable's instance.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
    const parent = this;
    const options = {
      startRows: 0,
      startCols: 0,
      minRows: 0,
      minCols: 0,
      className: "listbox",
      copyPaste: false,
      autoColumnSize: false,
      autoRowSize: false,
      readOnly: true,
      fillHandle: false,
      autoWrapCol: false,
      autoWrapRow: false,
      afterOnCellMouseDown(_, coords) {
        const sourceValue = this.getSourceData(coords.row, coords.col);
        if (sourceValue !== void 0) {
          parent.setValue(sourceValue);
        }
        parent.instance.destroyEditor();
      },
      preventWheel: true,
      layoutDirection: this.hot.isRtl() ? "rtl" : "ltr"
    };
    if (this.cellProperties.handsontable) {
      extend2(options, cellProperties.handsontable);
    }
    this.htOptions = options;
  }
  /**
   * Begins editing on a highlighted cell and hides fillHandle corner if was present.
   *
   * @param {*} newInitialValue The editor initial value.
   * @param {*} event The keyboard event object.
   */
  beginEditing(newInitialValue, event2) {
    const onBeginEditing = this.hot.getSettings().onBeginEditing;
    if (onBeginEditing && onBeginEditing() === false) {
      return;
    }
    super.beginEditing(newInitialValue, event2);
  }
  /**
   * Creates an editor's elements and adds necessary CSS classnames.
   */
  createElements() {
    super.createElements();
    const DIV = this.hot.rootDocument.createElement("DIV");
    DIV.className = "handsontableEditor";
    this.TEXTAREA_PARENT.appendChild(DIV);
    this.htContainer = DIV;
    this.assignHooks();
  }
  /**
   * Finishes editing and start saving or restoring process for editing cell or last selected range.
   *
   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
   * @param {Function} callback The callback function, fired after editor closing.
   */
  finishEditing(restoreOriginalValue, ctrlDown, callback) {
    if (this.htEditor && this.htEditor.isListening()) {
      this.hot.listen();
    }
    if (this.htEditor && this.htEditor.getSelectedLast()) {
      const value = this.htEditor.getInstance().getValue();
      if (value !== void 0) {
        this.setValue(value);
      }
    }
    super.finishEditing(restoreOriginalValue, ctrlDown, callback);
  }
  /**
   * Assings afterDestroy callback to prevent memory leaks.
   *
   * @private
   */
  assignHooks() {
    this.hot.addHook("afterDestroy", () => {
      if (this.htEditor) {
        this.htEditor.destroy();
      }
    });
  }
  /**
   * Register shortcuts responsible for handling editor.
   *
   * @private
   */
  registerShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    super.registerShortcuts();
    const contextConfig = {
      group: SHORTCUTS_GROUP3,
      relativeToGroup: SHORTCUTS_GROUP_NAVIGATION,
      position: "before"
    };
    const action = (rowToSelect, event2) => {
      const innerHOT = this.htEditor.getInstance();
      if (rowToSelect !== void 0) {
        if (rowToSelect < 0 || innerHOT.flipped && rowToSelect > innerHOT.countRows() - 1) {
          innerHOT.deselectCell();
        } else {
          innerHOT.selectCell(rowToSelect, 0);
        }
        if (innerHOT.getData().length) {
          event2.preventDefault();
          stopImmediatePropagation(event2);
          this.hot.listen();
          this.TEXTAREA.focus();
          return false;
        }
      }
    };
    editorContext.addShortcuts([{
      keys: [["ArrowUp"]],
      callback: (event2) => {
        const innerHOT = this.htEditor.getInstance();
        let rowToSelect;
        let selectedRow;
        if (!innerHOT.getSelectedLast() && innerHOT.flipped) {
          rowToSelect = innerHOT.countRows() - 1;
        } else if (innerHOT.getSelectedLast()) {
          if (innerHOT.flipped) {
            selectedRow = innerHOT.getSelectedLast()[0];
            rowToSelect = Math.max(0, selectedRow - 1);
          } else {
            selectedRow = innerHOT.getSelectedLast()[0];
            rowToSelect = selectedRow - 1;
          }
        }
        return action(rowToSelect, event2);
      },
      preventDefault: false
      // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.
    }, {
      keys: [["ArrowDown"]],
      callback: (event2) => {
        const innerHOT = this.htEditor.getInstance();
        let rowToSelect;
        let selectedRow;
        if (!innerHOT.getSelectedLast() && !innerHOT.flipped) {
          rowToSelect = 0;
        } else if (innerHOT.getSelectedLast()) {
          if (innerHOT.flipped) {
            rowToSelect = innerHOT.getSelectedLast()[0] + 1;
          } else if (!innerHOT.flipped) {
            const lastRow = innerHOT.countRows() - 1;
            selectedRow = innerHOT.getSelectedLast()[0];
            rowToSelect = Math.min(lastRow, selectedRow + 1);
          }
        }
        return action(rowToSelect, event2);
      },
      preventDefault: false
      // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.
    }], contextConfig);
  }
  /**
   * Unregister shortcuts responsible for handling editor.
   *
   * @private
   */
  unregisterShortcuts() {
    super.unregisterShortcuts();
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP3);
  }
};

// node_modules/handsontable/editors/autocompleteEditor/autocompleteEditor.mjs
function _defineProperty16(obj, key, value) {
  key = _toPropertyKey16(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey16(arg) {
  var key = _toPrimitive16(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive16(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var privatePool5 = /* @__PURE__ */ new WeakMap();
var EDITOR_TYPE4 = "autocomplete";
var AutocompleteEditor = class extends HandsontableEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE4;
  }
  constructor(instance) {
    super(instance);
    _defineProperty16(this, "sortByRelevance", function(value, choices, caseSensitive) {
      const choicesRelevance = [];
      const result = [];
      const valueLength = value.length;
      let choicesCount = choices.length;
      let charsLeft;
      let currentItem;
      let i;
      let valueIndex;
      if (valueLength === 0) {
        for (i = 0; i < choicesCount; i++) {
          result.push(i);
        }
        return result;
      }
      for (i = 0; i < choicesCount; i++) {
        currentItem = stripTags(stringify(choices[i]));
        if (caseSensitive) {
          valueIndex = currentItem.indexOf(value);
        } else {
          const locale2 = this.cellProperties.locale;
          valueIndex = currentItem.toLocaleLowerCase(locale2).indexOf(value.toLocaleLowerCase(locale2));
        }
        if (valueIndex !== -1) {
          charsLeft = currentItem.length - valueIndex - valueLength;
          choicesRelevance.push({
            baseIndex: i,
            index: valueIndex,
            charsLeft,
            value: currentItem
          });
        }
      }
      choicesRelevance.sort((a, b) => {
        if (b.index === -1) {
          return -1;
        }
        if (a.index === -1) {
          return 1;
        }
        if (a.index < b.index) {
          return -1;
        } else if (b.index < a.index) {
          return 1;
        } else if (a.index === b.index) {
          if (a.charsLeft < b.charsLeft) {
            return -1;
          } else if (a.charsLeft > b.charsLeft) {
            return 1;
          }
        }
        return 0;
      });
      for (i = 0, choicesCount = choicesRelevance.length; i < choicesCount; i++) {
        result.push(choicesRelevance[i].baseIndex);
      }
      return result;
    });
    this.query = null;
    this.strippedChoices = [];
    this.rawChoices = [];
    privatePool5.set(this, {
      skipOne: false,
      isMacOS: this.hot.rootWindow.navigator.platform.indexOf("Mac") > -1
    });
  }
  /**
   * Gets current value from editable element.
   *
   * @returns {string}
   */
  getValue() {
    const selectedValue = this.rawChoices.find((value) => {
      const strippedValue = this.stripValueIfNeeded(value);
      return strippedValue === this.TEXTAREA.value;
    });
    if (isDefined(selectedValue)) {
      return selectedValue;
    }
    return this.TEXTAREA.value;
  }
  /**
   * Creates an editor's elements and adds necessary CSS classnames.
   */
  createElements() {
    super.createElements();
    addClass(this.htContainer, "autocompleteEditor");
    addClass(this.htContainer, this.hot.rootWindow.navigator.platform.indexOf("Mac") === -1 ? "" : "htMacScroll");
  }
  /**
   * Opens the editor and adjust its size and internal Handsontable's instance.
   */
  open() {
    const priv = privatePool5.get(this);
    super.open();
    const choicesListHot = this.htEditor.getInstance();
    const trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;
    this.showEditableElement();
    this.focus();
    let scrollbarWidth = getScrollbarWidth();
    if (scrollbarWidth === 0 && priv.isMacOS) {
      scrollbarWidth += 15;
    }
    this.addHook("beforeKeyDown", (event2) => this.onBeforeKeyDown(event2));
    choicesListHot.updateSettings({
      colWidths: trimDropdown ? [outerWidth(this.TEXTAREA) - 2] : void 0,
      width: trimDropdown ? outerWidth(this.TEXTAREA) + scrollbarWidth : void 0,
      renderer: (instance, TD, row, col, prop, value, cellProperties) => {
        textRenderer(instance, TD, row, col, prop, value, cellProperties);
        const {
          filteringCaseSensitive,
          allowHtml,
          locale: locale2
        } = this.cellProperties;
        const query = this.query;
        let cellValue = stringify(value);
        let indexOfMatch;
        let match;
        if (cellValue && !allowHtml) {
          indexOfMatch = filteringCaseSensitive === true ? cellValue.indexOf(query) : cellValue.toLocaleLowerCase(locale2).indexOf(query.toLocaleLowerCase(locale2));
          if (indexOfMatch !== -1) {
            match = cellValue.substr(indexOfMatch, query.length);
            cellValue = cellValue.replace(match, `<strong>${match}</strong>`);
          }
        }
        TD.innerHTML = cellValue;
      },
      autoColumnSize: true
    });
    if (priv.skipOne) {
      priv.skipOne = false;
    }
    this.hot._registerTimeout(() => {
      this.queryChoices(this.TEXTAREA.value);
    });
  }
  /**
   * Closes the editor.
   */
  close() {
    this.removeHooksByKey("beforeKeyDown");
    super.close();
  }
  /**
   * Verifies result of validation or closes editor if user's cancelled changes.
   *
   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,
   *                                   then an editor won't be closed until validation is passed.
   */
  discardEditor(result) {
    super.discardEditor(result);
    this.hot.view.render();
  }
  /**
   * Prepares choices list based on applied argument.
   *
   * @private
   * @param {string} query The query.
   */
  queryChoices(query) {
    const source = this.cellProperties.source;
    this.query = query;
    if (typeof source === "function") {
      source.call(this.cellProperties, query, (choices) => {
        this.rawChoices = choices;
        this.updateChoicesList(this.stripValuesIfNeeded(choices));
      });
    } else if (Array.isArray(source)) {
      this.rawChoices = source;
      this.updateChoicesList(this.stripValuesIfNeeded(source));
    } else {
      this.updateChoicesList([]);
    }
  }
  /**
   * Updates list of the possible completions to choose.
   *
   * @private
   * @param {Array} choicesList The choices list to process.
   */
  updateChoicesList(choicesList) {
    const pos = getCaretPosition(this.TEXTAREA);
    const endPos = getSelectionEndPosition(this.TEXTAREA);
    const sortByRelevanceSetting = this.cellProperties.sortByRelevance;
    const filterSetting = this.cellProperties.filter;
    let orderByRelevance = null;
    let highlightIndex = null;
    let choices = choicesList;
    if (sortByRelevanceSetting) {
      orderByRelevance = this.sortByRelevance(this.stripValueIfNeeded(this.getValue()), choices, this.cellProperties.filteringCaseSensitive);
    }
    const orderByRelevanceLength = Array.isArray(orderByRelevance) ? orderByRelevance.length : 0;
    if (filterSetting === false) {
      if (orderByRelevanceLength) {
        highlightIndex = orderByRelevance[0];
      }
    } else {
      const sorted = [];
      for (let i = 0, choicesCount = choices.length; i < choicesCount; i++) {
        if (sortByRelevanceSetting && orderByRelevanceLength <= i) {
          break;
        }
        if (orderByRelevanceLength) {
          sorted.push(choices[orderByRelevance[i]]);
        } else {
          sorted.push(choices[i]);
        }
      }
      highlightIndex = 0;
      choices = sorted;
    }
    this.strippedChoices = choices;
    this.htEditor.loadData(pivot([choices]));
    this.updateDropdownHeight();
    this.flipDropdownIfNeeded();
    if (this.cellProperties.strict === true) {
      this.highlightBestMatchingChoice(highlightIndex);
    }
    this.hot.listen();
    setCaretPosition(this.TEXTAREA, pos, pos === endPos ? void 0 : endPos);
  }
  /**
   * Checks where is enough place to open editor.
   *
   * @private
   * @returns {boolean}
   */
  flipDropdownIfNeeded() {
    const trimmingContainer = getTrimmingContainer(this.hot.view._wt.wtTable.TABLE);
    const isWindowAsScrollableElement = trimmingContainer === this.hot.rootWindow;
    const preventOverflow = this.cellProperties.preventOverflow;
    if (isWindowAsScrollableElement || !isWindowAsScrollableElement && (preventOverflow || preventOverflow === "horizontal")) {
      return false;
    }
    const textareaOffset = offset2(this.TEXTAREA);
    const textareaHeight = outerHeight(this.TEXTAREA);
    const dropdownHeight = this.getDropdownHeight();
    const trimmingContainerScrollTop = trimmingContainer.scrollTop;
    const headersHeight = outerHeight(this.hot.view._wt.wtTable.THEAD);
    const containerOffset = offset2(trimmingContainer);
    const spaceAbove = textareaOffset.top - containerOffset.top - headersHeight + trimmingContainerScrollTop;
    const spaceBelow = trimmingContainer.scrollHeight - spaceAbove - headersHeight - textareaHeight;
    const flipNeeded = dropdownHeight > spaceBelow && spaceAbove > spaceBelow;
    if (flipNeeded) {
      this.flipDropdown(dropdownHeight);
    } else {
      this.unflipDropdown();
    }
    this.limitDropdownIfNeeded(flipNeeded ? spaceAbove : spaceBelow, dropdownHeight);
    return flipNeeded;
  }
  /**
   * Checks if the internal table should generate scrollbar or could be rendered without it.
   *
   * @private
   * @param {number} spaceAvailable The free space as height defined in px available for dropdown list.
   * @param {number} dropdownHeight The dropdown height.
   */
  limitDropdownIfNeeded(spaceAvailable, dropdownHeight) {
    if (dropdownHeight > spaceAvailable) {
      let tempHeight = 0;
      let i = 0;
      let lastRowHeight = 0;
      let height = null;
      do {
        lastRowHeight = this.htEditor.getRowHeight(i) || this.htEditor.view._wt.getSetting("defaultRowHeight");
        tempHeight += lastRowHeight;
        i += 1;
      } while (tempHeight < spaceAvailable);
      height = tempHeight - lastRowHeight;
      if (this.htEditor.flipped) {
        this.htEditor.rootElement.style.top = `${parseInt(this.htEditor.rootElement.style.top, 10) + dropdownHeight - height}px`;
      }
      this.setDropdownHeight(tempHeight - lastRowHeight);
    }
  }
  /**
   * Configures editor to open it at the top.
   *
   * @private
   * @param {number} dropdownHeight The dropdown height.
   */
  flipDropdown(dropdownHeight) {
    const dropdownStyle = this.htEditor.rootElement.style;
    dropdownStyle.position = "absolute";
    dropdownStyle.top = `${-dropdownHeight}px`;
    this.htEditor.flipped = true;
  }
  /**
   * Configures editor to open it at the bottom.
   *
   * @private
   */
  unflipDropdown() {
    const dropdownStyle = this.htEditor.rootElement.style;
    dropdownStyle.position = "absolute";
    dropdownStyle.top = "";
    this.htEditor.flipped = void 0;
  }
  /**
   * Updates width and height of the internal Handsontable's instance.
   *
   * @private
   */
  updateDropdownHeight() {
    const currentDropdownWidth = this.htEditor.getColWidth(0) + getScrollbarWidth(this.hot.rootDocument) + 2;
    const trimDropdown = this.cellProperties.trimDropdown;
    this.htEditor.updateSettings({
      height: this.getDropdownHeight(),
      width: trimDropdown ? void 0 : currentDropdownWidth
    });
    this.htEditor.view._wt.wtTable.alignOverlaysWithTrimmingContainer();
  }
  /**
   * Sets new height of the internal Handsontable's instance.
   *
   * @private
   * @param {number} height The new dropdown height.
   */
  setDropdownHeight(height) {
    this.htEditor.updateSettings({
      height
    });
  }
  /**
   * Creates new selection on specified row index, or deselects selected cells.
   *
   * @private
   * @param {number|undefined} index The visual row index.
   */
  highlightBestMatchingChoice(index2) {
    if (typeof index2 === "number") {
      this.htEditor.selectCell(index2, 0, void 0, void 0, void 0, false);
    } else {
      this.htEditor.deselectCell();
    }
  }
  /**
   * Calculates and return the internal Handsontable's height.
   *
   * @private
   * @returns {number}
   */
  getDropdownHeight() {
    const firstRowHeight = this.htEditor.getInstance().getRowHeight(0) || 23;
    const visibleRows = this.cellProperties.visibleRows;
    return this.strippedChoices.length >= visibleRows ? visibleRows * firstRowHeight : this.strippedChoices.length * firstRowHeight + 8;
  }
  /**
   * Sanitizes value from potential dangerous tags.
   *
   * @private
   * @param {string} value The value to sanitize.
   * @returns {string}
   */
  stripValueIfNeeded(value) {
    return this.stripValuesIfNeeded([value])[0];
  }
  /**
   * Sanitizes an array of the values from potential dangerous tags.
   *
   * @private
   * @param {string[]} values The value to sanitize.
   * @returns {string[]}
   */
  stripValuesIfNeeded(values) {
    const {
      allowHtml
    } = this.cellProperties;
    const stringifiedValues = arrayMap(values, (value) => stringify(value));
    const strippedValues = arrayMap(stringifiedValues, (value) => allowHtml ? value : stripTags(value));
    return strippedValues;
  }
  /**
   * Captures use of arrow down and up to control their behaviour.
   *
   * @private
   * @param {number} keyCode The keyboard keycode.
   * @returns {boolean}
   */
  allowKeyEventPropagation(keyCode) {
    const selectedRange = this.htEditor.getSelectedRangeLast();
    const selected = {
      row: selectedRange ? selectedRange.from.row : -1
    };
    let allowed = false;
    if (keyCode === KEY_CODES.ARROW_DOWN && selected.row > 0 && selected.row < this.htEditor.countRows() - 1) {
      allowed = true;
    }
    if (keyCode === KEY_CODES.ARROW_UP && selected.row > -1) {
      allowed = true;
    }
    return allowed;
  }
  /**
   * OnBeforeKeyDown callback.
   *
   * @private
   * @param {KeyboardEvent} event The keyboard event object.
   */
  onBeforeKeyDown(event2) {
    const priv = privatePool5.get(this);
    priv.skipOne = false;
    if (isPrintableChar(event2.keyCode) || event2.keyCode === KEY_CODES.BACKSPACE || event2.keyCode === KEY_CODES.DELETE || event2.keyCode === KEY_CODES.INSERT) {
      let timeOffset = 10;
      if (event2.keyCode === KEY_CODES.C && (event2.ctrlKey || event2.metaKey)) {
        return;
      }
      if (!this.isOpened()) {
        timeOffset += 10;
      }
      if (this.htEditor) {
        this.hot._registerTimeout(() => {
          this.queryChoices(this.TEXTAREA.value);
          priv.skipOne = true;
        }, timeOffset);
      }
    }
  }
};

// node_modules/handsontable/editors/checkboxEditor/checkboxEditor.mjs
var EDITOR_TYPE5 = "checkbox";
var CheckboxEditor = class extends BaseEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE5;
  }
  beginEditing(initialValue, event2) {
    if (event2 && event2.type === "mouseup") {
      const checkbox = this.TD.querySelector('input[type="checkbox"]');
      if (!hasClass(checkbox, "htBadValue")) {
        checkbox.click();
      }
    }
  }
  finishEditing() {
  }
  init() {
  }
  open() {
  }
  close() {
  }
  getValue() {
  }
  setValue() {
  }
  focus() {
  }
};

// node_modules/handsontable/editors/dateEditor/dateEditor.mjs
init_moment();
var import_pikaday = __toESM(require_pikaday(), 1);
var EDITOR_TYPE6 = "date";
var SHORTCUTS_GROUP_EDITOR3 = "dateEditor";
var DateEditor = class extends TextEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE6;
  }
  /**
   * @param {Core} hotInstance Handsontable instance.
   * @private
   */
  constructor(hotInstance) {
    super(hotInstance);
    this.defaultDateFormat = "DD/MM/YYYY";
    this.isCellEdited = false;
    this.parentDestroyed = false;
    this.$datePicker = null;
  }
  init() {
    if (typeof moment_default !== "function") {
      throw new Error("You need to include moment.js to your project.");
    }
    if (typeof import_pikaday.default !== "function") {
      throw new Error("You need to include Pikaday to your project.");
    }
    super.init();
    this.instance.addHook("afterDestroy", () => {
      this.parentDestroyed = true;
      this.destroyElements();
    });
  }
  /**
   * Create data picker instance.
   */
  createElements() {
    super.createElements();
    this.datePicker = this.hot.rootDocument.createElement("DIV");
    this.datePickerStyle = this.datePicker.style;
    this.datePickerStyle.position = "absolute";
    this.datePickerStyle.top = 0;
    this.datePickerStyle.left = 0;
    this.datePickerStyle.zIndex = 9999;
    this.datePicker.setAttribute("dir", this.hot.isRtl() ? "rtl" : "ltr");
    addClass(this.datePicker, "htDatepickerHolder");
    this.hot.rootDocument.body.appendChild(this.datePicker);
    const eventManager = new eventManager_default(this);
    eventManager.addEventListener(this.datePicker, "mousedown", (event2) => event2.stopPropagation());
  }
  /**
   * Destroy data picker instance.
   */
  destroyElements() {
    const datePickerParentElement = this.datePicker.parentNode;
    if (this.$datePicker) {
      this.$datePicker.destroy();
    }
    if (datePickerParentElement) {
      datePickerParentElement.removeChild(this.datePicker);
    }
  }
  /**
   * Prepare editor to appear.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
  }
  /**
   * Open editor.
   *
   * @param {Event} [event=null] The event object.
   */
  open() {
    let event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    super.open();
    this.showDatepicker(event2);
    editorContext.addShortcut({
      keys: [["Enter"]],
      callback: (keyboardEvent) => {
        keyboardEvent.stopPropagation();
      },
      group: SHORTCUTS_GROUP_EDITOR3
    });
  }
  /**
   * Close editor.
   */
  close() {
    var _this$$datePicker;
    this._opened = false;
    if ((_this$$datePicker = this.$datePicker) !== null && _this$$datePicker !== void 0 && _this$$datePicker.destroy) {
      this.$datePicker.destroy();
    }
    this.instance._registerTimeout(() => {
      this.instance._refreshBorders();
    });
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR3);
    super.close();
  }
  /**
   * Finishes editing and start saving or restoring process for editing cell or last selected range.
   *
   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
   */
  finishEditing() {
    let restoreOriginalValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let ctrlDown = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (restoreOriginalValue) {
      const value = this.originalValue;
      if (value !== void 0) {
        this.setValue(value);
      }
    }
    super.finishEditing(restoreOriginalValue, ctrlDown);
  }
  /**
   * Show data picker.
   *
   * @param {Event} event The event object.
   */
  showDatepicker(event2) {
    const offset3 = this.TD.getBoundingClientRect();
    const dateFormat = this.cellProperties.dateFormat || this.defaultDateFormat;
    const isMouseDown = this.instance.view.isMouseDown();
    const isMeta = event2 ? isFunctionKey(event2.keyCode) : false;
    let dateStr;
    this.datePicker.style.display = "block";
    this.$datePicker = new import_pikaday.default(this.getDatePickerConfig());
    this.$datePicker._onInputFocus = function() {
    };
    this.datePickerStyle.top = `${this.hot.rootWindow.pageYOffset + offset3.top + outerHeight(this.TD)}px`;
    let pickerLeftPosition = this.hot.rootWindow.pageXOffset;
    if (this.hot.isRtl()) {
      pickerLeftPosition = offset3.right - outerWidth(this.datePicker);
    } else {
      pickerLeftPosition = offset3.left;
    }
    this.datePickerStyle.left = `${pickerLeftPosition}px`;
    if (this.originalValue) {
      dateStr = this.originalValue;
      if (moment_default(dateStr, dateFormat, true).isValid()) {
        this.$datePicker.setMoment(moment_default(dateStr, dateFormat), true);
      }
      if (this.getValue() !== this.originalValue) {
        this.setValue(this.originalValue);
      }
      if (!isMeta && !isMouseDown) {
        this.setValue("");
      }
    } else if (this.cellProperties.defaultDate) {
      dateStr = this.cellProperties.defaultDate;
      if (moment_default(dateStr, dateFormat, true).isValid()) {
        this.$datePicker.setMoment(moment_default(dateStr, dateFormat), true);
      }
      if (!isMeta && !isMouseDown) {
        this.setValue("");
      }
    } else {
      this.$datePicker.gotoToday();
    }
  }
  /**
   * Hide data picker.
   */
  hideDatepicker() {
    this.datePickerStyle.display = "none";
    this.$datePicker.hide();
  }
  /**
   * Get date picker options.
   *
   * @returns {object}
   */
  getDatePickerConfig() {
    const htInput = this.TEXTAREA;
    const options = {};
    if (this.cellProperties && this.cellProperties.datePickerConfig) {
      deepExtend(options, this.cellProperties.datePickerConfig);
    }
    const origOnSelect = options.onSelect;
    const origOnClose = options.onClose;
    options.field = htInput;
    options.trigger = htInput;
    options.container = this.datePicker;
    options.bound = false;
    options.format = options.format || this.defaultDateFormat;
    options.reposition = options.reposition || false;
    options.isRTL = false;
    options.onSelect = (value) => {
      let dateStr = value;
      if (!isNaN(dateStr.getTime())) {
        dateStr = moment_default(dateStr).format(this.cellProperties.dateFormat || this.defaultDateFormat);
      }
      this.setValue(dateStr);
      this.hideDatepicker();
      if (origOnSelect) {
        origOnSelect();
      }
    };
    options.onClose = () => {
      if (!this.parentDestroyed) {
        this.finishEditing(false);
      }
      if (origOnClose) {
        origOnClose();
      }
    };
    return options;
  }
};

// node_modules/handsontable/editors/dropdownEditor/dropdownEditor.mjs
var EDITOR_TYPE7 = "dropdown";
var DropdownEditor = class extends AutocompleteEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE7;
  }
  /**
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
    this.cellProperties.filter = false;
    this.cellProperties.strict = true;
  }
};
pluginHooks_default.getSingleton().add("beforeValidate", function(value, row, col) {
  const cellMeta = this.getCellMeta(row, this.propToCol(col));
  if (cellMeta.editor === DropdownEditor) {
    if (cellMeta.strict === void 0) {
      cellMeta.filter = false;
      cellMeta.strict = true;
    }
  }
});

// node_modules/handsontable/editors/numericEditor/numericEditor.mjs
var EDITOR_TYPE8 = "numeric";
var NumericEditor = class extends TextEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE8;
  }
};

// node_modules/handsontable/editors/passwordEditor/passwordEditor.mjs
var EDITOR_TYPE9 = "password";
var PasswordEditor = class extends TextEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE9;
  }
  createElements() {
    super.createElements();
    this.TEXTAREA = this.hot.rootDocument.createElement("input");
    this.TEXTAREA.setAttribute("type", "password");
    this.TEXTAREA.setAttribute("data-hot-input", "");
    this.TEXTAREA.className = "handsontableInput";
    this.textareaStyle = this.TEXTAREA.style;
    this.textareaStyle.width = 0;
    this.textareaStyle.height = 0;
    empty(this.TEXTAREA_PARENT);
    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
  }
};

// node_modules/handsontable/editors/selectEditor/selectEditor.mjs
var EDITOR_VISIBLE_CLASS_NAME2 = "ht_editor_visible";
var SHORTCUTS_GROUP4 = "selectEditor";
var EDITOR_TYPE10 = "select";
var SelectEditor = class extends BaseEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE10;
  }
  /**
   * Initializes editor instance, DOM Element and mount hooks.
   */
  init() {
    this.select = this.hot.rootDocument.createElement("SELECT");
    addClass(this.select, "htSelectEditor");
    this.select.style.display = "none";
    this.hot.rootElement.appendChild(this.select);
    this.registerHooks();
  }
  /**
   * Returns select's value.
   *
   * @returns {*}
   */
  getValue() {
    return this.select.value;
  }
  /**
   * Sets value in the select element.
   *
   * @param {*} value A new select's value.
   */
  setValue(value) {
    this.select.value = value;
  }
  /**
   * Opens the editor and adjust its size.
   */
  open() {
    this._opened = true;
    this.refreshDimensions();
    this.select.style.display = "";
    const shortcutManager = this.hot.getShortcutManager();
    shortcutManager.setActiveContextName("editor");
    this.registerShortcuts();
  }
  /**
   * Closes the editor.
   */
  close() {
    this._opened = false;
    this.select.style.display = "none";
    if (hasClass(this.select, EDITOR_VISIBLE_CLASS_NAME2)) {
      removeClass(this.select, EDITOR_VISIBLE_CLASS_NAME2);
    }
    this.unregisterShortcuts();
    this.clearHooks();
  }
  /**
   * Sets focus state on the select element.
   */
  focus() {
    this.select.focus();
  }
  /**
   * Binds hooks to refresh editor's size after scrolling of the viewport or resizing of columns/rows.
   *
   * @private
   */
  registerHooks() {
    this.addHook("afterScrollHorizontally", () => this.refreshDimensions());
    this.addHook("afterScrollVertically", () => this.refreshDimensions());
    this.addHook("afterColumnResize", () => this.refreshDimensions());
    this.addHook("afterRowResize", () => this.refreshDimensions());
  }
  /**
   * Prepares editor's meta data and a list of available options.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
    const selectOptions = this.cellProperties.selectOptions;
    let options;
    if (typeof selectOptions === "function") {
      options = this.prepareOptions(selectOptions(this.row, this.col, this.prop));
    } else {
      options = this.prepareOptions(selectOptions);
    }
    empty(this.select);
    objectEach(options, (optionValue, key) => {
      const optionElement = this.hot.rootDocument.createElement("OPTION");
      optionElement.value = key;
      fastInnerHTML(optionElement, optionValue);
      this.select.appendChild(optionElement);
    });
  }
  /**
   * Creates consistent list of available options.
   *
   * @private
   * @param {Array|object} optionsToPrepare The list of the values to render in the select eleemnt.
   * @returns {object}
   */
  prepareOptions(optionsToPrepare) {
    let preparedOptions = {};
    if (Array.isArray(optionsToPrepare)) {
      for (let i = 0, len = optionsToPrepare.length; i < len; i++) {
        preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
      }
    } else if (typeof optionsToPrepare === "object") {
      preparedOptions = optionsToPrepare;
    }
    return preparedOptions;
  }
  /**
   * Refreshes editor's value using source data.
   *
   * @private
   */
  refreshValue() {
    const sourceData = this.hot.getSourceDataAtCell(this.row, this.prop);
    this.originalValue = sourceData;
    this.setValue(sourceData);
    this.refreshDimensions();
  }
  /**
   * Refreshes editor's size and position.
   *
   * @private
   */
  refreshDimensions() {
    if (this.state !== EDITOR_STATE.EDITING) {
      return;
    }
    this.TD = this.getEditedCell();
    if (!this.TD) {
      this.close();
      return;
    }
    const {
      top: top2,
      start,
      width,
      height
    } = this.getEditedCellRect();
    const selectStyle = this.select.style;
    selectStyle.height = `${height}px`;
    selectStyle.width = `${width}px`;
    selectStyle.top = `${top2}px`;
    selectStyle[this.hot.isRtl() ? "right" : "left"] = `${start}px`;
    selectStyle.margin = "0px";
    addClass(this.select, EDITOR_VISIBLE_CLASS_NAME2);
  }
  /**
   * Register shortcuts responsible for handling editor.
   *
   * @private
   */
  registerShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    const contextConfig = {
      group: SHORTCUTS_GROUP4
    };
    if (this.isInFullEditMode() === false) {
      return;
    }
    editorContext.addShortcuts([{
      keys: [["ArrowUp"]],
      callback: () => {
        const previousOptionIndex = this.select.selectedIndex - 1;
        if (previousOptionIndex >= 0) {
          this.select[previousOptionIndex].selected = true;
        }
      }
    }, {
      keys: [["ArrowDown"]],
      callback: () => {
        const nextOptionIndex = this.select.selectedIndex + 1;
        if (nextOptionIndex <= this.select.length - 1) {
          this.select[nextOptionIndex].selected = true;
        }
      }
    }], contextConfig);
  }
  /**
   * Unregister shortcuts responsible for handling editor.
   *
   * @private
   */
  unregisterShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP4);
  }
};

// node_modules/handsontable/editors/timeEditor/timeEditor.mjs
var EDITOR_TYPE11 = "time";
var TimeEditor = class extends TextEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE11;
  }
  /**
   * Prepares editor's meta data.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
    this.TEXTAREA.dir = "ltr";
  }
};

// node_modules/handsontable/editors/index.mjs
function registerAllEditors() {
  _register(BaseEditor);
  _register(AutocompleteEditor);
  _register(CheckboxEditor);
  _register(DateEditor);
  _register(DropdownEditor);
  _register(HandsontableEditor);
  _register(NumericEditor);
  _register(PasswordEditor);
  _register(SelectEditor);
  _register(TextEditor);
  _register(TimeEditor);
}

// node_modules/handsontable/renderers/htmlRenderer/htmlRenderer.mjs
var RENDERER_TYPE3 = "html";
function htmlRenderer(instance, TD, row, col, prop, value, cellProperties) {
  baseRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  fastInnerHTML(TD, value === null || value === void 0 ? "" : value, false);
}
htmlRenderer.RENDERER_TYPE = RENDERER_TYPE3;

// node_modules/handsontable/renderers/autocompleteRenderer/autocompleteRenderer.mjs
var RENDERER_TYPE4 = "autocomplete";
function autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {
  const {
    rootDocument
  } = instance;
  const rendererFunc = cellProperties.allowHtml ? htmlRenderer : textRenderer;
  const ARROW = rootDocument.createElement("DIV");
  ARROW.className = "htAutocompleteArrow";
  ARROW.appendChild(rootDocument.createTextNode(String.fromCharCode(9660)));
  rendererFunc.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  if (!TD.firstChild) {
    TD.appendChild(rootDocument.createTextNode(String.fromCharCode(160)));
  }
  TD.insertBefore(ARROW, TD.firstChild);
  addClass(TD, "htAutocomplete");
  if (!instance.acArrowListener) {
    const eventManager = new eventManager_default(instance);
    instance.acArrowListener = function(event2) {
      if (hasClass(event2.target, "htAutocompleteArrow")) {
        instance.view._wt.getSetting("onCellDblClick", null, instance._createCellCoords(row, col), TD);
      }
    };
    eventManager.addEventListener(instance.rootElement, "mousedown", instance.acArrowListener);
    instance.addHookOnce("afterDestroy", () => {
      eventManager.destroy();
    });
  }
}
autocompleteRenderer.RENDERER_TYPE = RENDERER_TYPE4;

// node_modules/handsontable/renderers/checkboxRenderer/checkboxRenderer.mjs
var isListeningKeyDownEvent = /* @__PURE__ */ new WeakMap();
var isCheckboxListenerAdded = /* @__PURE__ */ new WeakMap();
var BAD_VALUE_CLASS = "htBadValue";
var ATTR_ROW = "data-row";
var ATTR_COLUMN = "data-col";
var SHORTCUTS_GROUP5 = "checkboxRenderer";
var RENDERER_TYPE5 = "checkbox";
pluginHooks_default.getSingleton().add("modifyAutoColumnSizeSeed", function(bundleSeed, cellMeta, cellValue) {
  const {
    label,
    type,
    row,
    column,
    prop
  } = cellMeta;
  if (type !== RENDERER_TYPE5) {
    return;
  }
  if (label) {
    const {
      value: labelValue,
      property: labelProperty
    } = label;
    let labelText = cellValue;
    if (labelValue) {
      labelText = typeof labelValue === "function" ? labelValue(row, column, prop, cellValue) : labelValue;
    } else if (labelProperty) {
      const labelData = this.getDataAtRowProp(row, labelProperty);
      labelText = labelData !== null ? labelData : cellValue;
    }
    bundleSeed = labelText;
  }
  return bundleSeed;
});
function checkboxRenderer(instance, TD, row, col, prop, value, cellProperties) {
  const {
    rootDocument
  } = instance;
  baseRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  registerEvents(instance);
  let input = createInput(rootDocument);
  const labelOptions = cellProperties.label;
  let badValue = false;
  if (typeof cellProperties.checkedTemplate === "undefined") {
    cellProperties.checkedTemplate = true;
  }
  if (typeof cellProperties.uncheckedTemplate === "undefined") {
    cellProperties.uncheckedTemplate = false;
  }
  empty(TD);
  if (value === cellProperties.checkedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.checkedTemplate).toLocaleLowerCase(cellProperties.locale)) {
    input.checked = true;
  } else if (value === cellProperties.uncheckedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.uncheckedTemplate).toLocaleLowerCase(cellProperties.locale)) {
    input.checked = false;
  } else if (isEmpty(value)) {
    addClass(input, "noValue");
  } else {
    input.style.display = "none";
    addClass(input, BAD_VALUE_CLASS);
    badValue = true;
  }
  input.setAttribute(ATTR_ROW, row);
  input.setAttribute(ATTR_COLUMN, col);
  if (!badValue && labelOptions) {
    let labelText = "";
    if (labelOptions.value) {
      labelText = typeof labelOptions.value === "function" ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;
    } else if (labelOptions.property) {
      const labelValue = instance.getDataAtRowProp(row, labelOptions.property);
      labelText = labelValue !== null ? labelValue : "";
    }
    const label = createLabel(rootDocument, labelText, labelOptions.separated !== true);
    if (labelOptions.position === "before") {
      if (labelOptions.separated) {
        TD.appendChild(label);
        TD.appendChild(input);
      } else {
        label.appendChild(input);
        input = label;
      }
    } else if (!labelOptions.position || labelOptions.position === "after") {
      if (labelOptions.separated) {
        TD.appendChild(input);
        TD.appendChild(label);
      } else {
        label.insertBefore(input, label.firstChild);
        input = label;
      }
    }
  }
  if (!labelOptions || labelOptions && !labelOptions.separated) {
    TD.appendChild(input);
  }
  if (badValue) {
    TD.appendChild(rootDocument.createTextNode("#bad-value#"));
  }
  if (!isListeningKeyDownEvent.has(instance)) {
    isListeningKeyDownEvent.set(instance, true);
    registerShortcuts();
  }
  function registerShortcuts() {
    const shortcutManager = instance.getShortcutManager();
    const gridContext = shortcutManager.getContext("grid");
    const config = {
      group: SHORTCUTS_GROUP5
    };
    gridContext.addShortcuts([{
      keys: [["space"]],
      callback: () => {
        changeSelectedCheckboxesState();
        return !areSelectedCheckboxCells();
      }
    }, {
      keys: [["enter"]],
      callback: () => {
        changeSelectedCheckboxesState();
        return !areSelectedCheckboxCells();
      },
      runOnlyIf: () => instance.getSettings().enterBeginsEditing
    }, {
      keys: [["delete"], ["backspace"]],
      callback: () => {
        changeSelectedCheckboxesState(true);
        return !areSelectedCheckboxCells();
      },
      relativeToGroup: SHORTCUTS_GROUP_EDITOR,
      position: "before"
    }], config);
  }
  function changeSelectedCheckboxesState() {
    let uncheckCheckbox = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const selRange = instance.getSelectedRange();
    if (!selRange) {
      return;
    }
    for (let key = 0; key < selRange.length; key++) {
      const {
        row: startRow,
        col: startColumn
      } = selRange[key].getTopStartCorner();
      const {
        row: endRow,
        col: endColumn
      } = selRange[key].getBottomEndCorner();
      const changes = [];
      for (let visualRow = startRow; visualRow <= endRow; visualRow += 1) {
        for (let visualColumn = startColumn; visualColumn <= endColumn; visualColumn += 1) {
          const cachedCellProperties = instance.getCellMeta(visualRow, visualColumn);
          if (cachedCellProperties.type !== "checkbox") {
            return;
          }
          if (cachedCellProperties.readOnly === true) {
            continue;
          }
          if (typeof cachedCellProperties.checkedTemplate === "undefined") {
            cachedCellProperties.checkedTemplate = true;
          }
          if (typeof cachedCellProperties.uncheckedTemplate === "undefined") {
            cachedCellProperties.uncheckedTemplate = false;
          }
          const dataAtCell = instance.getDataAtCell(visualRow, visualColumn);
          if (uncheckCheckbox === false) {
            if ([cachedCellProperties.checkedTemplate, cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {
              changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
            } else if ([cachedCellProperties.uncheckedTemplate, cachedCellProperties.uncheckedTemplate.toString(), null, void 0].includes(dataAtCell)) {
              changes.push([visualRow, visualColumn, cachedCellProperties.checkedTemplate]);
            }
          } else {
            changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
          }
        }
      }
      if (changes.length > 0) {
        instance.setDataAtCell(changes);
      }
    }
  }
  function areSelectedCheckboxCells() {
    const selRange = instance.getSelectedRange();
    if (!selRange) {
      return;
    }
    for (let key = 0; key < selRange.length; key++) {
      const topLeft = selRange[key].getTopStartCorner();
      const bottomRight = selRange[key].getBottomEndCorner();
      for (let visualRow = topLeft.row; visualRow <= bottomRight.row; visualRow++) {
        for (let visualColumn = topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {
          const cachedCellProperties = instance.getCellMeta(visualRow, visualColumn);
          if (cachedCellProperties.type !== "checkbox") {
            return false;
          }
          const cell = instance.getCell(visualRow, visualColumn);
          if (cell === null || cell === void 0) {
            return true;
          } else {
            const checkboxes = cell.querySelectorAll("input[type=checkbox]");
            if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
}
checkboxRenderer.RENDERER_TYPE = RENDERER_TYPE5;
function registerEvents(instance) {
  let eventManager = isCheckboxListenerAdded.get(instance);
  if (!eventManager) {
    const {
      rootElement
    } = instance;
    eventManager = new eventManager_default(instance);
    eventManager.addEventListener(rootElement, "click", (event2) => onClick(event2, instance));
    eventManager.addEventListener(rootElement, "mouseup", (event2) => onMouseUp(event2, instance));
    eventManager.addEventListener(rootElement, "change", (event2) => onChange(event2, instance));
    isCheckboxListenerAdded.set(instance, eventManager);
  }
  return eventManager;
}
function createInput(rootDocument) {
  const input = rootDocument.createElement("input");
  input.className = "htCheckboxRendererInput";
  input.type = "checkbox";
  input.setAttribute("autocomplete", "off");
  input.setAttribute("tabindex", "-1");
  return input.cloneNode(false);
}
function createLabel(rootDocument, text2, fullWidth) {
  const label = rootDocument.createElement("label");
  label.className = `htCheckboxRendererLabel ${fullWidth ? "fullWidth" : ""}`;
  label.appendChild(rootDocument.createTextNode(text2));
  return label.cloneNode(true);
}
function onMouseUp(event2, instance) {
  const {
    target
  } = event2;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  setTimeout(instance.listen, 10);
}
function onClick(event2, instance) {
  const {
    target
  } = event2;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  const row = parseInt(target.getAttribute(ATTR_ROW), 10);
  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);
  const cellProperties = instance.getCellMeta(row, col);
  if (cellProperties.readOnly) {
    event2.preventDefault();
  }
}
function onChange(event2, instance) {
  const {
    target
  } = event2;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  const row = parseInt(target.getAttribute(ATTR_ROW), 10);
  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);
  const cellProperties = instance.getCellMeta(row, col);
  if (!cellProperties.readOnly) {
    let newCheckboxValue = null;
    if (event2.target.checked) {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? true : cellProperties.checkedTemplate;
    } else {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? false : cellProperties.uncheckedTemplate;
    }
    instance.setDataAtCell(row, col, newCheckboxValue);
  }
}
function isCheckboxInput(element) {
  return element.tagName === "INPUT" && element.getAttribute("type") === "checkbox";
}

// node_modules/handsontable/renderers/numericRenderer/numericRenderer.mjs
var import_numbro = __toESM(require_numbro_min(), 1);
var RENDERER_TYPE6 = "numeric";
function numericRenderer(instance, TD, row, col, prop, value, cellProperties) {
  let newValue = value;
  if (isNumeric(newValue)) {
    const numericFormat = cellProperties.numericFormat;
    const cellCulture = numericFormat && numericFormat.culture || "-";
    const cellFormatPattern = numericFormat && numericFormat.pattern;
    const className = cellProperties.className || "";
    const classArr = className.length ? className.split(" ") : [];
    if (typeof cellCulture !== "undefined" && !import_numbro.default.languages()[cellCulture]) {
      const shortTag = cellCulture.replace("-", "");
      const langData = import_numbro.default.allLanguages ? import_numbro.default.allLanguages[cellCulture] : import_numbro.default[shortTag];
      if (langData) {
        import_numbro.default.registerLanguage(langData);
      }
    }
    import_numbro.default.setLanguage(cellCulture);
    newValue = (0, import_numbro.default)(newValue).format(cellFormatPattern || "0");
    if (classArr.indexOf("htLeft") < 0 && classArr.indexOf("htCenter") < 0 && classArr.indexOf("htRight") < 0 && classArr.indexOf("htJustify") < 0) {
      classArr.push("htRight");
    }
    if (classArr.indexOf("htNumeric") < 0) {
      classArr.push("htNumeric");
    }
    cellProperties.className = classArr.join(" ");
    TD.dir = "ltr";
  }
  textRenderer(instance, TD, row, col, prop, newValue, cellProperties);
}
numericRenderer.RENDERER_TYPE = RENDERER_TYPE6;

// node_modules/handsontable/renderers/passwordRenderer/passwordRenderer.mjs
var RENDERER_TYPE7 = "password";
function passwordRenderer(instance, TD, row, col, prop, value, cellProperties) {
  textRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  const hashLength = cellProperties.hashLength || TD.innerHTML.length;
  const hashSymbol = cellProperties.hashSymbol || "*";
  let hash = "";
  rangeEach(hashLength - 1, () => {
    hash += hashSymbol;
  });
  fastInnerHTML(TD, hash);
}
passwordRenderer.RENDERER_TYPE = RENDERER_TYPE7;

// node_modules/handsontable/renderers/timeRenderer/timeRenderer.mjs
var RENDERER_TYPE8 = "time";
function timeRenderer(instance, TD, row, col, prop, value, cellProperties) {
  textRenderer.apply(this, [instance, TD, row, col, prop, value, cellProperties]);
  TD.dir = "ltr";
}
timeRenderer.RENDERER_TYPE = RENDERER_TYPE8;

// node_modules/handsontable/renderers/index.mjs
function registerAllRenderers() {
  _register2(autocompleteRenderer);
  _register2(baseRenderer);
  _register2(checkboxRenderer);
  _register2(htmlRenderer);
  _register2(numericRenderer);
  _register2(passwordRenderer);
  _register2(textRenderer);
  _register2(timeRenderer);
}

// node_modules/handsontable/validators/autocompleteValidator/autocompleteValidator.mjs
var VALIDATOR_TYPE = "autocomplete";
function autocompleteValidator(value, callback) {
  let valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
    return;
  }
  if (this.strict && this.source) {
    if (typeof this.source === "function") {
      this.source(valueToValidate, process(valueToValidate, callback));
    } else {
      process(valueToValidate, callback)(this.source);
    }
  } else {
    callback(true);
  }
}
autocompleteValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;
function process(value, callback) {
  const originalVal = value;
  return function(source) {
    let found = false;
    for (let s = 0, slen = source.length; s < slen; s++) {
      if (originalVal === source[s]) {
        found = true;
        break;
      }
    }
    callback(found);
  };
}

// node_modules/handsontable/validators/dateValidator/dateValidator.mjs
init_moment();

// node_modules/handsontable/helpers/date.mjs
var date_exports = {};
__export(date_exports, {
  getNormalizedDate: () => getNormalizedDate
});
function getNormalizedDate(dateString) {
  const nativeDate = new Date(dateString);
  if (!isNaN((/* @__PURE__ */ new Date(`${dateString}T00:00`)).getDate())) {
    return new Date(nativeDate.getTime() + nativeDate.getTimezoneOffset() * 6e4);
  }
  return nativeDate;
}

// node_modules/handsontable/validators/dateValidator/dateValidator.mjs
var VALIDATOR_TYPE2 = "date";
function dateValidator(value, callback) {
  const dateEditor = _getEditorInstance(EDITOR_TYPE6, this.instance);
  let valueToValidate = value;
  let valid = true;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  let isValidFormat = moment_default(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();
  let isValidDate = moment_default(new Date(valueToValidate)).isValid() || isValidFormat;
  if (this.allowEmpty && valueToValidate === "") {
    isValidDate = true;
    isValidFormat = true;
  }
  if (!isValidDate) {
    valid = false;
  }
  if (!isValidDate && isValidFormat) {
    valid = true;
  }
  if (isValidDate && !isValidFormat) {
    if (this.correctFormat === true) {
      const correctedValue = correctFormat(valueToValidate, this.dateFormat);
      const row = this.instance.toVisualRow(this.row);
      const column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "dateValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
dateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE2;
function correctFormat(value, dateFormat) {
  const dateFromDate = moment_default(getNormalizedDate(value));
  const dateFromMoment = moment_default(value, dateFormat);
  const isAlphanumeric = value.search(/[A-z]/g) > -1;
  let date;
  if (dateFromDate.isValid() && dateFromDate.format("x") === dateFromMoment.format("x") || !dateFromMoment.isValid() || isAlphanumeric) {
    date = dateFromDate;
  } else {
    date = dateFromMoment;
  }
  return date.format(dateFormat);
}

// node_modules/handsontable/validators/numericValidator/numericValidator.mjs
var VALIDATOR_TYPE3 = "numeric";
function numericValidator(value, callback) {
  let valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
  } else if (valueToValidate === "") {
    callback(false);
  } else {
    callback(isNumeric(value));
  }
}
numericValidator.VALIDATOR_TYPE = VALIDATOR_TYPE3;

// node_modules/handsontable/validators/timeValidator/timeValidator.mjs
init_moment();
var STRICT_FORMATS = [
  "YYYY-MM-DDTHH:mm:ss.SSSZ",
  "X",
  // Unix timestamp
  "x"
  // Unix ms timestamp
];
var VALIDATOR_TYPE4 = "time";
function timeValidator(value, callback) {
  const timeFormat = this.timeFormat || "h:mm:ss a";
  let valid = true;
  let valueToValidate = value;
  if (valueToValidate === null) {
    valueToValidate = "";
  }
  valueToValidate = /^\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;
  const twoDigitValue = /^\d{1,2}$/.test(valueToValidate);
  if (twoDigitValue) {
    valueToValidate += ":00";
  }
  const date = moment_default(valueToValidate, STRICT_FORMATS, true).isValid() ? moment_default(valueToValidate) : moment_default(valueToValidate, timeFormat);
  let isValidTime = date.isValid();
  let isValidFormat = moment_default(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;
  if (this.allowEmpty && valueToValidate === "") {
    isValidTime = true;
    isValidFormat = true;
  }
  if (!isValidTime) {
    valid = false;
  }
  if (!isValidTime && isValidFormat) {
    valid = true;
  }
  if (isValidTime && !isValidFormat) {
    if (this.correctFormat === true) {
      const correctedValue = date.format(timeFormat);
      const row = this.instance.toVisualRow(this.row);
      const column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "timeValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
timeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE4;

// node_modules/handsontable/validators/index.mjs
function registerAllValidators() {
  _register3(autocompleteValidator);
  _register3(dateValidator);
  _register3(numericValidator);
  _register3(timeValidator);
}

// node_modules/handsontable/cellTypes/autocompleteType/autocompleteType.mjs
var CELL_TYPE3 = "autocomplete";
var AutocompleteCellType = {
  CELL_TYPE: CELL_TYPE3,
  editor: AutocompleteEditor,
  renderer: autocompleteRenderer,
  validator: autocompleteValidator
};

// node_modules/handsontable/cellTypes/checkboxType/checkboxType.mjs
var CELL_TYPE4 = "checkbox";
var CheckboxCellType = {
  CELL_TYPE: CELL_TYPE4,
  editor: CheckboxEditor,
  renderer: checkboxRenderer
};

// node_modules/handsontable/cellTypes/dateType/dateType.mjs
var CELL_TYPE5 = "date";
var DateCellType = {
  CELL_TYPE: CELL_TYPE5,
  editor: DateEditor,
  // displays small gray arrow on right side of the cell
  renderer: autocompleteRenderer,
  validator: dateValidator
};

// node_modules/handsontable/cellTypes/dropdownType/dropdownType.mjs
var CELL_TYPE6 = "dropdown";
var DropdownCellType = {
  CELL_TYPE: CELL_TYPE6,
  editor: DropdownEditor,
  // displays small gray arrow on right side of the cell
  renderer: autocompleteRenderer,
  validator: autocompleteValidator
};

// node_modules/handsontable/cellTypes/handsontableType/handsontableType.mjs
var CELL_TYPE7 = "handsontable";
var HandsontableCellType = {
  CELL_TYPE: CELL_TYPE7,
  editor: HandsontableEditor,
  // displays small gray arrow on right side of the cell
  renderer: autocompleteRenderer
};

// node_modules/handsontable/cellTypes/numericType/numericType.mjs
var CELL_TYPE8 = "numeric";
var NumericCellType = {
  CELL_TYPE: CELL_TYPE8,
  editor: NumericEditor,
  renderer: numericRenderer,
  validator: numericValidator,
  dataType: "number"
};

// node_modules/handsontable/cellTypes/passwordType/passwordType.mjs
var CELL_TYPE9 = "password";
var PasswordCellType = {
  CELL_TYPE: CELL_TYPE9,
  editor: PasswordEditor,
  renderer: passwordRenderer,
  copyable: false
};

// node_modules/handsontable/cellTypes/timeType/timeType.mjs
var CELL_TYPE10 = "time";
var TimeCellType = {
  CELL_TYPE: CELL_TYPE10,
  editor: TimeEditor,
  renderer: timeRenderer,
  validator: timeValidator
};

// node_modules/handsontable/cellTypes/index.mjs
function registerAllCellTypes() {
  _register4(AutocompleteCellType);
  _register4(CheckboxCellType);
  _register4(DateCellType);
  _register4(DropdownCellType);
  _register4(HandsontableCellType);
  _register4(NumericCellType);
  _register4(PasswordCellType);
  _register4(TextCellType);
  _register4(TimeCellType);
}

// node_modules/handsontable/plugins/base/base.mjs
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration6(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration6(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var DEPS_TYPE_CHECKERS = /* @__PURE__ */ new Map([["plugin", hasPlugin], ["cell-type", hasItem4], ["editor", hasItem], ["renderer", hasItem2], ["validator", hasItem3]]);
var PLUGIN_KEY = "base";
var privatePool6 = /* @__PURE__ */ new WeakMap();
var missingDependeciesMsgs = [];
var initializedPlugins = null;
var _isRelevantToSettings = /* @__PURE__ */ new WeakSet();
var BasePlugin = class {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY;
  }
  /**
   * The `SETTING_KEYS` getter defines the keys that, when present in the config object, trigger the plugin update
   * after the `updateSettings` calls.
   * - When it returns `true`, the plugin updates after all `updateSettings` calls, regardless of the contents of the
   * config object.
   * - When it returns `false`, the plugin never updates on `updateSettings` calls.
   *
   * @returns {string[] | boolean}
   */
  static get SETTING_KEYS() {
    return [this.PLUGIN_KEY];
  }
  /**
   * @param {object} hotInstance Handsontable instance.
   */
  constructor(hotInstance) {
    _classPrivateMethodInitSpec(this, _isRelevantToSettings);
    defineGetter(this, "hot", hotInstance, {
      writable: false
    });
    privatePool6.set(this, {
      hooks: {}
    });
    initializedPlugins = null;
    this.pluginName = null;
    this.pluginsInitializedCallbacks = [];
    this.isPluginsReady = false;
    this.enabled = false;
    this.initialized = false;
    this.hot.addHook("afterPluginsInitialized", () => this.onAfterPluginsInitialized());
    this.hot.addHook("afterUpdateSettings", (newSettings) => this.onUpdateSettings(newSettings));
    this.hot.addHook("beforeInit", () => this.init());
  }
  init() {
    this.pluginName = this.hot.getPluginName(this);
    const pluginDeps = this.constructor.PLUGIN_DEPS;
    const dependecies = Array.isArray(pluginDeps) ? pluginDeps : [];
    if (dependecies.length > 0) {
      const missingDependencies = [];
      dependecies.forEach((dependency) => {
        const [type, moduleName] = dependency.split(":");
        if (!DEPS_TYPE_CHECKERS.has(type)) {
          throw new Error(`Unknown plugin dependency type "${type}" was found.`);
        }
        if (!DEPS_TYPE_CHECKERS.get(type)(moduleName)) {
          missingDependencies.push(` - ${moduleName} (${type})`);
        }
      });
      if (missingDependencies.length > 0) {
        const errorMsg = [`The ${this.pluginName} plugin requires the following modules:
`, `${missingDependencies.join("\n")}
`].join("");
        missingDependeciesMsgs.push(errorMsg);
      }
    }
    if (!initializedPlugins) {
      initializedPlugins = getPluginsNames();
    }
    if (initializedPlugins.indexOf("UndoRedo") >= 0) {
      initializedPlugins.splice(initializedPlugins.indexOf("UndoRedo"), 1);
    }
    if (initializedPlugins.indexOf(this.pluginName) >= 0) {
      initializedPlugins.splice(initializedPlugins.indexOf(this.pluginName), 1);
    }
    this.hot.addHookOnce("afterPluginsInitialized", () => {
      if (this.isEnabled && this.isEnabled()) {
        this.enablePlugin();
      }
    });
    const isAllPluginsAreInitialized = initializedPlugins.length === 0;
    if (isAllPluginsAreInitialized) {
      if (missingDependeciesMsgs.length > 0) {
        const errorMsg = [`${missingDependeciesMsgs.join("\n")}
`, "You have to import and register them manually."].join("");
        throw new Error(errorMsg);
      }
      this.hot.runHooks("afterPluginsInitialized");
    }
    this.initialized = true;
  }
  /**
   * Enable plugin for this Handsontable instance.
   */
  enablePlugin() {
    this.enabled = true;
  }
  /**
   * Disable plugin for this Handsontable instance.
   */
  disablePlugin() {
    if (this.eventManager) {
      this.eventManager.clear();
    }
    this.clearHooks();
    this.enabled = false;
  }
  /**
   * Add listener to plugin hooks system.
   *
   * @param {string} name The hook name.
   * @param {Function} callback The listener function to add.
   */
  addHook(name, callback) {
    privatePool6.get(this).hooks[name] = privatePool6.get(this).hooks[name] || [];
    const hooks2 = privatePool6.get(this).hooks[name];
    this.hot.addHook(name, callback);
    hooks2.push(callback);
    privatePool6.get(this).hooks[name] = hooks2;
  }
  /**
   * Remove all hooks listeners by hook name.
   *
   * @param {string} name The hook name.
   */
  removeHooks(name) {
    arrayEach(privatePool6.get(this).hooks[name] || [], (callback) => {
      this.hot.removeHook(name, callback);
    });
  }
  /**
   * Clear all hooks.
   */
  clearHooks() {
    const hooks2 = privatePool6.get(this).hooks;
    objectEach(hooks2, (callbacks, name) => this.removeHooks(name));
    hooks2.length = 0;
  }
  /**
   * Register function which will be immediately called after all plugins initialized.
   *
   * @param {Function} callback The listener function to call.
   */
  callOnPluginsReady(callback) {
    if (this.isPluginsReady) {
      callback();
    } else {
      this.pluginsInitializedCallbacks.push(callback);
    }
  }
  /**
   * On after plugins initialized listener.
   *
   * @private
   */
  onAfterPluginsInitialized() {
    arrayEach(this.pluginsInitializedCallbacks, (callback) => callback());
    this.pluginsInitializedCallbacks.length = 0;
    this.isPluginsReady = true;
  }
  /**
   * On update settings listener.
   *
   * @private
   * @param {object} newSettings New set of settings passed to the `updateSettings` method.
   */
  onUpdateSettings(newSettings) {
    const relevantToSettings = _classPrivateMethodGet(this, _isRelevantToSettings, _isRelevantToSettings2).call(this, newSettings);
    if (this.isEnabled) {
      if (this.enabled && !this.isEnabled()) {
        this.disablePlugin();
      }
      if (!this.enabled && this.isEnabled()) {
        this.enablePlugin();
      }
      if (this.enabled && this.isEnabled() && relevantToSettings) {
        this.updatePlugin(newSettings);
      }
    }
  }
  /**
   * Updates the plugin to use the latest options you have specified.
   *
   * @private
   */
  updatePlugin() {
  }
  /**
   * Destroy plugin.
   */
  destroy() {
    if (this.eventManager) {
      this.eventManager.destroy();
    }
    this.clearHooks();
    objectEach(this, (value, property) => {
      if (property !== "hot") {
        this[property] = null;
      }
    });
    delete this.t;
    delete this.hot;
  }
};
function _isRelevantToSettings2(settings) {
  if (!settings) {
    return false;
  }
  const settingKeys = this.constructor.SETTING_KEYS;
  if (typeof settingKeys === "boolean") {
    return settingKeys;
  }
  for (let i = 0; i < settingKeys.length; i++) {
    if (settings[settingKeys[i]] !== void 0) {
      return true;
    }
  }
  return false;
}

// node_modules/handsontable/utils/ghostTable.mjs
var GhostTable = class {
  constructor(hotInstance) {
    this.hot = hotInstance;
    this.container = null;
    this.injected = false;
    this.rows = [];
    this.columns = [];
    this.samples = null;
    this.settings = {
      useHeaders: true
    };
  }
  /**
   * Add row.
   *
   * @param {number} row Row index.
   * @param {Map} samples Samples Map object.
   */
  addRow(row, samples) {
    if (this.columns.length) {
      throw new Error("Doesn't support multi-dimensional table");
    }
    if (!this.rows.length) {
      this.container = this.createContainer(this.hot.rootElement.className);
    }
    const rowObject = {
      row
    };
    this.rows.push(rowObject);
    this.samples = samples;
    this.table = this.createTable(this.hot.table.className);
    this.table.colGroup.appendChild(this.createColGroupsCol());
    this.table.tr.appendChild(this.createRow(row));
    this.container.container.appendChild(this.table.fragment);
    rowObject.table = this.table.table;
  }
  /**
   * Add a row consisting of the column headers.
   *
   * @param {Map} samples A map with sampled table values.
   */
  addColumnHeadersRow(samples) {
    const colHeader = this.hot.getColHeader(0);
    if (colHeader !== null && colHeader !== void 0) {
      const rowObject = {
        row: -1
      };
      this.rows.push(rowObject);
      this.container = this.createContainer(this.hot.rootElement.className);
      this.samples = samples;
      this.table = this.createTable(this.hot.table.className);
      this.table.colGroup.appendChild(this.createColGroupsCol());
      this.appendColumnHeadersRow();
      this.container.container.appendChild(this.table.fragment);
      rowObject.table = this.table.table;
    }
  }
  /**
   * Add column.
   *
   * @param {number} column Column index.
   * @param {Map} samples A map with sampled table values.
   */
  addColumn(column, samples) {
    if (this.rows.length) {
      throw new Error("Doesn't support multi-dimensional table");
    }
    if (!this.columns.length) {
      this.container = this.createContainer(this.hot.rootElement.className);
    }
    const columnObject = {
      col: column
    };
    this.columns.push(columnObject);
    this.samples = samples;
    this.table = this.createTable(this.hot.table.className);
    if (this.getSetting("useHeaders") && this.hot.getColHeader(column) !== null) {
      this.hot.view.appendColHeader(column, this.table.th);
    }
    this.table.tBody.appendChild(this.createCol(column));
    this.container.container.appendChild(this.table.fragment);
    columnObject.table = this.table.table;
  }
  /**
   * Get calculated heights.
   *
   * @param {Function} callback Callback which will be fired for each calculated row.
   */
  getHeights(callback) {
    if (!this.injected) {
      this.injectTable();
    }
    arrayEach(this.rows, (row) => {
      callback(row.row, outerHeight(row.table) - 1);
    });
  }
  /**
   * Get calculated widths.
   *
   * @param {Function} callback Callback which will be fired for each calculated column.
   */
  getWidths(callback) {
    if (!this.injected) {
      this.injectTable();
    }
    arrayEach(this.columns, (column) => {
      const {
        width
      } = column.table.getBoundingClientRect();
      callback(column.col, Math.ceil(width));
    });
  }
  /**
   * Set the Ghost Table settings to the provided object.
   *
   * @param {object} settings New Ghost Table Settings.
   */
  setSettings(settings) {
    this.settings = settings;
  }
  /**
   * Set a single setting of the Ghost Table.
   *
   * @param {string} name Setting name.
   * @param {*} value Setting value.
   */
  setSetting(name, value) {
    if (!this.settings) {
      this.settings = {};
    }
    this.settings[name] = value;
  }
  /**
   * Get the Ghost Table settings.
   *
   * @returns {object|null}
   */
  getSettings() {
    return this.settings;
  }
  /**
   * Get a single Ghost Table setting.
   *
   * @param {string} name The setting name to get.
   * @returns {boolean|null}
   */
  getSetting(name) {
    if (this.settings) {
      return this.settings[name];
    }
    return null;
  }
  /**
   * Create colgroup col elements.
   *
   * @returns {DocumentFragment}
   */
  createColGroupsCol() {
    const fragment = this.hot.rootDocument.createDocumentFragment();
    if (this.hot.hasRowHeaders()) {
      fragment.appendChild(this.createColElement(-1));
    }
    this.samples.forEach((sample) => {
      arrayEach(sample.strings, (string) => {
        fragment.appendChild(this.createColElement(string.col));
      });
    });
    return fragment;
  }
  /**
   * Create table row element.
   *
   * @param {number} row Row index.
   * @returns {DocumentFragment} Returns created table row elements.
   */
  createRow(row) {
    const {
      rootDocument
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    const th = rootDocument.createElement("th");
    if (this.hot.hasRowHeaders()) {
      this.hot.view.appendRowHeader(row, th);
      fragment.appendChild(th);
    }
    this.samples.forEach((sample) => {
      arrayEach(sample.strings, (string) => {
        const column = string.col;
        const cellProperties = this.hot.getCellMeta(row, column);
        cellProperties.col = column;
        cellProperties.row = row;
        const renderer = this.hot.getCellRenderer(cellProperties);
        const td = rootDocument.createElement("td");
        td.setAttribute("ghost-table", 1);
        renderer(this.hot, td, row, column, this.hot.colToProp(column), string.value, cellProperties);
        fragment.appendChild(td);
      });
    });
    return fragment;
  }
  /**
   * Creates DOM elements for headers and appends them to the THEAD element of the table.
   */
  appendColumnHeadersRow() {
    const {
      rootDocument
    } = this.hot;
    const domFragment = rootDocument.createDocumentFragment();
    const columnHeaders = [];
    if (this.hot.hasRowHeaders()) {
      const th = rootDocument.createElement("th");
      columnHeaders.push([-1, th]);
      domFragment.appendChild(th);
    }
    this.samples.forEach((sample) => {
      arrayEach(sample.strings, (string) => {
        const column = string.col;
        const th = rootDocument.createElement("th");
        columnHeaders.push([column, th]);
        domFragment.appendChild(th);
      });
    });
    this.table.tHead.appendChild(domFragment);
    arrayEach(columnHeaders, (columnHeader) => {
      const [column, th] = columnHeader;
      this.hot.view.appendColHeader(column, th);
    });
  }
  /**
   * Create table column elements.
   *
   * @param {number} column Column index.
   * @returns {DocumentFragment} Returns created column table column elements.
   */
  createCol(column) {
    const {
      rootDocument
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    this.samples.forEach((sample) => {
      arrayEach(sample.strings, (string) => {
        const row = string.row;
        const cellProperties = this.hot.getCellMeta(row, column);
        cellProperties.col = column;
        cellProperties.row = row;
        const renderer = this.hot.getCellRenderer(cellProperties);
        const td = rootDocument.createElement("td");
        const tr = rootDocument.createElement("tr");
        td.setAttribute("ghost-table", 1);
        renderer(this.hot, td, row, column, this.hot.colToProp(column), string.value, cellProperties);
        tr.appendChild(td);
        fragment.appendChild(tr);
      });
    });
    return fragment;
  }
  /**
   * Remove table from document and reset internal state.
   */
  clean() {
    this.rows.length = 0;
    this.rows[-1] = void 0;
    this.columns.length = 0;
    if (this.samples) {
      this.samples.clear();
    }
    this.samples = null;
    this.removeTable();
  }
  /**
   * Inject generated table into document.
   *
   * @param {HTMLElement} [parent=null] The element to which the ghost table is injected.
   */
  injectTable() {
    let parent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (!this.injected) {
      (parent || this.hot.rootElement).appendChild(this.container.fragment);
      this.injected = true;
    }
  }
  /**
   * Remove table from document.
   */
  removeTable() {
    if (this.injected && this.container.container.parentNode) {
      this.container.container.parentNode.removeChild(this.container.container);
      this.container = null;
      this.injected = false;
    }
  }
  /**
   * Create col element.
   *
   * @param {number} column Column index.
   * @returns {HTMLElement}
   */
  createColElement(column) {
    const col = this.hot.rootDocument.createElement("col");
    col.style.width = `${this.hot.view._wt.wtTable.getStretchedColumnWidth(column)}px`;
    return col;
  }
  /**
   * Create table element.
   *
   * @param {string} className The CSS classes to add.
   * @returns {object}
   */
  createTable() {
    let className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const {
      rootDocument
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    const table = rootDocument.createElement("table");
    const tHead = rootDocument.createElement("thead");
    const tBody = rootDocument.createElement("tbody");
    const colGroup = rootDocument.createElement("colgroup");
    const tr = rootDocument.createElement("tr");
    const th = rootDocument.createElement("th");
    if (this.isVertical()) {
      table.appendChild(colGroup);
    }
    if (this.isHorizontal()) {
      tr.appendChild(th);
      tHead.appendChild(tr);
      table.style.tableLayout = "auto";
      table.style.width = "auto";
    }
    table.appendChild(tHead);
    if (this.isVertical()) {
      tBody.appendChild(tr);
    }
    table.appendChild(tBody);
    addClass(table, className);
    fragment.appendChild(table);
    return {
      fragment,
      table,
      tHead,
      tBody,
      colGroup,
      tr,
      th
    };
  }
  /**
   * Create container for tables.
   *
   * @param {string} className The CSS classes to add.
   * @returns {object}
   */
  createContainer() {
    let className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const {
      rootDocument
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    const container = rootDocument.createElement("div");
    const containerClassName = `htGhostTable htAutoSize ${className.trim()}`;
    addClass(container, containerClassName);
    fragment.appendChild(container);
    return {
      fragment,
      container
    };
  }
  /**
   * Checks if table is raised vertically (checking rows).
   *
   * @returns {boolean}
   */
  isVertical() {
    return !!(this.rows.length && !this.columns.length);
  }
  /**
   * Checks if table is raised horizontally (checking columns).
   *
   * @returns {boolean}
   */
  isHorizontal() {
    return !!(this.columns.length && !this.rows.length);
  }
};
var ghostTable_default = GhostTable;

// node_modules/handsontable/utils/samplesGenerator.mjs
var SamplesGenerator = class _SamplesGenerator {
  /**
   * Number of samples to take of each value length.
   *
   * @type {number}
   */
  static get SAMPLE_COUNT() {
    return 3;
  }
  constructor(dataFactory) {
    this.samples = null;
    this.dataFactory = dataFactory;
    this.customSampleCount = null;
    this.allowDuplicates = false;
  }
  /**
   * Get the sample count for this instance.
   *
   * @returns {number}
   */
  getSampleCount() {
    if (this.customSampleCount) {
      return this.customSampleCount;
    }
    return _SamplesGenerator.SAMPLE_COUNT;
  }
  /**
   * Set the sample count.
   *
   * @param {number} sampleCount Number of samples to be collected.
   */
  setSampleCount(sampleCount) {
    this.customSampleCount = sampleCount;
  }
  /**
   * Set if the generator should accept duplicate values.
   *
   * @param {boolean} allowDuplicates `true` to allow duplicate values.
   */
  setAllowDuplicates(allowDuplicates) {
    this.allowDuplicates = allowDuplicates;
  }
  /**
   * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.
   *
   * @param {object|number} rowRange The rows range to generate the samples.
   * @param {object} colRange The column range to generate the samples.
   * @returns {object}
   */
  generateRowSamples(rowRange, colRange) {
    return this.generateSamples("row", colRange, rowRange);
  }
  /**
   * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.
   *
   * @param {object} colRange Column index.
   * @param {object} rowRange Column index.
   * @returns {object}
   */
  generateColumnSamples(colRange, rowRange) {
    return this.generateSamples("col", rowRange, colRange);
  }
  /**
   * Generate collection of samples.
   *
   * @param {string} type Type to generate. Can be `col` or `row`.
   * @param {object} range The range to generate the samples.
   * @param {object|number} specifierRange The range to generate the samples.
   * @returns {Map}
   */
  generateSamples(type, range, specifierRange) {
    const samples = /* @__PURE__ */ new Map();
    const {
      from: from2,
      to: to2
    } = typeof specifierRange === "number" ? {
      from: specifierRange,
      to: specifierRange
    } : specifierRange;
    rangeEach(from2, to2, (index2) => {
      const sample = this.generateSample(type, range, index2);
      samples.set(index2, sample);
    });
    return samples;
  }
  /**
   * Generate sample for specified type (`row` or `col`).
   *
   * @param {string} type Samples type `row` or `col`.
   * @param {object} range The range to generate the samples.
   * @param {number} specifierValue The range to generate the samples.
   * @returns {Map}
   */
  generateSample(type, range, specifierValue) {
    if (type !== "row" && type !== "col") {
      throw new Error("Unsupported sample type");
    }
    const samples = /* @__PURE__ */ new Map();
    const computedKey = type === "row" ? "col" : "row";
    const sampledValues = [];
    rangeEach(range.from, range.to, (index2) => {
      const {
        value,
        bundleSeed
      } = type === "row" ? this.dataFactory(specifierValue, index2) : this.dataFactory(index2, specifierValue);
      const hasCustomBundleSeed = typeof bundleSeed === "string" && bundleSeed.length > 0;
      let seed;
      if (hasCustomBundleSeed) {
        seed = bundleSeed;
      } else if (isObject2(value)) {
        seed = `${Object.keys(value).length}`;
      } else if (Array.isArray(value)) {
        seed = `${value.length}`;
      } else {
        seed = `${stringify(value).length}`;
      }
      if (!samples.has(seed)) {
        samples.set(seed, {
          needed: this.getSampleCount(),
          strings: []
        });
      }
      const sample = samples.get(seed);
      if (sample.needed) {
        const duplicate = sampledValues.indexOf(value) > -1;
        if (!duplicate || this.allowDuplicates || hasCustomBundleSeed) {
          sample.strings.push({
            value,
            [computedKey]: index2
          });
          sampledValues.push(value);
          sample.needed -= 1;
        }
      }
    });
    return samples;
  }
};
var samplesGenerator_default = SamplesGenerator;

// node_modules/handsontable/plugins/autoColumnSize/autoColumnSize.mjs
pluginHooks_default.getSingleton().register("modifyAutoColumnSizeSeed");
var PLUGIN_KEY2 = "autoColumnSize";
var PLUGIN_PRIORITY = 10;
var privatePool7 = /* @__PURE__ */ new WeakMap();
var COLUMN_SIZE_MAP_NAME = "autoColumnSize";
var AutoColumnSize = class _AutoColumnSize extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY2;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY;
  }
  static get SETTING_KEYS() {
    return true;
  }
  static get CALCULATION_STEP() {
    return 50;
  }
  static get SYNC_CALCULATION_LIMIT() {
    return 50;
  }
  constructor(hotInstance) {
    super(hotInstance);
    privatePool7.set(this, {
      /**
       * Cached column header names. It is used to diff current column headers with previous state and detect which
       * columns width should be updated.
       *
       * @private
       * @type {Array}
       */
      cachedColumnHeaders: []
    });
    this.ghostTable = new ghostTable_default(this.hot);
    this.samplesGenerator = new samplesGenerator_default((row, column) => {
      const cellMeta = this.hot.getCellMeta(row, column);
      let cellValue = "";
      if (!cellMeta.spanned) {
        cellValue = this.hot.getDataAtCell(row, column);
      }
      let bundleSeed = "";
      if (this.hot.hasHook("modifyAutoColumnSizeSeed")) {
        bundleSeed = this.hot.runHooks("modifyAutoColumnSizeSeed", bundleSeed, cellMeta, cellValue);
      }
      return {
        value: cellValue,
        bundleSeed
      };
    });
    this.firstCalculation = true;
    this.inProgress = false;
    this.measuredColumns = 0;
    this.columnWidthsMap = new PhysicalIndexToValueMap();
    this.hot.columnIndexMapper.registerMap(COLUMN_SIZE_MAP_NAME, this.columnWidthsMap);
    this.addHook("beforeColumnResize", (size, column, isDblClick) => this.onBeforeColumnResize(size, column, isDblClick));
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link #enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY2] !== false && !this.hot.getSettings().colWidths;
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const setting = this.hot.getSettings()[PLUGIN_KEY2];
    if (setting && setting.useHeaders !== null && setting.useHeaders !== void 0) {
      this.ghostTable.setSetting("useHeaders", setting.useHeaders);
    }
    this.setSamplingOptions();
    this.addHook("afterLoadData", function() {
      return _this.onAfterLoadData(...arguments);
    });
    this.addHook("beforeChangeRender", (changes) => this.onBeforeChange(changes));
    this.addHook("afterFormulasValuesUpdate", (changes) => this.onAfterFormulasValuesUpdate(changes));
    this.addHook("beforeViewRender", (force) => this.onBeforeViewRender(force));
    this.addHook("modifyColWidth", (width, col) => this.getColumnWidth(col, width));
    this.addHook("afterInit", () => this.onAfterInit());
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state. This method is executed when {@link Core#updateSettings} is invoked.
   */
  updatePlugin() {
    const changedColumns = this.findColumnsWhereHeaderWasChanged();
    if (changedColumns.length) {
      this.clearCache(changedColumns);
      this.calculateVisibleColumnsWidth();
    }
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    super.disablePlugin();
    this.addHook("beforeColumnResize", (size, column, isDblClick) => this.onBeforeColumnResize(size, column, isDblClick));
  }
  /**
   * Calculates visible columns width.
   */
  calculateVisibleColumnsWidth() {
    const rowsCount = this.hot.countRows();
    if (!rowsCount) {
      return;
    }
    const force = this.hot.renderCall;
    const firstVisibleColumn = this.getFirstVisibleColumn();
    const lastVisibleColumn = this.getLastVisibleColumn();
    if (firstVisibleColumn === -1 || lastVisibleColumn === -1) {
      return;
    }
    this.calculateColumnsWidth({
      from: firstVisibleColumn,
      to: lastVisibleColumn
    }, void 0, force);
  }
  /**
   * Calculates a columns width.
   *
   * @param {number|object} colRange Visual column index or an object with `from` and `to` visual indexes as a range.
   * @param {number|object} rowRange Visual row index or an object with `from` and `to` visual indexes as a range.
   * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.
   */
  calculateColumnsWidth() {
    let colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      from: 0,
      to: this.hot.countCols() - 1
    };
    let rowRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      from: 0,
      to: this.hot.countRows() - 1
    };
    let force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const columnsRange = typeof colRange === "number" ? {
      from: colRange,
      to: colRange
    } : colRange;
    const rowsRange = typeof rowRange === "number" ? {
      from: rowRange,
      to: rowRange
    } : rowRange;
    rangeEach(columnsRange.from, columnsRange.to, (visualColumn) => {
      let physicalColumn = this.hot.toPhysicalColumn(visualColumn);
      if (physicalColumn === null) {
        physicalColumn = visualColumn;
      }
      if (force || this.columnWidthsMap.getValueAtIndex(physicalColumn) === null && !this.hot._getColWidthFromSettings(physicalColumn)) {
        const samples = this.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);
        arrayEach(samples, (_ref2) => {
          let [column, sample] = _ref2;
          return this.ghostTable.addColumn(column, sample);
        });
      }
    });
    if (this.ghostTable.columns.length) {
      this.hot.batchExecution(() => {
        this.ghostTable.getWidths((visualColumn, width) => {
          const physicalColumn = this.hot.toPhysicalColumn(visualColumn);
          this.columnWidthsMap.setValueAtIndex(physicalColumn, width);
        });
      }, true);
      this.measuredColumns = columnsRange.to + 1;
      this.ghostTable.clean();
    }
  }
  /**
   * Calculates all columns width. The calculated column will be cached in the {@link AutoColumnSize#widths} property.
   * To retrieve width for specified column use {@link AutoColumnSize#getColumnWidth} method.
   *
   * @param {object|number} rowRange Row index or an object with `from` and `to` properties which define row range.
   */
  calculateAllColumnsWidth() {
    let rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      from: 0,
      to: this.hot.countRows() - 1
    };
    let current = 0;
    const length = this.hot.countCols() - 1;
    let timer = null;
    this.inProgress = true;
    const loop = () => {
      if (!this.hot) {
        cancelAnimationFrame(timer);
        this.inProgress = false;
        return;
      }
      this.calculateColumnsWidth({
        from: current,
        to: Math.min(current + _AutoColumnSize.CALCULATION_STEP, length)
      }, rowRange);
      current = current + _AutoColumnSize.CALCULATION_STEP + 1;
      if (current < length) {
        timer = requestAnimationFrame(loop);
      } else {
        cancelAnimationFrame(timer);
        this.inProgress = false;
        this.hot.view.adjustElementsSize();
      }
    };
    const syncLimit = this.getSyncCalculationLimit();
    if (this.firstCalculation && syncLimit >= 0) {
      this.calculateColumnsWidth({
        from: 0,
        to: syncLimit
      }, rowRange);
      this.firstCalculation = false;
      current = syncLimit + 1;
    }
    if (current < length) {
      loop();
    } else {
      this.inProgress = false;
    }
  }
  /**
   * Sets the sampling options.
   *
   * @private
   */
  setSamplingOptions() {
    const setting = this.hot.getSettings()[PLUGIN_KEY2];
    const samplingRatio = setting && hasOwnProperty2(setting, "samplingRatio") ? setting.samplingRatio : void 0;
    const allowSampleDuplicates = setting && hasOwnProperty2(setting, "allowSampleDuplicates") ? setting.allowSampleDuplicates : void 0;
    if (samplingRatio && !isNaN(samplingRatio)) {
      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
    }
    if (allowSampleDuplicates) {
      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
    }
  }
  /**
   * Recalculates all columns width (overwrite cache values).
   */
  recalculateAllColumnsWidth() {
    if (this.hot.view && this.hot.view._wt.wtTable.isVisible()) {
      this.clearCache();
      this.calculateAllColumnsWidth();
    }
  }
  /**
   * Gets value which tells how many columns should be calculated synchronously (rest of the columns will be calculated
   * asynchronously). The limit is calculated based on `syncLimit` set to `autoColumnSize` option (see {@link Options#autoColumnSize}).
   *
   * @returns {number}
   */
  getSyncCalculationLimit() {
    const settings = this.hot.getSettings()[PLUGIN_KEY2];
    let limit = _AutoColumnSize.SYNC_CALCULATION_LIMIT;
    const colsLimit = this.hot.countCols() - 1;
    if (isObject2(settings)) {
      limit = settings.syncLimit;
      if (isPercentValue(limit)) {
        limit = valueAccordingPercent(colsLimit, limit);
      } else {
        limit >>= 0;
      }
    }
    return Math.min(limit, colsLimit);
  }
  /**
   * Gets the calculated column width.
   *
   * @param {number} column Visual column index.
   * @param {number} [defaultWidth] Default column width. It will be picked up if no calculated width found.
   * @param {boolean} [keepMinimum=true] If `true` then returned value won't be smaller then 50 (default column width).
   * @returns {number}
   */
  getColumnWidth(column) {
    let defaultWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    let keepMinimum = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    let width = defaultWidth;
    if (width === void 0) {
      width = this.columnWidthsMap.getValueAtIndex(this.hot.toPhysicalColumn(column));
      if (keepMinimum && typeof width === "number") {
        width = Math.max(width, viewportColumns_default.DEFAULT_WIDTH);
      }
    }
    return width;
  }
  /**
   * Gets the first visible column.
   *
   * @returns {number} Returns visual column index, -1 if table is not rendered or if there are no columns to base the the calculations on.
   */
  getFirstVisibleColumn() {
    const wot = this.hot.view._wt;
    if (wot.wtViewport.columnsVisibleCalculator) {
      const firstFullyVisibleColumn = wot.wtTable.getFirstVisibleColumn();
      if (firstFullyVisibleColumn !== -1) {
        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstFullyVisibleColumn);
      }
    }
    if (wot.wtViewport.columnsRenderCalculator) {
      const firstRenderedColumn = wot.wtTable.getFirstRenderedColumn();
      if (firstRenderedColumn !== -1) {
        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstRenderedColumn);
      }
    }
    return -1;
  }
  /**
   * Gets the last visible column.
   *
   * @returns {number} Returns visual column index or -1 if table is not rendered.
   */
  getLastVisibleColumn() {
    const wot = this.hot.view._wt;
    if (wot.wtViewport.columnsVisibleCalculator) {
      const lastFullyVisibleColumn = wot.wtTable.getLastVisibleColumn();
      if (lastFullyVisibleColumn !== -1) {
        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastFullyVisibleColumn);
      }
    }
    if (wot.wtViewport.columnsRenderCalculator) {
      const lastRenderedColumn = wot.wtTable.getLastRenderedColumn();
      if (lastRenderedColumn !== -1) {
        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastRenderedColumn);
      }
    }
    return -1;
  }
  /**
   * Collects all columns which titles has been changed in comparison to the previous state.
   *
   * @private
   * @returns {Array} It returns an array of physical column indexes.
   */
  findColumnsWhereHeaderWasChanged() {
    const columnHeaders = this.hot.getColHeader();
    const {
      cachedColumnHeaders
    } = privatePool7.get(this);
    const changedColumns = arrayReduce(columnHeaders, (acc, columnTitle, physicalColumn) => {
      const cachedColumnsLength = cachedColumnHeaders.length;
      if (cachedColumnsLength - 1 < physicalColumn || cachedColumnHeaders[physicalColumn] !== columnTitle) {
        acc.push(physicalColumn);
      }
      if (cachedColumnsLength - 1 < physicalColumn) {
        cachedColumnHeaders.push(columnTitle);
      } else {
        cachedColumnHeaders[physicalColumn] = columnTitle;
      }
      return acc;
    }, []);
    return changedColumns;
  }
  /**
   * Clears cache of calculated column widths. If you want to clear only selected columns pass an array with their indexes.
   * Otherwise whole cache will be cleared.
   *
   * @param {number[]} [columns] List of physical column indexes to clear.
   */
  clearCache() {
    let columns = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (columns.length) {
      this.hot.batchExecution(() => {
        arrayEach(columns, (physicalIndex) => {
          this.columnWidthsMap.setValueAtIndex(physicalIndex, null);
        });
      }, true);
    } else {
      this.columnWidthsMap.clear();
    }
  }
  /**
   * Checks if all widths were calculated. If not then return `true` (need recalculate).
   *
   * @returns {boolean}
   */
  isNeedRecalculate() {
    return !!arrayFilter(this.columnWidthsMap.getValues().slice(0, this.measuredColumns), (item) => item === null).length;
  }
  /**
   * On before view render listener.
   *
   * @private
   */
  onBeforeViewRender() {
    this.calculateVisibleColumnsWidth();
    if (this.isNeedRecalculate() && !this.inProgress) {
      this.calculateAllColumnsWidth();
    }
  }
  /**
   * On after load data listener.
   *
   * @private
   */
  onAfterLoadData() {
    if (this.hot.view) {
      this.recalculateAllColumnsWidth();
    } else {
      setTimeout(() => {
        if (this.hot) {
          this.recalculateAllColumnsWidth();
        }
      }, 0);
    }
  }
  /**
   * On before change listener.
   *
   * @private
   * @param {Array} changes An array of modified data.
   */
  onBeforeChange(changes) {
    const changedColumns = arrayMap(changes, (_ref2) => {
      let [, columnProperty] = _ref2;
      return this.hot.toPhysicalColumn(this.hot.propToCol(columnProperty));
    });
    this.clearCache(Array.from(new Set(changedColumns)));
  }
  /**
   * On before column resize listener.
   *
   * @private
   * @param {number} size Calculated new column width.
   * @param {number} column Visual index of the resized column.
   * @param {boolean} isDblClick  Flag that determines whether there was a double-click.
   * @returns {number}
   */
  onBeforeColumnResize(size, column, isDblClick) {
    let newSize = size;
    if (isDblClick) {
      this.calculateColumnsWidth(column, void 0, true);
      newSize = this.getColumnWidth(column, void 0, false);
    }
    return newSize;
  }
  /**
   * On after Handsontable init fill plugin with all necessary values.
   *
   * @private
   */
  onAfterInit() {
    privatePool7.get(this).cachedColumnHeaders = this.hot.getColHeader();
  }
  /**
   * After formulas values updated listener.
   *
   * @private
   * @param {Array} changes An array of modified data.
   */
  onAfterFormulasValuesUpdate(changes) {
    const filteredChanges = arrayFilter(changes, (change) => {
      var _change$address;
      return isDefined((_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.col);
    });
    const changedColumns = arrayMap(filteredChanges, (change) => change.address.col);
    this.clearCache(Array.from(new Set(changedColumns)));
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.ghostTable.clean();
    super.destroy();
  }
};

// node_modules/handsontable/plugins/autofill/utils.mjs
var DIRECTIONS = {
  horizontal: "horizontal",
  vertical: "vertical"
};
function getDragDirectionAndRange(startSelection, endSelection, cellCoordsFactory) {
  let startOfDragCoords;
  let endOfDragCoords;
  let directionOfDrag;
  if (endSelection[0] === startSelection[0] && endSelection[1] < startSelection[1]) {
    directionOfDrag = "left";
    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);
    endOfDragCoords = cellCoordsFactory(endSelection[2], startSelection[1] - 1);
  } else if (endSelection[2] === startSelection[2] && endSelection[0] === startSelection[0] && endSelection[3] > startSelection[3]) {
    directionOfDrag = "right";
    startOfDragCoords = cellCoordsFactory(endSelection[0], startSelection[3] + 1);
    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);
  } else if (endSelection[0] < startSelection[0] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "up";
    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);
    endOfDragCoords = cellCoordsFactory(startSelection[0] - 1, endSelection[3]);
  } else if (endSelection[2] > startSelection[2] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "down";
    startOfDragCoords = cellCoordsFactory(startSelection[2] + 1, endSelection[1]);
    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);
  }
  if (startOfDragCoords) {
    startOfDragCoords.normalize();
  }
  if (endOfDragCoords) {
    endOfDragCoords.normalize();
  }
  return {
    directionOfDrag,
    startOfDragCoords,
    endOfDragCoords
  };
}
function getMappedFillHandleSetting(fillHandle) {
  const mappedSettings = {};
  if (fillHandle === true) {
    mappedSettings.directions = Object.keys(DIRECTIONS);
    mappedSettings.autoInsertRow = true;
  } else if (isObject2(fillHandle)) {
    if (isDefined(fillHandle.autoInsertRow)) {
      if (fillHandle.direction === DIRECTIONS.horizontal) {
        mappedSettings.autoInsertRow = false;
      } else {
        mappedSettings.autoInsertRow = fillHandle.autoInsertRow;
      }
    } else {
      mappedSettings.autoInsertRow = false;
    }
    if (isDefined(fillHandle.direction)) {
      mappedSettings.directions = [fillHandle.direction];
    } else {
      mappedSettings.directions = Object.keys(DIRECTIONS);
    }
  } else if (typeof fillHandle === "string") {
    mappedSettings.directions = [fillHandle];
    mappedSettings.autoInsertRow = true;
  } else {
    mappedSettings.directions = [];
    mappedSettings.autoInsertRow = false;
  }
  return mappedSettings;
}

// node_modules/handsontable/plugins/autofill/autofill.mjs
pluginHooks_default.getSingleton().register("modifyAutofillRange");
pluginHooks_default.getSingleton().register("beforeAutofill");
pluginHooks_default.getSingleton().register("afterAutofill");
var PLUGIN_KEY3 = "autofill";
var PLUGIN_PRIORITY2 = 20;
var SETTING_KEYS = ["fillHandle"];
var INSERT_ROW_ALTER_ACTION_NAME = "insert_row_below";
var INTERVAL_FOR_ADDING_ROW = 200;
var Autofill = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY3;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY2;
  }
  static get SETTING_KEYS() {
    return [PLUGIN_KEY3, ...SETTING_KEYS];
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.eventManager = new eventManager_default(this);
    this.addingStarted = false;
    this.mouseDownOnCellCorner = false;
    this.mouseDragOutside = false;
    this.handleDraggedCells = 0;
    this.directions = [];
    this.autoInsertRow = false;
  }
  /**
   * Checks if the plugin is enabled in the Handsontable settings.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings().fillHandle;
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.mapSettings();
    this.registerEvents();
    this.addHook("afterOnCellCornerMouseDown", (event2) => this.onAfterCellCornerMouseDown(event2));
    this.addHook("afterOnCellCornerDblClick", (event2) => this.onCellCornerDblClick(event2));
    this.addHook("beforeOnCellMouseOver", (_, coords) => this.onBeforeCellMouseOver(coords));
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - `autofill`
   *  - [`fillHandle`](@/api/options.md#fillhandle)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.clearMappedSettings();
    super.disablePlugin();
  }
  /**
   * Gets selection data.
   *
   * @private
   * @returns {object[]} Ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.
   */
  getSelectionData() {
    const selection = this.hot.getSelectedRangeLast();
    const {
      row: startRow,
      col: startCol
    } = selection.getTopStartCorner();
    const {
      row: endRow,
      col: endCol
    } = selection.getBottomEndCorner();
    const copyableRanges = this.hot.runHooks("modifyCopyableRange", [{
      startRow,
      startCol,
      endRow,
      endCol
    }]);
    const copyableRows = [];
    const copyableColumns = [];
    const data = [];
    arrayEach(copyableRanges, (range) => {
      for (let visualRow = range.startRow; visualRow <= range.endRow; visualRow += 1) {
        if (copyableRows.indexOf(visualRow) === -1) {
          copyableRows.push(visualRow);
        }
      }
      for (let visualColumn = range.startCol; visualColumn <= range.endCol; visualColumn += 1) {
        if (copyableColumns.indexOf(visualColumn) === -1) {
          copyableColumns.push(visualColumn);
        }
      }
    });
    arrayEach(copyableRows, (row) => {
      const rowSet = [];
      arrayEach(copyableColumns, (column) => {
        rowSet.push(this.hot.getCopyableData(row, column));
      });
      data.push(rowSet);
    });
    return data;
  }
  /**
   * Try to apply fill values to the area in fill border, omitting the selection border.
   *
   * @private
   * @returns {boolean} Reports if fill was applied.
   *
   * @fires Hooks#modifyAutofillRange
   * @fires Hooks#beforeAutofill
   * @fires Hooks#afterAutofill
   */
  fillIn() {
    if (this.hot.selection.highlight.getFill().isEmpty()) {
      return false;
    }
    const [fillStartRow, fillStartColumn, fillEndRow, fillEndColumn] = this.hot.selection.highlight.getFill().getVisualCorners();
    const selectionRangeLast = this.hot.getSelectedRangeLast();
    const topStartCorner = selectionRangeLast.getTopStartCorner();
    const bottomEndCorner = selectionRangeLast.getBottomEndCorner();
    this.resetSelectionOfDraggedArea();
    const cornersOfSelectedCells = [topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col];
    const cornersOfSelectionAndDragAreas = this.hot.runHooks("modifyAutofillRange", [Math.min(topStartCorner.row, fillStartRow), Math.min(topStartCorner.col, fillStartColumn), Math.max(bottomEndCorner.row, fillEndRow), Math.max(bottomEndCorner.col, fillEndColumn)], cornersOfSelectedCells);
    const {
      directionOfDrag,
      startOfDragCoords,
      endOfDragCoords
    } = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas, (row, column) => this.hot._createCellCoords(row, column));
    if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {
      const selectionData = this.getSelectionData();
      const sourceRange = selectionRangeLast.clone();
      const targetRange = this.hot._createCellRange(startOfDragCoords, startOfDragCoords, endOfDragCoords);
      const beforeAutofillHookResult = this.hot.runHooks("beforeAutofill", selectionData, sourceRange, targetRange, directionOfDrag);
      if (beforeAutofillHookResult === false) {
        this.hot.selection.highlight.getFill().clear();
        this.hot.render();
        return false;
      }
      let fillData = beforeAutofillHookResult;
      const res = beforeAutofillHookResult;
      if (["up", "left"].indexOf(directionOfDrag) > -1 && !(res.length === 1 && res[0].length === 0)) {
        fillData = [];
        if (directionOfDrag === "up") {
          const dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;
          const fillOffset = dragLength % res.length;
          for (let i = 0; i < dragLength; i++) {
            fillData.push(res[(i + (res.length - fillOffset)) % res.length]);
          }
        } else {
          const dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;
          const fillOffset = dragLength % res[0].length;
          for (let i = 0; i < res.length; i++) {
            fillData.push([]);
            for (let j = 0; j < dragLength; j++) {
              fillData[i].push(res[i][(j + (res[i].length - fillOffset)) % res[i].length]);
            }
          }
        }
      }
      this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, `${this.pluginName}.fill`, null);
      this.setSelection(cornersOfSelectionAndDragAreas);
      this.hot.runHooks("afterAutofill", fillData, sourceRange, targetRange, directionOfDrag);
      this.hot.render();
    } else {
      this.hot._refreshBorders();
    }
    return true;
  }
  /**
   * Reduces the selection area if the handle was dragged outside of the table or on headers.
   *
   * @private
   * @param {CellCoords} coords Indexes of selection corners.
   * @returns {CellCoords}
   */
  reduceSelectionAreaIfNeeded(coords) {
    if (coords.row < 0) {
      coords.row = 0;
    }
    if (coords.col < 0) {
      coords.col = 0;
    }
    return coords;
  }
  /**
   * Gets the coordinates of the drag & drop borders.
   *
   * @private
   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.
   * @returns {CellCoords}
   */
  getCoordsOfDragAndDropBorders(coordsOfSelection) {
    const currentSelection = this.hot.getSelectedRangeLast();
    const bottomRightCorner = currentSelection.getBottomEndCorner();
    let coords = coordsOfSelection;
    if (this.directions.includes(DIRECTIONS.vertical) && this.directions.includes(DIRECTIONS.horizontal)) {
      const topStartCorner = currentSelection.getTopStartCorner();
      if (bottomRightCorner.col <= coordsOfSelection.col || topStartCorner.col >= coordsOfSelection.col) {
        coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);
      }
      if (bottomRightCorner.row < coordsOfSelection.row || topStartCorner.row > coordsOfSelection.row) {
        coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);
      }
    } else if (this.directions.includes(DIRECTIONS.vertical)) {
      coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);
    } else if (this.directions.includes(DIRECTIONS.horizontal)) {
      coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);
    } else {
      return;
    }
    return this.reduceSelectionAreaIfNeeded(coords);
  }
  /**
   * Show the fill border.
   *
   * @private
   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.
   */
  showBorder(coordsOfSelection) {
    const coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);
    if (coordsOfDragAndDropBorders) {
      this.redrawBorders(coordsOfDragAndDropBorders);
    }
  }
  /**
   * Add new row.
   *
   * @private
   */
  addRow() {
    this.hot._registerTimeout(() => {
      this.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, void 0, 1, `${this.pluginName}.fill`);
      this.addingStarted = false;
    }, INTERVAL_FOR_ADDING_ROW);
  }
  /**
   * Add new rows if they are needed to continue auto-filling values.
   *
   * @private
   */
  addNewRowIfNeeded() {
    if (!this.hot.selection.highlight.getFill().isEmpty() && this.addingStarted === false && this.autoInsertRow) {
      const cornersOfSelectedCells = this.hot.getSelectedLast();
      const cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getVisualCorners();
      const nrOfTableRows = this.hot.countRows();
      if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {
        this.addingStarted = true;
        this.addRow();
      }
    }
  }
  /**
   * Get index of last adjacent filled in row.
   *
   * @private
   * @param {Array} cornersOfSelectedCells Indexes of selection corners.
   * @returns {number} Gives number greater than or equal to zero when selection adjacent can be applied.
   *                   Or -1 when selection adjacent can't be applied.
   */
  getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {
    const data = this.hot.getData();
    const nrOfTableRows = this.hot.countRows();
    let lastFilledInRowIndex;
    for (let rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {
      for (let columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {
        const dataInCell = data[rowIndex][columnIndex];
        if (dataInCell) {
          return -1;
        }
      }
      const dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];
      const dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];
      if (!!dataInNextLeftCell || !!dataInNextRightCell) {
        lastFilledInRowIndex = rowIndex;
      }
    }
    return lastFilledInRowIndex;
  }
  /**
   * Adds a selection from the start area to the specific row index.
   *
   * @private
   * @param {Array} selectStartArea Selection area from which we start to create more comprehensive selection.
   * @param {number} rowIndex The row index into the selection will be added.
   */
  addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {
    this.hot.selection.highlight.getFill().clear().add(this.hot._createCellCoords(selectStartArea[0], selectStartArea[1])).add(this.hot._createCellCoords(rowIndex, selectStartArea[3])).commit();
  }
  /**
   * Sets selection based on passed corners.
   *
   * @private
   * @param {Array} cornersOfArea An array witch defines selection.
   */
  setSelection(cornersOfArea) {
    this.hot.selectCell(...arrayMap(cornersOfArea, (index2) => Math.max(index2, 0)), false, false);
  }
  /**
   * Try to select cells down to the last row in the left column and then returns if selection was applied.
   *
   * @private
   * @returns {boolean}
   */
  selectAdjacent() {
    const cornersOfSelectedCells = this.hot.getSelectedLast();
    const lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);
    if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === void 0) {
      return false;
    }
    this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);
    return true;
  }
  /**
   * Resets selection of dragged area.
   *
   * @private
   */
  resetSelectionOfDraggedArea() {
    this.handleDraggedCells = 0;
    this.hot.selection.highlight.getFill().clear();
  }
  /**
   * Redraws borders.
   *
   * @private
   * @param {CellCoords} coords `CellCoords` coord object.
   */
  redrawBorders(coords) {
    this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords).commit();
    this.hot.view.render();
  }
  /**
   * Get if mouse was dragged outside.
   *
   * @private
   * @param {MouseEvent} event `mousemove` event properties.
   * @returns {boolean}
   */
  getIfMouseWasDraggedOutside(event2) {
    const {
      documentElement
    } = this.hot.rootDocument;
    const tableBottom = offset2(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);
    const tableRight = offset2(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);
    return event2.clientY > tableBottom && event2.clientX <= tableRight;
  }
  /**
   * Bind the events used by the plugin.
   *
   * @private
   */
  registerEvents() {
    const {
      documentElement
    } = this.hot.rootDocument;
    this.eventManager.addEventListener(documentElement, "mouseup", () => this.onMouseUp());
    this.eventManager.addEventListener(documentElement, "mousemove", (event2) => this.onMouseMove(event2));
  }
  /**
   * On cell corner double click callback.
   *
   * @private
   */
  onCellCornerDblClick() {
    const selectionApplied = this.selectAdjacent();
    if (selectionApplied) {
      this.fillIn();
    }
  }
  /**
   * On after cell corner mouse down listener.
   *
   * @private
   */
  onAfterCellCornerMouseDown() {
    this.handleDraggedCells = 1;
    this.mouseDownOnCellCorner = true;
  }
  /**
   * On before cell mouse over listener.
   *
   * @private
   * @param {CellCoords} coords `CellCoords` coord object.
   */
  onBeforeCellMouseOver(coords) {
    if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {
      this.handleDraggedCells += 1;
      this.showBorder(coords);
      this.addNewRowIfNeeded();
    }
  }
  /**
   * On mouse up listener.
   *
   * @private
   */
  onMouseUp() {
    if (this.handleDraggedCells) {
      if (this.handleDraggedCells > 1) {
        this.fillIn();
      }
      this.handleDraggedCells = 0;
      this.mouseDownOnCellCorner = false;
    }
  }
  /**
   * On mouse move listener.
   *
   * @private
   * @param {MouseEvent} event `mousemove` event properties.
   */
  onMouseMove(event2) {
    const mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event2);
    if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {
      this.mouseDragOutside = true;
      this.addingStarted = true;
    } else {
      this.mouseDragOutside = false;
    }
    if (this.mouseDragOutside && this.autoInsertRow) {
      this.addRow();
    }
  }
  /**
   * Clears mapped settings.
   *
   * @private
   */
  clearMappedSettings() {
    this.directions.length = 0;
    this.autoInsertRow = false;
  }
  /**
   * Map settings.
   *
   * @private
   */
  mapSettings() {
    const mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);
    this.directions = mappedSettings.directions;
    this.autoInsertRow = mappedSettings.autoInsertRow;
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/autoRowSize/autoRowSize.mjs
var PLUGIN_KEY4 = "autoRowSize";
var PLUGIN_PRIORITY3 = 40;
var ROW_WIDTHS_MAP_NAME = "autoRowSize";
var AutoRowSize = class _AutoRowSize extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY4;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY3;
  }
  static get SETTING_KEYS() {
    return true;
  }
  static get CALCULATION_STEP() {
    return 50;
  }
  static get SYNC_CALCULATION_LIMIT() {
    return 500;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.rowHeightsMap = void 0;
    this.headerHeight = null;
    this.ghostTable = new ghostTable_default(this.hot);
    this.samplesGenerator = new samplesGenerator_default((row, col) => {
      let cellValue;
      if (row >= 0) {
        cellValue = this.hot.getDataAtCell(row, col);
      } else if (row === -1) {
        cellValue = this.hot.getColHeader(col);
      }
      return {
        value: cellValue
      };
    });
    this.firstCalculation = true;
    this.inProgress = false;
    this.measuredRows = 0;
    this.rowHeightsMap = new PhysicalIndexToValueMap();
    this.hot.rowIndexMapper.registerMap(ROW_WIDTHS_MAP_NAME, this.rowHeightsMap);
    this.addHook("beforeRowResize", (size, row, isDblClick) => this.onBeforeRowResize(size, row, isDblClick));
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    const settings = this.hot.getSettings()[PLUGIN_KEY4];
    return settings === true || isObject2(settings);
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.setSamplingOptions();
    this.addHook("afterLoadData", function() {
      return _this.onAfterLoadData(...arguments);
    });
    this.addHook("beforeChangeRender", (changes) => this.onBeforeChange(changes));
    this.addHook("beforeColumnResize", () => this.recalculateAllRowsHeight());
    this.addHook("beforeViewRender", (force) => this.onBeforeViewRender(force));
    this.addHook("modifyRowHeight", (height, row) => this.getRowHeight(row, height));
    this.addHook("modifyColumnHeaderHeight", () => this.getColumnHeaderHeight());
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.headerHeight = null;
    super.disablePlugin();
    this.addHook("beforeRowResize", (size, row, isDblClick) => this.onBeforeRowResize(size, row, isDblClick));
  }
  /**
   * Calculate a given rows height.
   *
   * @param {number|object} rowRange Row index or an object with `from` and `to` indexes as a range.
   * @param {number|object} colRange Column index or an object with `from` and `to` indexes as a range.
   * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.
   */
  calculateRowsHeight() {
    let rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      from: 0,
      to: this.hot.countRows() - 1
    };
    let colRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      from: 0,
      to: this.hot.countCols() - 1
    };
    let force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const rowsRange = typeof rowRange === "number" ? {
      from: rowRange,
      to: rowRange
    } : rowRange;
    const columnsRange = typeof colRange === "number" ? {
      from: colRange,
      to: colRange
    } : colRange;
    if (this.hot.getColHeader(0) !== null) {
      const samples = this.samplesGenerator.generateRowSamples(-1, columnsRange);
      this.ghostTable.addColumnHeadersRow(samples.get(-1));
    }
    rangeEach(rowsRange.from, rowsRange.to, (row) => {
      if (force || this.rowHeightsMap.getValueAtIndex(row) === null) {
        const samples = this.samplesGenerator.generateRowSamples(row, columnsRange);
        arrayEach(samples, (_ref2) => {
          let [rowIndex, sample] = _ref2;
          return this.ghostTable.addRow(rowIndex, sample);
        });
      }
    });
    if (this.ghostTable.rows.length) {
      this.hot.batchExecution(() => {
        this.ghostTable.getHeights((row, height) => {
          if (row < 0) {
            this.headerHeight = height;
          } else {
            this.rowHeightsMap.setValueAtIndex(this.hot.toPhysicalRow(row), height);
          }
        });
      }, true);
      this.measuredRows = rowsRange.to + 1;
      this.ghostTable.clean();
    }
  }
  /**
   * Calculate all rows heights. The calculated row will be cached in the {@link AutoRowSize#heights} property.
   * To retrieve height for specified row use {@link AutoRowSize#getRowHeight} method.
   *
   * @param {object|number} colRange Row index or an object with `from` and `to` properties which define row range.
   */
  calculateAllRowsHeight() {
    let colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      from: 0,
      to: this.hot.countCols() - 1
    };
    let current = 0;
    const length = this.hot.countRows() - 1;
    let timer = null;
    this.inProgress = true;
    const loop = () => {
      if (!this.hot) {
        cancelAnimationFrame(timer);
        this.inProgress = false;
        return;
      }
      this.calculateRowsHeight({
        from: current,
        to: Math.min(current + _AutoRowSize.CALCULATION_STEP, length)
      }, colRange);
      current = current + _AutoRowSize.CALCULATION_STEP + 1;
      if (current < length) {
        timer = requestAnimationFrame(loop);
      } else {
        cancelAnimationFrame(timer);
        this.inProgress = false;
        this.hot.view.adjustElementsSize(true);
        if (this.hot.view._wt.wtOverlays.inlineStartOverlay.needFullRender) {
          this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.draw();
        }
      }
    };
    const syncLimit = this.getSyncCalculationLimit();
    if (this.firstCalculation && syncLimit >= 0) {
      this.calculateRowsHeight({
        from: 0,
        to: syncLimit
      }, colRange);
      this.firstCalculation = false;
      current = syncLimit + 1;
    }
    if (current < length) {
      loop();
    } else {
      this.inProgress = false;
      this.hot.view.adjustElementsSize(false);
    }
  }
  /**
   * Sets the sampling options.
   *
   * @private
   */
  setSamplingOptions() {
    const setting = this.hot.getSettings()[PLUGIN_KEY4];
    const samplingRatio = setting && hasOwnProperty2(setting, "samplingRatio") ? setting.samplingRatio : void 0;
    const allowSampleDuplicates = setting && hasOwnProperty2(setting, "allowSampleDuplicates") ? setting.allowSampleDuplicates : void 0;
    if (samplingRatio && !isNaN(samplingRatio)) {
      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
    }
    if (allowSampleDuplicates) {
      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
    }
  }
  /**
   * Recalculates all rows height (overwrite cache values).
   */
  recalculateAllRowsHeight() {
    if (isVisible(this.hot.view._wt.wtTable.TABLE)) {
      this.clearCache();
      this.calculateAllRowsHeight();
    }
  }
  /**
   * Gets value which tells how many rows should be calculated synchronously (rest of the rows will be calculated
   * asynchronously). The limit is calculated based on `syncLimit` set to autoRowSize option (see {@link Options#autoRowSize}).
   *
   * @returns {number}
   */
  getSyncCalculationLimit() {
    const settings = this.hot.getSettings()[PLUGIN_KEY4];
    let limit = _AutoRowSize.SYNC_CALCULATION_LIMIT;
    const rowsLimit = this.hot.countRows() - 1;
    if (isObject2(settings)) {
      limit = settings.syncLimit;
      if (isPercentValue(limit)) {
        limit = valueAccordingPercent(rowsLimit, limit);
      } else {
        limit >>= 0;
      }
    }
    return Math.min(limit, rowsLimit);
  }
  /**
   * Get a row's height, as measured in the DOM.
   *
   * The height returned includes 1 px of the row's bottom border.
   *
   * Mind that this method is different from the
   * [`getRowHeight()`](@/api/core.md#getrowheight) method
   * of Handsontable's [Core](@/api/core.md).
   *
   * @param {number} row A visual row index.
   * @param {number} [defaultHeight] If no height is found, `defaultHeight` is returned instead.
   * @returns {number} The height of the specified row, in pixels.
   */
  getRowHeight(row) {
    let defaultHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    const cachedHeight = row < 0 ? this.headerHeight : this.rowHeightsMap.getValueAtIndex(this.hot.toPhysicalRow(row));
    let height = defaultHeight;
    if (cachedHeight !== null && cachedHeight > (defaultHeight || 0)) {
      height = cachedHeight;
    }
    return height;
  }
  /**
   * Get the calculated column header height.
   *
   * @returns {number|undefined}
   */
  getColumnHeaderHeight() {
    return this.headerHeight;
  }
  /**
   * Get the first visible row.
   *
   * @returns {number} Returns row index, -1 if table is not rendered or if there are no rows to base the the calculations on.
   */
  getFirstVisibleRow() {
    const wot = this.hot.view._wt;
    if (wot.wtViewport.rowsVisibleCalculator) {
      return wot.wtTable.getFirstVisibleRow();
    }
    if (wot.wtViewport.rowsRenderCalculator) {
      return wot.wtTable.getFirstRenderedRow();
    }
    return -1;
  }
  /**
   * Gets the last visible row.
   *
   * @returns {number} Returns row index or -1 if table is not rendered.
   */
  getLastVisibleRow() {
    const wot = this.hot.view._wt;
    if (wot.wtViewport.rowsVisibleCalculator) {
      return wot.wtTable.getLastVisibleRow();
    }
    if (wot.wtViewport.rowsRenderCalculator) {
      return wot.wtTable.getLastRenderedRow();
    }
    return -1;
  }
  /**
   * Clears cached heights.
   */
  clearCache() {
    this.headerHeight = null;
    this.rowHeightsMap.init();
  }
  /**
   * Clears cache by range.
   *
   * @param {object|number} range Row index or an object with `from` and `to` properties which define row range.
   */
  clearCacheByRange(range) {
    const {
      from: from2,
      to: to2
    } = typeof range === "number" ? {
      from: range,
      to: range
    } : range;
    this.hot.batchExecution(() => {
      rangeEach(Math.min(from2, to2), Math.max(from2, to2), (row) => {
        this.rowHeightsMap.setValueAtIndex(row, null);
      });
    }, true);
  }
  /**
   * Checks if all heights were calculated. If not then return `true` (need recalculate).
   *
   * @returns {boolean}
   */
  isNeedRecalculate() {
    return !!arrayFilter(this.rowHeightsMap.getValues().slice(0, this.measuredRows), (item) => item === null).length;
  }
  /**
   * On before view render listener.
   *
   * @private
   */
  onBeforeViewRender() {
    const force = this.hot.renderCall;
    const fixedRowsBottom = this.hot.getSettings().fixedRowsBottom;
    const firstVisibleRow = this.getFirstVisibleRow();
    const lastVisibleRow = this.getLastVisibleRow();
    if (firstVisibleRow === -1 || lastVisibleRow === -1) {
      return;
    }
    this.calculateRowsHeight({
      from: firstVisibleRow,
      to: lastVisibleRow
    }, void 0, force);
    if (fixedRowsBottom) {
      const totalRows = this.hot.countRows() - 1;
      this.calculateRowsHeight({
        from: totalRows - fixedRowsBottom,
        to: totalRows
      });
    }
    if (this.isNeedRecalculate() && !this.inProgress) {
      this.calculateAllRowsHeight();
    }
  }
  /**
   * On before row move listener.
   *
   * @private
   * @param {number} from Row index where was grabbed.
   * @param {number} to Destination row index.
   */
  onBeforeRowMove(from2, to2) {
    this.clearCacheByRange({
      from: from2,
      to: to2
    });
    this.calculateAllRowsHeight();
  }
  /**
   * On before row resize listener.
   *
   * @private
   * @param {number} size The size of the current row index.
   * @param {number} row Current row index.
   * @param {boolean} isDblClick Indicates if the resize was triggered by doubleclick.
   * @returns {number}
   */
  onBeforeRowResize(size, row, isDblClick) {
    let newSize = size;
    if (isDblClick) {
      this.calculateRowsHeight(row, void 0, true);
      newSize = this.getRowHeight(row);
    }
    return newSize;
  }
  /**
   * On after load data listener.
   *
   * @private
   */
  onAfterLoadData() {
    if (this.hot.view) {
      this.recalculateAllRowsHeight();
    } else {
      setTimeout(() => {
        if (this.hot) {
          this.recalculateAllRowsHeight();
        }
      }, 0);
    }
  }
  /**
   * On before change listener.
   *
   * @private
   * @param {Array} changes 2D array containing information about each of the edited cells.
   */
  onBeforeChange(changes) {
    let range = null;
    if (changes.length === 1) {
      range = changes[0][0];
    } else if (changes.length > 1) {
      range = {
        from: changes[0][0],
        to: changes[changes.length - 1][0]
      };
    }
    if (range !== null) {
      this.clearCacheByRange(range);
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.ghostTable.clean();
    super.destroy();
  }
};

// node_modules/handsontable/plugins/bindRowsWithHeaders/maps/looseBindsMap.mjs
var {
  getListWithInsertedItems: getListWithInsertedItems3,
  getListWithRemovedItems: getListWithRemovedItems3
} = alterUtilsFactory("physicallyIndexed");
var LooseBindsMap = class extends IndexMap {
  constructor() {
    super((index2) => index2);
  }
  /**
   * Add values to list and reorganize.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    const listAfterUpdate = getIncreasedIndexes(this.indexedValues, insertedIndexes);
    this.indexedValues = getListWithInsertedItems3(listAfterUpdate, insertionIndex, insertedIndexes, this.initValueOrFn);
    super.insert(insertionIndex, insertedIndexes);
  }
  /**
   * Remove values from the list and reorganize.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    const listAfterUpdate = getListWithRemovedItems3(this.indexedValues, removedIndexes);
    this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);
    super.remove(removedIndexes);
  }
};
var looseBindsMap_default = LooseBindsMap;

// node_modules/handsontable/plugins/bindRowsWithHeaders/maps/strictBindsMap.mjs
var {
  getListWithInsertedItems: getListWithInsertedItems4,
  getListWithRemovedItems: getListWithRemovedItems4
} = alterUtilsFactory("physicallyIndexed");
var StrictBindsMap = class extends IndexMap {
  constructor() {
    super((index2) => index2);
  }
  /**
   * Add values to list and reorganize.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    this.indexedValues = getListWithInsertedItems4(this.indexedValues, insertionIndex, insertedIndexes, (_, ordinalNumber) => this.getNextValue(ordinalNumber));
    super.insert(insertionIndex, insertedIndexes);
  }
  /**
   * Remove values from the list and reorganize.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    this.indexedValues = getListWithRemovedItems4(this.indexedValues, removedIndexes);
    super.remove(removedIndexes);
  }
  /**
   * Get next values, which should be greater than actual maximum value in the list.
   *
   * @param {number} ordinalNumber Position in the list.
   * @returns {number}
   */
  getNextValue(ordinalNumber) {
    return Math.max(...this.getValues()) + 1 + ordinalNumber;
  }
};
var strictBindsMap_default = StrictBindsMap;

// node_modules/handsontable/plugins/bindRowsWithHeaders/bindRowsWithHeaders.mjs
var PLUGIN_KEY5 = "bindRowsWithHeaders";
var PLUGIN_PRIORITY4 = 210;
var DEFAULT_BIND = "loose";
var bindTypeToMapStrategy = /* @__PURE__ */ new Map([["loose", looseBindsMap_default], ["strict", strictBindsMap_default]]);
var BindRowsWithHeaders = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY5;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY4;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.headerIndexes = null;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link BindRowsWithHeaders#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY5];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    let bindType = this.hot.getSettings()[PLUGIN_KEY5];
    if (typeof bindType !== "string") {
      bindType = DEFAULT_BIND;
    }
    const MapStrategy = bindTypeToMapStrategy.get(bindType);
    this.headerIndexes = this.hot.rowIndexMapper.registerMap("bindRowsWithHeaders", new MapStrategy());
    this.addHook("modifyRowHeader", (row) => this.onModifyRowHeader(row));
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.rowIndexMapper.unregisterMap("bindRowsWithHeaders");
    super.disablePlugin();
  }
  /**
   * On modify row header listener.
   *
   * @private
   * @param {number} row Row index.
   * @returns {number}
   */
  onModifyRowHeader(row) {
    return this.headerIndexes.getValueAtIndex(this.hot.toPhysicalRow(row));
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/collapsibleColumns/collapsibleColumns.mjs
function _classPrivateFieldInitSpec6(obj, privateMap, value) {
  _checkPrivateRedeclaration7(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration7(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty17(obj, key, value) {
  key = _toPropertyKey17(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey17(arg) {
  var key = _toPrimitive17(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive17(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldGet6(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor6(receiver, privateMap, "get");
  return _classApplyDescriptorGet6(receiver, descriptor);
}
function _classApplyDescriptorGet6(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet6(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor6(receiver, privateMap, "set");
  _classApplyDescriptorSet6(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor6(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet6(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var PLUGIN_KEY6 = "collapsibleColumns";
var PLUGIN_PRIORITY5 = 290;
var SETTING_KEYS2 = ["nestedHeaders"];
var COLLAPSIBLE_ELEMENT_CLASS = "collapsibleIndicator";
var actionDictionary = /* @__PURE__ */ new Map([["collapse", {
  hideColumn: true,
  beforeHook: "beforeColumnCollapse",
  afterHook: "afterColumnCollapse"
}], ["expand", {
  hideColumn: false,
  beforeHook: "beforeColumnExpand",
  afterHook: "afterColumnExpand"
}]]);
var _collapsedColumnsMap = /* @__PURE__ */ new WeakMap();
var CollapsibleColumns = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _defineProperty17(this, "nestedHeadersPlugin", null);
    _defineProperty17(this, "eventManager", new eventManager_default(this));
    _defineProperty17(this, "headerStateManager", null);
    _classPrivateFieldInitSpec6(this, _collapsedColumnsMap, {
      writable: true,
      value: null
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY6;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY5;
  }
  static get PLUGIN_DEPS() {
    return ["plugin:NestedHeaders"];
  }
  static get SETTING_KEYS() {
    return [PLUGIN_KEY6, ...SETTING_KEYS2];
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link CollapsibleColumns#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY6];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const {
      nestedHeaders
    } = this.hot.getSettings();
    if (!nestedHeaders) {
      warn2("You need to configure the Nested Headers plugin in order to use collapsible headers.");
    }
    _classPrivateFieldSet6(this, _collapsedColumnsMap, this.hot.columnIndexMapper.createAndRegisterIndexMap(this.pluginName, "hiding"));
    this.nestedHeadersPlugin = this.hot.getPlugin("nestedHeaders");
    this.headerStateManager = this.nestedHeadersPlugin.getStateManager();
    this.addHook("init", () => this.onInit());
    this.addHook("afterLoadData", function() {
      return _this.onAfterLoadData(...arguments);
    });
    this.addHook("afterGetColHeader", function() {
      return _this.onAfterGetColHeader(...arguments);
    });
    this.addHook("beforeOnCellMouseDown", (event2, coords, TD) => this.onBeforeOnCellMouseDown(event2, coords, TD));
    super.enablePlugin();
    this.updatePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *   - [`collapsibleColumns`](@/api/options.md#collapsiblecolumns)
   *   - [`nestedHeaders`](@/api/options.md#nestedheaders)
   */
  updatePlugin() {
    if (!this.hot.view) {
      return;
    }
    if (!this.nestedHeadersPlugin.detectedOverlappedHeaders) {
      const {
        collapsibleColumns
      } = this.hot.getSettings();
      if (typeof collapsibleColumns === "boolean") {
        this.headerStateManager.mapState((headerSettings) => {
          return {
            collapsible: headerSettings.origColspan > 1
          };
        });
      } else if (Array.isArray(collapsibleColumns)) {
        this.headerStateManager.mapState(() => {
          return {
            collapsible: false
          };
        });
        this.headerStateManager.mergeStateWith(collapsibleColumns);
      }
    }
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.columnIndexMapper.unregisterMap(this.pluginName);
    _classPrivateFieldSet6(this, _collapsedColumnsMap, null);
    this.nestedHeadersPlugin = null;
    this.clearButtons();
    super.disablePlugin();
  }
  /**
   * Clears the expand/collapse buttons.
   *
   * @private
   */
  clearButtons() {
    if (!this.hot.view) {
      return;
    }
    const headerLevels = this.hot.view._wt.getSetting("columnHeaders").length;
    const mainHeaders = this.hot.view._wt.wtTable.THEAD;
    const topHeaders = this.hot.view._wt.wtOverlays.topOverlay.clone.wtTable.THEAD;
    const topLeftCornerHeaders = this.hot.view._wt.wtOverlays.topInlineStartCornerOverlay ? this.hot.view._wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;
    const removeButton = function(button) {
      if (button) {
        button.parentNode.removeChild(button);
      }
    };
    rangeEach(0, headerLevels - 1, (i) => {
      const masterLevel = mainHeaders.childNodes[i];
      const topLevel = topHeaders.childNodes[i];
      const topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;
      rangeEach(0, masterLevel.childNodes.length - 1, (j) => {
        let button = masterLevel.childNodes[j].querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);
        removeButton(button);
        if (topLevel && topLevel.childNodes[j]) {
          button = topLevel.childNodes[j].querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);
          removeButton(button);
        }
        if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {
          button = topLeftCornerLevel.childNodes[j].querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);
          removeButton(button);
        }
      });
    }, true);
  }
  /**
   * Expands section at the provided coords.
   *
   * @param {object} coords Contains coordinates information. (`coords.row`, `coords.col`).
   */
  expandSection(coords) {
    this.toggleCollapsibleSection([coords], "expand");
  }
  /**
   * Collapses section at the provided coords.
   *
   * @param {object} coords Contains coordinates information. (`coords.row`, `coords.col`).
   */
  collapseSection(coords) {
    this.toggleCollapsibleSection([coords], "collapse");
  }
  /**
   * Collapses or expand all collapsible sections, depending on the action parameter.
   *
   * @param {string} action 'collapse' or 'expand'.
   */
  toggleAllCollapsibleSections(action) {
    const coords = this.headerStateManager.mapNodes((headerSettings) => {
      const {
        collapsible,
        origColspan,
        headerLevel,
        columnIndex,
        isCollapsed
      } = headerSettings;
      if (collapsible === true && origColspan > 1 && (isCollapsed && action === "expand" || !isCollapsed && action === "collapse")) {
        return {
          row: this.headerStateManager.levelToRowCoords(headerLevel),
          col: columnIndex
        };
      }
    });
    this.toggleCollapsibleSection(coords, action);
  }
  /**
   * Collapses all collapsible sections.
   */
  collapseAll() {
    this.toggleAllCollapsibleSections("collapse");
  }
  /**
   * Expands all collapsible sections.
   */
  expandAll() {
    this.toggleAllCollapsibleSections("expand");
  }
  /**
   * Collapses/Expands a section.
   *
   * @param {Array} coords Array of coords - section coordinates.
   * @param {string} [action] Action definition ('collapse' or 'expand').
   * @fires Hooks#beforeColumnCollapse
   * @fires Hooks#beforeColumnExpand
   * @fires Hooks#afterColumnCollapse
   * @fires Hooks#afterColumnExpand
   */
  toggleCollapsibleSection(coords, action) {
    if (!actionDictionary.has(action)) {
      throw new Error(`Unsupported action is passed (${action}).`);
    }
    if (!Array.isArray(coords)) {
      return;
    }
    const filteredCoords = arrayFilter(coords, (_ref2) => {
      let {
        row
      } = _ref2;
      return row < 0;
    });
    let isActionPossible = filteredCoords.length > 0;
    arrayEach(filteredCoords, (_ref2) => {
      var _this$headerStateMana;
      let {
        row,
        col: column
      } = _ref2;
      const {
        collapsible,
        isCollapsed
      } = (_this$headerStateMana = this.headerStateManager.getHeaderSettings(row, column)) !== null && _this$headerStateMana !== void 0 ? _this$headerStateMana : {};
      if (!collapsible || isCollapsed && action === "collapse" || !isCollapsed && action === "expand") {
        isActionPossible = false;
        return false;
      }
    });
    const nodeModRollbacks = [];
    const affectedColumnsIndexes = [];
    if (isActionPossible) {
      arrayEach(filteredCoords, (_ref3) => {
        let {
          row,
          col: column
        } = _ref3;
        const {
          colspanCompensation,
          affectedColumns,
          rollbackModification
        } = this.headerStateManager.triggerNodeModification(action, row, column);
        if (colspanCompensation > 0) {
          affectedColumnsIndexes.push(...affectedColumns);
          nodeModRollbacks.push(rollbackModification);
        }
      });
    }
    const currentCollapsedColumns = this.getCollapsedColumns();
    let destinationCollapsedColumns = [];
    if (action === "collapse") {
      destinationCollapsedColumns = arrayUnique([...currentCollapsedColumns, ...affectedColumnsIndexes]);
    } else if (action === "expand") {
      destinationCollapsedColumns = arrayFilter(currentCollapsedColumns, (index2) => !affectedColumnsIndexes.includes(index2));
    }
    const actionTranslator = actionDictionary.get(action);
    const isActionAllowed = this.hot.runHooks(actionTranslator.beforeHook, currentCollapsedColumns, destinationCollapsedColumns, isActionPossible);
    if (isActionAllowed === false) {
      arrayEach(nodeModRollbacks, (nodeModRollback) => {
        nodeModRollback();
      });
      return;
    }
    this.hot.batchExecution(() => {
      arrayEach(affectedColumnsIndexes, (visualColumn) => {
        _classPrivateFieldGet6(this, _collapsedColumnsMap).setValueAtIndex(this.hot.toPhysicalColumn(visualColumn), actionTranslator.hideColumn);
      });
    }, true);
    const isActionPerformed = this.getCollapsedColumns().length !== currentCollapsedColumns.length;
    this.hot.runHooks(actionTranslator.afterHook, currentCollapsedColumns, destinationCollapsedColumns, isActionPossible, isActionPerformed);
    this.hot.render();
    this.hot.view.adjustElementsSize(true);
  }
  /**
   * Gets an array of physical indexes of collapsed columns.
   *
   * @private
   * @returns {number[]}
   */
  getCollapsedColumns() {
    return _classPrivateFieldGet6(this, _collapsedColumnsMap).getHiddenIndexes();
  }
  /**
   * Adds the indicator to the headers.
   *
   * @private
   * @param {number} column Column index.
   * @param {HTMLElement} TH TH element.
   * @param {number} headerLevel The index of header level counting from the top (positive
   *                             values counting from 0 to N).
   */
  onAfterGetColHeader(column, TH, headerLevel) {
    var _this$headerStateMana2;
    const {
      collapsible,
      origColspan,
      isCollapsed
    } = (_this$headerStateMana2 = this.headerStateManager.getHeaderSettings(headerLevel, column)) !== null && _this$headerStateMana2 !== void 0 ? _this$headerStateMana2 : {};
    const isNodeCollapsible = collapsible && origColspan > 1 && column >= this.hot.getSettings().fixedColumnsStart;
    let collapsibleElement = TH.querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);
    if (isNodeCollapsible) {
      if (!collapsibleElement) {
        collapsibleElement = this.hot.rootDocument.createElement("div");
        addClass(collapsibleElement, COLLAPSIBLE_ELEMENT_CLASS);
        TH.querySelector("div:first-child").appendChild(collapsibleElement);
      }
      removeClass(collapsibleElement, ["collapsed", "expanded"]);
      if (isCollapsed) {
        addClass(collapsibleElement, "collapsed");
        fastInnerText(collapsibleElement, "+");
      } else {
        addClass(collapsibleElement, "expanded");
        fastInnerText(collapsibleElement, "-");
      }
    } else {
      var _collapsibleElement;
      (_collapsibleElement = collapsibleElement) === null || _collapsibleElement === void 0 || _collapsibleElement.remove();
    }
  }
  /**
   * Indicator mouse event callback.
   *
   * @private
   * @param {object} event Mouse event.
   * @param {object} coords Event coordinates.
   */
  onBeforeOnCellMouseDown(event2, coords) {
    if (hasClass(event2.target, COLLAPSIBLE_ELEMENT_CLASS)) {
      if (hasClass(event2.target, "expanded")) {
        this.eventManager.fireEvent(event2.target, "mouseup");
        this.toggleCollapsibleSection([coords], "collapse");
      } else if (hasClass(event2.target, "collapsed")) {
        this.eventManager.fireEvent(event2.target, "mouseup");
        this.toggleCollapsibleSection([coords], "expand");
      }
      stopImmediatePropagation(event2);
    }
  }
  /**
   * Updates the plugin state after HoT initialization.
   *
   * @private
   */
  onInit() {
    this.updatePlugin();
  }
  /**
   * Updates the plugin state after new dataset load.
   *
   * @private
   * @param {Array[]} sourceData Array of arrays or array of objects containing data.
   * @param {boolean} initialLoad Flag that determines whether the data has been loaded
   *                              during the initialization.
   */
  onAfterLoadData(sourceData, initialLoad) {
    if (!initialLoad) {
      this.updatePlugin();
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldSet6(this, _collapsedColumnsMap, null);
    super.destroy();
  }
};

// node_modules/handsontable/plugins/columnSorting/columnStatesManager.mjs
var inheritedColumnProperties = ["sortEmptyCells", "indicator", "headerAction", "compareFunctionFactory"];
var SORT_EMPTY_CELLS_DEFAULT = false;
var SHOW_SORT_INDICATOR_DEFAULT = true;
var HEADER_ACTION_DEFAULT = true;
var ColumnStatesManager = class {
  constructor(hot, mapName) {
    this.hot = hot;
    this.sortingStates = new LinkedPhysicalIndexToValueMap();
    this.sortEmptyCells = SORT_EMPTY_CELLS_DEFAULT;
    this.indicator = SHOW_SORT_INDICATOR_DEFAULT;
    this.headerAction = HEADER_ACTION_DEFAULT;
    this.compareFunctionFactory = void 0;
    this.mapName = mapName;
    this.hot.columnIndexMapper.registerMap(mapName, this.sortingStates);
  }
  /**
   * Update column properties which affect the sorting result.
   *
   * **Note**: All column properties can be overwritten by {@link Options#columns} option.
   *
   * @param {object} allSortSettings Column sorting plugin's configuration object.
   */
  updateAllColumnsProperties(allSortSettings) {
    if (!isObject2(allSortSettings)) {
      return;
    }
    objectEach(allSortSettings, (newValue, propertyName) => {
      if (inheritedColumnProperties.includes(propertyName)) {
        this[propertyName] = newValue;
      }
    });
  }
  /**
   * Get all column properties which affect the sorting result.
   *
   * @returns {object}
   */
  getAllColumnsProperties() {
    const columnProperties = {
      sortEmptyCells: this.sortEmptyCells,
      indicator: this.indicator,
      headerAction: this.headerAction
    };
    if (typeof this.compareFunctionFactory === "function") {
      columnProperties.compareFunctionFactory = this.compareFunctionFactory;
    }
    return columnProperties;
  }
  /**
   * Get sort order of column.
   *
   * @param {number} searchedColumn Visual column index.
   * @returns {string|undefined} Sort order (`asc` for ascending, `desc` for descending and undefined for not sorted).
   */
  getSortOrderOfColumn(searchedColumn) {
    var _this$sortingStates$g;
    return (_this$sortingStates$g = this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(searchedColumn))) === null || _this$sortingStates$g === void 0 ? void 0 : _this$sortingStates$g.sortOrder;
  }
  /**
   * Get order of particular column in the states queue.
   *
   * @param {number} column Visual column index.
   * @returns {number}
   */
  getIndexOfColumnInSortQueue(column) {
    column = this.hot.toPhysicalColumn(column);
    return this.sortingStates.getEntries().findIndex((_ref2) => {
      let [physicalColumn] = _ref2;
      return physicalColumn === column;
    });
  }
  /**
   * Get number of sorted columns.
   *
   * @returns {number}
   */
  getNumberOfSortedColumns() {
    return this.sortingStates.getLength();
  }
  /**
   * Get if list of sorted columns is empty.
   *
   * @returns {boolean}
   */
  isListOfSortedColumnsEmpty() {
    return this.getNumberOfSortedColumns() === 0;
  }
  /**
   * Get if particular column is sorted.
   *
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  isColumnSorted(column) {
    return isObject2(this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(column)));
  }
  /**
   * Queue of sort states containing sorted columns and their orders (Array of objects containing `column` and `sortOrder` properties).
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
   *
   * @returns {Array<object>}
   */
  getSortStates() {
    if (this.sortingStates === null) {
      return [];
    }
    const sortingStatesQueue = this.sortingStates.getEntries();
    return sortingStatesQueue.map((_ref2) => {
      let [physicalColumn, value] = _ref2;
      return {
        column: this.hot.toVisualColumn(physicalColumn),
        ...value
      };
    });
  }
  /**
   * Get sort state for particular column. Object contains `column` and `sortOrder` properties.
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
   *
   * @param {number} column Visual column index.
   * @returns {object|undefined}
   */
  getColumnSortState(column) {
    const sortOrder = this.getSortOrderOfColumn(column);
    if (isDefined(sortOrder)) {
      return {
        column,
        sortOrder
      };
    }
  }
  /**
   * Set all column states.
   *
   * @param {Array} sortStates Sort states.
   */
  setSortStates(sortStates) {
    this.sortingStates.clear();
    for (let i = 0; i < sortStates.length; i += 1) {
      this.sortingStates.setValueAtIndex(this.hot.toPhysicalColumn(sortStates[i].column), {
        sortOrder: sortStates[i].sortOrder
      });
    }
  }
  /**
   * Destroy the state manager.
   */
  destroy() {
    this.hot.columnIndexMapper.unregisterMap(this.mapName);
    this.sortingStates = null;
  }
};

// node_modules/handsontable/plugins/columnSorting/utils.mjs
var ASC_SORT_STATE = "asc";
var DESC_SORT_STATE = "desc";
var HEADER_SPAN_CLASS = "colHeader";
function isValidColumnState(columnState) {
  if (isObject2(columnState) === false) {
    return false;
  }
  const {
    column,
    sortOrder
  } = columnState;
  return Number.isInteger(column) && [ASC_SORT_STATE, DESC_SORT_STATE].includes(sortOrder);
}
function areValidSortStates(sortStates) {
  if (sortStates.some((columnState) => isValidColumnState(columnState) === false)) {
    return false;
  }
  const sortedColumns = sortStates.map((_ref2) => {
    let {
      column
    } = _ref2;
    return column;
  });
  return new Set(sortedColumns).size === sortedColumns.length;
}
function getNextSortOrder(sortOrder) {
  if (sortOrder === DESC_SORT_STATE) {
    return;
  } else if (sortOrder === ASC_SORT_STATE) {
    return DESC_SORT_STATE;
  }
  return ASC_SORT_STATE;
}
function getHeaderSpanElement(TH) {
  const headerSpanElement = TH.querySelector(`.${HEADER_SPAN_CLASS}`);
  return headerSpanElement;
}
function isFirstLevelColumnHeader(column, TH) {
  if (column < 0 || !TH.parentNode) {
    return false;
  }
  const TRs = TH.parentNode.parentNode.childNodes;
  const headerLevel = Array.from(TRs).indexOf(TH.parentNode) - TRs.length;
  if (headerLevel !== -1) {
    return false;
  }
  return true;
}
function wasHeaderClickedProperly(row, column, clickEvent) {
  return row === -1 && column >= 0 && isRightClick(clickEvent) === false;
}

// node_modules/handsontable/plugins/columnSorting/domHelpers.mjs
var HEADER_CLASS_ASC_SORT = "ascending";
var HEADER_CLASS_DESC_SORT = "descending";
var HEADER_CLASS_INDICATOR_DISABLED = "indicatorDisabled";
var HEADER_SORT_CLASS = "columnSorting";
var HEADER_ACTION_CLASS = "sortAction";
var orderToCssClass = /* @__PURE__ */ new Map([[ASC_SORT_STATE, HEADER_CLASS_ASC_SORT], [DESC_SORT_STATE, HEADER_CLASS_DESC_SORT]]);
function getClassesToAdd(columnStatesManager, column, showSortIndicator, headerAction) {
  const cssClasses = [HEADER_SORT_CLASS];
  if (headerAction) {
    cssClasses.push(HEADER_ACTION_CLASS);
  }
  if (showSortIndicator === false) {
    cssClasses.push(HEADER_CLASS_INDICATOR_DISABLED);
    return cssClasses;
  }
  const columnOrder = columnStatesManager.getSortOrderOfColumn(column);
  if (isDefined(columnOrder)) {
    cssClasses.push(orderToCssClass.get(columnOrder));
  }
  return cssClasses;
}
function getClassesToRemove() {
  return Array.from(orderToCssClass.values()).concat(HEADER_ACTION_CLASS, HEADER_CLASS_INDICATOR_DISABLED, HEADER_SORT_CLASS);
}

// node_modules/handsontable/plugins/columnSorting/sortFunction/default.mjs
function compareFunctionFactory(sortOrder, columnMeta, columnPluginSettings) {
  const locale2 = columnMeta.locale;
  return function(value, nextValue) {
    const {
      sortEmptyCells
    } = columnPluginSettings;
    if (typeof value === "string") {
      value = value.toLocaleLowerCase(locale2);
    }
    if (typeof nextValue === "string") {
      nextValue = nextValue.toLocaleLowerCase(locale2);
    }
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    if (isNaN(value) && !isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    } else if (!isNaN(value) && isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (!(isNaN(value) || isNaN(nextValue))) {
      value = parseFloat(value);
      nextValue = parseFloat(nextValue);
    }
    if (value < nextValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (value > nextValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE = "default";

// node_modules/handsontable/plugins/columnSorting/sortFunction/numeric.mjs
function compareFunctionFactory2(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    const parsedFirstValue = parseFloat(value);
    const parsedSecondValue = parseFloat(nextValue);
    const {
      sortEmptyCells
    } = columnPluginSettings;
    if (parsedFirstValue === parsedSecondValue || isNaN(parsedFirstValue) && isNaN(parsedSecondValue)) {
      return DO_NOT_SWAP;
    }
    if (sortEmptyCells) {
      if (isEmpty(value)) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      if (isEmpty(nextValue)) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
    }
    if (isNaN(parsedFirstValue)) {
      return FIRST_AFTER_SECOND;
    }
    if (isNaN(parsedSecondValue)) {
      return FIRST_BEFORE_SECOND;
    }
    if (parsedFirstValue < parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (parsedFirstValue > parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE2 = "numeric";

// node_modules/handsontable/plugins/columnSorting/sortFunction/checkbox.mjs
function compareFunctionFactory3(sortOrder, columnMeta, columnPluginSettings) {
  const checkedTemplate = columnMeta.checkedTemplate;
  const uncheckedTemplate = columnMeta.uncheckedTemplate;
  const {
    sortEmptyCells
  } = columnPluginSettings;
  return function(value, nextValue) {
    const isEmptyValue = isEmpty(value);
    const isEmptyNextValue = isEmpty(nextValue);
    const unifiedValue = isEmptyValue ? uncheckedTemplate : value;
    const unifiedNextValue = isEmptyNextValue ? uncheckedTemplate : nextValue;
    const isValueFromTemplate = unifiedValue === uncheckedTemplate || unifiedValue === checkedTemplate;
    const isNextValueFromTemplate = unifiedNextValue === uncheckedTemplate || unifiedNextValue === checkedTemplate;
    if (sortEmptyCells === false) {
      if (isEmptyValue && isEmptyNextValue === false) {
        return FIRST_AFTER_SECOND;
      }
      if (isEmptyValue === false && isEmptyNextValue) {
        return FIRST_BEFORE_SECOND;
      }
    }
    if (isValueFromTemplate === false && isNextValueFromTemplate) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (isValueFromTemplate && isNextValueFromTemplate === false) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    if (isValueFromTemplate === false && isNextValueFromTemplate === false) {
      return compareFunctionFactory(sortOrder, columnMeta, columnPluginSettings)(value, nextValue);
    }
    if (unifiedValue === uncheckedTemplate && unifiedNextValue === checkedTemplate) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (unifiedValue === checkedTemplate && unifiedNextValue === uncheckedTemplate) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE3 = "checkbox";

// node_modules/handsontable/plugins/columnSorting/sortFunction/date.mjs
init_moment();
function compareFunctionFactory4(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    const {
      sortEmptyCells
    } = columnPluginSettings;
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    const dateFormat = columnMeta.dateFormat;
    const firstDate = moment_default(value, dateFormat);
    const nextDate = moment_default(nextValue, dateFormat);
    if (!firstDate.isValid()) {
      return FIRST_AFTER_SECOND;
    }
    if (!nextDate.isValid()) {
      return FIRST_BEFORE_SECOND;
    }
    if (nextDate.isAfter(firstDate)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (nextDate.isBefore(firstDate)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE4 = "date";

// node_modules/handsontable/plugins/columnSorting/sortService/registry.mjs
var {
  register: registerCompareFunctionFactory,
  getItem: getGloballyCompareFunctionFactory,
  hasItem: hasGloballyCompareFunctionFactory
} = staticRegister("sorting.compareFunctionFactory");
var {
  register: registerRootComparator,
  getItem: getRootComparator
} = staticRegister("sorting.mainSortComparator");
function getCompareFunctionFactory(type) {
  if (hasGloballyCompareFunctionFactory(type)) {
    return getGloballyCompareFunctionFactory(type);
  }
  return getGloballyCompareFunctionFactory(COLUMN_DATA_TYPE);
}
registerCompareFunctionFactory(COLUMN_DATA_TYPE2, compareFunctionFactory2);
registerCompareFunctionFactory(COLUMN_DATA_TYPE3, compareFunctionFactory3);
registerCompareFunctionFactory(COLUMN_DATA_TYPE4, compareFunctionFactory4);
registerCompareFunctionFactory(COLUMN_DATA_TYPE, compareFunctionFactory);

// node_modules/handsontable/plugins/columnSorting/sortService/engine.mjs
var DO_NOT_SWAP = 0;
var FIRST_BEFORE_SECOND = -1;
var FIRST_AFTER_SECOND = 1;
function sort(indexesWithData, rootComparatorId) {
  const rootComparator3 = getRootComparator(rootComparatorId);
  for (var _len = arguments.length, argsForRootComparator = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    argsForRootComparator[_key - 2] = arguments[_key];
  }
  indexesWithData.sort(rootComparator3(...argsForRootComparator));
}

// node_modules/handsontable/plugins/columnSorting/rootComparator.mjs
function rootComparator(sortingOrders, columnMetas) {
  return function(rowIndexWithValues, nextRowIndexWithValues) {
    const [, ...values] = rowIndexWithValues;
    const [, ...nextValues] = nextRowIndexWithValues;
    return function getCompareResult(column) {
      const sortingOrder = sortingOrders[column];
      const columnMeta = columnMetas[column];
      const value = values[column];
      const nextValue = nextValues[column];
      const pluginSettings = columnMeta.columnSorting;
      const compareFunctionFactory5 = pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory : getCompareFunctionFactory(columnMeta.type);
      const compareResult = compareFunctionFactory5(sortingOrder, columnMeta, pluginSettings)(value, nextValue);
      return compareResult;
    }(0);
  };
}

// node_modules/handsontable/plugins/columnSorting/columnSorting.mjs
var PLUGIN_KEY7 = "columnSorting";
var PLUGIN_PRIORITY6 = 50;
var APPEND_COLUMN_CONFIG_STRATEGY = "append";
var REPLACE_COLUMN_CONFIG_STRATEGY = "replace";
registerRootComparator(PLUGIN_KEY7, rootComparator);
pluginHooks_default.getSingleton().register("beforeColumnSort");
pluginHooks_default.getSingleton().register("afterColumnSort");
var ColumnSorting = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY7;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY6;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.columnStatesManager = null;
    this.columnMetaCache = null;
    this.pluginKey = PLUGIN_KEY7;
    this.indexesSequenceCache = null;
  }
  /**
   * Checks if the plugin is enabled in the Handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ColumnSorting#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[this.pluginKey];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.columnStatesManager = new ColumnStatesManager(this.hot, `${this.pluginKey}.sortingStates`);
    this.columnMetaCache = new PhysicalIndexToValueMap((physicalIndex) => {
      let visualIndex = this.hot.toVisualColumn(physicalIndex);
      if (visualIndex === null) {
        visualIndex = physicalIndex;
      }
      return this.getMergedPluginSettings(visualIndex);
    });
    this.hot.columnIndexMapper.registerMap(`${this.pluginKey}.columnMeta`, this.columnMetaCache);
    this.addHook("afterGetColHeader", (column, TH) => this.onAfterGetColHeader(column, TH));
    this.addHook("beforeOnCellMouseDown", function() {
      return _this.onBeforeOnCellMouseDown(...arguments);
    });
    this.addHook("afterOnCellMouseDown", (event2, target) => this.onAfterOnCellMouseDown(event2, target));
    this.addHook("afterInit", () => this.loadOrSortBySettings());
    this.addHook("afterLoadData", function() {
      return _this.onAfterLoadData(...arguments);
    });
    if (this.hot.view) {
      this.loadOrSortBySettings();
    }
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    const clearColHeader = (column, TH) => {
      const headerSpanElement = getHeaderSpanElement(TH);
      if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
        return;
      }
      this.updateHeaderClasses(headerSpanElement);
    };
    this.hot.addHook("afterGetColHeader", clearColHeader);
    this.hot.addHookOnce("afterViewRender", () => {
      this.hot.removeHook("afterGetColHeader", clearColHeader);
    });
    this.hot.batchExecution(() => {
      if (this.indexesSequenceCache !== null) {
        this.hot.rowIndexMapper.setIndexesSequence(this.indexesSequenceCache.getValues());
        this.hot.rowIndexMapper.unregisterMap(this.pluginKey);
      }
    }, true);
    this.hot.columnIndexMapper.unregisterMap(`${this.pluginKey}.columnMeta`);
    this.columnStatesManager.destroy();
    this.columnMetaCache = null;
    this.columnStatesManager = null;
    super.disablePlugin();
  }
  // DIFF - MultiColumnSorting & ColumnSorting: changed function documentation.
  /**
   * Sorts the table by chosen columns and orders.
   *
   * @param {undefined|object} sortConfig Single column sort configuration. The configuration object contains `column` and `sortOrder` properties.
   * First of them contains visual column index, the second one contains sort order (`asc` for ascending, `desc` for descending).
   *
   * **Note**: Please keep in mind that every call of `sort` function set an entirely new sort order. Previous sort configs aren't preserved.
   *
   * @example
   * ```js
   * // sort ascending first visual column
   * hot.getPlugin('columnSorting').sort({ column: 0, sortOrder: 'asc' });
   * ```
   *
   * @fires Hooks#beforeColumnSort
   * @fires Hooks#afterColumnSort
   */
  sort(sortConfig) {
    const currentSortConfig = this.getSortConfig();
    const destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
    const sortPossible = this.areValidSortConfigs(destinationSortConfigs);
    const allowSort = this.hot.runHooks("beforeColumnSort", currentSortConfig, destinationSortConfigs, sortPossible);
    if (allowSort === false) {
      return;
    }
    if (currentSortConfig.length === 0 && this.indexesSequenceCache === null) {
      this.indexesSequenceCache = this.hot.rowIndexMapper.registerMap(this.pluginKey, new IndexesSequence());
      this.indexesSequenceCache.setValues(this.hot.rowIndexMapper.getIndexesSequence());
    }
    if (sortPossible) {
      this.columnStatesManager.setSortStates(destinationSortConfigs);
      this.sortByPresetSortStates(destinationSortConfigs);
      this.saveAllSortSettings(destinationSortConfigs);
    }
    this.hot.runHooks("afterColumnSort", currentSortConfig, sortPossible ? destinationSortConfigs : currentSortConfig, sortPossible);
    if (sortPossible) {
      this.hot.render();
      this.hot.forceFullRender = false;
      this.hot.view.render();
    }
  }
  /**
   * Clear the sort performed on the table.
   */
  clearSort() {
    this.sort([]);
  }
  /**
   * Checks if the table is sorted (any column have to be sorted).
   *
   * @returns {boolean}
   */
  isSorted() {
    return this.enabled && !this.columnStatesManager.isListOfSortedColumnsEmpty();
  }
  /**
   * Get sort configuration for particular column or for all sorted columns. Objects contain `column` and `sortOrder` properties.
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key. They are handled by the `sort` function.
   *
   * @param {number} [column] Visual column index.
   * @returns {undefined|object|Array}
   */
  getSortConfig(column) {
    if (isDefined(column)) {
      return this.columnStatesManager.getColumnSortState(column);
    }
    return this.columnStatesManager.getSortStates();
  }
  /**
   * @description
   * Warn: Useful mainly for providing server side sort implementation (see in the example below). It doesn't sort the data set. It just sets sort configuration for all sorted columns.
   * Note: Please keep in mind that this method doesn't re-render the table.
   *
   * @example
   * ```js
   * beforeColumnSort: function(currentSortConfig, destinationSortConfigs) {
   *   const columnSortPlugin = this.getPlugin('columnSorting');
   *
   *   columnSortPlugin.setSortConfig(destinationSortConfigs);
   *
   *   // const newData = ... // Calculated data set, ie. from an AJAX call.
   *
   *   this.loadData(newData); // Load new data set and re-render the table.
   *
   *   return false; // The blockade for the default sort action.
   * }
   * ```
   *
   * @param {undefined|object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   */
  setSortConfig(sortConfig) {
    const destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
    if (this.areValidSortConfigs(destinationSortConfigs)) {
      this.columnStatesManager.setSortStates(destinationSortConfigs);
    }
  }
  /**
   * Get normalized sort configs.
   *
   * @private
   * @param {object|Array} [sortConfig=[]] Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   * @returns {Array}
   */
  getNormalizedSortConfigs() {
    let sortConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (Array.isArray(sortConfig)) {
      return sortConfig.slice(0, 1);
    }
    return [sortConfig];
  }
  /**
   * Get if sort configs are valid.
   *
   * @private
   * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
   * @returns {boolean}
   */
  areValidSortConfigs(sortConfigs) {
    const numberOfColumns = this.hot.countCols();
    return areValidSortStates(sortConfigs) && sortConfigs.every((_ref2) => {
      let {
        column
      } = _ref2;
      return column <= numberOfColumns && column >= 0;
    });
  }
  /**
   * Saves all sorting settings. Saving works only when {@link Options#persistentState} option is enabled.
   *
   * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
   *
   * @private
   * @fires Hooks#persistentStateSave
   */
  saveAllSortSettings(sortConfigs) {
    const allSortSettings = this.columnStatesManager.getAllColumnsProperties();
    const translateColumnToPhysical = (_ref2) => {
      let {
        column: visualColumn,
        ...restOfProperties
      } = _ref2;
      return {
        column: this.hot.toPhysicalColumn(visualColumn),
        ...restOfProperties
      };
    };
    allSortSettings.initialConfig = arrayMap(sortConfigs, translateColumnToPhysical);
    this.hot.runHooks("persistentStateSave", "columnSorting", allSortSettings);
  }
  /**
   * Get all saved sorting settings. Loading works only when {@link Options#persistentState} option is enabled.
   *
   * @private
   * @returns {object} Previously saved sort settings.
   *
   * @fires Hooks#persistentStateLoad
   */
  getAllSavedSortSettings() {
    const storedAllSortSettings = {};
    this.hot.runHooks("persistentStateLoad", "columnSorting", storedAllSortSettings);
    const allSortSettings = storedAllSortSettings.value;
    const translateColumnToVisual = (_ref3) => {
      let {
        column: physicalColumn,
        ...restOfProperties
      } = _ref3;
      return {
        column: this.hot.toVisualColumn(physicalColumn),
        ...restOfProperties
      };
    };
    if (isDefined(allSortSettings) && Array.isArray(allSortSettings.initialConfig)) {
      allSortSettings.initialConfig = arrayMap(allSortSettings.initialConfig, translateColumnToVisual);
    }
    return allSortSettings;
  }
  /**
   * Get next sort configuration for particular column. Object contain `column` and `sortOrder` properties.
   *
   * **Note**: Please keep in mind that returned object expose **visual** column index under the `column` key.
   *
   * @private
   * @param {number} column Visual column index.
   * @returns {undefined|object}
   */
  getColumnNextConfig(column) {
    const sortOrder = this.columnStatesManager.getSortOrderOfColumn(column);
    if (isDefined(sortOrder)) {
      const nextSortOrder = getNextSortOrder(sortOrder);
      if (isDefined(nextSortOrder)) {
        return {
          column,
          sortOrder: nextSortOrder
        };
      }
      return;
    }
    const nrOfColumns = this.hot.countCols();
    if (Number.isInteger(column) && column >= 0 && column < nrOfColumns) {
      return {
        column,
        sortOrder: getNextSortOrder()
      };
    }
  }
  /**
   * Get sort configuration with "next order" for particular column.
   *
   * @private
   * @param {number} columnToChange Visual column index of column which order will be changed.
   * @param {string} strategyId ID of strategy. Possible values: 'append' and 'replace'. The first one
   * change order of particular column and change it's position in the sort queue to the last one. The second one
   * just change order of particular column.
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
   *
   * @returns {Array}
   */
  getNextSortConfig(columnToChange) {
    let strategyId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : APPEND_COLUMN_CONFIG_STRATEGY;
    const indexOfColumnToChange = this.columnStatesManager.getIndexOfColumnInSortQueue(columnToChange);
    const isColumnSorted = indexOfColumnToChange !== -1;
    const currentSortConfig = this.getSortConfig();
    const nextColumnConfig = this.getColumnNextConfig(columnToChange);
    if (isColumnSorted) {
      if (isUndefined2(nextColumnConfig)) {
        return [...currentSortConfig.slice(0, indexOfColumnToChange), ...currentSortConfig.slice(indexOfColumnToChange + 1)];
      }
      if (strategyId === APPEND_COLUMN_CONFIG_STRATEGY) {
        return [...currentSortConfig.slice(0, indexOfColumnToChange), ...currentSortConfig.slice(indexOfColumnToChange + 1), nextColumnConfig];
      } else if (strategyId === REPLACE_COLUMN_CONFIG_STRATEGY) {
        return [...currentSortConfig.slice(0, indexOfColumnToChange), nextColumnConfig, ...currentSortConfig.slice(indexOfColumnToChange + 1)];
      }
    }
    if (isDefined(nextColumnConfig)) {
      return currentSortConfig.concat(nextColumnConfig);
    }
    return currentSortConfig;
  }
  /**
   * Get plugin's column config for the specified column index.
   *
   * @private
   * @param {object} columnConfig Configuration inside `columns` property for the specified column index.
   * @returns {object}
   */
  getPluginColumnConfig(columnConfig) {
    if (isObject2(columnConfig)) {
      const pluginColumnConfig = columnConfig[this.pluginKey];
      if (isObject2(pluginColumnConfig)) {
        return pluginColumnConfig;
      }
    }
    return {};
  }
  /**
   * Get plugin settings related properties, properly merged from cascade settings.
   *
   * @private
   * @param {number} column Visual column index.
   * @returns {object}
   */
  getMergedPluginSettings(column) {
    const pluginMainSettings = this.hot.getSettings()[this.pluginKey];
    const storedColumnProperties = this.columnStatesManager.getAllColumnsProperties();
    const cellMeta = this.hot.getCellMeta(0, column);
    const columnMeta = Object.getPrototypeOf(cellMeta);
    if (Array.isArray(columnMeta.columns)) {
      return Object.assign(storedColumnProperties, pluginMainSettings, this.getPluginColumnConfig(columnMeta.columns[column]));
    } else if (isFunction2(columnMeta.columns)) {
      return Object.assign(storedColumnProperties, pluginMainSettings, this.getPluginColumnConfig(columnMeta.columns(column)));
    }
    return Object.assign(storedColumnProperties, pluginMainSettings);
  }
  /**
   * Get copy of settings for first cell in the column.
   *
   * @private
   * @param {number} column Visual column index.
   * @returns {object}
   */
  // TODO: Workaround. Inheriting of non-primitive cell meta values doesn't work. Instead of getting properties from column meta we call this function.
  // TODO: Remove test named: "should not break the dataset when inserted new row" (#5431).
  getFirstCellSettings(column) {
    const cellMeta = this.hot.getCellMeta(0, column);
    const cellMetaCopy = Object.create(cellMeta);
    cellMetaCopy[this.pluginKey] = this.columnMetaCache.getValueAtIndex(this.hot.toPhysicalColumn(column));
    return cellMetaCopy;
  }
  /**
   * Get number of rows which should be sorted.
   *
   * @private
   * @param {number} numberOfRows Total number of displayed rows.
   * @returns {number}
   */
  getNumberOfRowsToSort(numberOfRows) {
    const settings = this.hot.getSettings();
    if (settings.maxRows <= numberOfRows) {
      return settings.maxRows;
    }
    return numberOfRows - settings.minSpareRows;
  }
  /**
   * Performs the sorting using a stable sort function basing on internal state of sorting.
   *
   * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
   * @private
   */
  sortByPresetSortStates(sortConfigs) {
    if (sortConfigs.length === 0) {
      this.hot.rowIndexMapper.setIndexesSequence(this.indexesSequenceCache.getValues());
      return;
    }
    const indexesWithData = [];
    const numberOfRows = this.hot.countRows();
    const getDataForSortedColumns = (visualRowIndex) => arrayMap(sortConfigs, (sortConfig) => this.hot.getDataAtCell(visualRowIndex, sortConfig.column));
    for (let visualRowIndex = 0; visualRowIndex < this.getNumberOfRowsToSort(numberOfRows); visualRowIndex += 1) {
      indexesWithData.push([this.hot.toPhysicalRow(visualRowIndex)].concat(getDataForSortedColumns(visualRowIndex)));
    }
    const indexesBefore = arrayMap(indexesWithData, (indexWithData) => indexWithData[0]);
    sort(indexesWithData, this.pluginKey, arrayMap(sortConfigs, (sortConfig) => sortConfig.sortOrder), arrayMap(sortConfigs, (sortConfig) => this.getFirstCellSettings(sortConfig.column)));
    for (let visualRowIndex = indexesWithData.length; visualRowIndex < numberOfRows; visualRowIndex += 1) {
      indexesWithData.push([visualRowIndex].concat(getDataForSortedColumns(visualRowIndex)));
    }
    const indexesAfter = arrayMap(indexesWithData, (indexWithData) => indexWithData[0]);
    const indexMapping = new Map(arrayMap(indexesBefore, (indexBefore, indexInsideArray) => [indexBefore, indexesAfter[indexInsideArray]]));
    const newIndexesSequence = arrayMap(this.hot.rowIndexMapper.getIndexesSequence(), (physicalIndex) => {
      if (indexMapping.has(physicalIndex)) {
        return indexMapping.get(physicalIndex);
      }
      return physicalIndex;
    });
    this.hot.rowIndexMapper.setIndexesSequence(newIndexesSequence);
  }
  /**
   * Load saved settings or sort by predefined plugin configuration.
   *
   * @private
   */
  loadOrSortBySettings() {
    const storedAllSortSettings = this.getAllSavedSortSettings();
    if (isObject2(storedAllSortSettings)) {
      this.sortBySettings(storedAllSortSettings);
    } else {
      const allSortSettings = this.hot.getSettings()[this.pluginKey];
      this.sortBySettings(allSortSettings);
    }
  }
  /**
   * Sort the table by provided configuration.
   *
   * @private
   * @param {object} allSortSettings All sort config settings. Object may contain `initialConfig`, `indicator`,
   * `sortEmptyCells`, `headerAction` and `compareFunctionFactory` properties.
   */
  sortBySettings(allSortSettings) {
    if (isObject2(allSortSettings)) {
      this.columnStatesManager.updateAllColumnsProperties(allSortSettings);
      const initialConfig = allSortSettings.initialConfig;
      if (Array.isArray(initialConfig) || isObject2(initialConfig)) {
        this.sort(initialConfig);
      }
    } else {
      this.hot.render();
    }
  }
  /**
   * Callback for the `onAfterGetColHeader` hook. Adds column sorting CSS classes.
   *
   * @private
   * @param {number} column Visual column index.
   * @param {Element} TH TH HTML element.
   */
  onAfterGetColHeader(column, TH) {
    const headerSpanElement = getHeaderSpanElement(TH);
    if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
      return;
    }
    const pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
    const showSortIndicator = pluginSettingsForColumn.indicator;
    const headerActionEnabled = pluginSettingsForColumn.headerAction;
    this.updateHeaderClasses(headerSpanElement, this.columnStatesManager, column, showSortIndicator, headerActionEnabled);
  }
  /**
   * Update header classes.
   *
   * @private
   * @param {HTMLElement} headerSpanElement Header span element.
   * @param {...*} args Extra arguments for helpers.
   */
  updateHeaderClasses(headerSpanElement) {
    removeClass(headerSpanElement, getClassesToRemove(headerSpanElement));
    if (this.enabled !== false) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      addClass(headerSpanElement, getClassesToAdd(...args));
    }
  }
  /**
   * Overwriting base plugin's `onUpdateSettings` method. Please keep in mind that `onAfterUpdateSettings` isn't called
   * for `updateSettings` in specific situations.
   *
   * @private
   * @param {object} newSettings New settings object.
   */
  onUpdateSettings(newSettings) {
    super.onUpdateSettings();
    if (this.columnMetaCache !== null) {
      this.columnMetaCache.init(this.hot.columnIndexMapper.getNumberOfIndexes());
    }
    if (isDefined(newSettings[this.pluginKey])) {
      this.sortBySettings(newSettings[this.pluginKey]);
    }
  }
  /**
   * Callback for the `afterLoadData` hook.
   *
   * @private
   * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.
   */
  onAfterLoadData(initialLoad) {
    if (initialLoad === true) {
      if (this.hot.view) {
        this.loadOrSortBySettings();
      }
    }
  }
  /**
   * Indicates if clickable header was clicked.
   *
   * @private
   * @param {MouseEvent} event The `mousedown` event.
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  wasClickableHeaderClicked(event2, column) {
    const pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
    const headerActionEnabled = pluginSettingsForColumn.headerAction;
    return headerActionEnabled && event2.target.nodeName === "SPAN";
  }
  /**
   * Changes the behavior of selection / dragging.
   *
   * @private
   * @param {MouseEvent} event The `mousedown` event.
   * @param {CellCoords} coords Visual coordinates.
   * @param {HTMLElement} TD The cell element.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  onBeforeOnCellMouseDown(event2, coords, TD, controller) {
    if (wasHeaderClickedProperly(coords.row, coords.col, event2) === false) {
      return;
    }
    if (this.wasClickableHeaderClicked(event2, coords.col) && this.hot.getShortcutManager().isCtrlPressed()) {
      controller.column = true;
    }
  }
  /**
   * Callback for the `onAfterOnCellMouseDown` hook.
   *
   * @private
   * @param {Event} event Event which are provided by hook.
   * @param {CellCoords} coords Visual coords of the selected cell.
   */
  onAfterOnCellMouseDown(event2, coords) {
    if (wasHeaderClickedProperly(coords.row, coords.col, event2) === false) {
      return;
    }
    if (this.wasClickableHeaderClicked(event2, coords.col)) {
      if (this.hot.getShortcutManager().isCtrlPressed()) {
        this.hot.deselectCell();
        this.hot.selectColumns(coords.col);
      }
      this.sort(this.getColumnNextConfig(coords.col));
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    var _this$columnStatesMan;
    (_this$columnStatesMan = this.columnStatesManager) === null || _this$columnStatesMan === void 0 || _this$columnStatesMan.destroy();
    super.destroy();
  }
};

// node_modules/handsontable/plugins/columnSummary/endpoints.mjs
var Endpoints = class {
  constructor(plugin, settings) {
    this.plugin = plugin;
    this.hot = this.plugin.hot;
    this.endpoints = [];
    this.settings = settings;
    this.settingsType = "array";
    this.currentEndpoint = null;
    this.cellsToSetCache = [];
  }
  /**
   * Get a single endpoint object.
   *
   * @param {number} index Index of the endpoint.
   * @returns {object}
   */
  getEndpoint(index2) {
    if (this.settingsType === "function") {
      return this.fillMissingEndpointData(this.settings)[index2];
    }
    return this.endpoints[index2];
  }
  /**
   * Get an array with all the endpoints.
   *
   * @returns {Array}
   */
  getAllEndpoints() {
    if (this.settingsType === "function") {
      return this.fillMissingEndpointData(this.settings);
    }
    return this.endpoints;
  }
  /**
   * Used to fill the blanks in the endpoint data provided by a settings function.
   *
   * @private
   * @param {Function} func Function provided in the HOT settings.
   * @returns {Array} An array of endpoints.
   */
  fillMissingEndpointData(func) {
    return this.parseSettings(func.call(this));
  }
  /**
   * Parse plugin's settings.
   *
   * @param {Array} settings The settings array.
   * @returns {object[]}
   */
  parseSettings(settings) {
    const endpointsArray = [];
    let settingsArray = settings;
    if (!settingsArray && typeof this.settings === "function") {
      this.settingsType = "function";
      return;
    }
    if (!settingsArray) {
      settingsArray = this.settings;
    }
    arrayEach(settingsArray, (val) => {
      const newEndpoint = {};
      this.assignSetting(val, newEndpoint, "ranges", [[0, this.hot.countRows() - 1]]);
      this.assignSetting(val, newEndpoint, "reversedRowCoords", false);
      this.assignSetting(val, newEndpoint, "destinationRow", new Error(`
        You must provide a destination row for the Column Summary plugin in order to work properly!
      `));
      this.assignSetting(val, newEndpoint, "destinationColumn", new Error(`
        You must provide a destination column for the Column Summary plugin in order to work properly!
      `));
      this.assignSetting(val, newEndpoint, "sourceColumn", val.destinationColumn);
      this.assignSetting(val, newEndpoint, "type", "sum");
      this.assignSetting(val, newEndpoint, "forceNumeric", false);
      this.assignSetting(val, newEndpoint, "suppressDataTypeErrors", true);
      this.assignSetting(val, newEndpoint, "suppressDataTypeErrors", true);
      this.assignSetting(val, newEndpoint, "customFunction", null);
      this.assignSetting(val, newEndpoint, "readOnly", true);
      this.assignSetting(val, newEndpoint, "roundFloat", false);
      endpointsArray.push(newEndpoint);
    });
    return endpointsArray;
  }
  /**
   * Setter for the internal setting objects.
   *
   * @param {object} settings Object with the settings.
   * @param {object} endpoint Contains information about the endpoint for the the calculation.
   * @param {string} name Settings name.
   * @param {object} defaultValue Default value for the settings.
   */
  assignSetting(settings, endpoint, name, defaultValue) {
    if (name === "ranges" && settings[name] === void 0) {
      endpoint[name] = defaultValue;
      return;
    } else if (name === "ranges" && settings[name].length === 0) {
      return;
    }
    if (settings[name] === void 0) {
      if (defaultValue instanceof Error) {
        throw defaultValue;
      }
      endpoint[name] = defaultValue;
    } else {
      if (name === "destinationRow" && endpoint.reversedRowCoords) {
        endpoint[name] = this.hot.countRows() - settings[name] - 1;
      } else {
        endpoint[name] = settings[name];
      }
    }
  }
  /**
   * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.
   *
   * @private
   * @param {string} action Type of the action performed.
   * @param {number} index Row/column index.
   * @param {number} number Number of rows/columns added/removed.
   */
  resetSetupBeforeStructureAlteration(action, index2, number) {
    if (this.settingsType !== "function") {
      return;
    }
    const type = action.indexOf("row") > -1 ? "row" : "col";
    const endpoints = this.getAllEndpoints();
    arrayEach(endpoints, (val) => {
      if (type === "row" && val.destinationRow >= index2) {
        if (action === "insert_row") {
          val.alterRowOffset = number;
        } else if (action === "remove_row") {
          val.alterRowOffset = -1 * number;
        }
      }
      if (type === "col" && val.destinationColumn >= index2) {
        if (action === "insert_col") {
          val.alterColumnOffset = number;
        } else if (action === "remove_col") {
          val.alterColumnOffset = -1 * number;
        }
      }
    });
    this.resetAllEndpoints(endpoints, false);
  }
  /**
   * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality
   * after changing the table structure.
   *
   * @private
   * @param {string} action Type of the action performed.
   * @param {number} index Row/column index.
   * @param {number} number Number of rows/columns added/removed.
   * @param {Array} [logicRows] Array of the logical indexes.
   * @param {string} [source] Source of change.
   * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.
   */
  resetSetupAfterStructureAlteration(action, index2, number, logicRows, source) {
    let forceRefresh = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    if (this.settingsType === "function") {
      const beforeViewRenderCallback = () => {
        this.hot.removeHook("beforeViewRender", beforeViewRenderCallback);
        return this.refreshAllEndpoints();
      };
      this.hot.addHookOnce("beforeViewRender", beforeViewRenderCallback);
      return;
    }
    const type = action.indexOf("row") > -1 ? "row" : "col";
    const multiplier = action.indexOf("remove") > -1 ? -1 : 1;
    const endpoints = this.getAllEndpoints();
    const rowMoving = action.indexOf("move_row") === 0;
    const placeOfAlteration = index2;
    arrayEach(endpoints, (val) => {
      if (type === "row" && val.destinationRow >= placeOfAlteration) {
        val.alterRowOffset = multiplier * number;
      }
      if (type === "col" && val.destinationColumn >= placeOfAlteration) {
        val.alterColumnOffset = multiplier * number;
      }
    });
    this.resetAllEndpoints(endpoints, !rowMoving);
    if (rowMoving) {
      arrayEach(endpoints, (endpoint) => {
        this.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);
        this.recreatePhysicalRanges(endpoint);
        this.clearOffsetInformation(endpoint);
      });
    } else {
      arrayEach(endpoints, (endpoint) => {
        this.shiftEndpointCoordinates(endpoint, placeOfAlteration);
      });
    }
    if (forceRefresh) {
      this.refreshAllEndpoints();
    }
  }
  /**
   * Clear the offset information from the endpoint object.
   *
   * @private
   * @param {object} endpoint And endpoint object.
   */
  clearOffsetInformation(endpoint) {
    endpoint.alterRowOffset = void 0;
    endpoint.alterColumnOffset = void 0;
  }
  /**
   * Extend the row ranges for the provided endpoint.
   *
   * @private
   * @param {object} endpoint The endpoint object.
   * @param {number} placeOfAlteration Index of the row where the alteration takes place.
   * @param {number} previousPosition Previous endpoint result position.
   * @param {number} offset Offset generated by the alteration.
   */
  extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset3) {
    arrayEach(endpoint.ranges, (range) => {
      if (range[1]) {
        if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {
          if (previousPosition > range[1]) {
            range[1] += offset3;
          } else if (previousPosition < range[0]) {
            range[0] -= offset3;
          }
        } else if (previousPosition >= range[0] && previousPosition <= range[1]) {
          range[1] -= offset3;
          if (placeOfAlteration <= range[0]) {
            range[0] += 1;
            range[1] += 1;
          }
        }
      }
    });
  }
  /**
   * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.
   *
   * @private
   * @param {object} endpoint An endpoint object.
   */
  recreatePhysicalRanges(endpoint) {
    const ranges = endpoint.ranges;
    const newRanges = [];
    const allIndexes = [];
    arrayEach(ranges, (range) => {
      const newRange = [];
      if (range[1]) {
        for (let i = range[0]; i <= range[1]; i++) {
          newRange.push(this.hot.toPhysicalRow(i));
        }
      } else {
        newRange.push(this.hot.toPhysicalRow(range[0]));
      }
      allIndexes.push(newRange);
    });
    arrayEach(allIndexes, (range) => {
      let newRange = [];
      arrayEach(range, (coord, index2) => {
        if (index2 === 0) {
          newRange.push(coord);
        } else if (range[index2] !== range[index2 - 1] + 1) {
          newRange.push(range[index2 - 1]);
          newRanges.push(newRange);
          newRange = [];
          newRange.push(coord);
        }
        if (index2 === range.length - 1) {
          newRange.push(coord);
          newRanges.push(newRange);
        }
      });
    });
    endpoint.ranges = newRanges;
  }
  /**
   * Shifts the endpoint coordinates by the defined offset.
   *
   * @private
   * @param {object} endpoint Endpoint object.
   * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.
   */
  shiftEndpointCoordinates(endpoint, offsetStartIndex) {
    if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {
      endpoint.destinationRow += endpoint.alterRowOffset || 0;
      arrayEach(endpoint.ranges, (element) => {
        arrayEach(element, (subElement, j) => {
          if (subElement >= offsetStartIndex) {
            element[j] += endpoint.alterRowOffset || 0;
          }
        });
      });
    } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {
      endpoint.destinationColumn += endpoint.alterColumnOffset || 0;
      endpoint.sourceColumn += endpoint.alterColumnOffset || 0;
    }
  }
  /**
   * Resets (removes) the endpoints from the table.
   *
   * @param {Array} [endpoints] Array containing the endpoints.
   * @param {boolean} [useOffset=true] Use the cell offset value.
   */
  resetAllEndpoints() {
    let endpoints = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getAllEndpoints();
    let useOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const anyEndpointOutOfRange = endpoints.some((endpoint) => {
      const alterRowOffset = endpoint.alterRowOffset || 0;
      const alterColOffset = endpoint.alterColumnOffset || 0;
      if (endpoint.destinationRow + alterRowOffset >= this.hot.countRows() || endpoint.destinationColumn + alterColOffset >= this.hot.countCols()) {
        return true;
      }
      return false;
    });
    if (anyEndpointOutOfRange) {
      return;
    }
    this.cellsToSetCache = [];
    arrayEach(endpoints, (endpoint) => {
      this.resetEndpointValue(endpoint, useOffset);
    });
    this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
    this.cellsToSetCache = [];
  }
  /**
   * Calculate and refresh all defined endpoints.
   */
  refreshAllEndpoints() {
    this.cellsToSetCache = [];
    arrayEach(this.getAllEndpoints(), (value) => {
      this.currentEndpoint = value;
      this.plugin.calculate(value);
      this.setEndpointValue(value, "init");
    });
    this.currentEndpoint = null;
    this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
    this.cellsToSetCache = [];
  }
  /**
   * Calculate and refresh endpoints only in the changed columns.
   *
   * @param {Array} changes Array of changes from the `afterChange` hook.
   */
  refreshChangedEndpoints(changes) {
    const needToRefresh = [];
    this.cellsToSetCache = [];
    arrayEach(changes, (value, key, changesObj) => {
      if (`${value[2] || ""}` === `${value[3]}`) {
        return;
      }
      arrayEach(this.getAllEndpoints(), (endpoint, j) => {
        if (this.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {
          needToRefresh.push(j);
        }
      });
    });
    arrayEach(needToRefresh, (value) => {
      this.refreshEndpoint(this.getEndpoint(value));
    });
    this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
    this.cellsToSetCache = [];
  }
  /**
   * Calculate and refresh a single endpoint.
   *
   * @param {object} endpoint Contains the endpoint information.
   */
  refreshEndpoint(endpoint) {
    this.currentEndpoint = endpoint;
    this.plugin.calculate(endpoint);
    this.setEndpointValue(endpoint);
    this.currentEndpoint = null;
  }
  /**
   * Reset the endpoint value.
   *
   * @param {object} endpoint Contains the endpoint information.
   * @param {boolean} [useOffset=true] Use the cell offset value.
   */
  resetEndpointValue(endpoint) {
    let useOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const alterRowOffset = endpoint.alterRowOffset || 0;
    const alterColOffset = endpoint.alterColumnOffset || 0;
    this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), ""]);
  }
  /**
   * Set the endpoint value.
   *
   * @param {object} endpoint Contains the endpoint information.
   * @param {string} [source] Source of the call information.
   * @param {boolean} [render=false] `true` if it needs to render the table afterwards.
   */
  setEndpointValue(endpoint, source) {
    let render = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);
    if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {
      this.throwOutOfBoundsWarning();
      return;
    }
    const destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow);
    if (destinationVisualRow !== null) {
      const cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn);
      if (source === "init" || cellMeta.readOnly !== endpoint.readOnly) {
        cellMeta.readOnly = endpoint.readOnly;
        cellMeta.className = "columnSummaryResult";
      }
    }
    if (endpoint.roundFloat && !isNaN(endpoint.result)) {
      endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);
    }
    if (render) {
      this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, "ColumnSummary.set");
    } else {
      this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);
    }
    endpoint.alterRowOffset = void 0;
    endpoint.alterColumnOffset = void 0;
  }
  /**
   * Throw an error for the calculation range being out of boundaries.
   *
   * @private
   */
  throwOutOfBoundsWarning() {
    warn2("One of the Column Summary plugins' destination points you provided is beyond the table boundaries!");
  }
};
var endpoints_default = Endpoints;

// node_modules/handsontable/plugins/columnSummary/utils.mjs
function isNullishOrNaN(value) {
  return value === null || value === void 0 || isNaN(value);
}

// node_modules/handsontable/plugins/columnSummary/columnSummary.mjs
var PLUGIN_KEY8 = "columnSummary";
var PLUGIN_PRIORITY7 = 220;
var ColumnSummary = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY8;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY7;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.endpoints = null;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ColumnSummary#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY8];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.settings = this.hot.getSettings()[PLUGIN_KEY8];
    this.endpoints = new endpoints_default(this, this.settings);
    this.addHook("afterInit", function() {
      return _this.onAfterInit(...arguments);
    });
    this.addHook("afterChange", function() {
      return _this.onAfterChange(...arguments);
    });
    this.addHook("beforeCreateRow", (index2, amount, source) => this.endpoints.resetSetupBeforeStructureAlteration("insert_row", index2, amount, null, source));
    this.addHook("beforeCreateCol", (index2, amount, source) => this.endpoints.resetSetupBeforeStructureAlteration("insert_col", index2, amount, null, source));
    this.addHook("beforeRemoveRow", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _this.endpoints.resetSetupBeforeStructureAlteration("remove_row", ...args);
    });
    this.addHook("beforeRemoveCol", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.endpoints.resetSetupBeforeStructureAlteration("remove_col", ...args);
    });
    this.addHook("afterCreateRow", (index2, amount, source) => this.endpoints.resetSetupAfterStructureAlteration("insert_row", index2, amount, null, source));
    this.addHook("afterCreateCol", (index2, amount, source) => this.endpoints.resetSetupAfterStructureAlteration("insert_col", index2, amount, null, source));
    this.addHook("afterRemoveRow", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.endpoints.resetSetupAfterStructureAlteration("remove_row", ...args);
    });
    this.addHook("afterRemoveCol", function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.endpoints.resetSetupAfterStructureAlteration("remove_col", ...args);
    });
    this.addHook("afterRowMove", function() {
      return _this.onAfterRowMove(...arguments);
    });
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.endpoints = null;
    this.settings = null;
    this.currentEndpoint = null;
  }
  /**
   * Calculates math for a single endpoint.
   *
   * @private
   * @param {object} endpoint Contains information about the endpoint.
   */
  calculate(endpoint) {
    switch (endpoint.type.toLowerCase()) {
      case "sum":
        endpoint.result = this.calculateSum(endpoint);
        break;
      case "min":
        endpoint.result = this.calculateMinMax(endpoint, endpoint.type);
        break;
      case "max":
        endpoint.result = this.calculateMinMax(endpoint, endpoint.type);
        break;
      case "count":
        endpoint.result = this.countEntries(endpoint);
        break;
      case "average":
        endpoint.result = this.calculateAverage(endpoint);
        break;
      case "custom":
        endpoint.result = endpoint.customFunction.call(this, endpoint);
        break;
      default:
        break;
    }
  }
  /**
   * Calculates sum of the values contained in ranges provided in the plugin config.
   *
   * @private
   * @param {object} endpoint Contains the endpoint information.
   * @returns {number} Sum for the selected range.
   */
  calculateSum(endpoint) {
    let sum = 0;
    objectEach(endpoint.ranges, (range) => {
      sum += this.getPartialSum(range, endpoint.sourceColumn);
    });
    return sum;
  }
  /**
   * Returns partial sum of values from a single row range.
   *
   * @private
   * @param {Array} rowRange Range for the sum.
   * @param {number} col Column index.
   * @returns {number} The partial sum.
   */
  getPartialSum(rowRange, col) {
    let sum = 0;
    let i = rowRange[1] || rowRange[0];
    let cellValue = null;
    let biggestDecimalPlacesCount = 0;
    do {
      cellValue = this.getCellValue(i, col);
      cellValue = isNullishOrNaN(cellValue) ? null : cellValue;
      if (cellValue !== null) {
        const decimalPlaces = (`${cellValue}`.split(".")[1] || []).length || 1;
        if (decimalPlaces > biggestDecimalPlacesCount) {
          biggestDecimalPlacesCount = decimalPlaces;
        }
      }
      sum += cellValue || 0;
      i -= 1;
    } while (i >= rowRange[0]);
    return Math.round(sum * 10 ** biggestDecimalPlacesCount) / 10 ** biggestDecimalPlacesCount;
  }
  /**
   * Calculates the minimal value for the selected ranges.
   *
   * @private
   * @param {object} endpoint Contains the endpoint information.
   * @param {string} type `'min'` or `'max'`.
   * @returns {number} Min or Max value.
   */
  calculateMinMax(endpoint, type) {
    let result = null;
    objectEach(endpoint.ranges, (range) => {
      const partialResult = this.getPartialMinMax(range, endpoint.sourceColumn, type);
      if (result === null && partialResult !== null) {
        result = partialResult;
      }
      if (partialResult !== null) {
        switch (type) {
          case "min":
            result = Math.min(result, partialResult);
            break;
          case "max":
            result = Math.max(result, partialResult);
            break;
          default:
            break;
        }
      }
    });
    return result === null ? "Not enough data" : result;
  }
  /**
   * Returns a local minimum of the provided sub-range.
   *
   * @private
   * @param {Array} rowRange Range for the calculation.
   * @param {number} col Column index.
   * @param {string} type `'min'` or `'max'`.
   * @returns {number|null} Min or max value.
   */
  getPartialMinMax(rowRange, col, type) {
    let result = null;
    let i = rowRange[1] || rowRange[0];
    let cellValue;
    do {
      cellValue = this.getCellValue(i, col);
      cellValue = isNullishOrNaN(cellValue) ? null : cellValue;
      if (result === null) {
        result = cellValue;
      } else if (cellValue !== null) {
        switch (type) {
          case "min":
            result = Math.min(result, cellValue);
            break;
          case "max":
            result = Math.max(result, cellValue);
            break;
          default:
            break;
        }
      }
      i -= 1;
    } while (i >= rowRange[0]);
    return result;
  }
  /**
   * Counts empty cells in the provided row range.
   *
   * @private
   * @param {Array} rowRange Row range for the calculation.
   * @param {number} col Column index.
   * @returns {number} Empty cells count.
   */
  countEmpty(rowRange, col) {
    let cellValue;
    let counter = 0;
    let i = rowRange[1] || rowRange[0];
    do {
      cellValue = this.getCellValue(i, col);
      cellValue = isNullishOrNaN(cellValue) ? null : cellValue;
      if (cellValue === null) {
        counter += 1;
      }
      i -= 1;
    } while (i >= rowRange[0]);
    return counter;
  }
  /**
   * Counts non-empty cells in the provided row range.
   *
   * @private
   * @param {object} endpoint Contains the endpoint information.
   * @returns {number} Entry count.
   */
  countEntries(endpoint) {
    let result = 0;
    const ranges = endpoint.ranges;
    objectEach(ranges, (range) => {
      const partial2 = range[1] === void 0 ? 1 : range[1] - range[0] + 1;
      const emptyCount = this.countEmpty(range, endpoint.sourceColumn);
      result += partial2;
      result -= emptyCount;
    });
    return result;
  }
  /**
   * Calculates the average value from the cells in the range.
   *
   * @private
   * @param {object} endpoint Contains the endpoint information.
   * @returns {number} Avarage value.
   */
  calculateAverage(endpoint) {
    const sum = this.calculateSum(endpoint);
    const entriesCount = this.countEntries(endpoint);
    return sum / entriesCount;
  }
  /**
   * Returns a cell value, taking into consideration a basic validation.
   *
   * @private
   * @param {number} row Row index.
   * @param {number} col Column index.
   * @returns {string} The cell value.
   */
  getCellValue(row, col) {
    const visualRowIndex = this.hot.toVisualRow(row);
    const visualColumnIndex = this.hot.toVisualColumn(col);
    let cellValue = this.hot.getSourceDataAtCell(row, col);
    let cellClassName = "";
    if (visualRowIndex !== null && visualColumnIndex !== null) {
      cellClassName = this.hot.getCellMeta(visualRowIndex, visualColumnIndex).className || "";
    }
    if (cellClassName.indexOf("columnSummaryResult") > -1) {
      return null;
    }
    if (this.endpoints.currentEndpoint.forceNumeric) {
      if (typeof cellValue === "string") {
        cellValue = cellValue.replace(/,/, ".");
      }
      cellValue = parseFloat(cellValue);
    }
    if (isNaN(cellValue)) {
      if (!this.endpoints.currentEndpoint.suppressDataTypeErrors) {
        throw new Error(toSingleLine`ColumnSummary plugin: cell at (${row}, ${col}) is not in a\x20
          numeric format. Cannot do the calculation.`);
      }
    }
    return cellValue;
  }
  /**
   * `afterInit` hook callback.
   *
   * @private
   */
  onAfterInit() {
    this.endpoints.endpoints = this.endpoints.parseSettings();
    this.endpoints.refreshAllEndpoints(true);
  }
  /**
   * `afterChange` hook callback.
   *
   * @private
   * @param {Array} changes 2D array containing information about each of the edited cells.
   * @param {string} source The string that identifies source of changes.
   */
  onAfterChange(changes, source) {
    if (changes && source !== "ColumnSummary.reset" && source !== "ColumnSummary.set" && source !== "loadData") {
      this.endpoints.refreshChangedEndpoints(changes);
    }
  }
  /**
   * `beforeRowMove` hook callback.
   *
   * @private
   * @param {Array} rows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md).
   */
  onAfterRowMove(rows, finalIndex) {
    this.endpoints.resetSetupBeforeStructureAlteration("move_row", rows[0], rows.length, rows, this.pluginName);
    this.endpoints.resetSetupAfterStructureAlteration("move_row", finalIndex, rows.length, rows, this.pluginName);
  }
};

// node_modules/handsontable/plugins/comments/commentEditor.mjs
var CommentEditor = class _CommentEditor {
  static get CLASS_EDITOR_CONTAINER() {
    return "htCommentsContainer";
  }
  static get CLASS_EDITOR() {
    return "htComments";
  }
  static get CLASS_INPUT() {
    return "htCommentTextArea";
  }
  static get CLASS_CELL() {
    return "htCommentCell";
  }
  constructor(rootDocument, isRtl) {
    this.rootDocument = rootDocument;
    this.isRtl = isRtl;
    this.container = null;
    this.editor = this.createEditor();
    this.editorStyle = this.editor.style;
    this.hidden = true;
    this.hide();
  }
  /**
   * Set position of the comments editor according to the  provided x and y coordinates.
   *
   * @param {number} x X position (in pixels).
   * @param {number} y Y position (in pixels).
   */
  setPosition(x, y) {
    this.editorStyle.left = `${x}px`;
    this.editorStyle.top = `${y}px`;
  }
  /**
   * Set the editor size according to the provided arguments.
   *
   * @param {number} width Width in pixels.
   * @param {number} height Height in pixels.
   */
  setSize(width, height) {
    if (width && height) {
      const input = this.getInputElement();
      input.style.width = `${width}px`;
      input.style.height = `${height}px`;
    }
  }
  /**
   * Returns the size of the comments editor.
   *
   * @returns {{ width: number, height: number }}
   */
  getSize() {
    return {
      width: outerWidth(this.getInputElement()),
      height: outerHeight(this.getInputElement())
    };
  }
  /**
   * Reset the editor size to its initial state.
   */
  resetSize() {
    const input = this.getInputElement();
    input.style.width = "";
    input.style.height = "";
  }
  /**
   * Set the read-only state for the comments editor.
   *
   * @param {boolean} state The new read only state.
   */
  setReadOnlyState(state) {
    const input = this.getInputElement();
    input.readOnly = state;
  }
  /**
   * Show the comments editor.
   */
  show() {
    this.editorStyle.display = "block";
    this.hidden = false;
  }
  /**
   * Hide the comments editor.
   */
  hide() {
    if (!this.hidden) {
      this.editorStyle.display = "none";
    }
    this.hidden = true;
  }
  /**
   * Checks if the editor is visible.
   *
   * @returns {boolean}
   */
  isVisible() {
    return this.editorStyle.display === "block";
  }
  /**
   * Set the comment value.
   *
   * @param {string} [value] The value to use.
   */
  setValue() {
    let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const comment = value || "";
    this.getInputElement().value = comment;
  }
  /**
   * Get the comment value.
   *
   * @returns {string}
   */
  getValue() {
    return this.getInputElement().value;
  }
  /**
   * Checks if the comment input element is focused.
   *
   * @returns {boolean}
   */
  isFocused() {
    return this.rootDocument.activeElement === this.getInputElement();
  }
  /**
   * Focus the comments input element.
   */
  focus() {
    this.getInputElement().focus();
  }
  /**
   * Create the `textarea` to be used as a comments editor.
   *
   * @returns {HTMLElement}
   */
  createEditor() {
    const editor = this.rootDocument.createElement("div");
    const textArea = this.rootDocument.createElement("textarea");
    editor.style.display = "none";
    this.container = this.rootDocument.createElement("div");
    this.container.setAttribute("dir", this.isRtl ? "rtl" : "ltr");
    addClass(this.container, _CommentEditor.CLASS_EDITOR_CONTAINER);
    this.rootDocument.body.appendChild(this.container);
    addClass(editor, _CommentEditor.CLASS_EDITOR);
    addClass(textArea, _CommentEditor.CLASS_INPUT);
    editor.appendChild(textArea);
    this.container.appendChild(editor);
    return editor;
  }
  /**
   * Get the input element.
   *
   * @returns {HTMLElement}
   */
  getInputElement() {
    return this.editor.querySelector(`.${_CommentEditor.CLASS_INPUT}`);
  }
  /**
   * Destroy the comments editor.
   */
  destroy() {
    const containerParentElement = this.container ? this.container.parentNode : null;
    this.editor.parentNode.removeChild(this.editor);
    this.editor = null;
    this.editorStyle = null;
    if (containerParentElement) {
      containerParentElement.removeChild(this.container);
    }
  }
};
var commentEditor_default = CommentEditor;

// node_modules/handsontable/plugins/contextMenu/predefinedItems/separator.mjs
var KEY = "---------";
function separatorItem() {
  return {
    name: KEY
  };
}

// node_modules/handsontable/plugins/contextMenu/utils.mjs
function normalizeSelection(selRanges) {
  return arrayMap(selRanges, (range) => ({
    start: range.getTopStartCorner(),
    end: range.getBottomEndCorner()
  }));
}
function isSeparator(cell) {
  return hasClass(cell, "htSeparator");
}
function hasSubMenu(cell) {
  return hasClass(cell, "htSubmenu");
}
function isDisabled(cell) {
  return hasClass(cell, "htDisabled");
}
function isSelectionDisabled(cell) {
  return hasClass(cell, "htSelectionDisabled");
}
function getValidSelection(hot) {
  const selected = hot.getSelected();
  if (!selected) {
    return null;
  }
  if (selected[0] < 0) {
    return null;
  }
  return selected;
}
function prepareVerticalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  const replacedClassName = className.replace("htTop", "").replace("htMiddle", "").replace("htBottom", "").replace("  ", "");
  return `${replacedClassName} ${alignment}`;
}
function prepareHorizontalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  const replacedClassName = className.replace("htLeft", "").replace("htCenter", "").replace("htRight", "").replace("htJustify", "").replace("  ", "");
  return `${replacedClassName} ${alignment}`;
}
function getAlignmentClasses(ranges, callback) {
  const classes = {};
  arrayEach(ranges, (range) => {
    range.forAll((row, col) => {
      if (row >= 0 && col >= 0) {
        if (!classes[row]) {
          classes[row] = [];
        }
        classes[row][col] = callback(row, col);
      }
    });
  });
  return classes;
}
function align(ranges, type, alignment, cellDescriptor, propertySetter) {
  arrayEach(ranges, (range) => {
    range.forAll((row, col) => {
      if (row >= 0 && col >= 0) {
        applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter);
      }
    });
  });
}
function applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter) {
  const cellMeta = cellDescriptor(row, col);
  let className = alignment;
  if (cellMeta.className) {
    if (type === "vertical") {
      className = prepareVerticalAlignClass(cellMeta.className, alignment);
    } else {
      className = prepareHorizontalAlignClass(cellMeta.className, alignment);
    }
  }
  propertySetter(row, col, "className", className);
}
function checkSelectionConsistency(ranges, comparator) {
  let result = false;
  if (Array.isArray(ranges)) {
    arrayEach(ranges, (range) => {
      range.forAll((row, col) => {
        if (row >= 0 && col >= 0 && comparator(row, col)) {
          result = true;
          return false;
        }
      });
      return result;
    });
  }
  return result;
}
function markLabelAsSelected(label) {
  return `<span class="selected">${String.fromCharCode(10003)}</span>${label}`;
}
function isItemHidden(item, instance) {
  return !item.hidden || !(typeof item.hidden === "function" && item.hidden.call(instance));
}
function shiftSeparators(items, separator) {
  const result = items.slice(0);
  for (let i = 0; i < result.length; ) {
    if (result[i].name === separator) {
      result.shift();
    } else {
      break;
    }
  }
  return result;
}
function popSeparators(items, separator) {
  let result = items.slice(0);
  result.reverse();
  result = shiftSeparators(result, separator);
  result.reverse();
  return result;
}
function removeDuplicatedSeparators(items) {
  const result = [];
  arrayEach(items, (value, index2) => {
    if (index2 > 0) {
      if (result[result.length - 1].name !== value.name) {
        result.push(value);
      }
    } else {
      result.push(value);
    }
  });
  return result;
}
function filterSeparators(items) {
  let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : KEY;
  let result = items.slice(0);
  result = shiftSeparators(result, separator);
  result = popSeparators(result, separator);
  result = removeDuplicatedSeparators(result);
  return result;
}

// node_modules/handsontable/plugins/comments/displaySwitch.mjs
var DEFAULT_DISPLAY_DELAY = 250;
var DEFAULT_HIDE_DELAY = 250;
var DisplaySwitch = class {
  constructor(displayDelay) {
    this.wasLastActionShow = true;
    this.showDebounced = null;
    this.hidingTimer = null;
    this.updateDelay(displayDelay);
  }
  /**
   * Responsible for hiding comment after proper delay.
   */
  hide() {
    this.wasLastActionShow = false;
    this.hidingTimer = setTimeout(() => {
      if (this.wasLastActionShow === false) {
        this.runLocalHooks("hide");
      }
    }, DEFAULT_HIDE_DELAY);
  }
  /**
   * Responsible for showing comment after proper delay.
   *
   * @param {object} range Coordinates of selected cell.
   */
  show(range) {
    this.wasLastActionShow = true;
    this.showDebounced(range);
  }
  /**
   * Cancel hiding comment.
   */
  cancelHiding() {
    this.wasLastActionShow = true;
    clearTimeout(this.hidingTimer);
    this.hidingTimer = null;
  }
  /**
   * Update the switch settings.
   *
   * @param {number} displayDelay Delay of showing the comments (in milliseconds).
   */
  updateDelay() {
    let displayDelay = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_DISPLAY_DELAY;
    this.showDebounced = debounce((range) => {
      if (this.wasLastActionShow) {
        this.runLocalHooks("show", range.from.row, range.from.col);
      }
    }, displayDelay);
  }
  /**
   * Destroy the switcher.
   */
  destroy() {
    this.clearLocalHooks();
  }
};
mixin(DisplaySwitch, localHooks_default);
var displaySwitch_default = DisplaySwitch;

// node_modules/handsontable/plugins/comments/comments.mjs
var PLUGIN_KEY9 = "comments";
var PLUGIN_PRIORITY8 = 60;
var privatePool8 = /* @__PURE__ */ new WeakMap();
var META_COMMENT = "comment";
var META_COMMENT_VALUE = "value";
var META_STYLE = "style";
var META_READONLY = "readOnly";
var Comments = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY9;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY8;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.editor = null;
    this.displaySwitch = null;
    this.eventManager = null;
    this.range = {};
    this.preventEditorAutoSwitch = false;
    privatePool8.set(this, {
      tempEditorDimensions: {},
      cellBelowCursor: null
    });
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link Comments#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY9];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    if (!this.editor) {
      this.editor = new commentEditor_default(this.hot.rootDocument, this.hot.isRtl());
    }
    if (!this.eventManager) {
      this.eventManager = new eventManager_default(this);
    }
    if (!this.displaySwitch) {
      this.displaySwitch = new displaySwitch_default(this.getDisplayDelaySetting());
    }
    this.addHook("afterContextMenuDefaultOptions", (options) => this.addToContextMenu(options));
    this.addHook("afterRenderer", (TD, row, col, prop, value, cellProperties) => this.onAfterRenderer(TD, cellProperties));
    this.addHook("afterScrollHorizontally", () => this.hide());
    this.addHook("afterScrollVertically", () => this.hide());
    this.addHook("afterBeginEditing", () => this.hide());
    this.displaySwitch.addLocalHook("hide", () => this.hide());
    this.displaySwitch.addLocalHook("show", (row, col) => this.showAtCell(row, col));
    this.registerListeners();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *   - [`comments`](@/api/options.md#comments)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
    this.displaySwitch.updateDelay(this.getDisplayDelaySetting());
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    super.disablePlugin();
  }
  /**
   * Registers all necessary DOM listeners.
   *
   * @private
   */
  registerListeners() {
    const {
      rootDocument
    } = this.hot;
    this.eventManager.addEventListener(rootDocument, "mouseover", (event2) => this.onMouseOver(event2));
    this.eventManager.addEventListener(rootDocument, "mousedown", (event2) => this.onMouseDown(event2));
    this.eventManager.addEventListener(rootDocument, "mouseup", () => this.onMouseUp());
    this.eventManager.addEventListener(this.editor.getInputElement(), "blur", () => this.onEditorBlur());
    this.eventManager.addEventListener(this.editor.getInputElement(), "mousedown", (event2) => this.onEditorMouseDown(event2));
    this.eventManager.addEventListener(this.editor.getInputElement(), "mouseup", (event2) => this.onEditorMouseUp(event2));
  }
  /**
   * Sets the current cell range to be able to use general methods like {@link Comments#setComment}, {@link Comments#removeComment}, {@link Comments#show}.
   *
   * @param {object} range Object with `from` property, each with `row` and `col` properties.
   */
  setRange(range) {
    this.range = range;
  }
  /**
   * Clears the currently selected cell.
   */
  clearRange() {
    this.range = {};
  }
  /**
   * Checks if the event target is a cell containing a comment.
   *
   * @private
   * @param {Event} event DOM event.
   * @returns {boolean}
   */
  targetIsCellWithComment(event2) {
    const closestCell = closest(event2.target, "TD", "TBODY");
    return !!(closestCell && hasClass(closestCell, "htCommentCell") && closest(closestCell, [this.hot.rootElement]));
  }
  /**
   * Checks if the event target is a comment textarea.
   *
   * @private
   * @param {Event} event DOM event.
   * @returns {boolean}
   */
  targetIsCommentTextArea(event2) {
    return this.editor.getInputElement() === event2.target;
  }
  /**
   * Sets a comment for a cell according to the previously set range (see {@link Comments#setRange}).
   *
   * @param {string} value Comment contents.
   */
  setComment(value) {
    if (!this.range.from) {
      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
    }
    const editorValue = this.editor.getValue();
    let comment = "";
    if (value !== null && value !== void 0) {
      comment = value;
    } else if (editorValue !== null && editorValue !== void 0) {
      comment = editorValue;
    }
    const row = this.range.from.row;
    const col = this.range.from.col;
    this.updateCommentMeta(row, col, {
      [META_COMMENT_VALUE]: comment
    });
    this.hot.render();
  }
  /**
   * Sets a comment for a specified cell.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} value Comment contents.
   */
  setCommentAtCell(row, column, value) {
    this.setRange({
      from: this.hot._createCellCoords(row, column)
    });
    this.setComment(value);
  }
  /**
   * Removes a comment from a cell according to previously set range (see {@link Comments#setRange}).
   *
   * @param {boolean} [forceRender=true] If set to `true`, the table will be re-rendered at the end of the operation.
   */
  removeComment() {
    let forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (!this.range.from) {
      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
    }
    this.hot.setCellMeta(this.range.from.row, this.range.from.col, META_COMMENT);
    if (forceRender) {
      this.hot.render();
    }
    this.hide();
  }
  /**
   * Removes a comment from a specified cell.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {boolean} [forceRender=true] If `true`, the table will be re-rendered at the end of the operation.
   */
  removeCommentAtCell(row, column) {
    let forceRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    this.setRange({
      from: this.hot._createCellCoords(row, column)
    });
    this.removeComment(forceRender);
  }
  /**
   * Gets comment from a cell according to previously set range (see {@link Comments#setRange}).
   *
   * @returns {string|undefined} Returns a content of the comment.
   */
  getComment() {
    const row = this.range.from.row;
    const column = this.range.from.col;
    return this.getCommentMeta(row, column, META_COMMENT_VALUE);
  }
  /**
   * Gets comment from a cell at the provided coordinates.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {string|undefined} Returns a content of the comment.
   */
  getCommentAtCell(row, column) {
    return this.getCommentMeta(row, column, META_COMMENT_VALUE);
  }
  /**
   * Shows the comment editor accordingly to the previously set range (see {@link Comments#setRange}).
   *
   * @returns {boolean} Returns `true` if comment editor was shown.
   */
  show() {
    if (!this.range.from) {
      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
    }
    const {
      from: {
        row,
        col
      }
    } = this.range;
    if (row < 0 || row > this.hot.countSourceRows() - 1 || col < 0 || col > this.hot.countSourceCols() - 1) {
      return false;
    }
    const meta = this.hot.getCellMeta(this.range.from.row, this.range.from.col);
    this.editor.setValue(meta[META_COMMENT] ? meta[META_COMMENT][META_COMMENT_VALUE] : "");
    this.editor.show();
    this.refreshEditor(true);
    return true;
  }
  /**
   * Shows comment editor according to cell coordinates.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {boolean} Returns `true` if comment editor was shown.
   */
  showAtCell(row, column) {
    this.setRange({
      from: this.hot._createCellCoords(row, column)
    });
    return this.show();
  }
  /**
   * Hides the comment editor.
   */
  hide() {
    this.editor.hide();
  }
  /**
   * Refreshes comment editor position and styling.
   *
   * @param {boolean} [force=false] If `true` then recalculation will be forced.
   */
  refreshEditor() {
    var _renderableRow, _renderableColumn;
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!force && (!this.range.from || !this.editor.isVisible())) {
      return;
    }
    const {
      rowIndexMapper,
      columnIndexMapper
    } = this.hot;
    const {
      row: visualRow,
      col: visualColumn
    } = this.range.from;
    let renderableRow = rowIndexMapper.getRenderableFromVisualIndex(visualRow);
    let renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(visualColumn);
    const targetingPreviousRow = renderableRow === null;
    this.editor.setPosition(0, 0);
    if (renderableRow === null) {
      renderableRow = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHiddenIndex(visualRow, -1));
    }
    if (renderableColumn === null) {
      renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(visualColumn, -1));
    }
    const isBeforeRenderedRows = renderableRow === null;
    const isBeforeRenderedColumns = renderableColumn === null;
    renderableRow = (_renderableRow = renderableRow) !== null && _renderableRow !== void 0 ? _renderableRow : 0;
    renderableColumn = (_renderableColumn = renderableColumn) !== null && _renderableColumn !== void 0 ? _renderableColumn : 0;
    const {
      rootWindow,
      view: {
        _wt: wt
      }
    } = this.hot;
    const {
      wtTable
    } = wt;
    const TD = wt.getCell({
      row: renderableRow,
      col: renderableColumn
    }, true);
    const commentStyle = this.getCommentMeta(visualRow, visualColumn, META_STYLE);
    if (commentStyle) {
      this.editor.setSize(commentStyle.width, commentStyle.height);
    } else {
      this.editor.resetSize();
    }
    const lastColWidth = isBeforeRenderedColumns ? 0 : wtTable.getStretchedColumnWidth(renderableColumn);
    const lastRowHeight = targetingPreviousRow && !isBeforeRenderedRows ? outerHeight(TD) : 0;
    const {
      left: left2,
      top: top2,
      width: cellWidth,
      height: cellHeight
    } = TD.getBoundingClientRect();
    const {
      width: editorWidth,
      height: editorHeight
    } = this.editor.getSize();
    const {
      innerWidth: innerWidth2,
      innerHeight: innerHeight2
    } = this.hot.rootWindow;
    const documentElement = this.hot.rootDocument.documentElement;
    let x = left2 + rootWindow.scrollX + lastColWidth;
    let y = top2 + rootWindow.scrollY + lastRowHeight;
    if (this.hot.isRtl()) {
      x -= editorWidth + lastColWidth;
    }
    if (this.hot.isLtr() && left2 + cellWidth + editorWidth > innerWidth2) {
      x = left2 + rootWindow.scrollX - editorWidth - 1;
    } else if (this.hot.isRtl() && x < -(documentElement.scrollWidth - documentElement.clientWidth)) {
      x = left2 + rootWindow.scrollX + lastColWidth + 1;
    }
    if (top2 + editorHeight > innerHeight2) {
      y -= editorHeight - cellHeight + 1;
    }
    this.editor.setPosition(x, y);
    this.editor.setReadOnlyState(this.getCommentMeta(visualRow, visualColumn, META_READONLY));
  }
  /**
   * Checks if there is a comment for selected range.
   *
   * @private
   * @returns {boolean}
   */
  checkSelectionCommentsConsistency() {
    const selected = this.hot.getSelectedRangeLast();
    if (!selected) {
      return false;
    }
    let hasComment = false;
    const cell = selected.getTopStartCorner();
    if (this.getCommentMeta(cell.row, cell.col, META_COMMENT_VALUE)) {
      hasComment = true;
    }
    return hasComment;
  }
  /**
   * Sets or update the comment-related cell meta.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} metaObject Object defining all the comment-related meta information.
   */
  updateCommentMeta(row, column, metaObject) {
    const oldComment = this.hot.getCellMeta(row, column)[META_COMMENT];
    let newComment;
    if (oldComment) {
      newComment = deepClone(oldComment);
      deepExtend(newComment, metaObject);
    } else {
      newComment = metaObject;
    }
    this.hot.setCellMeta(row, column, META_COMMENT, newComment);
  }
  /**
   * Gets the comment related meta information.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} property Cell meta property.
   * @returns {Mixed}
   */
  getCommentMeta(row, column, property) {
    const cellMeta = this.hot.getCellMeta(row, column);
    if (!cellMeta[META_COMMENT]) {
      return void 0;
    }
    return cellMeta[META_COMMENT][property];
  }
  /**
   * `mousedown` event callback.
   *
   * @private
   * @param {MouseEvent} event The `mousedown` event.
   */
  onMouseDown(event2) {
    if (!this.hot.view || !this.hot.view._wt) {
      return;
    }
    if (!this.preventEditorAutoSwitch && !this.targetIsCommentTextArea(event2)) {
      const eventCell = closest(event2.target, "TD", "TBODY");
      let coordinates = null;
      if (eventCell) {
        coordinates = this.hot.getCoords(eventCell);
      }
      if (!eventCell || this.range.from && coordinates && (this.range.from.row !== coordinates.row || this.range.from.col !== coordinates.col)) {
        this.hide();
      }
    }
  }
  /**
   * `mouseover` event callback.
   *
   * @private
   * @param {MouseEvent} event The `mouseover` event.
   */
  onMouseOver(event2) {
    const priv = privatePool8.get(this);
    const {
      rootDocument
    } = this.hot;
    if (this.preventEditorAutoSwitch || this.editor.isFocused() || hasClass(event2.target, "wtBorder") || priv.cellBelowCursor === event2.target || !this.editor) {
      return;
    }
    priv.cellBelowCursor = rootDocument.elementFromPoint(event2.clientX, event2.clientY);
    if (this.targetIsCellWithComment(event2)) {
      const range = this.hot._createCellRange(this.hot.getCoords(event2.target));
      this.displaySwitch.show(range);
    } else if (isChildOf(event2.target, rootDocument) && !this.targetIsCommentTextArea(event2)) {
      this.displaySwitch.hide();
    }
  }
  /**
   * `mouseup` event callback.
   *
   * @private
   */
  onMouseUp() {
    this.preventEditorAutoSwitch = false;
  }
  /**
   * The `afterRenderer` hook callback.
   *
   * @private
   * @param {HTMLTableCellElement} TD The rendered `TD` element.
   * @param {object} cellProperties The rendered cell's property object.
   */
  onAfterRenderer(TD, cellProperties) {
    if (cellProperties[META_COMMENT] && cellProperties[META_COMMENT][META_COMMENT_VALUE]) {
      addClass(TD, cellProperties.commentedCellClassName);
    }
  }
  /**
   * `blur` event callback for the comment editor.
   *
   * @private
   */
  onEditorBlur() {
    this.setComment();
  }
  /**
   * `mousedown` hook. Along with `onEditorMouseUp` used to simulate the textarea resizing event.
   *
   * @private
   * @param {MouseEvent} event The `mousedown` event.
   */
  onEditorMouseDown(event2) {
    const priv = privatePool8.get(this);
    priv.tempEditorDimensions = {
      width: outerWidth(event2.target),
      height: outerHeight(event2.target)
    };
  }
  /**
   * `mouseup` hook. Along with `onEditorMouseDown` used to simulate the textarea resizing event.
   *
   * @private
   * @param {MouseEvent} event The `mouseup` event.
   */
  onEditorMouseUp(event2) {
    const priv = privatePool8.get(this);
    const currentWidth = outerWidth(event2.target);
    const currentHeight = outerHeight(event2.target);
    if (currentWidth !== priv.tempEditorDimensions.width + 1 || currentHeight !== priv.tempEditorDimensions.height + 2) {
      this.updateCommentMeta(this.range.from.row, this.range.from.col, {
        [META_STYLE]: {
          width: currentWidth,
          height: currentHeight
        }
      });
    }
  }
  /**
   * Context Menu's "Add comment" callback. Results in showing the comment editor.
   *
   * @private
   */
  onContextMenuAddComment() {
    const coords = this.hot.getSelectedRangeLast();
    this.preventEditorAutoSwitch = true;
    this.displaySwitch.cancelHiding();
    this.setRange({
      from: coords.highlight
    });
    this.show();
    this.hot.deselectCell();
    this.editor.focus();
  }
  /**
   * Context Menu's "remove comment" callback.
   *
   * @private
   */
  onContextMenuRemoveComment() {
    const coords = this.hot.getSelectedRangeLast();
    this.preventEditorAutoSwitch = true;
    coords.forAll((row, column) => {
      if (row >= 0 && column >= 0) {
        this.removeCommentAtCell(row, column, false);
      }
    });
    this.hot.render();
  }
  /**
   * Context Menu's "make comment read-only" callback.
   *
   * @private
   */
  onContextMenuMakeReadOnly() {
    const coords = this.hot.getSelectedRangeLast();
    this.preventEditorAutoSwitch = true;
    coords.forAll((row, column) => {
      if (row >= 0 && column >= 0) {
        const currentState = !!this.getCommentMeta(row, column, META_READONLY);
        this.updateCommentMeta(row, column, {
          [META_READONLY]: !currentState
        });
      }
    });
  }
  /**
   * Add Comments plugin options to the Context Menu.
   *
   * @private
   * @param {object} defaultOptions The menu options.
   */
  addToContextMenu(defaultOptions) {
    const isThereAnyCellRendered = () => {
      return this.hot.rowIndexMapper.getRenderableIndexesLength() > 0 && this.hot.columnIndexMapper.getRenderableIndexesLength() > 0;
    };
    defaultOptions.items.push({
      name: "---------"
    }, {
      key: "commentsAddEdit",
      name: () => {
        if (this.checkSelectionCommentsConsistency()) {
          return this.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_EDIT_COMMENT);
        }
        return this.hot.getTranslatedPhrase(CONTEXTMENU_ITEMS_ADD_COMMENT);
      },
      callback: () => this.onContextMenuAddComment(),
      disabled: () => {
        if (!isThereAnyCellRendered()) {
          return true;
        }
        return !(this.hot.getSelectedLast() && !this.hot.selection.isSelectedByCorner());
      }
    }, {
      key: "commentsRemove",
      name() {
        return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COMMENT);
      },
      callback: () => this.onContextMenuRemoveComment(),
      disabled: () => {
        if (!isThereAnyCellRendered()) {
          return true;
        }
        return !(this.hot.getSelectedLast() && !this.hot.selection.isSelectedByCorner());
      }
    }, {
      key: "commentsReadOnly",
      name() {
        let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY_COMMENT);
        const hasProperty = checkSelectionConsistency(this.getSelectedRangeLast(), (row, col) => {
          let readOnlyProperty = this.getCellMeta(row, col)[META_COMMENT];
          if (readOnlyProperty) {
            readOnlyProperty = readOnlyProperty[META_READONLY];
          }
          if (readOnlyProperty) {
            return true;
          }
        });
        if (hasProperty) {
          label = markLabelAsSelected(label);
        }
        return label;
      },
      callback: () => this.onContextMenuMakeReadOnly(),
      disabled: () => {
        if (!isThereAnyCellRendered()) {
          return true;
        }
        return !(this.hot.getSelectedLast() && !this.hot.selection.isSelectedByCorner()) || !this.checkSelectionCommentsConsistency();
      }
    });
  }
  /**
   * Get `displayDelay` setting of comment plugin.
   *
   * @private
   * @returns {number|undefined}
   */
  getDisplayDelaySetting() {
    const commentSetting = this.hot.getSettings()[PLUGIN_KEY9];
    if (isObject2(commentSetting)) {
      return commentSetting.displayDelay;
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    if (this.editor) {
      this.editor.destroy();
    }
    if (this.displaySwitch) {
      this.displaySwitch.destroy();
    }
    super.destroy();
  }
};

// node_modules/core-js/modules/es.array.unshift.js
var $5 = require_export();
var toObject4 = require_to_object();
var lengthOfArrayLike3 = require_length_of_array_like();
var setArrayLength2 = require_array_set_length();
var deletePropertyOrThrow = require_delete_property_or_throw();
var doesNotExceedSafeInteger2 = require_does_not_exceed_safe_integer();
var INCORRECT_RESULT = [].unshift(0) !== 1;
var properErrorOnNonWritableLength2 = function() {
  try {
    Object.defineProperty([], "length", { writable: false }).unshift();
  } catch (error2) {
    return error2 instanceof TypeError;
  }
};
var FORCED3 = INCORRECT_RESULT || !properErrorOnNonWritableLength2();
$5({ target: "Array", proto: true, arity: 1, forced: FORCED3 }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  unshift: function unshift(item) {
    var O = toObject4(this);
    var len = lengthOfArrayLike3(O);
    var argCount = arguments.length;
    if (argCount) {
      doesNotExceedSafeInteger2(len + argCount);
      var k = len;
      while (k--) {
        var to2 = k + argCount;
        if (k in O)
          O[to2] = O[k];
        else
          deletePropertyOrThrow(O, to2);
      }
      for (var j = 0; j < argCount; j++) {
        O[j] = arguments[j];
      }
    }
    return setArrayLength2(O, len + argCount);
  }
});

// node_modules/handsontable/plugins/contextMenu/commandExecutor.mjs
var CommandExecutor = class {
  constructor(hotInstance) {
    this.hot = hotInstance;
    this.commands = {};
    this.commonCallback = null;
  }
  /**
   * Register command.
   *
   * @param {string} name Command name.
   * @param {object} commandDescriptor Command descriptor object with properties like `key` (command id),
   *                                   `callback` (task to execute), `name` (command name), `disabled` (command availability).
   */
  registerCommand(name, commandDescriptor) {
    this.commands[name] = commandDescriptor;
  }
  /**
   * Set common callback which will be trigger on every executed command.
   *
   * @param {Function} callback Function which will be fired on every command execute.
   */
  setCommonCallback(callback) {
    this.commonCallback = callback;
  }
  /**
   * Execute command by its name.
   *
   * @param {string} commandName Command id.
   * @param {*} params Arguments passed to command task.
   */
  execute(commandName) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    const commandSplit = commandName.split(":");
    const commandNamePrimary = commandSplit[0];
    const subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;
    let command = this.commands[commandNamePrimary];
    if (!command) {
      throw new Error(`Menu command '${commandNamePrimary}' not exists.`);
    }
    if (subCommandName && command.submenu) {
      command = findSubCommand(subCommandName, command.submenu.items);
    }
    if (command.disabled === true) {
      return;
    }
    if (typeof command.disabled === "function" && command.disabled.call(this.hot) === true) {
      return;
    }
    if (hasOwnProperty2(command, "submenu")) {
      return;
    }
    const callbacks = [];
    if (typeof command.callback === "function") {
      callbacks.push(command.callback);
    }
    if (typeof this.commonCallback === "function") {
      callbacks.push(this.commonCallback);
    }
    params.unshift(commandSplit.join(":"));
    arrayEach(callbacks, (callback) => callback.apply(this.hot, params));
  }
};
function findSubCommand(subCommandName, subCommands) {
  let command;
  arrayEach(subCommands, (cmd) => {
    const cmds = cmd.key ? cmd.key.split(":") : null;
    if (Array.isArray(cmds) && cmds[1] === subCommandName) {
      command = cmd;
      return false;
    }
  });
  return command;
}
var commandExecutor_default = CommandExecutor;

// node_modules/handsontable/plugins/contextMenu/predefinedItems/alignment.mjs
var KEY2 = "alignment";
function alignmentItem() {
  return {
    key: KEY2,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT);
    },
    disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      return !(this.getSelectedRange() && !this.selection.isSelectedByCorner());
    },
    submenu: {
      items: [{
        key: `${KEY2}:left`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htLeft") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htLeft";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:center`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htCenter") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htCenter";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:right`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htRight") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htRight";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:justify`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htJustify") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htJustify";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        name: KEY
      }, {
        key: `${KEY2}:top`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_TOP);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htTop") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "vertical";
          const alignment = "htTop";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:middle`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htMiddle") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "vertical";
          const alignment = "htMiddle";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:bottom`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htBottom") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "vertical";
          const alignment = "htBottom";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }]
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/clearColumn.mjs
var KEY3 = "clear_column";
function clearColumnItem() {
  return {
    key: KEY3,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CLEAR_COLUMN);
    },
    callback(key, selection) {
      const startColumn = selection[0].start.col;
      const endColumn = selection[0].end.col;
      if (this.countRows()) {
        this.populateFromArray(0, startColumn, [[null]], Math.max(selection[0].start.row, selection[0].end.row), endColumn, "ContextMenu.clearColumn");
      }
    },
    disabled() {
      const selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      return !this.selection.isSelectedByColumnHeader();
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/columnLeft.mjs
var KEY4 = "col_left";
function columnLeftItem() {
  return {
    key: KEY4,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_LEFT);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getTopLeftCorner();
      const alterAction = this.isRtl() ? "insert_col_end" : "insert_col_start";
      this.alter(alterAction, latestSelection.col, 1, "ContextMenu.columnLeft");
    },
    disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      const selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        const totalColumns = this.countCols();
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/columnRight.mjs
var KEY5 = "col_right";
function columnRightItem() {
  return {
    key: KEY5,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_RIGHT);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getTopRightCorner();
      const alterAction = this.isRtl() ? "insert_col_start" : "insert_col_end";
      this.alter(alterAction, latestSelection.col, 1, "ContextMenu.columnRight");
    },
    disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      const selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/readOnly.mjs
var KEY6 = "make_read_only";
function readOnlyItem() {
  return {
    key: KEY6,
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY);
      const atLeastOneReadOnly = checkSelectionConsistency(this.getSelectedRange(), (row, col) => this.getCellMeta(row, col).readOnly);
      if (atLeastOneReadOnly) {
        label = markLabelAsSelected(label);
      }
      return label;
    },
    callback() {
      const ranges = this.getSelectedRange();
      const atLeastOneReadOnly = checkSelectionConsistency(ranges, (row, col) => this.getCellMeta(row, col).readOnly);
      arrayEach(ranges, (range) => {
        range.forAll((row, col) => {
          if (row >= 0 && col >= 0) {
            this.setCellMeta(row, col, "readOnly", !atLeastOneReadOnly);
          }
        });
      });
      this.render();
    },
    disabled() {
      if (this.selection.isSelectedByCorner()) {
        return true;
      }
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      if (!this.getSelectedRange() || this.getSelectedRange().length === 0) {
        return true;
      }
      return false;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/redo.mjs
var KEY7 = "redo";
function redoItem() {
  return {
    key: KEY7,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REDO);
    },
    callback() {
      this.redo();
    },
    hidden() {
      const undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled() {
      return !this.getPlugin("undoRedo").isRedoAvailable();
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/removeColumn.mjs
var KEY8 = "remove_col";
function removeColumnItem() {
  return {
    key: KEY8,
    name() {
      const selection = this.getSelected();
      let pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          const [, fromColumn, , toColumn] = selection[0];
          if (fromColumn - toColumn !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COLUMN, pluralForm);
    },
    callback() {
      this.alter("remove_col", transformSelectionToColumnDistance(this.getSelected()), null, "ContextMenu.removeColumn");
    },
    disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      const selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      const totalColumns = this.countCols();
      if (this.selection.isSelectedByCorner()) {
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || totalColumns === 0;
    },
    hidden() {
      return !this.getSettings().allowRemoveColumn;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/removeRow.mjs
var KEY9 = "remove_row";
function removeRowItem() {
  return {
    key: KEY9,
    name() {
      const selection = this.getSelected();
      let pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          const [fromRow, , toRow] = selection[0];
          if (fromRow - toRow !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_ROW, pluralForm);
    },
    callback() {
      this.alter("remove_row", transformSelectionToRowDistance(this.getSelected()), 1, "ContextMenu.removeRow");
    },
    disabled() {
      const selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      const totalRows = this.countRows();
      if (this.selection.isSelectedByCorner()) {
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || totalRows === 0;
    },
    hidden() {
      return !this.getSettings().allowRemoveRow;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/rowAbove.mjs
var KEY10 = "row_above";
function rowAboveItem() {
  return {
    key: KEY10,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_ABOVE);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getTopLeftCorner();
      this.alter("insert_row_above", latestSelection.row, 1, "ContextMenu.rowAbove");
    },
    disabled() {
      const selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        const totalRows = this.countRows();
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/rowBelow.mjs
var KEY11 = "row_below";
function rowBelowItem() {
  return {
    key: KEY11,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_BELOW);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getBottomRightCorner();
      this.alter("insert_row_below", latestSelection.row, 1, "ContextMenu.rowBelow");
    },
    disabled() {
      const selected = getValidSelection(this);
      if (!selected) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/noItems.mjs
var KEY12 = "no_items";
function noItemsItem() {
  return {
    key: KEY12,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NO_ITEMS);
    },
    disabled: true,
    isCommand: false
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/undo.mjs
var KEY13 = "undo";
function undoItem() {
  return {
    key: KEY13,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNDO);
    },
    callback() {
      this.undo();
    },
    hidden() {
      const undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled() {
      return !this.getPlugin("undoRedo").isUndoAvailable();
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems.mjs
var ITEMS = [KEY10, KEY11, KEY4, KEY5, KEY3, KEY9, KEY8, KEY13, KEY7, KEY6, KEY2, KEY, KEY12];
var _predefinedItems = {
  [KEY]: separatorItem,
  [KEY12]: noItemsItem,
  [KEY10]: rowAboveItem,
  [KEY11]: rowBelowItem,
  [KEY4]: columnLeftItem,
  [KEY5]: columnRightItem,
  [KEY3]: clearColumnItem,
  [KEY9]: removeRowItem,
  [KEY8]: removeColumnItem,
  [KEY13]: undoItem,
  [KEY7]: redoItem,
  [KEY6]: readOnlyItem,
  [KEY2]: alignmentItem
};
function predefinedItems() {
  const items = {};
  objectEach(_predefinedItems, (itemFactory, key) => {
    items[key] = itemFactory();
  });
  return items;
}

// node_modules/handsontable/plugins/contextMenu/itemsFactory.mjs
var ItemsFactory = class {
  constructor(hotInstance) {
    let orderPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    this.hot = hotInstance;
    this.predefinedItems = predefinedItems();
    this.defaultOrderPattern = orderPattern;
  }
  /**
   * Set predefined items.
   *
   * @param {Array} predefinedItemsCollection Array of predefined items.
   */
  setPredefinedItems(predefinedItemsCollection) {
    const items = {};
    this.defaultOrderPattern.length = 0;
    objectEach(predefinedItemsCollection, (value, key) => {
      let menuItemKey = "";
      if (value.name === KEY) {
        items[KEY] = value;
        menuItemKey = KEY;
      } else if (isNaN(parseInt(key, 10))) {
        value.key = value.key === void 0 ? key : value.key;
        items[key] = value;
        menuItemKey = value.key;
      } else {
        items[value.key] = value;
        menuItemKey = value.key;
      }
      this.defaultOrderPattern.push(menuItemKey);
    });
    this.predefinedItems = items;
  }
  /**
   * Get all menu items based on pattern.
   *
   * @param {Array|object|boolean} pattern Pattern which you can define by displaying menu items order. If `true` default
   *                                       pattern will be used.
   * @returns {Array}
   */
  getItems() {
    let pattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return getItems(pattern, this.defaultOrderPattern, this.predefinedItems);
  }
};
function getItems() {
  let itemsPattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
  let defaultPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let items = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const result = [];
  let pattern = itemsPattern;
  if (pattern && pattern.items) {
    pattern = pattern.items;
  } else if (!Array.isArray(pattern)) {
    pattern = defaultPattern;
  }
  if (isObject2(pattern)) {
    objectEach(pattern, (value, key) => {
      let item = items[typeof value === "string" ? value : key];
      if (!item) {
        item = value;
      }
      if (isObject2(value)) {
        extend2(item, value);
      } else if (typeof item === "string") {
        item = {
          name: item
        };
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  } else {
    arrayEach(pattern, (name, key) => {
      let item = items[name];
      if (!item && ITEMS.indexOf(name) >= 0) {
        return;
      }
      if (!item) {
        item = {
          name,
          key: `${key}`
        };
      }
      if (isObject2(name)) {
        extend2(item, name);
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  }
  return result;
}
var itemsFactory_default = ItemsFactory;

// node_modules/handsontable/plugins/contextMenu/cursor.mjs
var Cursor = class {
  constructor(object, rootWindow) {
    const windowScrollTop = getWindowScrollTop(rootWindow);
    const windowScrollLeft = getWindowScrollLeft(rootWindow);
    let top2;
    let topRelative;
    let left2;
    let leftRelative;
    let cellHeight;
    let cellWidth;
    this.rootWindow = rootWindow;
    this.type = this.getSourceType(object);
    if (this.type === "literal") {
      top2 = parseInt(object.top, 10);
      left2 = parseInt(object.left, 10);
      cellHeight = object.height || 0;
      cellWidth = object.width || 0;
      topRelative = top2;
      leftRelative = left2;
      top2 += windowScrollTop;
      left2 += windowScrollLeft;
    } else if (this.type === "event") {
      top2 = parseInt(object.pageY, 10);
      left2 = parseInt(object.pageX, 10);
      cellHeight = object.target.clientHeight;
      cellWidth = object.target.clientWidth;
      topRelative = top2 - windowScrollTop;
      leftRelative = left2 - windowScrollLeft;
    }
    this.top = top2;
    this.topRelative = topRelative;
    this.left = left2;
    this.leftRelative = leftRelative;
    this.scrollTop = windowScrollTop;
    this.scrollLeft = windowScrollLeft;
    this.cellHeight = cellHeight;
    this.cellWidth = cellWidth;
  }
  /**
   * Get source type name.
   *
   * @param {*} object Event or Object with coordinates.
   * @returns {string} Returns one of this values: `'literal'`, `'event'`.
   */
  getSourceType(object) {
    let type = "literal";
    if (object instanceof Event) {
      type = "event";
    }
    return type;
  }
  /**
   * Checks if element can be placed above the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit above the cursor.
   * @returns {boolean}
   */
  fitsAbove(element) {
    return this.topRelative >= element.offsetHeight;
  }
  /**
   * Checks if element can be placed below the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit below the cursor.
   * @param {number} [viewportHeight] The viewport height.
   * @returns {boolean}
   */
  fitsBelow(element) {
    let viewportHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerHeight;
    return this.topRelative + element.offsetHeight <= viewportHeight;
  }
  /**
   * Checks if element can be placed on the right of the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit on the right of the cursor.
   * @param {number} [viewportWidth] The viewport width.
   * @returns {boolean}
   */
  fitsOnRight(element) {
    let viewportWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerWidth;
    return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;
  }
  /**
   * Checks if element can be placed on the left on the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit on the left of the cursor.
   * @returns {boolean}
   */
  fitsOnLeft(element) {
    return this.leftRelative >= element.offsetWidth;
  }
};
var cursor_default = Cursor;

// node_modules/handsontable/plugins/contextMenu/menu.mjs
var MIN_WIDTH = 215;
var SHORTCUTS_CONTEXT = "menu";
var SHORTCUTS_GROUP6 = SHORTCUTS_CONTEXT;
var Menu = class _Menu {
  /**
   * @param {Core} hotInstance Handsontable instance.
   * @param {MenuOptions} [options] Menu options.
   */
  constructor(hotInstance, options) {
    this.hot = hotInstance;
    this.options = options || {
      parent: null,
      name: null,
      className: "",
      keepInViewport: true,
      standalone: false,
      minWidth: MIN_WIDTH,
      container: this.hot.rootDocument.documentElement
    };
    this.eventManager = new eventManager_default(this);
    this.container = this.createContainer(this.options.name);
    this.hotMenu = null;
    this.hotSubMenus = {};
    this.parentMenu = this.options.parent || null;
    this.menuItems = null;
    this.origOutsideClickDeselects = null;
    this.keyEvent = false;
    this.offset = {
      above: 0,
      below: 0,
      left: 0,
      right: 0
    };
    this._afterScrollCallback = null;
    this.registerEvents();
  }
  /**
   * Register event listeners.
   *
   * @private
   */
  registerEvents() {
    let frame = this.hot.rootWindow;
    while (frame) {
      this.eventManager.addEventListener(frame.document, "mousedown", (event2) => this.onDocumentMouseDown(event2));
      this.eventManager.addEventListener(frame.document, "contextmenu", (event2) => this.onDocumentContextMenu(event2));
      frame = getParentWindow(frame);
    }
  }
  /**
   * Set array of objects which defines menu items.
   *
   * @param {Array} menuItems Menu items to display.
   */
  setMenuItems(menuItems) {
    this.menuItems = menuItems;
  }
  /**
   * Returns currently selected menu item. Returns `null` if no item was selected.
   *
   * @returns {object|null}
   */
  getSelectedItem() {
    return this.hasSelectedItem() ? this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelectedLast()[0]) : null;
  }
  /**
   * Checks if the menu has selected (highlighted) any item from the menu list.
   *
   * @returns {boolean}
   */
  hasSelectedItem() {
    return Array.isArray(this.hotMenu.getSelectedLast());
  }
  /**
   * Set offset menu position for specified area (`above`, `below`, `left` or `right`).
   *
   * @param {string} area Specified area name (`above`, `below`, `left` or `right`).
   * @param {number} offset Offset value.
   */
  setOffset(area) {
    let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.offset[area] = offset3;
  }
  /**
   * Check if menu is using as sub-menu.
   *
   * @returns {boolean}
   */
  isSubMenu() {
    return this.parentMenu !== null;
  }
  /**
   * Open menu.
   *
   * @fires Hooks#beforeContextMenuShow
   * @fires Hooks#afterContextMenuShow
   */
  open() {
    var _this = this;
    this.runLocalHooks("beforeOpen");
    this.container.removeAttribute("style");
    this.container.style.display = "block";
    const delayedOpenSubMenu = debounce((row) => this.openSubMenu(row), 300);
    const minWidthOfMenu = this.options.minWidth || MIN_WIDTH;
    let noItemsDefined = false;
    let filteredItems = arrayFilter(this.menuItems, (item) => {
      if (item.key === KEY12) {
        noItemsDefined = true;
      }
      return isItemHidden(item, this.hot);
    });
    if (filteredItems.length < 1 && !noItemsDefined) {
      filteredItems.push(predefinedItems()[KEY12]);
    } else if (filteredItems.length === 0) {
      return;
    }
    filteredItems = filterSeparators(filteredItems, KEY);
    let shouldAutoCloseMenu = false;
    const settings = {
      data: filteredItems,
      colHeaders: false,
      autoColumnSize: true,
      autoWrapRow: false,
      modifyColWidth(width) {
        if (isDefined(width) && width < minWidthOfMenu) {
          return minWidthOfMenu;
        }
        return width;
      },
      autoRowSize: false,
      readOnly: true,
      editor: false,
      copyPaste: false,
      maxCols: 1,
      columns: [{
        data: "name",
        renderer: (hot, TD, row, col, prop, value) => this.menuItemRenderer(hot, TD, row, col, prop, value)
      }],
      renderAllRows: true,
      fragmentSelection: false,
      outsideClickDeselects: false,
      disableVisualSelection: "area",
      layoutDirection: this.hot.isRtl() ? "rtl" : "ltr",
      afterOnCellMouseOver: (event2, coords) => {
        if (this.isAllSubMenusClosed()) {
          delayedOpenSubMenu(coords.row);
        } else {
          this.openSubMenu(coords.row);
        }
      },
      rowHeights: (row) => filteredItems[row].name === KEY ? 1 : 23,
      afterOnCellContextMenu: (event2) => {
        event2.preventDefault();
        if (isWindowsOS() && shouldAutoCloseMenu && this.hasSelectedItem()) {
          this.close(true);
        }
      },
      beforeOnCellMouseUp: (event2) => {
        if (this.hasSelectedItem()) {
          shouldAutoCloseMenu = !this.isCommandPassive(this.getSelectedItem());
          this.executeCommand(event2);
        }
      },
      afterOnCellMouseUp: (event2) => {
        if ((!isWindowsOS() || !isRightClick(event2)) && shouldAutoCloseMenu && this.hasSelectedItem()) {
          if (isMobileBrowser() || isIpadOS()) {
            setTimeout(() => this.close(true), 325);
          } else {
            this.close(true);
          }
        }
      },
      afterUnlisten: () => {
        if (!this.hasSelectedItem() && this.isOpened()) {
          this.hotMenu.listen();
        }
      }
    };
    this.origOutsideClickDeselects = this.hot.getSettings().outsideClickDeselects;
    this.hot.getSettings().outsideClickDeselects = false;
    this.hotMenu = new Core(this.container, settings);
    this.hotMenu.addHook("afterInit", () => this.onAfterInit());
    this.hotMenu.addHook("afterSelection", function() {
      return _this.onAfterSelection(...arguments);
    });
    this.hotMenu.init();
    this.hotMenu.listen();
    const shortcutManager = this.hotMenu.getShortcutManager();
    const menuContext = shortcutManager.addContext(SHORTCUTS_GROUP6);
    const config = {
      group: SHORTCUTS_CONTEXT
    };
    const menuContextConfig = {
      ...config,
      runOnlyIf: (event2) => isInput(event2.target) === false || this.container.contains(event2.target) === false
    };
    shortcutManager.setActiveContextName("menu");
    menuContext.addShortcuts([{
      keys: [["Escape"]],
      callback: () => {
        this.keyEvent = true;
        this.close();
        this.keyEvent = false;
      }
    }, {
      keys: [["ArrowDown"]],
      callback: () => {
        const selection = this.hotMenu.getSelectedLast();
        this.keyEvent = true;
        if (selection) {
          this.selectNextCell(selection[0], selection[1]);
        } else {
          this.selectFirstCell();
        }
        this.keyEvent = false;
      }
    }, {
      keys: [["ArrowUp"]],
      callback: () => {
        const selection = this.hotMenu.getSelectedLast();
        this.keyEvent = true;
        if (selection) {
          this.selectPrevCell(selection[0], selection[1]);
        } else {
          this.selectLastCell();
        }
        this.keyEvent = false;
      }
    }, {
      keys: [["ArrowRight"]],
      callback: () => {
        const selection = this.hotMenu.getSelectedLast();
        this.keyEvent = true;
        if (selection) {
          const menu = this.openSubMenu(selection[0]);
          if (menu) {
            menu.selectFirstCell();
          }
        }
        this.keyEvent = false;
      }
    }, {
      keys: [["ArrowLeft"]],
      callback: () => {
        const selection = this.hotMenu.getSelectedLast();
        this.keyEvent = true;
        if (selection && this.isSubMenu()) {
          this.close();
          if (this.parentMenu) {
            this.parentMenu.hotMenu.listen();
          }
        }
        this.keyEvent = false;
      }
    }, {
      keys: [["Enter"]],
      callback: (event2) => {
        const selection = this.hotMenu.getSelectedLast();
        this.keyEvent = true;
        if (!this.hotMenu.getSourceDataAtRow(selection[0]).submenu) {
          this.executeCommand(event2);
          this.close(true);
        }
        this.keyEvent = false;
      }
    }, {
      keys: [["PageUp"]],
      callback: () => {
        const selection = this.hotMenu.getSelectedLast();
        this.keyEvent = true;
        if (selection) {
          this.hotMenu.selection.transformStart(-this.hotMenu.countVisibleRows(), 0);
        } else {
          this.selectFirstCell();
        }
        this.keyEvent = false;
      }
    }, {
      keys: [["PageDown"]],
      callback: () => {
        const selection = this.hotMenu.getSelectedLast();
        this.keyEvent = true;
        if (selection) {
          this.hotMenu.selection.transformStart(this.hotMenu.countVisibleRows(), 0);
        } else {
          this.selectLastCell();
        }
        this.keyEvent = false;
      }
    }], menuContextConfig);
    this.blockMainTableCallbacks();
    this.runLocalHooks("afterOpen");
  }
  /**
   * Close menu.
   *
   * @param {boolean} [closeParent=false] If `true` try to close parent menu if exists.
   */
  close() {
    let closeParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!this.isOpened()) {
      return;
    }
    if (closeParent && this.parentMenu) {
      this.parentMenu.close();
    } else {
      this.closeAllSubMenus();
      this.container.style.display = "none";
      this.releaseMainTableCallbacks();
      this.hotMenu.destroy();
      this.hotMenu = null;
      this.hot.getSettings().outsideClickDeselects = this.origOutsideClickDeselects;
      this.runLocalHooks("afterClose");
      if (this.parentMenu) {
        this.parentMenu.hotMenu.listen();
      }
    }
  }
  /**
   * Open sub menu at the provided row index.
   *
   * @param {number} row Row index.
   * @returns {Menu|boolean} Returns created menu or `false` if no one menu was created.
   */
  openSubMenu(row) {
    if (!this.hotMenu) {
      return false;
    }
    const cell = this.hotMenu.getCell(row, 0);
    this.closeAllSubMenus();
    if (!cell || !hasSubMenu(cell)) {
      return false;
    }
    const dataItem = this.hotMenu.getSourceDataAtRow(row);
    const subMenu = new _Menu(this.hot, {
      parent: this,
      name: dataItem.name,
      className: this.options.className,
      keepInViewport: true,
      container: this.options.container
    });
    subMenu.setMenuItems(dataItem.submenu.items);
    subMenu.open();
    subMenu.setPosition(cell.getBoundingClientRect());
    this.hotSubMenus[dataItem.key] = subMenu;
    return subMenu;
  }
  /**
   * Close sub menu at row index.
   *
   * @param {number} row Row index.
   */
  closeSubMenu(row) {
    const dataItem = this.hotMenu.getSourceDataAtRow(row);
    const menus = this.hotSubMenus[dataItem.key];
    if (menus) {
      menus.destroy();
      delete this.hotSubMenus[dataItem.key];
    }
  }
  /**
   * Close all opened sub menus.
   */
  closeAllSubMenus() {
    arrayEach(this.hotMenu.getData(), (value, row) => this.closeSubMenu(row));
  }
  /**
   * Checks if all created and opened sub menus are closed.
   *
   * @returns {boolean}
   */
  isAllSubMenusClosed() {
    return Object.keys(this.hotSubMenus).length === 0;
  }
  /**
   * Destroy instance.
   */
  destroy() {
    const menuContainerParentElement = this.container.parentNode;
    this.clearLocalHooks();
    this.close();
    this.parentMenu = null;
    this.eventManager.destroy();
    if (menuContainerParentElement) {
      menuContainerParentElement.removeChild(this.container);
    }
  }
  /**
   * Checks if menu was opened.
   *
   * @returns {boolean} Returns `true` if menu was opened.
   */
  isOpened() {
    return this.hotMenu !== null;
  }
  /**
   * Execute menu command.
   *
   * The `executeCommand()` method works only for selected cells.
   *
   * When no cells are selected, `executeCommand()` doesn't do anything.
   *
   * @param {Event} [event] The mouse event object.
   */
  executeCommand(event2) {
    if (!this.isOpened() || !this.hasSelectedItem()) {
      return;
    }
    const selectedItem = this.getSelectedItem();
    this.runLocalHooks("select", selectedItem, event2);
    if (this.isCommandPassive(selectedItem)) {
      return;
    }
    const selRanges = this.hot.getSelectedRange();
    const normalizedSelection = selRanges ? normalizeSelection(selRanges) : [];
    this.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event2);
    if (this.isSubMenu()) {
      this.parentMenu.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event2);
    }
  }
  /**
   * Checks if the passed command is passive or not. The command is passive when it's marked as
   * disabled, the descriptor object contains `isCommand` property set to `false`, command
   * is a separator, or the item is recognized as submenu. For passive items the menu is not
   * closed automatically after the user trigger the command through the UI.
   *
   * @param {object} commandDescriptor Selected menu item from the menu data source.
   * @returns {boolean}
   */
  isCommandPassive(commandDescriptor) {
    const {
      isCommand,
      name: commandName,
      disabled,
      submenu
    } = commandDescriptor;
    const isItemDisabled = disabled === true || typeof disabled === "function" && disabled.call(this.hot) === true;
    return isCommand === false || commandName === KEY || isItemDisabled === true || submenu;
  }
  /**
   * Set menu position based on dom event or based on literal object.
   *
   * @param {Event|object} coords Event or literal Object with coordinates.
   */
  setPosition(coords) {
    const cursor = new cursor_default(coords, this.container.ownerDocument.defaultView);
    if (this.options.keepInViewport) {
      if (cursor.fitsBelow(this.container)) {
        this.setPositionBelowCursor(cursor);
      } else if (cursor.fitsAbove(this.container)) {
        this.setPositionAboveCursor(cursor);
      } else {
        this.setPositionBelowCursor(cursor);
      }
      if (this.hot.isLtr()) {
        this.setHorizontalPositionForLtr(cursor);
      } else {
        this.setHorizontalPositionForRtl(cursor);
      }
    } else {
      this.setPositionBelowCursor(cursor);
      this.setPositionOnRightOfCursor(cursor);
    }
  }
  /**
   * Set menu horizontal position for RTL mode.
   *
   * @param {Cursor} cursor `Cursor` object.
   */
  setHorizontalPositionForRtl(cursor) {
    if (cursor.fitsOnLeft(this.container)) {
      this.setPositionOnLeftOfCursor(cursor);
    } else {
      this.setPositionOnRightOfCursor(cursor);
    }
  }
  /**
   * Set menu horizontal position for LTR mode.
   *
   * @param {Cursor} cursor `Cursor` object.
   */
  setHorizontalPositionForLtr(cursor) {
    if (cursor.fitsOnRight(this.container)) {
      this.setPositionOnRightOfCursor(cursor);
    } else {
      this.setPositionOnLeftOfCursor(cursor);
    }
  }
  /**
   * Set menu position above cursor object.
   *
   * @param {Cursor} cursor `Cursor` object.
   */
  setPositionAboveCursor(cursor) {
    let top2 = this.offset.above + cursor.top - this.container.offsetHeight;
    if (this.isSubMenu()) {
      top2 = cursor.top + cursor.cellHeight - this.container.offsetHeight + 3;
    }
    this.container.style.top = `${top2}px`;
  }
  /**
   * Set menu position below cursor object.
   *
   * @param {Cursor} cursor `Cursor` object.
   */
  setPositionBelowCursor(cursor) {
    let top2 = this.offset.below + cursor.top + 1;
    if (this.isSubMenu()) {
      top2 = cursor.top - 1;
    }
    this.container.style.top = `${top2}px`;
  }
  /**
   * Set menu position on the right of cursor object.
   *
   * @param {Cursor} cursor `Cursor` object.
   */
  setPositionOnRightOfCursor(cursor) {
    let left2 = cursor.left;
    if (this.isSubMenu()) {
      const {
        right: parentMenuRight
      } = this.parentMenu.container.getBoundingClientRect();
      left2 += cursor.cellWidth + parentMenuRight - (cursor.left + cursor.cellWidth);
    } else {
      left2 += this.offset.right;
    }
    this.container.style.left = `${left2}px`;
  }
  /**
   * Set menu position on the left of cursor object.
   *
   * @param {Cursor} cursor `Cursor` object.
   */
  setPositionOnLeftOfCursor(cursor) {
    let left2 = this.offset.left + cursor.left - this.container.offsetWidth;
    if (this.isSubMenu()) {
      const {
        left: parentMenuLeft
      } = this.parentMenu.container.getBoundingClientRect();
      left2 -= cursor.left - parentMenuLeft;
    }
    this.container.style.left = `${left2}px`;
  }
  /**
   * Select first cell in opened menu.
   */
  selectFirstCell() {
    const cell = this.hotMenu.getCell(0, 0);
    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
      this.selectNextCell(0, 0);
    } else {
      this.hotMenu.selectCell(0, 0);
    }
  }
  /**
   * Select last cell in opened menu.
   */
  selectLastCell() {
    const lastRow = this.hotMenu.countRows() - 1;
    const cell = this.hotMenu.getCell(lastRow, 0);
    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
      this.selectPrevCell(lastRow, 0);
    } else {
      this.hotMenu.selectCell(lastRow, 0, void 0, void 0, false);
      this.hotMenu.scrollViewportTo(lastRow, 0, true, false);
    }
  }
  /**
   * Select next cell in opened menu.
   *
   * @param {number} row Row index.
   * @param {number} col Column index.
   */
  selectNextCell(row, col) {
    const nextRow = row + 1;
    const cell = nextRow < this.hotMenu.countRows() ? this.hotMenu.getCell(nextRow, col) : null;
    if (!cell) {
      return;
    }
    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
      this.selectNextCell(nextRow, col);
    } else {
      this.hotMenu.selectCell(nextRow, col);
    }
  }
  /**
   * Select previous cell in opened menu.
   *
   * @param {number} row Row index.
   * @param {number} col Column index.
   */
  selectPrevCell(row, col) {
    const prevRow = row - 1;
    const cell = prevRow >= 0 ? this.hotMenu.getCell(prevRow, col) : null;
    if (!cell) {
      return;
    }
    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
      this.selectPrevCell(prevRow, col);
    } else {
      this.hotMenu.selectCell(prevRow, col);
    }
  }
  /**
   * Menu item renderer.
   *
   * @private
   * @param {Core} hot The Handsontable instance.
   * @param {HTMLCellElement} TD The rendered cell element.
   * @param {number} row The visual index.
   * @param {number} col The visual index.
   * @param {string} prop The column property if used.
   * @param {string} value The cell value.
   */
  menuItemRenderer(hot, TD, row, col, prop, value) {
    const item = hot.getSourceDataAtRow(row);
    const wrapper = this.hot.rootDocument.createElement("div");
    const isSubMenu = (itemToTest) => hasOwnProperty2(itemToTest, "submenu");
    const itemIsSeparator = (itemToTest) => new RegExp(KEY, "i").test(itemToTest.name);
    const itemIsDisabled = (itemToTest) => itemToTest.disabled === true || typeof itemToTest.disabled === "function" && itemToTest.disabled.call(this.hot) === true;
    const itemIsSelectionDisabled = (itemToTest) => itemToTest.disableSelection;
    let itemValue = value;
    if (typeof itemValue === "function") {
      itemValue = itemValue.call(this.hot);
    }
    empty(TD);
    addClass(wrapper, "htItemWrapper");
    TD.appendChild(wrapper);
    if (itemIsSeparator(item)) {
      addClass(TD, "htSeparator");
    } else if (typeof item.renderer === "function") {
      addClass(TD, "htCustomMenuRenderer");
      TD.appendChild(item.renderer(hot, wrapper, row, col, prop, itemValue));
    } else {
      fastInnerHTML(wrapper, itemValue);
    }
    if (itemIsDisabled(item)) {
      addClass(TD, "htDisabled");
      this.eventManager.addEventListener(TD, "mouseenter", () => hot.deselectCell());
    } else if (itemIsSelectionDisabled(item)) {
      addClass(TD, "htSelectionDisabled");
      this.eventManager.addEventListener(TD, "mouseenter", () => hot.deselectCell());
    } else if (isSubMenu(item)) {
      addClass(TD, "htSubmenu");
      if (itemIsSelectionDisabled(item)) {
        this.eventManager.addEventListener(TD, "mouseenter", () => hot.deselectCell());
      } else {
        this.eventManager.addEventListener(TD, "mouseenter", () => hot.selectCell(row, col, void 0, void 0, false, false));
      }
    } else {
      removeClass(TD, ["htSubmenu", "htDisabled"]);
      if (itemIsSelectionDisabled(item)) {
        this.eventManager.addEventListener(TD, "mouseenter", () => hot.deselectCell());
      } else {
        this.eventManager.addEventListener(TD, "mouseenter", () => hot.selectCell(row, col, void 0, void 0, false, false));
      }
    }
  }
  /**
   * Create container/wrapper for handsontable.
   *
   * @private
   * @param {string} [name] Class name.
   * @returns {HTMLElement}
   */
  createContainer() {
    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const doc = this.options.container.ownerDocument;
    let className = name;
    let container;
    if (className) {
      if (isFunction2(className)) {
        className = className.call(this.hot);
        if (className === null || isUndefined2(className)) {
          className = "";
        } else {
          className = className.toString();
        }
      }
      className = className.replace(/[^A-z0-9]/g, "_");
      className = `${this.options.className}Sub_${className}`;
      container = doc.querySelector(`.${this.options.className}.${className}`);
    }
    if (!container) {
      container = doc.createElement("div");
      addClass(container, `htMenu ${this.options.className}`);
      if (className) {
        addClass(container, className);
      }
      this.options.container.appendChild(container);
    }
    return container;
  }
  /**
   * @private
   */
  blockMainTableCallbacks() {
    this._afterScrollCallback = function() {
    };
    this.hot.addHook("afterScrollVertically", this._afterScrollCallback);
    this.hot.addHook("afterScrollHorizontally", this._afterScrollCallback);
  }
  /**
   * @private
   */
  releaseMainTableCallbacks() {
    if (this._afterScrollCallback) {
      this.hot.removeHook("afterScrollVertically", this._afterScrollCallback);
      this.hot.removeHook("afterScrollHorizontally", this._afterScrollCallback);
      this._afterScrollCallback = null;
    }
  }
  /**
   * On after init listener.
   *
   * @private
   */
  onAfterInit() {
    const {
      wtTable
    } = this.hotMenu.view._wt;
    const data = this.hotMenu.getSettings().data;
    const hiderStyle = wtTable.hider.style;
    const holderStyle = wtTable.holder.style;
    const currentHiderWidth = parseInt(hiderStyle.width, 10);
    const realHeight = arrayReduce(data, (accumulator, value) => accumulator + (value.name === KEY ? 1 : 26), 0);
    holderStyle.width = `${currentHiderWidth + 3}px`;
    holderStyle.height = `${realHeight + 3}px`;
    hiderStyle.height = holderStyle.height;
  }
  /**
   * On after selection listener.
   *
   * @param {number} r Selection start row index.
   * @param {number} c Selection start column index.
   * @param {number} r2 Selection end row index.
   * @param {number} c2 Selection end column index.
   * @param {object} preventScrolling Object with `value` property where its value change will be observed.
   */
  onAfterSelection(r, c, r2, c2, preventScrolling) {
    if (this.keyEvent === false) {
      preventScrolling.value = true;
    }
  }
  /**
   * Document mouse down listener.
   *
   * @private
   * @param {Event} event The mouse event object.
   */
  onDocumentMouseDown(event2) {
    if (!this.isOpened()) {
      return;
    }
    if (this.options.standalone && this.hotMenu && !isChildOf(event2.target, this.hotMenu.rootElement)) {
      this.close(true);
    } else if ((this.isAllSubMenusClosed() || this.isSubMenu()) && !isChildOf(event2.target, ".htMenu")) {
      this.close(true);
    }
  }
  /**
   * Document's contextmenu listener.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onDocumentContextMenu(event2) {
    if (!this.isOpened()) {
      return;
    }
    if (hasClass(event2.target, "htCore") && isChildOf(event2.target, this.hotMenu.rootElement)) {
      event2.preventDefault();
    }
  }
};
mixin(Menu, localHooks_default);
var menu_default = Menu;

// node_modules/handsontable/plugins/contextMenu/contextMenu.mjs
var PLUGIN_KEY10 = "contextMenu";
var PLUGIN_PRIORITY9 = 70;
pluginHooks_default.getSingleton().register("afterContextMenuDefaultOptions");
pluginHooks_default.getSingleton().register("beforeContextMenuShow");
pluginHooks_default.getSingleton().register("afterContextMenuShow");
pluginHooks_default.getSingleton().register("afterContextMenuHide");
pluginHooks_default.getSingleton().register("afterContextMenuExecute");
var ContextMenu = class _ContextMenu extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY10;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY9;
  }
  static get PLUGIN_DEPS() {
    return ["plugin:AutoColumnSize"];
  }
  /**
   * Context menu default items order when `contextMenu` options is set as `true`.
   *
   * @returns {string[]}
   */
  static get DEFAULT_ITEMS() {
    return [KEY10, KEY11, KEY, KEY4, KEY5, KEY, KEY9, KEY8, KEY, KEY13, KEY7, KEY, KEY6, KEY, KEY2];
  }
  /**
   * @param {Core} hotInstance Handsontable instance.
   */
  constructor(hotInstance) {
    super(hotInstance);
    this.eventManager = new eventManager_default(this);
    this.commandExecutor = new commandExecutor_default(this.hot);
    this.itemsFactory = null;
    this.menu = null;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ContextMenu#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY10];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const settings = this.hot.getSettings()[PLUGIN_KEY10];
    if (typeof settings.callback === "function") {
      this.commandExecutor.setCommonCallback(settings.callback);
    }
    this.menu = new menu_default(this.hot, {
      className: "htContextMenu",
      keepInViewport: true,
      container: settings.uiContainer || this.hot.rootDocument.body
    });
    this.menu.addLocalHook("beforeOpen", () => this.onMenuBeforeOpen());
    this.menu.addLocalHook("afterOpen", () => this.onMenuAfterOpen());
    this.menu.addLocalHook("afterClose", () => this.onMenuAfterClose());
    this.menu.addLocalHook("executeCommand", function() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      return _this.executeCommand.call(_this, ...params);
    });
    this.addHook("afterOnCellContextMenu", (event2) => this.onAfterOnCellContextMenu(event2));
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`contextMenu`](@/api/options.md#contextmenu)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
      this.menu = null;
    }
    super.disablePlugin();
  }
  /**
   * Opens menu and re-position it based on the passed coordinates.
   *
   * @param {Event} event The mouse event object.
   */
  open(event2) {
    if (!this.menu) {
      return;
    }
    this.prepareMenuItems();
    this.menu.open();
    if (!this.menu.isOpened()) {
      return;
    }
    let offsetTop = 0;
    let offsetLeft = 0;
    if (this.hot.rootDocument !== this.menu.container.ownerDocument) {
      const {
        frameElement
      } = this.hot.rootWindow;
      const {
        top: top2,
        left: left2
      } = frameElement.getBoundingClientRect();
      offsetTop = top2 - getWindowScrollTop(event2.view);
      offsetLeft = left2 - getWindowScrollLeft(event2.view);
    } else {
      offsetTop = -1 * getWindowScrollTop(this.menu.hotMenu.rootWindow);
      offsetLeft = -1 * getWindowScrollLeft(this.menu.hotMenu.rootWindow);
    }
    this.menu.setPosition({
      top: parseInt(event2.pageY, 10) + offsetTop,
      left: parseInt(event2.pageX, 10) + offsetLeft
    });
  }
  /**
   * Closes the menu.
   */
  close() {
    if (!this.menu) {
      return;
    }
    this.menu.close();
    this.itemsFactory = null;
  }
  /**
   * Execute context menu command.
   *
   * The `executeCommand()` method works only for selected cells.
   *
   * When no cells are selected, `executeCommand()` doesn't do anything.
   *
   * You can execute all predefined commands:
   *  * `'row_above'` - Insert row above
   *  * `'row_below'` - Insert row below
   *  * `'col_left'` - Insert column left
   *  * `'col_right'` - Insert column right
   *  * `'clear_column'` - Clear selected column
   *  * `'remove_row'` - Remove row
   *  * `'remove_col'` - Remove column
   *  * `'undo'` - Undo last action
   *  * `'redo'` - Redo last action
   *  * `'make_read_only'` - Make cell read only
   *  * `'alignment:left'` - Alignment to the left
   *  * `'alignment:top'` - Alignment to the top
   *  * `'alignment:right'` - Alignment to the right
   *  * `'alignment:bottom'` - Alignment to the bottom
   *  * `'alignment:middle'` - Alignment to the middle
   *  * `'alignment:center'` - Alignment to the center (justify).
   *
   * Or you can execute command registered in settings where `key` is your command name.
   *
   * @param {string} commandName The command name to be executed.
   * @param {*} params Additional parameters passed to command executor module.
   */
  executeCommand(commandName) {
    if (this.itemsFactory === null) {
      this.prepareMenuItems();
    }
    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }
    this.commandExecutor.execute(commandName, ...params);
  }
  /**
   * Prepares available contextMenu's items list and registers them in commandExecutor.
   *
   * @private
   * @fires Hooks#afterContextMenuDefaultOptions
   * @fires Hooks#beforeContextMenuSetItems
   */
  prepareMenuItems() {
    this.itemsFactory = new itemsFactory_default(this.hot, _ContextMenu.DEFAULT_ITEMS);
    const settings = this.hot.getSettings()[PLUGIN_KEY10];
    const predefinedItems2 = {
      items: this.itemsFactory.getItems(settings)
    };
    this.hot.runHooks("afterContextMenuDefaultOptions", predefinedItems2);
    this.itemsFactory.setPredefinedItems(predefinedItems2.items);
    const menuItems = this.itemsFactory.getItems(settings);
    this.hot.runHooks("beforeContextMenuSetItems", menuItems);
    this.menu.setMenuItems(menuItems);
    arrayEach(menuItems, (command) => this.commandExecutor.registerCommand(command.key, command));
  }
  /**
   * On contextmenu listener.
   *
   * @private
   * @param {Event} event The mouse event object.
   */
  onAfterOnCellContextMenu(event2) {
    const settings = this.hot.getSettings();
    const showRowHeaders = settings.rowHeaders;
    const showColHeaders = settings.colHeaders;
    function isValidElement(element2) {
      return element2.nodeName === "TD" || element2.parentNode.nodeName === "TD";
    }
    const element = event2.target;
    this.close();
    if (hasClass(element, "handsontableInput")) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    if (!(showRowHeaders || showColHeaders)) {
      if (!isValidElement(element) && !(hasClass(element, "current") && hasClass(element, "wtBorder"))) {
        return;
      }
    }
    this.open(event2);
  }
  /**
   * On menu before open listener.
   *
   * @private
   */
  onMenuBeforeOpen() {
    this.hot.runHooks("beforeContextMenuShow", this);
  }
  /**
   * On menu after open listener.
   *
   * @private
   */
  onMenuAfterOpen() {
    this.hot.runHooks("afterContextMenuShow", this);
  }
  /**
   * On menu after close listener.
   *
   * @private
   */
  onMenuAfterClose() {
    this.hot.listen();
    this.hot.runHooks("afterContextMenuHide", this);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
    }
    super.destroy();
  }
};
ContextMenu.SEPARATOR = {
  name: KEY
};

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/copy.mjs
function copyItem(copyPastePlugin) {
  return {
    key: "copy",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY);
    },
    callback() {
      copyPastePlugin.copyCellsOnly();
    },
    disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/copyColumnHeadersOnly.mjs
function copyColumnHeadersOnlyItem(copyPastePlugin) {
  return {
    key: "copy_column_headers_only",
    name() {
      const selectedRange = this.getSelectedRangeLast();
      const nounForm = selectedRange ? Math.min(selectedRange.getWidth() - 1, 1) : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY, nounForm);
    },
    callback() {
      copyPastePlugin.copyColumnHeadersOnly();
    },
    disabled() {
      if (!this.hasColHeaders()) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/copyWithColumnGroupHeaders.mjs
function copyWithColumnGroupHeadersItem(copyPastePlugin) {
  return {
    key: "copy_with_column_group_headers",
    name() {
      const selectedRange = this.getSelectedRangeLast();
      const nounForm = selectedRange ? Math.min(selectedRange.getWidth() - 1, 1) : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS, nounForm);
    },
    callback() {
      copyPastePlugin.copyWithAllColumnHeaders();
    },
    disabled() {
      if (!this.hasColHeaders() || !this.getSettings().nestedHeaders) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/copyWithColumnHeaders.mjs
function copyWithColumnHeadersItem(copyPastePlugin) {
  return {
    key: "copy_with_column_headers",
    name() {
      const selectedRange = this.getSelectedRangeLast();
      const nounForm = selectedRange ? Math.min(selectedRange.getWidth() - 1, 1) : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS, nounForm);
    },
    callback() {
      copyPastePlugin.copyWithColumnHeaders();
    },
    disabled() {
      if (!this.hasColHeaders()) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/cut.mjs
function cutItem(copyPastePlugin) {
  return {
    key: "cut",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CUT);
    },
    callback() {
      copyPastePlugin.cut();
    },
    disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/clipboardData.mjs
var ClipboardData = class {
  constructor() {
    this.data = {};
  }
  setData(type, value) {
    this.data[type] = value;
  }
  getData(type) {
    return this.data[type] || void 0;
  }
};

// node_modules/handsontable/plugins/copyPaste/pasteEvent.mjs
var PasteEvent = class {
  constructor() {
    this.clipboardData = new ClipboardData();
  }
};

// node_modules/handsontable/plugins/copyPaste/focusableElement.mjs
var FocusableWrapper = class {
  constructor(container) {
    this.rootDocument = container.defaultView ? container : container.ownerDocument;
    this.mainElement = null;
    this.eventManager = new eventManager_default(this);
    this.listenersCount = /* @__PURE__ */ new WeakSet();
    this.container = container;
  }
  /**
   * Switch to the secondary focusable element. Used when no any main focusable element is provided.
   */
  useSecondaryElement() {
    const el = createOrGetSecondaryElement(this.container);
    if (!this.listenersCount.has(el)) {
      this.listenersCount.add(el);
      forwardEventsToLocalHooks(this.eventManager, el, this);
    }
    this.mainElement = el;
  }
  /**
   * Switch to the main focusable element.
   *
   * @param {HTMLElement} element The DOM element.
   */
  setFocusableElement(element) {
    if (!this.listenersCount.has(element)) {
      this.listenersCount.add(element);
      forwardEventsToLocalHooks(this.eventManager, element, this);
    }
    this.mainElement = element;
  }
  /**
   * Get currently set focusable element.
   *
   * @returns {HTMLElement}
   */
  getFocusableElement() {
    return this.mainElement;
  }
  /**
   * Set focus to the focusable element.
   */
  focus() {
    this.mainElement.value = " ";
    if (!isMobileBrowser()) {
      selectElementIfAllowed(this.mainElement);
    }
  }
};
mixin(FocusableWrapper, localHooks_default);
var refCounter = /* @__PURE__ */ new WeakMap();
function createElement(container) {
  const focusableWrapper = new FocusableWrapper(container);
  let counter = refCounter.get(container);
  counter = isNaN(counter) ? 0 : counter;
  refCounter.set(container, counter + 1);
  return focusableWrapper;
}
function deactivateElement(wrapper) {
  wrapper.eventManager.clear();
}
var runLocalHooks = (eventName, subject) => (event2) => subject.runLocalHooks(eventName, event2);
function forwardEventsToLocalHooks(eventManager, element, subject) {
  eventManager.addEventListener(element, "copy", runLocalHooks("copy", subject));
  eventManager.addEventListener(element, "cut", runLocalHooks("cut", subject));
  eventManager.addEventListener(element, "paste", runLocalHooks("paste", subject));
}
var secondaryElements = /* @__PURE__ */ new WeakMap();
function createOrGetSecondaryElement(container) {
  const secondaryElement = secondaryElements.get(container);
  if (secondaryElement) {
    if (!secondaryElement.parentElement) {
      container.appendChild(secondaryElement);
    }
    return secondaryElement;
  }
  const doc = container.defaultView ? container : container.ownerDocument;
  const element = doc.createElement("textarea");
  secondaryElements.set(container, element);
  element.setAttribute("data-hot-input", "");
  element.className = "HandsontableCopyPaste";
  element.tabIndex = -1;
  element.autocomplete = "off";
  element.wrap = "hard";
  element.value = " ";
  container.appendChild(element);
  return element;
}
function destroyElement(wrapper) {
  if (!(wrapper instanceof FocusableWrapper)) {
    return;
  }
  let counter = refCounter.get(wrapper.container);
  counter = isNaN(counter) ? 0 : counter;
  if (counter > 0) {
    counter -= 1;
  }
  deactivateElement(wrapper);
  if (counter <= 0) {
    counter = 0;
    const secondaryElement = secondaryElements.get(wrapper.container);
    if (secondaryElement && secondaryElement.parentNode) {
      secondaryElement.parentNode.removeChild(secondaryElement);
      secondaryElements.delete(wrapper.container);
    }
    wrapper.mainElement = null;
  }
  refCounter.set(wrapper.container, counter);
}

// node_modules/handsontable/plugins/copyPaste/copyableRanges.mjs
function _classPrivateMethodInitSpec2(obj, privateSet) {
  _checkPrivateRedeclaration8(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec7(obj, privateMap, value) {
  _checkPrivateRedeclaration8(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration8(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodGet2(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldGet7(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor7(receiver, privateMap, "get");
  return _classApplyDescriptorGet7(receiver, descriptor);
}
function _classApplyDescriptorGet7(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet7(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor7(receiver, privateMap, "set");
  _classApplyDescriptorSet7(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor7(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet7(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _selectedRange = /* @__PURE__ */ new WeakMap();
var _countRows = /* @__PURE__ */ new WeakMap();
var _countColumns = /* @__PURE__ */ new WeakMap();
var _rowsLimit = /* @__PURE__ */ new WeakMap();
var _columnsLimit = /* @__PURE__ */ new WeakMap();
var _countColumnHeaders = /* @__PURE__ */ new WeakMap();
var _trimColumnsRange = /* @__PURE__ */ new WeakSet();
var _trimRowsRange = /* @__PURE__ */ new WeakSet();
var CopyableRangesFactory = class {
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @param {{
   *   countRows: function(): number,
   *   countColumns: function(): number,
   *   rowsLimit: function(): number,
   *   columnsLimit: function(): number,
   *   countColumnHeaders: function(): number
   * }} dependencies The utils class dependencies.
   */
  constructor(_ref2) {
    let {
      countRows,
      countColumns,
      rowsLimit,
      columnsLimit,
      countColumnHeaders
    } = _ref2;
    _classPrivateMethodInitSpec2(this, _trimRowsRange);
    _classPrivateMethodInitSpec2(this, _trimColumnsRange);
    _classPrivateFieldInitSpec7(this, _selectedRange, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _countRows, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _countColumns, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _rowsLimit, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _columnsLimit, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _countColumnHeaders, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet7(this, _countRows, countRows);
    _classPrivateFieldSet7(this, _countColumns, countColumns);
    _classPrivateFieldSet7(this, _rowsLimit, rowsLimit);
    _classPrivateFieldSet7(this, _columnsLimit, columnsLimit);
    _classPrivateFieldSet7(this, _countColumnHeaders, countColumnHeaders);
  }
  /* eslint-enable jsdoc/require-description-complete-sentence */
  /**
   * Sets the selection range to be processed.
   *
   * @param {CellRange} selectedRange The selection range represented by the CellRange class.
   */
  setSelectedRange(selectedRange) {
    _classPrivateFieldSet7(this, _selectedRange, selectedRange);
  }
  /**
   * Returns a new coords object within the dataset range (cells) with `startRow`, `startCol`, `endRow`
   * and `endCol` keys.
   *
   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}
   */
  getCellsRange() {
    if (_classPrivateFieldGet7(this, _countRows).call(this) === 0 || _classPrivateFieldGet7(this, _countColumns).call(this) === 0) {
      return null;
    }
    const {
      row: startRow,
      col: startCol
    } = _classPrivateFieldGet7(this, _selectedRange).getTopStartCorner();
    const {
      row: endRow,
      col: endCol
    } = _classPrivateFieldGet7(this, _selectedRange).getBottomEndCorner();
    const finalEndRow = _classPrivateMethodGet2(this, _trimRowsRange, _trimRowsRange2).call(this, startRow, endRow);
    const finalEndCol = _classPrivateMethodGet2(this, _trimColumnsRange, _trimColumnsRange2).call(this, startCol, endCol);
    const isRangeTrimmed = endRow !== finalEndRow || endCol !== finalEndCol;
    return {
      isRangeTrimmed,
      startRow,
      startCol,
      endRow: finalEndRow,
      endCol: finalEndCol
    };
  }
  /**
   * Returns a new coords object within the most-bottom column headers range with `startRow`,
   * `startCol`, `endRow` and `endCol` keys.
   *
   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}
   */
  getMostBottomColumnHeadersRange() {
    if (_classPrivateFieldGet7(this, _countColumns).call(this) === 0 || _classPrivateFieldGet7(this, _countColumnHeaders).call(this) === 0) {
      return null;
    }
    const {
      col: startCol
    } = _classPrivateFieldGet7(this, _selectedRange).getTopStartCorner();
    const {
      col: endCol
    } = _classPrivateFieldGet7(this, _selectedRange).getBottomEndCorner();
    const finalEndCol = _classPrivateMethodGet2(this, _trimColumnsRange, _trimColumnsRange2).call(this, startCol, endCol);
    const isRangeTrimmed = endCol !== finalEndCol;
    return {
      isRangeTrimmed,
      startRow: -1,
      startCol,
      endRow: -1,
      endCol: finalEndCol
    };
  }
  /**
   * Returns a new coords object within all column headers layers (including nested headers) range with
   * `startRow`, `startCol`, `endRow` and `endCol` keys.
   *
   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}
   */
  getAllColumnHeadersRange() {
    if (_classPrivateFieldGet7(this, _countColumns).call(this) === 0 || _classPrivateFieldGet7(this, _countColumnHeaders).call(this) === 0) {
      return null;
    }
    const {
      col: startCol
    } = _classPrivateFieldGet7(this, _selectedRange).getTopStartCorner();
    const {
      col: endCol
    } = _classPrivateFieldGet7(this, _selectedRange).getBottomEndCorner();
    const finalEndCol = _classPrivateMethodGet2(this, _trimColumnsRange, _trimColumnsRange2).call(this, startCol, endCol);
    const isRangeTrimmed = endCol !== finalEndCol;
    return {
      isRangeTrimmed,
      startRow: -_classPrivateFieldGet7(this, _countColumnHeaders).call(this),
      startCol,
      endRow: -1,
      endCol: finalEndCol
    };
  }
};
function _trimColumnsRange2(startColumn, endColumn) {
  return Math.min(endColumn, Math.max(startColumn + _classPrivateFieldGet7(this, _columnsLimit).call(this) - 1, startColumn));
}
function _trimRowsRange2(startRow, endRow) {
  return Math.min(endRow, Math.max(startRow + _classPrivateFieldGet7(this, _rowsLimit).call(this) - 1, startRow));
}
function normalizeRanges(ranges) {
  const rows = [];
  const columns = [];
  arrayEach(ranges, (range) => {
    const minRow = Math.min(range.startRow, range.endRow);
    const maxRow = Math.max(range.startRow, range.endRow);
    rangeEach(minRow, maxRow, (row) => {
      if (rows.indexOf(row) === -1) {
        rows.push(row);
      }
    });
    const minColumn = Math.min(range.startCol, range.endCol);
    const maxColumn = Math.max(range.startCol, range.endCol);
    rangeEach(minColumn, maxColumn, (column) => {
      if (columns.indexOf(column) === -1) {
        columns.push(column);
      }
    });
  });
  return {
    rows,
    columns
  };
}

// node_modules/handsontable/plugins/copyPaste/copyPaste.mjs
function _classPrivateMethodInitSpec3(obj, privateSet) {
  _checkPrivateRedeclaration9(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec8(obj, privateMap, value) {
  _checkPrivateRedeclaration9(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration9(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty18(obj, key, value) {
  key = _toPropertyKey18(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey18(arg) {
  var key = _toPrimitive18(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive18(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet3(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldGet8(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor8(receiver, privateMap, "get");
  return _classApplyDescriptorGet8(receiver, descriptor);
}
function _classApplyDescriptorGet8(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet8(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor8(receiver, privateMap, "set");
  _classApplyDescriptorSet8(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor8(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet8(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
pluginHooks_default.getSingleton().register("afterCopyLimit");
pluginHooks_default.getSingleton().register("modifyCopyableRange");
pluginHooks_default.getSingleton().register("beforeCut");
pluginHooks_default.getSingleton().register("afterCut");
pluginHooks_default.getSingleton().register("beforePaste");
pluginHooks_default.getSingleton().register("afterPaste");
pluginHooks_default.getSingleton().register("beforeCopy");
pluginHooks_default.getSingleton().register("afterCopy");
var PLUGIN_KEY11 = "copyPaste";
var PLUGIN_PRIORITY10 = 80;
var SETTING_KEYS3 = ["fragmentSelection"];
var META_HEAD = ['<meta name="generator" content="Handsontable"/>', '<style type="text/css">td{white-space:normal}br{mso-data-placement:same-cell}</style>'].join("");
var _enableCopyColumnHeaders = /* @__PURE__ */ new WeakMap();
var _enableCopyColumnGroupHeaders = /* @__PURE__ */ new WeakMap();
var _enableCopyColumnHeadersOnly = /* @__PURE__ */ new WeakMap();
var _copyMode = /* @__PURE__ */ new WeakMap();
var _isTriggeredByCopy = /* @__PURE__ */ new WeakMap();
var _isTriggeredByCut = /* @__PURE__ */ new WeakMap();
var _copyableRangesFactory = /* @__PURE__ */ new WeakMap();
var _countCopiedHeaders = /* @__PURE__ */ new WeakSet();
var CopyPaste = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec3(this, _countCopiedHeaders);
    _defineProperty18(this, "columnsLimit", Infinity);
    _defineProperty18(this, "rowsLimit", Infinity);
    _defineProperty18(this, "pasteMode", "overwrite");
    _defineProperty18(this, "uiContainer", this.hot.rootDocument.body);
    _classPrivateFieldInitSpec8(this, _enableCopyColumnHeaders, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _enableCopyColumnGroupHeaders, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _enableCopyColumnHeadersOnly, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _copyMode, {
      writable: true,
      value: "cells-only"
    });
    _classPrivateFieldInitSpec8(this, _isTriggeredByCopy, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _isTriggeredByCut, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _copyableRangesFactory, {
      writable: true,
      value: new CopyableRangesFactory({
        countRows: () => this.hot.countRows(),
        countColumns: () => this.hot.countCols(),
        rowsLimit: () => this.rowsLimit,
        columnsLimit: () => this.columnsLimit,
        countColumnHeaders: () => this.hot.view.getColumnHeadersCount()
      })
    });
    _defineProperty18(this, "copyableRanges", []);
    _defineProperty18(this, "focusableElement", void 0);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY11;
  }
  static get SETTING_KEYS() {
    return [PLUGIN_KEY11, ...SETTING_KEYS3];
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY10;
  }
  /**
   * Checks if the [`CopyPaste`](#copypaste) plugin is enabled.
   *
   * This method gets called by Handsontable's [`beforeInit`](@/api/hooks.md#beforeinit) hook.
   * If it returns `true`, the [`enablePlugin()`](#enableplugin) method gets called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY11];
  }
  /**
   * Enables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    const {
      [PLUGIN_KEY11]: settings
    } = this.hot.getSettings();
    if (typeof settings === "object") {
      var _settings$pasteMode, _settings$uiContainer;
      this.pasteMode = (_settings$pasteMode = settings.pasteMode) !== null && _settings$pasteMode !== void 0 ? _settings$pasteMode : this.pasteMode;
      this.rowsLimit = isNaN(settings.rowsLimit) ? this.rowsLimit : settings.rowsLimit;
      this.columnsLimit = isNaN(settings.columnsLimit) ? this.columnsLimit : settings.columnsLimit;
      _classPrivateFieldSet8(this, _enableCopyColumnHeaders, !!settings.copyColumnHeaders);
      _classPrivateFieldSet8(this, _enableCopyColumnGroupHeaders, !!settings.copyColumnGroupHeaders);
      _classPrivateFieldSet8(this, _enableCopyColumnHeadersOnly, !!settings.copyColumnHeadersOnly);
      this.uiContainer = (_settings$uiContainer = settings.uiContainer) !== null && _settings$uiContainer !== void 0 ? _settings$uiContainer : this.uiContainer;
    }
    this.addHook("afterContextMenuDefaultOptions", (options) => this.onAfterContextMenuDefaultOptions(options));
    this.addHook("afterOnCellMouseUp", () => this.onAfterOnCellMouseUp());
    this.addHook("afterSelectionEnd", () => this.onAfterSelectionEnd());
    this.addHook("beforeKeyDown", () => this.onBeforeKeyDown());
    this.focusableElement = createElement(this.uiContainer);
    this.focusableElement.addLocalHook("copy", (event2) => this.onCopy(event2)).addLocalHook("cut", (event2) => this.onCut(event2)).addLocalHook("paste", (event2) => this.onPaste(event2));
    super.enablePlugin();
  }
  /**
   * Updates the state of the [`CopyPaste`](#copypaste) plugin.
   *
   * Gets called when [`updateSettings()`](@/api/core.md#updatesettings)
   * is invoked with any of the following configuration options:
   *  - [`copyPaste`](@/api/options.md#copypaste)
   *  - [`fragmentSelection`](@/api/options.md#fragmentselection)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    this.getOrCreateFocusableElement();
    super.updatePlugin();
  }
  /**
   * Disables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.
   */
  disablePlugin() {
    if (this.focusableElement) {
      destroyElement(this.focusableElement);
    }
    super.disablePlugin();
  }
  /**
   * Copies the contents of the selected cells (and/or their related column headers) to the system clipboard.
   *
   * Takes an optional parameter (`copyMode`) that defines the scope of copying:
   *
   * | `copyMode` value              | Description                                                     |
   * | ----------------------------- | --------------------------------------------------------------- |
   * | `'cells-only'` (default)      | Copy the selected cells                                         |
   * | `'with-column-headers'`       | - Copy the selected cells<br>- Copy the nearest column headers  |
   * | `'with-column-group-headers'` | - Copy the selected cells<br>- Copy all related columns headers |
   * | `'column-headers-only'`       | Copy the nearest column headers (without copying cells)         |
   *
   * @param {string} [copyMode='cells-only'] Copy mode.
   */
  copy() {
    let copyMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "cells-only";
    _classPrivateFieldSet8(this, _copyMode, copyMode);
    _classPrivateFieldSet8(this, _isTriggeredByCopy, true);
    this.getOrCreateFocusableElement();
    this.focusableElement.focus();
    this.hot.rootDocument.execCommand("copy");
  }
  /**
   * Copies the contents of the selected cells.
   */
  copyCellsOnly() {
    this.copy("cells-only");
  }
  /**
   * Copies the contents of column headers that are nearest to the selected cells.
   */
  copyColumnHeadersOnly() {
    this.copy("column-headers-only");
  }
  /**
   * Copies the contents of the selected cells and all their related column headers.
   */
  copyWithAllColumnHeaders() {
    this.copy("with-column-group-headers");
  }
  /**
   * Copies the contents of the selected cells and their nearest column headers.
   */
  copyWithColumnHeaders() {
    this.copy("with-column-headers");
  }
  /**
   * Cuts the contents of the selected cells to the system clipboard.
   */
  cut() {
    _classPrivateFieldSet8(this, _isTriggeredByCut, true);
    this.getOrCreateFocusableElement();
    this.focusableElement.focus();
    this.hot.rootDocument.execCommand("cut");
  }
  /**
   * Converts the contents of multiple ranges (`ranges`) into a single string.
   *
   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `endRow`, `startCol` and `endCol`.
   * @returns {string} A string that will be copied to the clipboard.
   */
  getRangedCopyableData(ranges) {
    return stringify2(this.getRangedData(ranges));
  }
  /**
   * Converts the contents of multiple ranges (`ranges`) into an array of arrays.
   *
   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.
   * @returns {Array[]} An array of arrays that will be copied to the clipboard.
   */
  getRangedData(ranges) {
    const data = [];
    const {
      rows,
      columns
    } = normalizeRanges(ranges);
    arrayEach(rows, (row) => {
      const rowSet = [];
      arrayEach(columns, (column) => {
        if (row < 0) {
          rowSet.push(this.hot.getColHeader(column, row));
        } else {
          rowSet.push(this.hot.getCopyableData(row, column));
        }
      });
      data.push(rowSet);
    });
    return data;
  }
  /**
   * Simulates the paste action.
   *
   * For security reasons, modern browsers don't allow reading from the system clipboard.
   *
   * @param {string} pastableText The value to paste, as a raw string.
   * @param {string} [pastableHtml=''] The value to paste, as HTML.
   */
  paste() {
    let pastableText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let pastableHtml = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pastableText;
    if (!pastableText && !pastableHtml) {
      return;
    }
    const pasteData = new PasteEvent();
    if (pastableText) {
      pasteData.clipboardData.setData("text/plain", pastableText);
    }
    if (pastableHtml) {
      pasteData.clipboardData.setData("text/html", pastableHtml);
    }
    this.getOrCreateFocusableElement();
    this.onPaste(pasteData);
  }
  /**
   * Prepares copyable text from the cells selection in the invisible textarea.
   */
  setCopyableText() {
    const selectionRange = this.hot.getSelectedRangeLast();
    if (!selectionRange) {
      return;
    }
    _classPrivateFieldGet8(this, _copyableRangesFactory).setSelectedRange(selectionRange);
    const groupedRanges = /* @__PURE__ */ new Map([["headers", null], ["cells", null]]);
    if (_classPrivateFieldGet8(this, _copyMode) === "column-headers-only") {
      groupedRanges.set("headers", _classPrivateFieldGet8(this, _copyableRangesFactory).getMostBottomColumnHeadersRange());
    } else {
      if (_classPrivateFieldGet8(this, _copyMode) === "with-column-headers") {
        groupedRanges.set("headers", _classPrivateFieldGet8(this, _copyableRangesFactory).getMostBottomColumnHeadersRange());
      } else if (_classPrivateFieldGet8(this, _copyMode) === "with-column-group-headers") {
        groupedRanges.set("headers", _classPrivateFieldGet8(this, _copyableRangesFactory).getAllColumnHeadersRange());
      }
      groupedRanges.set("cells", _classPrivateFieldGet8(this, _copyableRangesFactory).getCellsRange());
    }
    this.copyableRanges = Array.from(groupedRanges.values()).filter((range) => range !== null).map((_ref2) => {
      let {
        startRow,
        startCol,
        endRow,
        endCol
      } = _ref2;
      return {
        startRow,
        startCol,
        endRow,
        endCol
      };
    });
    this.copyableRanges = this.hot.runHooks("modifyCopyableRange", this.copyableRanges);
    const cellsRange = groupedRanges.get("cells");
    if (cellsRange !== null && cellsRange.isRangeTrimmed) {
      const {
        startRow,
        startCol,
        endRow,
        endCol
      } = cellsRange;
      this.hot.runHooks("afterCopyLimit", endRow - startRow + 1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);
    }
  }
  /**
   * Force focus on editable element.
   *
   * @private
   */
  getOrCreateFocusableElement() {
    var _this$hot$getActiveEd;
    const editableElement = (_this$hot$getActiveEd = this.hot.getActiveEditor()) === null || _this$hot$getActiveEd === void 0 ? void 0 : _this$hot$getActiveEd.TEXTAREA;
    if (editableElement) {
      this.focusableElement.setFocusableElement(editableElement);
    } else {
      this.focusableElement.useSecondaryElement();
    }
  }
  /**
   * Verifies if editor exists and is open.
   *
   * @private
   * @returns {boolean}
   */
  isEditorOpened() {
    var _this$hot$getActiveEd2;
    return (_this$hot$getActiveEd2 = this.hot.getActiveEditor()) === null || _this$hot$getActiveEd2 === void 0 ? void 0 : _this$hot$getActiveEd2.isOpened();
  }
  /**
   * Prepares new values to populate them into datasource.
   *
   * @private
   * @param {Array} inputArray An array of the data to populate.
   * @param {Array} [selection] The selection which indicates from what position the data will be populated.
   * @returns {Array} Range coordinates after populate data.
   */
  populateValues(inputArray) {
    let selection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.hot.getSelectedRangeLast();
    if (!inputArray.length) {
      return;
    }
    const populatedRowsLength = inputArray.length;
    const populatedColumnsLength = inputArray[0].length;
    const newRows = [];
    const {
      row: startRow,
      col: startColumn
    } = selection.getTopStartCorner();
    const {
      row: endRowFromSelection,
      col: endColumnFromSelection
    } = selection.getBottomEndCorner();
    let visualRowForPopulatedData = startRow;
    let visualColumnForPopulatedData = startColumn;
    let lastVisualRow = startRow;
    let lastVisualColumn = startColumn;
    while (newRows.length < populatedRowsLength || visualRowForPopulatedData <= endRowFromSelection) {
      const {
        skipRowOnPaste,
        visualRow
      } = this.hot.getCellMeta(visualRowForPopulatedData, startColumn);
      visualRowForPopulatedData = visualRow + 1;
      if (skipRowOnPaste === true) {
        continue;
      }
      lastVisualRow = visualRow;
      visualColumnForPopulatedData = startColumn;
      const newRow = [];
      const insertedRow = newRows.length % populatedRowsLength;
      while (newRow.length < populatedColumnsLength || visualColumnForPopulatedData <= endColumnFromSelection) {
        const {
          skipColumnOnPaste,
          visualCol
        } = this.hot.getCellMeta(startRow, visualColumnForPopulatedData);
        visualColumnForPopulatedData = visualCol + 1;
        if (skipColumnOnPaste === true) {
          continue;
        }
        lastVisualColumn = visualCol;
        const insertedColumn = newRow.length % populatedColumnsLength;
        newRow.push(inputArray[insertedRow][insertedColumn]);
      }
      newRows.push(newRow);
    }
    this.hot.populateFromArray(startRow, startColumn, newRows, void 0, void 0, "CopyPaste.paste", this.pasteMode);
    return [startRow, startColumn, lastVisualRow, lastVisualColumn];
  }
  /**
   * `copy` event callback on textarea element.
   *
   * @param {Event} event ClipboardEvent.
   * @private
   */
  onCopy(event2) {
    if (!this.hot.isListening() && !_classPrivateFieldGet8(this, _isTriggeredByCopy) || this.isEditorOpened()) {
      return;
    }
    this.setCopyableText();
    _classPrivateFieldSet8(this, _isTriggeredByCopy, false);
    const data = this.getRangedData(this.copyableRanges);
    const copiedHeadersCount = _classPrivateMethodGet3(this, _countCopiedHeaders, _countCopiedHeaders2).call(this, this.copyableRanges);
    const allowCopying = !!this.hot.runHooks("beforeCopy", data, this.copyableRanges, copiedHeadersCount);
    if (allowCopying) {
      const textPlain = stringify2(data);
      if (event2 && event2.clipboardData) {
        const textHTML = _dataToHTML(data, this.hot.rootDocument);
        event2.clipboardData.setData("text/plain", textPlain);
        event2.clipboardData.setData("text/html", [META_HEAD, textHTML].join(""));
      } else if (typeof ClipboardEvent === "undefined") {
        this.hot.rootWindow.clipboardData.setData("Text", textPlain);
      }
      this.hot.runHooks("afterCopy", data, this.copyableRanges, copiedHeadersCount);
    }
    _classPrivateFieldSet8(this, _copyMode, "cells-only");
    event2.preventDefault();
  }
  /**
   * `cut` event callback on textarea element.
   *
   * @param {Event} event ClipboardEvent.
   * @private
   */
  onCut(event2) {
    if (!this.hot.isListening() && !_classPrivateFieldGet8(this, _isTriggeredByCut) || this.isEditorOpened()) {
      return;
    }
    this.setCopyableText();
    _classPrivateFieldSet8(this, _isTriggeredByCut, false);
    const rangedData = this.getRangedData(this.copyableRanges);
    const allowCuttingOut = !!this.hot.runHooks("beforeCut", rangedData, this.copyableRanges);
    if (allowCuttingOut) {
      const textPlain = stringify2(rangedData);
      if (event2 && event2.clipboardData) {
        const textHTML = _dataToHTML(rangedData, this.hot.rootDocument);
        event2.clipboardData.setData("text/plain", textPlain);
        event2.clipboardData.setData("text/html", [META_HEAD, textHTML].join(""));
      } else if (typeof ClipboardEvent === "undefined") {
        this.hot.rootWindow.clipboardData.setData("Text", textPlain);
      }
      this.hot.emptySelectedCells("CopyPaste.cut");
      this.hot.runHooks("afterCut", rangedData, this.copyableRanges);
    }
    event2.preventDefault();
  }
  /**
   * `paste` event callback on textarea element.
   *
   * @param {Event} event ClipboardEvent or pseudo ClipboardEvent, if paste was called manually.
   * @private
   */
  onPaste(event2) {
    if (!this.hot.isListening() || this.isEditorOpened()) {
      return;
    }
    if (event2 && event2.preventDefault) {
      event2.preventDefault();
    }
    let pastedData;
    if (event2 && typeof event2.clipboardData !== "undefined") {
      const textHTML = sanitize(event2.clipboardData.getData("text/html"), {
        ADD_TAGS: ["meta"],
        ADD_ATTR: ["content"],
        FORCE_BODY: true
      });
      if (textHTML && /(<table)|(<TABLE)/g.test(textHTML)) {
        const parsedConfig = htmlToGridSettings(textHTML, this.hot.rootDocument);
        pastedData = parsedConfig.data;
      } else {
        pastedData = event2.clipboardData.getData("text/plain");
      }
    } else if (typeof ClipboardEvent === "undefined" && typeof this.hot.rootWindow.clipboardData !== "undefined") {
      pastedData = this.hot.rootWindow.clipboardData.getData("Text");
    }
    if (typeof pastedData === "string") {
      pastedData = parse(pastedData);
    }
    if (pastedData && pastedData.length === 0) {
      return;
    }
    if (this.hot.runHooks("beforePaste", pastedData, this.copyableRanges) === false) {
      return;
    }
    const [startRow, startColumn, endRow, endColumn] = this.populateValues(pastedData);
    this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, endRow), Math.min(this.hot.countCols() - 1, endColumn));
    this.hot.runHooks("afterPaste", pastedData, this.copyableRanges);
  }
  /**
   * Add copy and cut options to the Context Menu.
   *
   * @private
   * @param {object} options Contains default added options of the Context Menu.
   */
  onAfterContextMenuDefaultOptions(options) {
    options.items.push({
      name: "---------"
    }, copyItem(this));
    if (_classPrivateFieldGet8(this, _enableCopyColumnHeaders)) {
      options.items.push(copyWithColumnHeadersItem(this));
    }
    if (_classPrivateFieldGet8(this, _enableCopyColumnGroupHeaders)) {
      options.items.push(copyWithColumnGroupHeadersItem(this));
    }
    if (_classPrivateFieldGet8(this, _enableCopyColumnHeadersOnly)) {
      options.items.push(copyColumnHeadersOnlyItem(this));
    }
    options.items.push(cutItem(this));
  }
  /**
   * Force focus on focusableElement.
   *
   * @private
   */
  onAfterOnCellMouseUp() {
    if (!this.hot.isListening() || this.isEditorOpened() || this.hot.getSettings().fragmentSelection) {
      return;
    }
    this.getOrCreateFocusableElement();
    this.focusableElement.focus();
  }
  /**
   * Force focus on focusableElement after end of the selection.
   *
   * @private
   */
  onAfterSelectionEnd() {
    if (this.isEditorOpened()) {
      return;
    }
    this.getOrCreateFocusableElement();
    if (this.hot.getSettings().fragmentSelection && this.focusableElement.getFocusableElement() !== this.hot.rootDocument.activeElement && getSelectionText()) {
      return;
    }
    this.setCopyableText();
    this.focusableElement.focus();
  }
  /**
   * `beforeKeyDown` listener to force focus of focusableElement.
   *
   * @private
   */
  onBeforeKeyDown() {
    if (!this.hot.isListening() || this.isEditorOpened()) {
      return;
    }
    const activeElement = this.hot.rootDocument.activeElement;
    const activeEditor = this.hot.getActiveEditor();
    if (!activeEditor || activeElement !== this.focusableElement.getFocusableElement() && activeElement !== activeEditor.select) {
      return;
    }
    this.getOrCreateFocusableElement();
    this.focusableElement.focus();
  }
  /**
   * Destroys the `CopyPaste` plugin instance.
   */
  destroy() {
    if (this.focusableElement) {
      destroyElement(this.focusableElement);
      this.focusableElement = null;
    }
    super.destroy();
  }
};
function _countCopiedHeaders2(ranges) {
  const {
    rows
  } = normalizeRanges(ranges);
  let columnHeadersCount = 0;
  for (let row = 0; row < rows.length; row++) {
    if (rows[row] >= 0) {
      break;
    }
    columnHeadersCount += 1;
  }
  return {
    columnHeadersCount
  };
}

// node_modules/handsontable/plugins/customBorders/utils.mjs
function createId(row, col) {
  return `border_row${row}col${col}`;
}
function createDefaultCustomBorder() {
  return {
    width: 1,
    color: "#000"
  };
}
function createSingleEmptyBorder() {
  return {
    hide: true
  };
}
function createDefaultHtBorder() {
  return {
    width: 1,
    color: "#000",
    cornerVisible: false
  };
}
function normalizeBorder(border) {
  if (isDefined(border.start) || isDefined(border.left)) {
    var _border$start;
    border.start = (_border$start = border.start) !== null && _border$start !== void 0 ? _border$start : border.left;
  }
  if (isDefined(border.end) || isDefined(border.right)) {
    var _border$end;
    border.end = (_border$end = border.end) !== null && _border$end !== void 0 ? _border$end : border.right;
  }
  delete border.left;
  delete border.right;
  return border;
}
function denormalizeBorder(border) {
  if (isDefined(border.start)) {
    border.left = border.start;
  }
  if (isDefined(border.end)) {
    border.right = border.end;
  }
  return border;
}
function createEmptyBorders(row, col) {
  return {
    id: createId(row, col),
    border: createDefaultHtBorder(),
    row,
    col,
    top: createSingleEmptyBorder(),
    bottom: createSingleEmptyBorder(),
    start: createSingleEmptyBorder(),
    end: createSingleEmptyBorder()
  };
}
function extendDefaultBorder(defaultBorder, customBorder) {
  if (hasOwnProperty2(customBorder, "border") && customBorder.border) {
    defaultBorder.border = customBorder.border;
  }
  if (hasOwnProperty2(customBorder, "top") && isDefined(customBorder.top)) {
    if (customBorder.top) {
      if (!isObject2(customBorder.top)) {
        customBorder.top = createDefaultCustomBorder();
      }
      defaultBorder.top = customBorder.top;
    } else {
      customBorder.top = createSingleEmptyBorder();
      defaultBorder.top = customBorder.top;
    }
  }
  if (hasOwnProperty2(customBorder, "bottom") && isDefined(customBorder.bottom)) {
    if (customBorder.bottom) {
      if (!isObject2(customBorder.bottom)) {
        customBorder.bottom = createDefaultCustomBorder();
      }
      defaultBorder.bottom = customBorder.bottom;
    } else {
      customBorder.bottom = createSingleEmptyBorder();
      defaultBorder.bottom = customBorder.bottom;
    }
  }
  if (hasOwnProperty2(customBorder, "start") && isDefined(customBorder.start)) {
    if (customBorder.start) {
      if (!isObject2(customBorder.start)) {
        customBorder.start = createDefaultCustomBorder();
      }
      defaultBorder.start = customBorder.start;
    } else {
      customBorder.start = createSingleEmptyBorder();
      defaultBorder.start = customBorder.start;
    }
  }
  if (hasOwnProperty2(customBorder, "end") && isDefined(customBorder.end)) {
    if (customBorder.end) {
      if (!isObject2(customBorder.end)) {
        customBorder.end = createDefaultCustomBorder();
      }
      defaultBorder.end = customBorder.end;
    } else {
      customBorder.end = createSingleEmptyBorder();
      defaultBorder.end = customBorder.end;
    }
  }
  return defaultBorder;
}
function checkSelectionBorders(hot, direction) {
  let atLeastOneHasBorder = false;
  arrayEach(hot.getSelectedRange(), (range) => {
    range.forAll((r, c) => {
      if (r < 0 || c < 0) {
        return;
      }
      const metaBorders = hot.getCellMeta(r, c).borders;
      if (metaBorders) {
        if (direction) {
          if (!hasOwnProperty2(metaBorders[direction], "hide") || metaBorders[direction].hide === false) {
            atLeastOneHasBorder = true;
            return false;
          }
        } else {
          atLeastOneHasBorder = true;
          return false;
        }
      }
    });
  });
  return atLeastOneHasBorder;
}
function markSelected(label) {
  return `<span class="selected">${String.fromCharCode(10003)}</span>${label}`;
}
function hasLeftRightTypeOptions(borders) {
  return borders.some((border) => isDefined(border.left) || isDefined(border.right));
}
function hasStartEndTypeOptions(borders) {
  return borders.some((border) => isDefined(border.start) || isDefined(border.end));
}
var physicalToInlinePropNames = /* @__PURE__ */ new Map([["left", "start"], ["right", "end"]]);
function toInlinePropName(propName) {
  var _physicalToInlineProp;
  return (_physicalToInlineProp = physicalToInlinePropNames.get(propName)) !== null && _physicalToInlineProp !== void 0 ? _physicalToInlineProp : propName;
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/bottom.mjs
function bottom(customBordersPlugin) {
  return {
    key: "borders:bottom",
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_BOTTOM);
      const hasBorder = checkSelectionBorders(this, "bottom");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback(key, selected) {
      const hasBorder = checkSelectionBorders(this, "bottom");
      customBordersPlugin.prepareBorder(selected, "bottom", hasBorder);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/left.mjs
function left(customBordersPlugin) {
  const borderDirection = customBordersPlugin.hot.isRtl() ? "end" : "start";
  return {
    key: "borders:left",
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_LEFT);
      const hasBorder = checkSelectionBorders(this, borderDirection);
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback(key, selected) {
      const hasBorder = checkSelectionBorders(this, borderDirection);
      customBordersPlugin.prepareBorder(selected, borderDirection, hasBorder);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/noBorders.mjs
function noBorders(customBordersPlugin) {
  return {
    key: "borders:no_borders",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_BORDERS);
    },
    callback(key, selected) {
      customBordersPlugin.prepareBorder(selected, "noBorders");
    },
    disabled() {
      return !checkSelectionBorders(this);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/right.mjs
function right(customBordersPlugin) {
  const borderDirection = customBordersPlugin.hot.isRtl() ? "start" : "end";
  return {
    key: "borders:right",
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_RIGHT);
      const hasBorder = checkSelectionBorders(this, borderDirection);
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback(key, selected) {
      const hasBorder = checkSelectionBorders(this, borderDirection);
      customBordersPlugin.prepareBorder(selected, borderDirection, hasBorder);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/top.mjs
function top(customBordersPlugin) {
  return {
    key: "borders:top",
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_TOP);
      const hasBorder = checkSelectionBorders(this, "top");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback(key, selected) {
      const hasBorder = checkSelectionBorders(this, "top");
      customBordersPlugin.prepareBorder(selected, "top", hasBorder);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/customBorders.mjs
function _defineProperty19(obj, key, value) {
  key = _toPropertyKey19(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey19(arg) {
  var key = _toPrimitive19(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive19(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var PLUGIN_KEY12 = "customBorders";
var PLUGIN_PRIORITY11 = 90;
var CustomBorders = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _defineProperty19(this, "savedBorders", []);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY12;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY11;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link CustomBorders#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY12];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.addHook("afterContextMenuDefaultOptions", (options) => this.onAfterContextMenuDefaultOptions(options));
    this.addHook("init", () => this.onAfterInit());
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hideBorders();
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`customBorders`](@/api/options.md#customborders)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    this.changeBorderSettings();
    super.updatePlugin();
  }
  /**
   * Set custom borders.
   *
   * @example
   * ```js
   * const customBordersPlugin = hot.getPlugin('customBorders');
   *
   * // Using an array of arrays (produced by `.getSelected()` method).
   * customBordersPlugin.setBorders([[1, 1, 2, 2], [6, 2, 0, 2]], {start: {width: 2, color: 'blue'}});
   *
   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
   * //  Selecting a cell range.
   * hot.selectCell(0, 0, 2, 2);
   * // Returning selected cells' range with the getSelectedRange method.
   * customBordersPlugin.setBorders(hot.getSelectedRange(), {start: {hide: false, width: 2, color: 'blue'}});
   * ```
   *
   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
   * @param {object} borderObject Object with `top`, `right`, `bottom` and `start` properties.
   */
  setBorders(selectionRanges, borderObject) {
    let borderKeys = ["top", "bottom", "start", "end"];
    let normBorder = null;
    if (borderObject) {
      this.checkSettingsCohesion([borderObject]);
      borderKeys = Object.keys(borderObject);
      normBorder = normalizeBorder(borderObject);
    }
    const selectionType = detectSelectionType(selectionRanges);
    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
    arrayEach(selectionRanges, (selection) => {
      const [rowStart, columnStart, rowEnd, columnEnd] = selectionSchemaNormalizer(selection);
      for (let row = rowStart; row <= rowEnd; row += 1) {
        for (let col = columnStart; col <= columnEnd; col += 1) {
          arrayEach(borderKeys, (borderKey) => {
            this.prepareBorderFromCustomAdded(row, col, normBorder, toInlinePropName(borderKey));
          });
        }
      }
    });
    this.hot.view.render();
  }
  /**
   * Get custom borders.
   *
   * @example
   * ```js
   * const customBordersPlugin = hot.getPlugin('customBorders');
   *
   * // Using an array of arrays (produced by `.getSelected()` method).
   * customBordersPlugin.getBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);
   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
   * customBordersPlugin.getBorders(hot.getSelectedRange());
   * // Using without param - return all customBorders.
   * customBordersPlugin.getBorders();
   * ```
   *
   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
   * @returns {object[]} Returns array of border objects.
   */
  getBorders(selectionRanges) {
    if (!Array.isArray(selectionRanges)) {
      return this.savedBorders;
    }
    const selectionType = detectSelectionType(selectionRanges);
    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);
    const selectedBorders = [];
    arrayEach(selectionRanges, (selection) => {
      const [rowStart, columnStart, rowEnd, columnEnd] = selectionSchemaNormalizer(selection);
      for (let row = rowStart; row <= rowEnd; row += 1) {
        for (let col = columnStart; col <= columnEnd; col += 1) {
          arrayEach(this.savedBorders, (border) => {
            if (border.row === row && border.col === col) {
              selectedBorders.push(denormalizeBorder(border));
            }
          });
        }
      }
    });
    return selectedBorders;
  }
  /**
   * Clear custom borders.
   *
   * @example
   * ```js
   * const customBordersPlugin = hot.getPlugin('customBorders');
   *
   * // Using an array of arrays (produced by `.getSelected()` method).
   * customBordersPlugin.clearBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);
   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
   * customBordersPlugin.clearBorders(hot.getSelectedRange());
   * // Using without param - clear all customBorders.
   * customBordersPlugin.clearBorders();
   * ```
   *
   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
   */
  clearBorders(selectionRanges) {
    if (selectionRanges) {
      this.setBorders(selectionRanges);
    } else {
      arrayEach(this.savedBorders, (border) => {
        this.clearBordersFromSelectionSettings(border.id);
        this.clearNullCellRange();
        this.hot.removeCellMeta(border.row, border.col, "borders");
      });
      this.savedBorders.length = 0;
    }
  }
  /**
   * Insert WalkontableSelection instance into Walkontable settings.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.
   */
  insertBorderIntoSettings(border, place) {
    const hasSavedBorders = this.checkSavedBorders(border);
    if (!hasSavedBorders) {
      this.savedBorders.push(border);
    }
    const visualCellRange = this.hot._createCellRange(this.hot._createCellCoords(border.row, border.col));
    const hasCustomSelections = this.checkCustomSelections(border, visualCellRange, place);
    if (!hasCustomSelections) {
      this.hot.selection.highlight.addCustomSelection({
        border,
        visualCellRange
      });
    }
  }
  /**
   * Prepare borders from setting (single cell).
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} borderDescriptor Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.
   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.
   */
  prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {
    const nrOfRows = this.hot.countRows();
    const nrOfColumns = this.hot.countCols();
    if (row >= nrOfRows || column >= nrOfColumns) {
      return;
    }
    let border = createEmptyBorders(row, column);
    if (borderDescriptor) {
      border = extendDefaultBorder(border, borderDescriptor);
      arrayEach(this.hot.selection.highlight.customSelections, (customSelection) => {
        if (border.id === customSelection.settings.id) {
          Object.assign(customSelection.settings, borderDescriptor);
          border.id = customSelection.settings.id;
          border.top = customSelection.settings.top;
          border.bottom = customSelection.settings.bottom;
          border.start = customSelection.settings.start;
          border.end = customSelection.settings.end;
          return false;
        }
      });
    }
    this.hot.setCellMeta(row, column, "borders", denormalizeBorder(border));
    this.insertBorderIntoSettings(border, place);
  }
  /**
   * Prepare borders from setting (object).
   *
   * @private
   * @param {object} range {CellRange} The CellRange object.
   * @param {object} customBorder Object with `start`, `end`, `top` and `bottom` properties.
   */
  prepareBorderFromCustomAddedRange(range, customBorder) {
    const lastRowIndex = Math.min(range.to.row, this.hot.countRows() - 1);
    const lastColumnIndex = Math.min(range.to.col, this.hot.countCols() - 1);
    rangeEach(range.from.row, lastRowIndex, (rowIndex) => {
      rangeEach(range.from.col, lastColumnIndex, (colIndex) => {
        const border = createEmptyBorders(rowIndex, colIndex);
        let add2 = 0;
        if (rowIndex === range.from.row) {
          if (hasOwnProperty2(customBorder, "top")) {
            add2 += 1;
            border.top = customBorder.top;
          }
        }
        if (rowIndex === range.to.row) {
          if (hasOwnProperty2(customBorder, "bottom")) {
            add2 += 1;
            border.bottom = customBorder.bottom;
          }
        }
        if (colIndex === range.from.col) {
          if (hasOwnProperty2(customBorder, "start")) {
            add2 += 1;
            border.start = customBorder.start;
          }
        }
        if (colIndex === range.to.col) {
          if (hasOwnProperty2(customBorder, "end")) {
            add2 += 1;
            border.end = customBorder.end;
          }
        }
        if (add2 > 0) {
          this.hot.setCellMeta(rowIndex, colIndex, "borders", denormalizeBorder(border));
          this.insertBorderIntoSettings(border);
        } else {
        }
      });
    });
  }
  /**
   * Remove border (triggered from context menu).
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   */
  removeAllBorders(row, column) {
    const borderId = createId(row, column);
    this.spliceBorder(borderId);
    this.clearBordersFromSelectionSettings(borderId);
    this.clearNullCellRange();
    this.hot.removeCellMeta(row, column, "borders");
  }
  /**
   * Set borders for each cell re. To border position.
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.
   * @param {boolean} remove True when remove borders, and false when add borders.
   */
  setBorder(row, column, place, remove) {
    let bordersMeta = this.hot.getCellMeta(row, column).borders;
    if (!bordersMeta || bordersMeta.border === void 0) {
      bordersMeta = createEmptyBorders(row, column);
    } else {
      bordersMeta = normalizeBorder(bordersMeta);
    }
    if (remove) {
      bordersMeta[place] = createSingleEmptyBorder();
      const hideCount = this.countHide(bordersMeta);
      if (hideCount === 4) {
        this.removeAllBorders(row, column);
      } else {
        const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
        if (!customSelectionsChecker) {
          this.insertBorderIntoSettings(bordersMeta);
        }
        this.hot.setCellMeta(row, column, "borders", denormalizeBorder(bordersMeta));
      }
    } else {
      bordersMeta[place] = createDefaultCustomBorder();
      const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
      if (!customSelectionsChecker) {
        this.insertBorderIntoSettings(bordersMeta);
      }
      this.hot.setCellMeta(row, column, "borders", denormalizeBorder(bordersMeta));
    }
  }
  /**
   * Prepare borders based on cell and border position.
   *
   * @private
   * @param {CellRange[]} selected An array of CellRange objects.
   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.
   * @param {boolean} remove True when remove borders, and false when add borders.
   */
  prepareBorder(selected, place, remove) {
    arrayEach(selected, (_ref2) => {
      let {
        start,
        end
      } = _ref2;
      if (start.row === end.row && start.col === end.col) {
        if (place === "noBorders") {
          this.removeAllBorders(start.row, start.col);
        } else {
          this.setBorder(start.row, start.col, place, remove);
        }
      } else {
        switch (place) {
          case "noBorders":
            rangeEach(start.col, end.col, (colIndex) => {
              rangeEach(start.row, end.row, (rowIndex) => {
                this.removeAllBorders(rowIndex, colIndex);
              });
            });
            break;
          case "top":
            rangeEach(start.col, end.col, (topCol) => {
              this.setBorder(start.row, topCol, place, remove);
            });
            break;
          case "bottom":
            rangeEach(start.col, end.col, (bottomCol) => {
              this.setBorder(end.row, bottomCol, place, remove);
            });
            break;
          case "start":
            rangeEach(start.row, end.row, (rowStart) => {
              this.setBorder(rowStart, start.col, place, remove);
            });
            break;
          case "end":
            rangeEach(start.row, end.row, (rowEnd) => {
              this.setBorder(rowEnd, end.col, place, remove);
            });
            break;
          default:
            break;
        }
      }
    });
  }
  /**
   * Create borders from settings.
   *
   * @private
   * @param {Array} customBorders Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.
   */
  createCustomBorders(customBorders) {
    arrayEach(customBorders, (customBorder) => {
      const normCustomBorder = normalizeBorder(customBorder);
      if (customBorder.range) {
        this.prepareBorderFromCustomAddedRange(customBorder.range, normCustomBorder);
      } else {
        this.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, normCustomBorder);
      }
    });
  }
  /**
   * Count hide property in border object.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   * @returns {number}
   */
  countHide(border) {
    const {
      top: top2,
      bottom: bottom2,
      start,
      end
    } = border;
    const values = [top2, bottom2, start, end];
    return arrayReduce(values, (accumulator, value) => {
      let result = accumulator;
      if (value && value.hide) {
        result += 1;
      }
      return result;
    }, 0);
  }
  /**
   * Clear borders settings from custom selections.
   *
   * @private
   * @param {string} borderId Border id name as string.
   */
  clearBordersFromSelectionSettings(borderId) {
    const index2 = arrayMap(this.hot.selection.highlight.customSelections, (customSelection) => customSelection.settings.id).indexOf(borderId);
    if (index2 > -1) {
      this.hot.selection.highlight.customSelections[index2].clear();
    }
  }
  /**
   * Clear cellRange with null value.
   *
   * @private
   */
  clearNullCellRange() {
    arrayEach(this.hot.selection.highlight.customSelections, (customSelection, index2) => {
      if (customSelection.cellRange === null) {
        this.hot.selection.highlight.customSelections[index2].destroy();
        this.hot.selection.highlight.customSelections.splice(index2, 1);
        return false;
      }
    });
  }
  /**
   * Hide custom borders.
   *
   * @private
   */
  hideBorders() {
    arrayEach(this.savedBorders, (border) => {
      this.clearBordersFromSelectionSettings(border.id);
      this.clearNullCellRange();
    });
  }
  /**
   * Splice border from savedBorders.
   *
   * @private
   * @param {string} borderId Border id name as string.
   */
  spliceBorder(borderId) {
    const index2 = arrayMap(this.savedBorders, (border) => border.id).indexOf(borderId);
    if (index2 > -1) {
      this.savedBorders.splice(index2, 1);
    }
  }
  /**
   * Check if an border already exists in the savedBorders array, and if true update border in savedBorders.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   *
   * @returns {boolean}
   */
  checkSavedBorders(border) {
    let check = false;
    const hideCount = this.countHide(border);
    if (hideCount === 4) {
      this.spliceBorder(border.id);
      check = true;
    } else {
      arrayEach(this.savedBorders, (savedBorder, index2) => {
        if (border.id === savedBorder.id) {
          this.savedBorders[index2] = border;
          check = true;
          return false;
        }
      });
    }
    return check;
  }
  /**
   * Check if an border already exists in the customSelections, and if true call toggleHiddenClass method.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.
   * @param {boolean} remove True when remove borders, and false when add borders.
   *
   * @returns {boolean}
   */
  checkCustomSelectionsFromContextMenu(border, place, remove) {
    let check = false;
    arrayEach(this.hot.selection.highlight.customSelections, (customSelection) => {
      if (border.id === customSelection.settings.id) {
        objectEach(customSelection.instanceBorders, (borderObject) => {
          borderObject.toggleHiddenClass(place, remove);
        });
        check = true;
        return false;
      }
    });
    return check;
  }
  /**
   * Check if an border already exists in the customSelections, and if true reset cellRange.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   * @param {CellRange} cellRange The selection range to check.
   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.
   * @returns {boolean}
   */
  checkCustomSelections(border, cellRange, place) {
    const hideCount = this.countHide(border);
    let check = false;
    if (hideCount === 4) {
      this.removeAllBorders(border.row, border.col);
      check = true;
    } else {
      arrayEach(this.hot.selection.highlight.customSelections, (customSelection) => {
        if (border.id === customSelection.settings.id) {
          customSelection.visualCellRange = cellRange;
          customSelection.commit();
          if (place) {
            objectEach(customSelection.instanceBorders, (borderObject) => {
              borderObject.changeBorderStyle(place, border);
            });
          }
          check = true;
          return false;
        }
      });
    }
    return check;
  }
  /**
   * Change borders from settings.
   *
   * @private
   */
  changeBorderSettings() {
    const customBorders = this.hot.getSettings()[PLUGIN_KEY12];
    if (Array.isArray(customBorders)) {
      const bordersClone = deepClone(customBorders);
      this.checkSettingsCohesion(bordersClone);
      if (!bordersClone.length) {
        this.savedBorders = bordersClone;
      }
      this.createCustomBorders(bordersClone);
    } else if (customBorders !== void 0) {
      this.createCustomBorders(this.savedBorders);
    }
  }
  /**
   * Checks the settings cohesion. The properties such like "left"/"right" are supported only
   * in the LTR mode and the "left"/"right" options can not be used together with "start"/"end" properties.
   *
   * @private
   * @param {object[]} customBorders The user defined custom border objects array.
   */
  checkSettingsCohesion(customBorders) {
    const hasLeftOrRight = hasLeftRightTypeOptions(customBorders);
    const hasStartOrEnd = hasStartEndTypeOptions(customBorders);
    if (hasLeftOrRight && hasStartOrEnd) {
      throw new Error('The "left"/"right" and "start"/"end" options should not be used together. Please use only the option "start"/"end".');
    }
    if (this.hot.isRtl() && hasLeftOrRight) {
      throw new Error('The "left"/"right" properties are not supported for RTL. Please use option "start"/"end".');
    }
  }
  /**
   * Add border options to context menu.
   *
   * @private
   * @param {object} defaultOptions Context menu items.
   */
  onAfterContextMenuDefaultOptions(defaultOptions) {
    if (!this.hot.getSettings()[PLUGIN_KEY12]) {
      return;
    }
    defaultOptions.items.push({
      name: "---------"
    }, {
      key: "borders",
      name() {
        return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS);
      },
      disabled() {
        return this.selection.isSelectedByCorner();
      },
      submenu: {
        items: [top(this), right(this), bottom(this), left(this), noBorders(this)]
      }
    });
  }
  /**
   * `afterInit` hook callback.
   *
   * @private
   */
  onAfterInit() {
    this.changeBorderSettings();
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/dragToScroll/dragToScroll.mjs
var PLUGIN_KEY13 = "dragToScroll";
var PLUGIN_PRIORITY12 = 100;
var DragToScroll = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY13;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY12;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.eventManager = new eventManager_default(this);
    this.boundaries = null;
    this.callback = null;
    this.listening = false;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link DragToScroll#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY13];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.addHook("afterOnCellMouseDown", (event2) => this.setupListening(event2));
    this.addHook("afterOnCellCornerMouseDown", (event2) => this.setupListening(event2));
    this.registerEvents();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`dragToScroll`](@/api/options.md#dragtoscroll)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.unregisterEvents();
    super.disablePlugin();
  }
  /**
   * Sets the value of the visible element.
   *
   * @param {DOMRect} boundaries An object with coordinates compatible with DOMRect.
   */
  setBoundaries(boundaries) {
    this.boundaries = boundaries;
  }
  /**
   * Changes callback function.
   *
   * @param {Function} callback The callback function.
   */
  setCallback(callback) {
    this.callback = callback;
  }
  /**
   * Checks if the mouse position (X, Y) is outside of the viewport and fires a callback with calculated X an Y diffs
   * between passed boundaries.
   *
   * @param {number} x Mouse X coordinate to check.
   * @param {number} y Mouse Y coordinate to check.
   */
  check(x, y) {
    let diffX = 0;
    let diffY = 0;
    if (y < this.boundaries.top) {
      diffY = y - this.boundaries.top;
    } else if (y > this.boundaries.bottom) {
      diffY = y - this.boundaries.bottom;
    }
    if (x < this.boundaries.left) {
      diffX = x - this.boundaries.left;
    } else if (x > this.boundaries.right) {
      diffX = x - this.boundaries.right;
    }
    this.callback(diffX, diffY);
  }
  /**
   * Enables listening on `mousemove` event.
   *
   * @private
   */
  listen() {
    this.listening = true;
  }
  /**
   * Disables listening on `mousemove` event.
   *
   * @private
   */
  unlisten() {
    this.listening = false;
  }
  /**
   * Returns current state of listening.
   *
   * @private
   * @returns {boolean}
   */
  isListening() {
    return this.listening;
  }
  /**
   * Registers dom listeners.
   *
   * @private
   */
  registerEvents() {
    const {
      rootWindow
    } = this.hot;
    let frame = rootWindow;
    while (frame) {
      this.eventManager.addEventListener(frame.document, "contextmenu", () => this.unlisten());
      this.eventManager.addEventListener(frame.document, "mouseup", () => this.unlisten());
      this.eventManager.addEventListener(frame.document, "mousemove", (event2) => this.onMouseMove(event2));
      frame = getParentWindow(frame);
    }
  }
  /**
   * Unbinds the events used by the plugin.
   *
   * @private
   */
  unregisterEvents() {
    this.eventManager.clear();
  }
  /**
   * On after on cell/cellCorner mouse down listener.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  setupListening(event2) {
    if (isRightClick(event2)) {
      return;
    }
    const scrollHandler = this.hot.view._wt.wtTable.holder;
    if (scrollHandler === this.hot.rootWindow) {
      return;
    }
    this.setBoundaries(scrollHandler.getBoundingClientRect());
    this.setCallback((scrollX, scrollY) => {
      if (scrollX < 0) {
        scrollHandler.scrollLeft -= 50;
      } else if (scrollX > 0) {
        scrollHandler.scrollLeft += 50;
      }
      if (scrollY < 0) {
        scrollHandler.scrollTop -= 20;
      } else if (scrollY > 0) {
        scrollHandler.scrollTop += 20;
      }
    });
    this.listen();
  }
  /**
   * 'mouseMove' event callback.
   *
   * @private
   * @param {MouseEvent} event `mousemove` event properties.
   */
  onMouseMove(event2) {
    if (!this.isListening()) {
      return;
    }
    this.check(event2.clientX, event2.clientY);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/dropdownMenu/dropdownMenu.mjs
pluginHooks_default.getSingleton().register("afterDropdownMenuDefaultOptions");
pluginHooks_default.getSingleton().register("beforeDropdownMenuShow");
pluginHooks_default.getSingleton().register("afterDropdownMenuShow");
pluginHooks_default.getSingleton().register("afterDropdownMenuHide");
pluginHooks_default.getSingleton().register("afterDropdownMenuExecute");
var PLUGIN_KEY14 = "dropdownMenu";
var PLUGIN_PRIORITY13 = 230;
var BUTTON_CLASS_NAME = "changeType";
var DropdownMenu = class _DropdownMenu extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY14;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY13;
  }
  static get PLUGIN_DEPS() {
    return ["plugin:AutoColumnSize"];
  }
  /**
   * Default menu items order when `dropdownMenu` is enabled by setting the config item to `true`.
   *
   * @returns {Array}
   */
  static get DEFAULT_ITEMS() {
    return [KEY4, KEY5, KEY, KEY8, KEY, KEY3, KEY, KEY6, KEY, KEY2];
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.eventManager = new eventManager_default(this);
    this.commandExecutor = new commandExecutor_default(this.hot);
    this.itemsFactory = null;
    this.menu = null;
    this.hot.addHook("afterGetColHeader", (col, TH) => this.onAfterGetColHeader(col, TH));
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link DropdownMenu#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY14];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   *
   * @fires Hooks#afterDropdownMenuDefaultOptions
   * @fires Hooks#beforeDropdownMenuSetItems
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.itemsFactory = new itemsFactory_default(this.hot, _DropdownMenu.DEFAULT_ITEMS);
    const settings = this.hot.getSettings()[PLUGIN_KEY14];
    const predefinedItems2 = {
      items: this.itemsFactory.getItems(settings)
    };
    this.registerEvents();
    if (typeof settings.callback === "function") {
      this.commandExecutor.setCommonCallback(settings.callback);
    }
    super.enablePlugin();
    this.callOnPluginsReady(() => {
      this.hot.runHooks("afterDropdownMenuDefaultOptions", predefinedItems2);
      this.itemsFactory.setPredefinedItems(predefinedItems2.items);
      const menuItems = this.itemsFactory.getItems(settings);
      if (this.menu) {
        this.menu.destroy();
      }
      this.menu = new menu_default(this.hot, {
        className: "htDropdownMenu",
        keepInViewport: true,
        container: settings.uiContainer || this.hot.rootDocument.body
      });
      this.hot.runHooks("beforeDropdownMenuSetItems", menuItems);
      this.menu.setMenuItems(menuItems);
      this.menu.addLocalHook("beforeOpen", () => this.onMenuBeforeOpen());
      this.menu.addLocalHook("afterOpen", () => this.onMenuAfterOpen());
      this.menu.addLocalHook("afterClose", () => this.onMenuAfterClose());
      this.menu.addLocalHook("executeCommand", function() {
        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }
        return _this.executeCommand.call(_this, ...params);
      });
      arrayEach(menuItems, (command) => this.commandExecutor.registerCommand(command.key, command));
    });
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`dropdownMenu`](@/api/options.md#dropdownmenu)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
    }
    super.disablePlugin();
  }
  /**
   * Registers the DOM listeners.
   *
   * @private
   */
  registerEvents() {
    this.eventManager.addEventListener(this.hot.rootElement, "click", (event2) => this.onTableClick(event2));
  }
  /**
   * Opens menu and re-position it based on the passed coordinates.
   *
   * @param {object|Event} position An object with `pageX` and `pageY` properties which contains values relative to
   *                                the top left of the fully rendered content area in the browser or with `clientX`
   *                                and `clientY`  properties which contains values relative to the upper left edge
   *                                of the content area (the viewport) of the browser window. This object is structurally
   *                                compatible with native mouse event so it can be used either.
   * @fires Hooks#beforeDropdownMenuShow
   * @fires Hooks#afterDropdownMenuShow
   */
  open(position) {
    if (!this.menu) {
      return;
    }
    this.menu.open();
    if (position.width) {
      this.menu.setOffset("left", position.width);
    }
    this.menu.setPosition(position);
  }
  /**
   * Closes dropdown menu.
   */
  close() {
    if (!this.menu) {
      return;
    }
    this.menu.close();
  }
  /**
   * Executes context menu command.
   *
   * The `executeCommand()` method works only for selected cells.
   *
   * When no cells are selected, `executeCommand()` doesn't do anything.
   *
   * You can execute all predefined commands:
   *  * `'row_above'` - Insert row above
   *  * `'row_below'` - Insert row below
   *  * `'col_left'` - Insert column left
   *  * `'col_right'` - Insert column right
   *  * `'clear_column'` - Clear selected column
   *  * `'remove_row'` - Remove row
   *  * `'remove_col'` - Remove column
   *  * `'undo'` - Undo last action
   *  * `'redo'` - Redo last action
   *  * `'make_read_only'` - Make cell read only
   *  * `'alignment:left'` - Alignment to the left
   *  * `'alignment:top'` - Alignment to the top
   *  * `'alignment:right'` - Alignment to the right
   *  * `'alignment:bottom'` - Alignment to the bottom
   *  * `'alignment:middle'` - Alignment to the middle
   *  * `'alignment:center'` - Alignment to the center (justify).
   *
   * Or you can execute command registered in settings where `key` is your command name.
   *
   * @param {string} commandName Command name to execute.
   * @param {*} params Additional parameters passed to the command executor.
   */
  executeCommand(commandName) {
    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }
    this.commandExecutor.execute(commandName, ...params);
  }
  /**
   * Turns on / off listening on dropdown menu.
   *
   * @private
   * @param {boolean} listen Turn on listening when value is set to true, otherwise turn it off.
   */
  setListening() {
    let listen = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (this.menu.isOpened()) {
      if (listen) {
        this.menu.hotMenu.listen();
      } else {
        this.menu.hotMenu.unlisten();
      }
    }
  }
  /**
   * Table click listener.
   *
   * @private
   * @param {Event} event The mouse event object.
   */
  onTableClick(event2) {
    event2.stopPropagation();
    if (hasClass(event2.target, BUTTON_CLASS_NAME) && !this.menu.isOpened()) {
      let offsetTop = 0;
      let offsetLeft = 0;
      if (this.hot.rootDocument !== this.menu.container.ownerDocument) {
        const {
          frameElement
        } = this.hot.rootWindow;
        const {
          top: top2,
          left: left2
        } = frameElement.getBoundingClientRect();
        offsetTop = top2;
        offsetLeft = left2;
      }
      const rect = event2.target.getBoundingClientRect();
      this.open({
        left: rect.left + offsetLeft,
        top: rect.top + event2.target.offsetHeight + 3 + offsetTop,
        width: rect.width,
        height: rect.height
      });
    }
  }
  /**
   * On after get column header listener.
   *
   * @private
   * @param {number} col Visual column index.
   * @param {HTMLTableCellElement} TH Header's TH element.
   */
  onAfterGetColHeader(col, TH) {
    const headerRow = TH.parentNode;
    if (!headerRow) {
      return;
    }
    const headerRowList = headerRow.parentNode.childNodes;
    const level = Array.prototype.indexOf.call(headerRowList, headerRow);
    if (col < 0 || level !== headerRowList.length - 1) {
      return;
    }
    const existingButton = TH.querySelector(`.${BUTTON_CLASS_NAME}`);
    if (this.enabled && existingButton) {
      return;
    }
    if (!this.enabled) {
      if (existingButton) {
        existingButton.parentNode.removeChild(existingButton);
      }
      return;
    }
    const button = this.hot.rootDocument.createElement("button");
    button.className = BUTTON_CLASS_NAME;
    button.type = "button";
    button.onclick = function() {
      return false;
    };
    TH.firstChild.insertBefore(button, TH.firstChild.firstChild);
  }
  /**
   * On menu before open listener.
   *
   * @private
   * @fires Hooks#beforeDropdownMenuShow
   */
  onMenuBeforeOpen() {
    this.hot.runHooks("beforeDropdownMenuShow", this);
  }
  /**
   * On menu after open listener.
   *
   * @private
   * @fires Hooks#afterDropdownMenuShow
   */
  onMenuAfterOpen() {
    this.hot.runHooks("afterDropdownMenuShow", this);
  }
  /**
   * On menu after close listener.
   *
   * @private
   * @fires Hooks#afterDropdownMenuHide
   */
  onMenuAfterClose() {
    this.hot.listen();
    this.hot.runHooks("afterDropdownMenuHide", this);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
    }
    super.destroy();
  }
};
DropdownMenu.SEPARATOR = {
  name: KEY
};

// node_modules/handsontable/plugins/exportFile/dataProvider.mjs
var DataProvider = class {
  constructor(hotInstance) {
    this.hot = hotInstance;
    this.options = {};
  }
  /**
   * Set options for data provider.
   *
   * @param {object} options Object with specified options.
   */
  setOptions(options) {
    this.options = options;
  }
  /**
   * Get table data based on provided settings to the class constructor.
   *
   * @returns {Array}
   */
  getData() {
    const {
      startRow,
      startCol,
      endRow,
      endCol
    } = this._getDataRange();
    const options = this.options;
    const data = [];
    rangeEach(startRow, endRow, (rowIndex) => {
      const row = [];
      if (!options.exportHiddenRows && this._isHiddenRow(rowIndex)) {
        return;
      }
      rangeEach(startCol, endCol, (colIndex) => {
        if (!options.exportHiddenColumns && this._isHiddenColumn(colIndex)) {
          return;
        }
        row.push(this.hot.getDataAtCell(rowIndex, colIndex));
      });
      data.push(row);
    });
    return data;
  }
  /**
   * Gets list of row headers.
   *
   * @returns {Array}
   */
  getRowHeaders() {
    const headers = [];
    if (this.options.rowHeaders) {
      const {
        startRow,
        endRow
      } = this._getDataRange();
      const rowHeaders = this.hot.getRowHeader();
      rangeEach(startRow, endRow, (row) => {
        if (!this.options.exportHiddenRows && this._isHiddenRow(row)) {
          return;
        }
        headers.push(rowHeaders[row]);
      });
    }
    return headers;
  }
  /**
   * Gets list of columns headers.
   *
   * @returns {Array}
   */
  getColumnHeaders() {
    const headers = [];
    if (this.options.columnHeaders) {
      const {
        startCol,
        endCol
      } = this._getDataRange();
      const colHeaders = this.hot.getColHeader();
      rangeEach(startCol, endCol, (column) => {
        if (!this.options.exportHiddenColumns && this._isHiddenColumn(column)) {
          return;
        }
        headers.push(colHeaders[column]);
      });
    }
    return headers;
  }
  /**
   * Get data range object based on settings provided in the class constructor.
   *
   * @private
   * @returns {object} Returns object with keys `startRow`, `startCol`, `endRow` and `endCol`.
   */
  _getDataRange() {
    const cols = this.hot.countCols() - 1;
    const rows = this.hot.countRows() - 1;
    let [startRow = 0, startCol = 0, endRow = rows, endCol = cols] = this.options.range;
    startRow = Math.max(startRow, 0);
    startCol = Math.max(startCol, 0);
    endRow = Math.min(endRow, rows);
    endCol = Math.min(endCol, cols);
    return {
      startRow,
      startCol,
      endRow,
      endCol
    };
  }
  /**
   * Check if row at specified row index is hidden.
   *
   * @private
   * @param {number} row Row index.
   * @returns {boolean}
   */
  _isHiddenRow(row) {
    return this.hot.rowIndexMapper.isHidden(this.hot.toPhysicalRow(row));
  }
  /**
   * Check if column at specified column index is hidden.
   *
   * @private
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  _isHiddenColumn(column) {
    return this.hot.columnIndexMapper.isHidden(this.hot.toPhysicalColumn(column));
  }
};
var dataProvider_default = DataProvider;

// node_modules/handsontable/plugins/exportFile/types/_base.mjs
var BaseType = class _BaseType {
  /**
   * Default options.
   *
   * @returns {object}
   */
  static get DEFAULT_OPTIONS() {
    return {
      mimeType: "text/plain",
      fileExtension: "txt",
      filename: "Handsontable [YYYY]-[MM]-[DD]",
      encoding: "utf-8",
      bom: false,
      columnHeaders: false,
      rowHeaders: false,
      exportHiddenColumns: false,
      exportHiddenRows: false,
      range: []
    };
  }
  constructor(dataProvider, options) {
    this.dataProvider = dataProvider;
    this.options = this._mergeOptions(options);
    this.dataProvider.setOptions(this.options);
  }
  /**
   * Merge options provided by users with defaults.
   *
   * @param {object} options An object with options to merge with.
   * @returns {object} Returns new options object.
   */
  _mergeOptions(options) {
    let _options = clone3(this.constructor.DEFAULT_OPTIONS);
    const date = /* @__PURE__ */ new Date();
    _options = extend2(clone3(_BaseType.DEFAULT_OPTIONS), _options);
    _options = extend2(_options, options);
    _options.filename = substitute(_options.filename, {
      YYYY: date.getFullYear(),
      MM: `${date.getMonth() + 1}`.padStart(2, "0"),
      DD: `${date.getDate()}`.padStart(2, "0")
    });
    return _options;
  }
};
var base_default2 = BaseType;

// node_modules/handsontable/plugins/exportFile/types/csv.mjs
var CHAR_CARRIAGE_RETURN = String.fromCharCode(13);
var CHAR_DOUBLE_QUOTES = String.fromCharCode(34);
var CHAR_LINE_FEED = String.fromCharCode(10);
var Csv = class extends base_default2 {
  /**
   * Default options for exporting CSV format.
   *
   * @returns {object}
   */
  static get DEFAULT_OPTIONS() {
    return {
      mimeType: "text/csv",
      fileExtension: "csv",
      bom: true,
      columnDelimiter: ",",
      rowDelimiter: "\r\n"
    };
  }
  /**
   * Create string body in desired format.
   *
   * @returns {string}
   */
  export() {
    const options = this.options;
    const data = this.dataProvider.getData();
    let columnHeaders = this.dataProvider.getColumnHeaders();
    const hasColumnHeaders = columnHeaders.length > 0;
    const rowHeaders = this.dataProvider.getRowHeaders();
    const hasRowHeaders = rowHeaders.length > 0;
    let result = options.bom ? String.fromCharCode(65279) : "";
    if (hasColumnHeaders) {
      columnHeaders = arrayMap(columnHeaders, (value) => this._escapeCell(value, true));
      if (hasRowHeaders) {
        result += options.columnDelimiter;
      }
      result += columnHeaders.join(options.columnDelimiter);
      result += options.rowDelimiter;
    }
    arrayEach(data, (value, index2) => {
      if (index2 > 0) {
        result += options.rowDelimiter;
      }
      if (hasRowHeaders) {
        result += this._escapeCell(rowHeaders[index2]) + options.columnDelimiter;
      }
      result += value.map((cellValue) => this._escapeCell(cellValue)).join(options.columnDelimiter);
    });
    return result;
  }
  /**
   * Escape cell value.
   *
   * @param {*} value Cell value.
   * @param {boolean} [force=false] Indicates if cell value will be escaped forcefully.
   * @returns {string}
   */
  _escapeCell(value) {
    let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let escapedValue = stringify(value);
    if (escapedValue !== "" && (force || escapedValue.indexOf(CHAR_CARRIAGE_RETURN) >= 0 || escapedValue.indexOf(CHAR_DOUBLE_QUOTES) >= 0 || escapedValue.indexOf(CHAR_LINE_FEED) >= 0 || escapedValue.indexOf(this.options.columnDelimiter) >= 0)) {
      escapedValue = escapedValue.replace(new RegExp('"', "g"), '""');
      escapedValue = `"${escapedValue}"`;
    }
    return escapedValue;
  }
};
var csv_default = Csv;

// node_modules/handsontable/plugins/exportFile/typeFactory.mjs
var TYPE_CSV = "csv";
var EXPORT_TYPES = {
  [TYPE_CSV]: csv_default
};
function typeFactory(type, dataProvider, options) {
  if (typeof EXPORT_TYPES[type] === "function") {
    return new EXPORT_TYPES[type](dataProvider, options);
  }
  return null;
}

// node_modules/handsontable/plugins/exportFile/exportFile.mjs
var PLUGIN_KEY15 = "exportFile";
var PLUGIN_PRIORITY14 = 240;
var ExportFile = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY15;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY14;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ExportFile#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return true;
  }
  /**
   * @typedef ExportOptions
   * @memberof ExportFile
   * @type {object}
   * @property {boolean} [exportHiddenRows=false] Include hidden rows in the exported file.
   * @property {boolean} [exportHiddenColumns=false] Include hidden columns in the exported file.
   * @property {boolean} [columnHeaders=false] Include column headers in the exported file.
   * @property {boolean} [rowHeaders=false] Include row headers in the exported file.
   * @property {string} [columnDelimiter=','] Column delimiter.
   * @property {string} [range=[]] Cell range that will be exported to file.
   */
  /**
   * Exports table data as a string.
   *
   * @param {string} format Export format type eq. `'csv'`.
   * @param {ExportOptions} options Export options.
   * @returns {string}
   */
  exportAsString(format2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return this._createTypeFormatter(format2, options).export();
  }
  /**
   * Exports table data as a blob object.
   *
   * @param {string} format Export format type eq. `'csv'`.
   * @param {ExportOptions} options Export options.
   * @returns {Blob}
   */
  exportAsBlob(format2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return this._createBlob(this._createTypeFormatter(format2, options));
  }
  /**
   * Exports table data as a downloadable file.
   *
   * @param {string} format Export format type eq. `'csv'`.
   * @param {ExportOptions} options Export options.
   */
  downloadFile(format2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      rootDocument,
      rootWindow
    } = this.hot;
    const formatter = this._createTypeFormatter(format2, options);
    const blob = this._createBlob(formatter);
    const URL = rootWindow.URL || rootWindow.webkitURL;
    const a = rootDocument.createElement("a");
    const name = `${formatter.options.filename}.${formatter.options.fileExtension}`;
    if (a.download !== void 0) {
      const url = URL.createObjectURL(blob);
      a.style.display = "none";
      a.setAttribute("href", url);
      a.setAttribute("download", name);
      rootDocument.body.appendChild(a);
      a.dispatchEvent(new MouseEvent("click"));
      rootDocument.body.removeChild(a);
      setTimeout(() => {
        URL.revokeObjectURL(url);
      }, 100);
    } else if (navigator.msSaveOrOpenBlob) {
      navigator.msSaveOrOpenBlob(blob, name);
    }
  }
  /**
   * Creates and returns class formatter for specified export type.
   *
   * @private
   * @param {string} format Export format type eq. `'csv'`.
   * @param {ExportOptions} options Export options.
   * @returns {BaseType}
   */
  _createTypeFormatter(format2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!EXPORT_TYPES[format2]) {
      throw new Error(`Export format type "${format2}" is not supported.`);
    }
    return typeFactory(format2, new dataProvider_default(this.hot), options);
  }
  /**
   * Creates blob object based on provided type formatter class.
   *
   * @private
   * @param {BaseType} typeFormatter The instance of the specyfic formatter/exporter.
   * @returns {Blob}
   */
  _createBlob(typeFormatter) {
    let formatter = null;
    if (typeof Blob !== "undefined") {
      formatter = new Blob([typeFormatter.export()], {
        type: `${typeFormatter.options.mimeType};charset=${typeFormatter.options.encoding}`
      });
    }
    return formatter;
  }
};

// node_modules/handsontable/plugins/filters/component/_base.mjs
var BaseComponent = class {
  constructor(hotInstance, _ref2) {
    let {
      id,
      stateless = true
    } = _ref2;
    this.hot = hotInstance;
    this.id = id;
    this.elements = [];
    this.hidden = false;
    this.stateId = `Filters.component.${this.id}`;
    this.state = stateless ? null : this.hot.columnIndexMapper.registerMap(this.stateId, new LinkedPhysicalIndexToValueMap());
  }
  /**
   * Reset elements to its initial state.
   */
  reset() {
    arrayEach(this.elements, (ui) => ui.reset());
  }
  /**
   * Hide component.
   */
  hide() {
    this.hidden = true;
  }
  /**
   * Show component.
   */
  show() {
    this.hidden = false;
  }
  /**
   * Check if component is hidden.
   *
   * @returns {boolean}
   */
  isHidden() {
    return this.hot === null || this.hidden;
  }
  /**
   * Restores the component state from the given physical column index. The method
   * internally calls the `setState` method. The state then is individually processed
   * by each component.
   *
   * @param {number} physicalColumn The physical column index.
   */
  restoreState(physicalColumn) {
    if (this.state) {
      this.setState(this.state.getValueAtIndex(physicalColumn));
    }
  }
  /**
   * The custom logic for component state restoring.
   */
  setState() {
    throw new Error("The state setting logic is not implemented");
  }
  /**
   * Saves the component state to the given physical column index. The method
   * internally calls the `getState` method, which returns the current state of
   * the component.
   *
   * @param {number} physicalColumn The physical column index.
   */
  saveState(physicalColumn) {
    if (this.state) {
      this.state.setValueAtIndex(physicalColumn, this.getState());
    }
  }
  /**
   * The custom logic for component state gathering (for stateful components).
   */
  getState() {
    throw new Error("The state gathering logic is not implemented");
  }
  /**
   * Destroy element.
   */
  destroy() {
    this.hot.columnIndexMapper.unregisterMap(this.stateId);
    this.clearLocalHooks();
    arrayEach(this.elements, (ui) => ui.destroy());
    this.state = null;
    this.elements = null;
    this.hot = null;
  }
};
mixin(BaseComponent, localHooks_default);
var base_default3 = BaseComponent;

// node_modules/handsontable/plugins/filters/conditionRegisterer.mjs
var conditions = {};
function getCondition(name, args) {
  if (!conditions[name]) {
    throw Error(`Filter condition "${name}" does not exist.`);
  }
  const {
    condition: condition24,
    descriptor
  } = conditions[name];
  let conditionArguments = args;
  if (descriptor.inputValuesDecorator) {
    conditionArguments = descriptor.inputValuesDecorator(conditionArguments);
  }
  return function(dataRow) {
    return condition24.apply(dataRow.meta.instance, [].concat([dataRow], [conditionArguments]));
  };
}
function getConditionDescriptor(name) {
  if (!conditions[name]) {
    throw Error(`Filter condition "${name}" does not exist.`);
  }
  return conditions[name].descriptor;
}
function registerCondition(name, condition24, descriptor) {
  descriptor.key = name;
  conditions[name] = {
    condition: condition24,
    descriptor
  };
}

// node_modules/handsontable/plugins/filters/condition/none.mjs
var CONDITION_NAME = "none";
function condition() {
  return true;
}
registerCondition(CONDITION_NAME, condition, {
  name: FILTERS_CONDITIONS_NONE,
  inputsCount: 0,
  showOperators: false
});

// node_modules/handsontable/plugins/filters/condition/empty.mjs
var CONDITION_NAME2 = "empty";
function condition2(dataRow) {
  return isEmpty(dataRow.value);
}
registerCondition(CONDITION_NAME2, condition2, {
  name: FILTERS_CONDITIONS_EMPTY,
  inputsCount: 0,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/notEmpty.mjs
var CONDITION_NAME3 = "not_empty";
function condition3(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME2, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME3, condition3, {
  name: FILTERS_CONDITIONS_NOT_EMPTY,
  inputsCount: 0,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/equal.mjs
var CONDITION_NAME4 = "eq";
function condition4(dataRow, _ref2) {
  let [value] = _ref2;
  return stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale) === stringify(value);
}
registerCondition(CONDITION_NAME4, condition4, {
  name: FILTERS_CONDITIONS_EQUAL,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/notEqual.mjs
var CONDITION_NAME5 = "neq";
function condition5(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME4, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME5, condition5, {
  name: FILTERS_CONDITIONS_NOT_EQUAL,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/greaterThan.mjs
var CONDITION_NAME6 = "gt";
function condition6(dataRow, _ref2) {
  let [value] = _ref2;
  let conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value > conditionValue;
}
registerCondition(CONDITION_NAME6, condition6, {
  name: FILTERS_CONDITIONS_GREATER_THAN,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/greaterThanOrEqual.mjs
var CONDITION_NAME7 = "gte";
function condition7(dataRow, _ref2) {
  let [value] = _ref2;
  let conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value >= conditionValue;
}
registerCondition(CONDITION_NAME7, condition7, {
  name: FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/lessThan.mjs
var CONDITION_NAME8 = "lt";
function condition8(dataRow, _ref2) {
  let [value] = _ref2;
  let conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value < conditionValue;
}
registerCondition(CONDITION_NAME8, condition8, {
  name: FILTERS_CONDITIONS_LESS_THAN,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/lessThanOrEqual.mjs
var CONDITION_NAME9 = "lte";
function condition9(dataRow, _ref2) {
  let [value] = _ref2;
  let conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value <= conditionValue;
}
registerCondition(CONDITION_NAME9, condition9, {
  name: FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/date/after.mjs
init_moment();
var CONDITION_NAME10 = "date_after";
function condition10(dataRow, _ref2) {
  let [value] = _ref2;
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  const inputDate = moment_default(value, dataRow.meta.dateFormat);
  if (!date.isValid() || !inputDate.isValid()) {
    return false;
  }
  return date.diff(inputDate) >= 0;
}
registerCondition(CONDITION_NAME10, condition10, {
  name: FILTERS_CONDITIONS_AFTER,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/date/before.mjs
init_moment();
var CONDITION_NAME11 = "date_before";
function condition11(dataRow, _ref2) {
  let [value] = _ref2;
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  const inputDate = moment_default(value, dataRow.meta.dateFormat);
  if (!date.isValid() || !inputDate.isValid()) {
    return false;
  }
  return date.diff(inputDate) <= 0;
}
registerCondition(CONDITION_NAME11, condition11, {
  name: FILTERS_CONDITIONS_BEFORE,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/between.mjs
var CONDITION_NAME12 = "between";
function condition12(dataRow, _ref2) {
  let [from2, to2] = _ref2;
  let fromValue = from2;
  let toValue = to2;
  if (dataRow.meta.type === "numeric") {
    const _from = parseFloat(fromValue, 10);
    const _to = parseFloat(toValue, 10);
    fromValue = Math.min(_from, _to);
    toValue = Math.max(_from, _to);
  } else if (dataRow.meta.type === "date") {
    const dateBefore = getCondition(CONDITION_NAME11, [toValue]);
    const dateAfter = getCondition(CONDITION_NAME10, [fromValue]);
    return dateBefore(dataRow) && dateAfter(dataRow);
  }
  return dataRow.value >= fromValue && dataRow.value <= toValue;
}
registerCondition(CONDITION_NAME12, condition12, {
  name: FILTERS_CONDITIONS_BETWEEN,
  inputsCount: 2,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/notBetween.mjs
var CONDITION_NAME13 = "not_between";
function condition13(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME12, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME13, condition13, {
  name: FILTERS_CONDITIONS_NOT_BETWEEN,
  inputsCount: 2,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/beginsWith.mjs
var CONDITION_NAME14 = "begins_with";
function condition14(dataRow, _ref2) {
  let [value] = _ref2;
  return stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).startsWith(stringify(value));
}
registerCondition(CONDITION_NAME14, condition14, {
  name: FILTERS_CONDITIONS_BEGINS_WITH,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/endsWith.mjs
var CONDITION_NAME15 = "ends_with";
function condition15(dataRow, _ref2) {
  let [value] = _ref2;
  return stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).endsWith(stringify(value));
}
registerCondition(CONDITION_NAME15, condition15, {
  name: FILTERS_CONDITIONS_ENDS_WITH,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/contains.mjs
var CONDITION_NAME16 = "contains";
function condition16(dataRow, _ref2) {
  let [value] = _ref2;
  return stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).indexOf(stringify(value)) >= 0;
}
registerCondition(CONDITION_NAME16, condition16, {
  name: FILTERS_CONDITIONS_CONTAINS,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/notContains.mjs
var CONDITION_NAME17 = "not_contains";
function condition17(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME16, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME17, condition17, {
  name: FILTERS_CONDITIONS_NOT_CONTAIN,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/date/tomorrow.mjs
init_moment();
var CONDITION_NAME18 = "date_tomorrow";
function condition18(dataRow) {
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(moment_default().subtract(-1, "days").startOf("day"), "d");
}
registerCondition(CONDITION_NAME18, condition18, {
  name: FILTERS_CONDITIONS_TOMORROW,
  inputsCount: 0
});

// node_modules/handsontable/plugins/filters/condition/date/today.mjs
init_moment();
var CONDITION_NAME19 = "date_today";
function condition19(dataRow) {
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(moment_default().startOf("day"), "d");
}
registerCondition(CONDITION_NAME19, condition19, {
  name: FILTERS_CONDITIONS_TODAY,
  inputsCount: 0
});

// node_modules/handsontable/plugins/filters/condition/date/yesterday.mjs
init_moment();
var CONDITION_NAME20 = "date_yesterday";
function condition20(dataRow) {
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(moment_default().subtract(1, "days").startOf("day"), "d");
}
registerCondition(CONDITION_NAME20, condition20, {
  name: FILTERS_CONDITIONS_YESTERDAY,
  inputsCount: 0
});

// node_modules/handsontable/plugins/filters/utils.mjs
var sortCompare = getComparisonFunction();
function toVisualValue(value, defaultEmptyValue) {
  let visualValue = value;
  if (visualValue === "") {
    visualValue = `(${defaultEmptyValue})`;
  }
  return visualValue;
}
var SUPPORT_SET_CONSTRUCTOR = (/* @__PURE__ */ new Set([1])).has(1);
var SUPPORT_FAST_DEDUPE = SUPPORT_SET_CONSTRUCTOR && typeof Array.from === "function";
function createArrayAssertion(initialData) {
  let dataset = initialData;
  if (SUPPORT_SET_CONSTRUCTOR) {
    dataset = new Set(dataset);
  }
  return function(value) {
    let result;
    if (SUPPORT_SET_CONSTRUCTOR) {
      result = dataset.has(value);
    } else {
      result = !!~dataset.indexOf(value);
    }
    return result;
  };
}
function toEmptyString(value) {
  return value === null || value === void 0 ? "" : value;
}
function unifyColumnValues(values) {
  let unifiedValues = values;
  if (SUPPORT_FAST_DEDUPE) {
    unifiedValues = Array.from(new Set(unifiedValues));
  } else {
    unifiedValues = arrayUnique(unifiedValues);
  }
  unifiedValues = unifiedValues.sort((a, b) => {
    if (typeof a === "number" && typeof b === "number") {
      return a - b;
    }
    if (a === b) {
      return 0;
    }
    return a > b ? 1 : -1;
  });
  return unifiedValues;
}
function intersectValues(base, selected, defaultEmptyValue, callback) {
  const result = [];
  const same = base === selected;
  let selectedItemsAssertion;
  if (!same) {
    selectedItemsAssertion = createArrayAssertion(selected);
  }
  arrayEach(base, (value) => {
    let checked = false;
    if (same || selectedItemsAssertion(value)) {
      checked = true;
    }
    const item = {
      checked,
      value,
      visualValue: toVisualValue(value, defaultEmptyValue)
    };
    if (callback) {
      callback(item);
    }
    result.push(item);
  });
  return result;
}

// node_modules/handsontable/plugins/filters/condition/byValue.mjs
var CONDITION_NAME21 = "by_value";
function condition21(dataRow, _ref2) {
  let [value] = _ref2;
  return value(dataRow.value);
}
registerCondition(CONDITION_NAME21, condition21, {
  name: "By value",
  inputsCount: 0,
  inputValuesDecorator(_ref2) {
    let [data] = _ref2;
    return [createArrayAssertion(data)];
  },
  showOperators: false
});

// node_modules/handsontable/plugins/filters/condition/true.mjs
var CONDITION_NAME22 = "true";
function condition22() {
  return true;
}
registerCondition(CONDITION_NAME22, condition22, {
  name: "True"
});

// node_modules/handsontable/plugins/filters/condition/false.mjs
var CONDITION_NAME23 = "false";
function condition23() {
  return false;
}
registerCondition(CONDITION_NAME23, condition23, {
  name: "False"
});

// node_modules/handsontable/plugins/filters/logicalOperationRegisterer.mjs
var operations = {};
function getOperationFunc(id) {
  if (!operations[id]) {
    throw Error(`Operation with id "${id}" does not exist.`);
  }
  const func = operations[id].func;
  return function(conditions2, value) {
    return func(conditions2, value);
  };
}
function getOperationName(id) {
  return operations[id].name;
}
function registerOperation(id, name, func) {
  operations[id] = {
    name,
    func
  };
}

// node_modules/handsontable/plugins/filters/logicalOperations/conjunction.mjs
var OPERATION_ID = "conjunction";
var SHORT_NAME_FOR_COMPONENT = FILTERS_LABELS_CONJUNCTION;
function operationResult(conditions2, value) {
  return conditions2.every((condition24) => condition24.func(value));
}
registerOperation(OPERATION_ID, SHORT_NAME_FOR_COMPONENT, operationResult);

// node_modules/handsontable/plugins/filters/logicalOperations/disjunction.mjs
var OPERATION_ID2 = "disjunction";
var SHORT_NAME_FOR_COMPONENT2 = FILTERS_LABELS_DISJUNCTION;
function operationResult2(conditions2, value) {
  return conditions2.some((condition24) => condition24.func(value));
}
registerOperation(OPERATION_ID2, SHORT_NAME_FOR_COMPONENT2, operationResult2);

// node_modules/handsontable/plugins/filters/logicalOperations/disjunctionWithExtraCondition.mjs
var OPERATION_ID3 = "disjunctionWithExtraCondition";
var SHORT_NAME_FOR_COMPONENT3 = FILTERS_LABELS_DISJUNCTION;
function operationResult3(conditions2, value) {
  if (conditions2.length < 3) {
    throw Error("Operation doesn't work on less then three conditions.");
  }
  return conditions2.slice(0, conditions2.length - 1).some((condition24) => condition24.func(value)) && conditions2[conditions2.length - 1].func(value);
}
registerOperation(OPERATION_ID3, SHORT_NAME_FOR_COMPONENT3, operationResult3);

// node_modules/handsontable/plugins/filters/constants.mjs
var TYPE_NUMERIC = "numeric";
var TYPE_TEXT = "text";
var TYPE_DATE = "date";
var TYPES = {
  [TYPE_NUMERIC]: [CONDITION_NAME, KEY, CONDITION_NAME2, CONDITION_NAME3, KEY, CONDITION_NAME4, CONDITION_NAME5, KEY, CONDITION_NAME6, CONDITION_NAME7, CONDITION_NAME8, CONDITION_NAME9, CONDITION_NAME12, CONDITION_NAME13],
  [TYPE_TEXT]: [CONDITION_NAME, KEY, CONDITION_NAME2, CONDITION_NAME3, KEY, CONDITION_NAME4, CONDITION_NAME5, KEY, CONDITION_NAME14, CONDITION_NAME15, KEY, CONDITION_NAME16, CONDITION_NAME17],
  [TYPE_DATE]: [CONDITION_NAME, KEY, CONDITION_NAME2, CONDITION_NAME3, KEY, CONDITION_NAME4, CONDITION_NAME5, KEY, CONDITION_NAME11, CONDITION_NAME10, CONDITION_NAME12, KEY, CONDITION_NAME18, CONDITION_NAME19, CONDITION_NAME20]
};
function getOptionsList(type) {
  const items = [];
  let typeName = type;
  if (!TYPES[typeName]) {
    typeName = TYPE_TEXT;
  }
  arrayEach(TYPES[typeName], (typeValue) => {
    let option;
    if (typeValue === KEY) {
      option = {
        name: KEY
      };
    } else {
      option = clone3(getConditionDescriptor(typeValue));
    }
    items.push(option);
  });
  return items;
}

// node_modules/handsontable/plugins/filters/ui/_base.mjs
var STATE_BUILT = "built";
var STATE_BUILDING = "building";
var EVENTS_TO_REGISTER = ["click", "input", "keydown", "keypress", "keyup", "focus", "blur", "change"];
var BaseUI = class _BaseUI {
  static get DEFAULTS() {
    return clone3({
      className: "",
      value: "",
      tagName: "div",
      children: [],
      wrapIt: true
    });
  }
  constructor(hotInstance, options) {
    this.hot = hotInstance;
    this.eventManager = new eventManager_default(this);
    this.options = extend2(_BaseUI.DEFAULTS, options);
    this._element = this.hot.rootDocument.createElement(this.options.wrapIt ? "div" : this.options.tagName);
    this.buildState = null;
  }
  /**
   * Set the element value.
   *
   * @param {*} value Set the component value.
   */
  setValue(value) {
    this.options.value = value;
    this.update();
  }
  /**
   * Get the element value.
   *
   * @returns {*}
   */
  getValue() {
    return this.options.value;
  }
  /**
   * Get element as a DOM object.
   *
   * @returns {Element}
   */
  get element() {
    if (this.buildState === STATE_BUILDING) {
      return this._element;
    }
    if (this.buildState === STATE_BUILT) {
      this.update();
      return this._element;
    }
    this.buildState = STATE_BUILDING;
    this.build();
    this.buildState = STATE_BUILT;
    return this._element;
  }
  /**
   * Check if element was built (built whole DOM structure).
   *
   * @returns {boolean}
   */
  isBuilt() {
    return this.buildState === STATE_BUILT;
  }
  /**
   * Translate value if it is possible. It's checked if value belongs to namespace of translated phrases.
   *
   * @param {*} value Value which will may be translated.
   * @returns {*} Translated value if translation was possible, original value otherwise.
   */
  translateIfPossible(value) {
    if (typeof value === "string" && value.startsWith(FILTERS_NAMESPACE)) {
      return this.hot.getTranslatedPhrase(value);
    }
    return value;
  }
  /**
   * Build DOM structure.
   */
  build() {
    const registerEvent = (element, eventName) => {
      this.eventManager.addEventListener(element, eventName, (event2) => this.runLocalHooks(eventName, event2, this));
    };
    if (!this.buildState) {
      this.buildState = STATE_BUILDING;
    }
    if (this.options.className) {
      addClass(this._element, this.options.className);
    }
    if (this.options.children.length) {
      arrayEach(this.options.children, (element) => this._element.appendChild(element.element));
    } else if (this.options.wrapIt) {
      const element = this.hot.rootDocument.createElement(this.options.tagName);
      objectEach(this.options, (value, key) => {
        if (element[key] !== void 0 && key !== "className" && key !== "tagName" && key !== "children") {
          element[key] = this.translateIfPossible(value);
        }
      });
      this._element.appendChild(element);
      arrayEach(EVENTS_TO_REGISTER, (eventName) => registerEvent(element, eventName));
    } else {
      arrayEach(EVENTS_TO_REGISTER, (eventName) => registerEvent(this._element, eventName));
    }
  }
  /**
   * Update DOM structure.
   */
  update() {
  }
  /**
   * Reset to initial state.
   */
  reset() {
    this.options.value = "";
    this.update();
  }
  /**
   * Show element.
   */
  show() {
    this.element.style.display = "";
  }
  /**
   * Hide element.
   */
  hide() {
    this.element.style.display = "none";
  }
  /**
   * Focus element.
   */
  focus() {
  }
  destroy() {
    this.eventManager.destroy();
    this.eventManager = null;
    this.hot = null;
    if (this._element.parentNode) {
      this._element.parentNode.removeChild(this._element);
    }
    this._element = null;
  }
};
mixin(BaseUI, localHooks_default);
var base_default4 = BaseUI;

// node_modules/handsontable/plugins/filters/ui/input.mjs
var privatePool9 = /* @__PURE__ */ new WeakMap();
var InputUI = class _InputUI extends base_default4 {
  static get DEFAULTS() {
    return clone3({
      placeholder: "",
      type: "text",
      tagName: "input"
    });
  }
  constructor(hotInstance, options) {
    super(hotInstance, extend2(_InputUI.DEFAULTS, options));
    privatePool9.set(this, {});
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   */
  registerHooks() {
    this.addLocalHook("click", () => this.onClick());
    this.addLocalHook("keyup", (event2) => this.onKeyup(event2));
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    const priv = privatePool9.get(this);
    const icon = this.hot.rootDocument.createElement("div");
    priv.input = this._element.firstChild;
    addClass(this._element, "htUIInput");
    addClass(icon, "htUIInputIcon");
    this._element.appendChild(icon);
    this.update();
  }
  /**
   * Update element.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    const input = privatePool9.get(this).input;
    input.type = this.options.type;
    input.placeholder = this.translateIfPossible(this.options.placeholder);
    input.value = this.translateIfPossible(this.options.value);
  }
  /**
   * Focus element.
   */
  focus() {
    if (this.isBuilt()) {
      privatePool9.get(this).input.focus();
    }
  }
  /**
   * OnClick listener.
   */
  onClick() {
  }
  /**
   * OnKeyup listener.
   *
   * @param {Event} event The mouse event object.
   */
  onKeyup(event2) {
    this.options.value = event2.target.value;
  }
};
var input_default = InputUI;

// node_modules/handsontable/plugins/filters/ui/select.mjs
var privatePool10 = /* @__PURE__ */ new WeakMap();
var SelectUI = class _SelectUI extends base_default4 {
  static get DEFAULTS() {
    return clone3({
      className: "htUISelect",
      wrapIt: false
    });
  }
  constructor(hotInstance, options) {
    super(hotInstance, extend2(_SelectUI.DEFAULTS, options));
    privatePool10.set(this, {});
    this.menu = null;
    this.items = [];
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   */
  registerHooks() {
    this.addLocalHook("click", () => this.onClick());
  }
  /**
   * Set options which can be selected in the list.
   *
   * @param {Array} items Array of objects with required keys `key` and `name`.
   */
  setItems(items) {
    this.items = this.translateNames(items);
    if (this.menu) {
      this.menu.setMenuItems(this.items);
    }
  }
  /**
   * Translate names of menu items.
   *
   * @param {Array} items Array of objects with required keys `key` and `name`.
   * @returns {Array} Items with translated `name` keys.
   */
  translateNames(items) {
    arrayEach(items, (item) => {
      item.name = this.translateIfPossible(item.name);
    });
    return items;
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    this.menu = new menu_default(this.hot, {
      className: "htSelectUI htFiltersConditionsMenu",
      keepInViewport: false,
      standalone: true,
      container: this.options.menuContainer
    });
    this.menu.setMenuItems(this.items);
    const caption = new base_default4(this.hot, {
      className: "htUISelectCaption"
    });
    const dropdown = new base_default4(this.hot, {
      className: "htUISelectDropdown"
    });
    const priv = privatePool10.get(this);
    priv.caption = caption;
    priv.captionElement = caption.element;
    priv.dropdown = dropdown;
    arrayEach([caption, dropdown], (element) => this._element.appendChild(element.element));
    this.menu.addLocalHook("select", (command) => this.onMenuSelect(command));
    this.menu.addLocalHook("afterClose", () => this.onMenuClosed());
    this.update();
  }
  /**
   * Update DOM structure.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    let conditionName;
    if (this.options.value) {
      conditionName = this.options.value.name;
    } else {
      conditionName = this.menu.hot.getTranslatedPhrase(FILTERS_CONDITIONS_NONE);
    }
    privatePool10.get(this).captionElement.textContent = conditionName;
    super.update();
  }
  /**
   * Open select dropdown menu with available options.
   */
  openOptions() {
    const rect = this.element.getBoundingClientRect();
    if (this.menu) {
      this.menu.open();
      this.menu.setPosition({
        left: this.hot.isLtr() ? rect.left - 5 : rect.left - 31,
        top: rect.top - 1,
        width: rect.width,
        height: rect.height
      });
    }
  }
  /**
   * Close select dropdown menu.
   */
  closeOptions() {
    if (this.menu) {
      this.menu.close();
    }
  }
  /**
   * On menu selected listener.
   *
   * @private
   * @param {object} command Selected item.
   */
  onMenuSelect(command) {
    if (command.name !== KEY) {
      this.options.value = command;
      this.update();
      this.runLocalHooks("select", this.options.value);
    }
  }
  /**
   * On menu closed listener.
   *
   * @private
   */
  onMenuClosed() {
    this.runLocalHooks("afterClose");
  }
  /**
   * On element click listener.
   *
   * @private
   */
  onClick() {
    this.openOptions();
  }
  /**
   * Destroy instance.
   */
  destroy() {
    if (this.menu) {
      this.menu.destroy();
      this.menu = null;
    }
    const {
      caption,
      dropdown
    } = privatePool10.get(this);
    if (caption) {
      caption.destroy();
    }
    if (dropdown) {
      dropdown.destroy();
    }
    super.destroy();
  }
};
var select_default = SelectUI;

// node_modules/handsontable/plugins/filters/component/condition.mjs
var ConditionComponent = class extends base_default3 {
  constructor(hotInstance, options) {
    super(hotInstance, {
      id: options.id,
      stateless: false
    });
    this.name = options.name;
    this.addSeparator = options.addSeparator;
    this.elements.push(new select_default(this.hot, {
      menuContainer: options.menuContainer
    }));
    this.elements.push(new input_default(this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_VALUE
    }));
    this.elements.push(new input_default(this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE
    }));
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   *
   * @private
   */
  registerHooks() {
    this.getSelectElement().addLocalHook("select", (command) => this.onConditionSelect(command));
    this.getSelectElement().addLocalHook("afterClose", () => this.onSelectUIClosed());
    arrayEach(this.getInputElements(), (input) => {
      input.addLocalHook("keydown", (event2) => this.onInputKeyDown(event2));
    });
  }
  /**
   * Set state of the component.
   *
   * @param {object} value State to restore.
   */
  setState(value) {
    this.reset();
    if (!value) {
      return;
    }
    const copyOfCommand = clone3(value.command);
    if (copyOfCommand.name.startsWith(FILTERS_CONDITIONS_NAMESPACE)) {
      copyOfCommand.name = this.hot.getTranslatedPhrase(copyOfCommand.name);
    }
    this.getSelectElement().setValue(copyOfCommand);
    arrayEach(value.args, (arg, index2) => {
      if (index2 > copyOfCommand.inputsCount - 1) {
        return false;
      }
      const element = this.getInputElement(index2);
      element.setValue(arg);
      element[copyOfCommand.inputsCount > index2 ? "show" : "hide"]();
      if (!index2) {
        setTimeout(() => element.focus(), 10);
      }
    });
  }
  /**
   * Export state of the component (get selected filter and filter arguments).
   *
   * @returns {object} Returns object where `command` key keeps used condition filter and `args` key its arguments.
   */
  getState() {
    const command = this.getSelectElement().getValue() || getConditionDescriptor(CONDITION_NAME);
    const args = [];
    arrayEach(this.getInputElements(), (element, index2) => {
      if (command.inputsCount > index2) {
        args.push(element.getValue());
      }
    });
    return {
      command,
      args
    };
  }
  /**
   * Update state of component.
   *
   * @param {object} condition The condition object.
   * @param {object} condition.command The command object with condition name as `key` property.
   * @param {Array} condition.args An array of values to compare.
   * @param {number} column Physical column index.
   */
  updateState(condition24, column) {
    const command = condition24 ? getConditionDescriptor(condition24.name) : getConditionDescriptor(CONDITION_NAME);
    this.state.setValueAtIndex(column, {
      command,
      args: condition24 ? condition24.args : []
    });
    if (!condition24) {
      arrayEach(this.getInputElements(), (element) => element.setValue(null));
    }
  }
  /**
   * Get select element.
   *
   * @returns {SelectUI}
   */
  getSelectElement() {
    return this.elements.filter((element) => element instanceof select_default)[0];
  }
  /**
   * Get input element.
   *
   * @param {number} index Index an array of elements.
   * @returns {InputUI}
   */
  getInputElement() {
    let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.getInputElements()[index2];
  }
  /**
   * Get input elements.
   *
   * @returns {Array}
   */
  getInputElements() {
    return this.elements.filter((element) => element instanceof input_default);
  }
  /**
   * Get menu object descriptor.
   *
   * @returns {object}
   */
  getMenuItemDescriptor() {
    return {
      key: this.id,
      name: this.name,
      isCommand: false,
      disableSelection: true,
      hidden: () => this.isHidden(),
      renderer: (hot, wrapper, row, col, prop, value) => {
        addClass(wrapper.parentNode, "htFiltersMenuCondition");
        if (this.addSeparator) {
          addClass(wrapper.parentNode, "border");
        }
        const label = this.hot.rootDocument.createElement("div");
        addClass(label, "htFiltersMenuLabel");
        label.textContent = value;
        wrapper.appendChild(label);
        if (!wrapper.parentNode.hasAttribute("ghost-table")) {
          arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));
        }
        return wrapper;
      }
    };
  }
  /**
   * Reset elements to their initial state.
   */
  reset() {
    const selectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
    let items = [getConditionDescriptor(CONDITION_NAME)];
    if (selectedColumn !== null) {
      const {
        visualIndex
      } = selectedColumn;
      items = getOptionsList(this.hot.getDataType(0, visualIndex, this.hot.countRows(), visualIndex));
    }
    arrayEach(this.getInputElements(), (element) => element.hide());
    this.getSelectElement().setItems(items);
    super.reset();
    this.getSelectElement().setValue(items[0]);
  }
  /**
   * On condition select listener.
   *
   * @private
   * @param {object} command Menu item object (command).
   */
  onConditionSelect(command) {
    arrayEach(this.getInputElements(), (element, index2) => {
      element[command.inputsCount > index2 ? "show" : "hide"]();
      if (index2 === 0) {
        setTimeout(() => element.focus(), 10);
      }
    });
    this.runLocalHooks("change", command);
  }
  /**
   * On component SelectUI closed listener.
   *
   * @private
   */
  onSelectUIClosed() {
    this.runLocalHooks("afterClose");
  }
  /**
   * Key down listener.
   *
   * @private
   * @param {Event} event The DOM event object.
   */
  onInputKeyDown(event2) {
    if (isKey(event2.keyCode, "ENTER")) {
      this.runLocalHooks("accept");
      stopImmediatePropagation(event2);
    } else if (isKey(event2.keyCode, "ESCAPE")) {
      this.runLocalHooks("cancel");
      stopImmediatePropagation(event2);
    }
  }
};
var condition_default = ConditionComponent;

// node_modules/handsontable/plugins/filters/ui/radioInput.mjs
var privatePool11 = /* @__PURE__ */ new WeakMap();
var RadioInputUI = class _RadioInputUI extends base_default4 {
  static get DEFAULTS() {
    return clone3({
      type: "radio",
      tagName: "input",
      className: "htUIRadio",
      label: {}
    });
  }
  constructor(hotInstance, options) {
    super(hotInstance, extend2(_RadioInputUI.DEFAULTS, options));
    privatePool11.set(this, {});
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    const priv = privatePool11.get(this);
    priv.input = this._element.firstChild;
    const label = this.hot.rootDocument.createElement("label");
    label.textContent = this.translateIfPossible(this.options.label.textContent);
    label.htmlFor = this.translateIfPossible(this.options.label.htmlFor);
    priv.label = label;
    this._element.appendChild(label);
    this.update();
  }
  /**
   * Update element.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    const priv = privatePool11.get(this);
    priv.input.checked = this.options.checked;
    priv.label.textContent = this.translateIfPossible(this.options.label.textContent);
  }
  /**
   * Check if radio button is checked.
   *
   * @returns {boolean}
   */
  isChecked() {
    return this.options.checked;
  }
  /**
   * Set input checked attribute.
   *
   * @param {boolean} value Set the component state.
   */
  setChecked() {
    let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    this.options.checked = value;
    this.update();
  }
  /**
   * Focus element.
   */
  focus() {
    if (this.isBuilt()) {
      privatePool11.get(this).input.focus();
    }
  }
};
var radioInput_default = RadioInputUI;

// node_modules/handsontable/plugins/filters/component/operators.mjs
var SELECTED_AT_START_ELEMENT_INDEX = 0;
var OperatorsComponent = class extends base_default3 {
  constructor(hotInstance, options) {
    super(hotInstance, {
      id: options.id,
      stateless: false
    });
    this.name = options.name;
    this.buildOperatorsElement();
  }
  /**
   * Get menu object descriptor.
   *
   * @returns {object}
   */
  getMenuItemDescriptor() {
    return {
      key: this.id,
      name: this.name,
      isCommand: false,
      disableSelection: true,
      hidden: () => this.isHidden(),
      renderer: (hot, wrapper) => {
        addClass(wrapper.parentNode, "htFiltersMenuOperators");
        if (!wrapper.parentNode.hasAttribute("ghost-table")) {
          arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));
        }
        return wrapper;
      }
    };
  }
  /**
   * Add RadioInputUI elements to component.
   *
   * @private
   */
  buildOperatorsElement() {
    const operationKeys = [OPERATION_ID, OPERATION_ID2];
    arrayEach(operationKeys, (operation) => {
      const radioInput = new radioInput_default(this.hot, {
        name: "operator",
        label: {
          htmlFor: operation,
          textContent: getOperationName(operation)
        },
        value: operation,
        checked: operation === operationKeys[SELECTED_AT_START_ELEMENT_INDEX],
        id: operation
      });
      radioInput.addLocalHook("change", (event2) => this.onRadioInputChange(event2));
      this.elements.push(radioInput);
    });
  }
  /**
   * Set state of operators component to check radio input at specific `index`.
   *
   * @param {number} searchedIndex Index of radio input to check.
   */
  setChecked(searchedIndex) {
    if (this.elements.length < searchedIndex) {
      throw Error(toSingleLine`Radio button with index ${searchedIndex} doesn't exist.`);
    }
    arrayEach(this.elements, (element, index2) => {
      element.setChecked(index2 === searchedIndex);
    });
  }
  /**
   * Get `id` of active operator.
   *
   * @returns {string}
   */
  getActiveOperationId() {
    const operationElement = this.elements.find((element) => element instanceof radioInput_default && element.isChecked());
    if (operationElement) {
      return operationElement.getValue();
    }
    return OPERATION_ID;
  }
  /**
   * Export state of the component (get selected operator).
   *
   * @returns {string} Returns `id` of selected operator.
   */
  getState() {
    return this.getActiveOperationId();
  }
  /**
   * Set state of the component.
   *
   * @param {object} value State to restore.
   */
  setState(value) {
    this.reset();
    if (value && this.getActiveOperationId() !== value) {
      arrayEach(this.elements, (element) => {
        element.setChecked(element.getValue() === value);
      });
    }
  }
  /**
   * Update state of component.
   *
   * @param {string} [operationId='conjunction'] Id of selected operation.
   * @param {number} column Physical column index.
   */
  updateState() {
    let operationId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OPERATION_ID;
    let column = arguments.length > 1 ? arguments[1] : void 0;
    let selectedOperationId = operationId;
    if (selectedOperationId === OPERATION_ID3) {
      selectedOperationId = OPERATION_ID2;
    }
    this.state.setValueAtIndex(column, selectedOperationId);
  }
  /**
   * Reset elements to their initial state.
   */
  reset() {
    this.setChecked(SELECTED_AT_START_ELEMENT_INDEX);
  }
  /**
   * OnChange listener.
   *
   * @private
   * @param {Event} event The DOM event object.
   */
  onRadioInputChange(event2) {
    this.setState(event2.target.value);
  }
};
var operators_default = OperatorsComponent;

// node_modules/handsontable/plugins/filters/ui/link.mjs
var privatePool12 = /* @__PURE__ */ new WeakMap();
var LinkUI = class _LinkUI extends base_default4 {
  static get DEFAULTS() {
    return clone3({
      href: "#",
      tagName: "a"
    });
  }
  constructor(hotInstance, options) {
    super(hotInstance, extend2(_LinkUI.DEFAULTS, options));
    privatePool12.set(this, {});
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    const priv = privatePool12.get(this);
    priv.link = this._element.firstChild;
  }
  /**
   * Update element.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    privatePool12.get(this).link.textContent = this.translateIfPossible(this.options.textContent);
  }
};
var link_default = LinkUI;

// node_modules/handsontable/plugins/filters/ui/multipleSelect.mjs
var privatePool13 = /* @__PURE__ */ new WeakMap();
var SHORTCUTS_GROUP7 = "multipleSelect.itemBox";
var MultipleSelectUI = class _MultipleSelectUI extends base_default4 {
  static get DEFAULTS() {
    return clone3({
      className: "htUIMultipleSelect",
      value: []
    });
  }
  constructor(hotInstance, options) {
    super(hotInstance, extend2(_MultipleSelectUI.DEFAULTS, options));
    privatePool13.set(this, {});
    this.searchInput = new input_default(this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_SEARCH,
      className: "htUIMultipleSelectSearch"
    });
    this.selectAllUI = new link_default(this.hot, {
      textContent: FILTERS_BUTTONS_SELECT_ALL,
      className: "htUISelectAll"
    });
    this.clearAllUI = new link_default(this.hot, {
      textContent: FILTERS_BUTTONS_CLEAR,
      className: "htUIClearAll"
    });
    this.items = [];
    this.itemsBox = null;
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   */
  registerHooks() {
    this.searchInput.addLocalHook("keydown", (event2) => this.onInputKeyDown(event2));
    this.searchInput.addLocalHook("input", (event2) => this.onInput(event2));
    this.selectAllUI.addLocalHook("click", (event2) => this.onSelectAllClick(event2));
    this.clearAllUI.addLocalHook("click", (event2) => this.onClearAllClick(event2));
  }
  /**
   * Set available options.
   *
   * @param {Array} items Array of objects with `checked` and `label` property.
   */
  setItems(items) {
    this.items = items;
    if (this.itemsBox) {
      this.itemsBox.loadData(this.items);
    }
  }
  /**
   * Set a locale for the component.
   *
   * @param {string} locale Locale used for filter actions performed on data, ie. `en-US`.
   */
  setLocale(locale2) {
    this.locale = locale2;
  }
  /**
   * Get a locale for the component.
   *
   * @returns {string}
   */
  getLocale() {
    return this.locale;
  }
  /**
   * Get all available options.
   *
   * @returns {Array}
   */
  getItems() {
    return [...this.items];
  }
  /**
   * Get element value.
   *
   * @returns {Array} Array of selected values.
   */
  getValue() {
    return itemsToValue(this.items);
  }
  /**
   * Check if all values listed in element are selected.
   *
   * @returns {boolean}
   */
  isSelectedAllValues() {
    return this.items.length === this.getValue().length;
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    const {
      rootDocument
    } = this.hot;
    const itemsBoxWrapper = rootDocument.createElement("div");
    const selectionControl = new base_default4(this.hot, {
      className: "htUISelectionControls",
      children: [this.selectAllUI, this.clearAllUI]
    });
    this._element.appendChild(this.searchInput.element);
    this._element.appendChild(selectionControl.element);
    this._element.appendChild(itemsBoxWrapper);
    const hotInitializer = (wrapper) => {
      if (!this._element) {
        return;
      }
      if (this.itemsBox) {
        this.itemsBox.destroy();
      }
      addClass(wrapper, "htUIMultipleSelectHot");
      this.itemsBox = new this.hot.constructor(wrapper, {
        data: this.items,
        columns: [{
          data: "checked",
          type: "checkbox",
          label: {
            property: "visualValue",
            position: "after"
          }
        }],
        beforeRenderer: (TD, row, col, prop, value, cellProperties) => {
          TD.title = cellProperties.instance.getDataAtRowProp(row, cellProperties.label.property);
        },
        maxCols: 1,
        autoWrapCol: true,
        height: 110,
        // Workaround for #151.
        colWidths: () => this.itemsBox.container.scrollWidth - getScrollbarWidth(rootDocument),
        copyPaste: false,
        disableVisualSelection: "area",
        fillHandle: false,
        fragmentSelection: "cell",
        tabMoves: {
          row: 1,
          col: 0
        },
        layoutDirection: this.hot.isRtl() ? "rtl" : "ltr"
      });
      this.itemsBox.init();
      const shortcutManager = this.itemsBox.getShortcutManager();
      const gridContext = shortcutManager.getContext("grid");
      gridContext.addShortcut({
        // TODO: Is this shortcut really needed? We have one test for that case, but focus is performed programmatically.
        keys: [["Escape"]],
        callback: (event2) => {
          this.runLocalHooks("keydown", event2, this);
        },
        group: SHORTCUTS_GROUP7
      });
    };
    hotInitializer(itemsBoxWrapper);
    setTimeout(() => hotInitializer(itemsBoxWrapper), 100);
  }
  /**
   * Reset DOM structure.
   */
  reset() {
    this.searchInput.reset();
    this.selectAllUI.reset();
    this.clearAllUI.reset();
  }
  /**
   * Update DOM structure.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    this.itemsBox.loadData(valueToItems(this.items, this.options.value));
    super.update();
  }
  /**
   * Destroy instance.
   */
  destroy() {
    if (this.itemsBox) {
      this.itemsBox.destroy();
    }
    this.searchInput.destroy();
    this.clearAllUI.destroy();
    this.selectAllUI.destroy();
    this.searchInput = null;
    this.clearAllUI = null;
    this.selectAllUI = null;
    this.itemsBox = null;
    this.items = null;
    super.destroy();
  }
  /**
   * 'input' event listener for input element.
   *
   * @private
   * @param {Event} event DOM event.
   */
  onInput(event2) {
    const value = event2.target.value.toLocaleLowerCase(this.getLocale());
    let filteredItems;
    if (value === "") {
      filteredItems = [...this.items];
    } else {
      filteredItems = arrayFilter(this.items, (item) => `${item.value}`.toLocaleLowerCase(this.getLocale()).indexOf(value) >= 0);
    }
    this.itemsBox.loadData(filteredItems);
  }
  /**
   * 'keydown' event listener for input element.
   *
   * @private
   * @param {Event} event DOM event.
   */
  onInputKeyDown(event2) {
    this.runLocalHooks("keydown", event2, this);
    const isKeyCode = partial(isKey, event2.keyCode);
    if (isKeyCode("ARROW_DOWN|TAB") && !this.itemsBox.isListening()) {
      stopImmediatePropagation(event2);
      this.itemsBox.listen();
      this.itemsBox.selectCell(0, 0);
    }
  }
  /**
   * On click listener for "Select all" link.
   *
   * @private
   * @param {DOMEvent} event The mouse event object.
   */
  onSelectAllClick(event2) {
    const changes = [];
    event2.preventDefault();
    arrayEach(this.itemsBox.getSourceData(), (row, rowIndex) => {
      row.checked = true;
      changes.push(dataRowToChangesArray(row, rowIndex)[0]);
    });
    this.itemsBox.setSourceDataAtCell(changes);
  }
  /**
   * On click listener for "Clear" link.
   *
   * @private
   * @param {DOMEvent} event The mouse event object.
   */
  onClearAllClick(event2) {
    const changes = [];
    event2.preventDefault();
    arrayEach(this.itemsBox.getSourceData(), (row, rowIndex) => {
      row.checked = false;
      changes.push(dataRowToChangesArray(row, rowIndex)[0]);
    });
    this.itemsBox.setSourceDataAtCell(changes);
  }
};
var multipleSelect_default = MultipleSelectUI;
function valueToItems(availableItems, selectedValue) {
  const arrayAssertion = createArrayAssertion(selectedValue);
  return arrayMap(availableItems, (item) => {
    item.checked = arrayAssertion(item.value);
    return item;
  });
}
function itemsToValue(availableItems) {
  const items = [];
  arrayEach(availableItems, (item) => {
    if (item.checked) {
      items.push(item.value);
    }
  });
  return items;
}

// node_modules/handsontable/plugins/filters/component/value.mjs
var ValueComponent = class extends base_default3 {
  constructor(hotInstance, options) {
    super(hotInstance, {
      id: options.id,
      stateless: false
    });
    this.name = options.name;
    this.elements.push(new multipleSelect_default(this.hot));
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   *
   * @private
   */
  registerHooks() {
    this.getMultipleSelectElement().addLocalHook("keydown", (event2) => this.onInputKeyDown(event2));
  }
  /**
   * Set state of the component.
   *
   * @param {object} value The component value.
   */
  setState(value) {
    this.reset();
    if (value && value.command.key === CONDITION_NAME21) {
      const select = this.getMultipleSelectElement();
      select.setItems(value.itemsSnapshot);
      select.setValue(value.args[0]);
      select.setLocale(value.locale);
    }
  }
  /**
   * Export state of the component (get selected filter and filter arguments).
   *
   * @returns {object} Returns object where `command` key keeps used condition filter and `args` key its arguments.
   */
  getState() {
    const select = this.getMultipleSelectElement();
    const availableItems = select.getItems();
    return {
      command: {
        key: select.isSelectedAllValues() || !availableItems.length ? CONDITION_NAME : CONDITION_NAME21
      },
      args: [select.getValue()],
      itemsSnapshot: availableItems
    };
  }
  /**
   * Update state of component.
   *
   * @param {object} stateInfo Information about state containing stack of edited column,
   * stack of dependent conditions, data factory and optional condition arguments change. It's described by object containing keys:
   * `editedConditionStack`, `dependentConditionStacks`, `visibleDataFactory` and `conditionArgsChange`.
   */
  updateState(stateInfo) {
    const updateColumnState = (physicalColumn, conditions2, conditionArgsChange, filteredRowsFactory, conditionsStack) => {
      const [firstByValueCondition] = arrayFilter(conditions2, (condition24) => condition24.name === CONDITION_NAME21);
      const state = {};
      const defaultBlankCellValue = this.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);
      if (firstByValueCondition) {
        const rowValues = unifyColumnValues(arrayMap(filteredRowsFactory(physicalColumn, conditionsStack), (row) => row.value));
        if (conditionArgsChange) {
          firstByValueCondition.args[0] = conditionArgsChange;
        }
        const selectedValues = [];
        const itemsSnapshot = intersectValues(rowValues, firstByValueCondition.args[0], defaultBlankCellValue, (item) => {
          if (item.checked) {
            selectedValues.push(item.value);
          }
        });
        const column = stateInfo.editedConditionStack.column;
        state.locale = this.hot.getCellMeta(0, column).locale;
        state.args = [selectedValues];
        state.command = getConditionDescriptor(CONDITION_NAME21);
        state.itemsSnapshot = itemsSnapshot;
      } else {
        state.args = [];
        state.command = getConditionDescriptor(CONDITION_NAME);
      }
      this.state.setValueAtIndex(physicalColumn, state);
    };
    updateColumnState(stateInfo.editedConditionStack.column, stateInfo.editedConditionStack.conditions, stateInfo.conditionArgsChange, stateInfo.filteredRowsFactory);
    if (stateInfo.dependentConditionStacks.length) {
      updateColumnState(stateInfo.dependentConditionStacks[0].column, stateInfo.dependentConditionStacks[0].conditions, stateInfo.conditionArgsChange, stateInfo.filteredRowsFactory, stateInfo.editedConditionStack);
    }
  }
  /**
   * Get multiple select element.
   *
   * @returns {MultipleSelectUI}
   */
  getMultipleSelectElement() {
    return this.elements.filter((element) => element instanceof multipleSelect_default)[0];
  }
  /**
   * Get object descriptor for menu item entry.
   *
   * @returns {object}
   */
  getMenuItemDescriptor() {
    return {
      key: this.id,
      name: this.name,
      isCommand: false,
      disableSelection: true,
      hidden: () => this.isHidden(),
      renderer: (hot, wrapper, row, col, prop, value) => {
        addClass(wrapper.parentNode, "htFiltersMenuValue");
        const label = this.hot.rootDocument.createElement("div");
        addClass(label, "htFiltersMenuLabel");
        label.textContent = value;
        wrapper.appendChild(label);
        if (!wrapper.parentNode.hasAttribute("ghost-table")) {
          arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));
        }
        return wrapper;
      }
    };
  }
  /**
   * Reset elements to their initial state.
   */
  reset() {
    const defaultBlankCellValue = this.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);
    const values = unifyColumnValues(this._getColumnVisibleValues());
    const items = intersectValues(values, values, defaultBlankCellValue);
    this.getMultipleSelectElement().setItems(items);
    super.reset();
    this.getMultipleSelectElement().setValue(values);
    const selectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
    if (selectedColumn !== null) {
      this.getMultipleSelectElement().setLocale(this.hot.getCellMeta(0, selectedColumn.visualIndex).locale);
    }
  }
  /**
   * Key down listener.
   *
   * @private
   * @param {Event} event The DOM event object.
   */
  onInputKeyDown(event2) {
    if (isKey(event2.keyCode, "ESCAPE")) {
      this.runLocalHooks("cancel");
      stopImmediatePropagation(event2);
    }
  }
  /**
   * Get data for currently selected column.
   *
   * @returns {Array}
   * @private
   */
  _getColumnVisibleValues() {
    const selectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
    if (selectedColumn === null) {
      return [];
    }
    return arrayMap(this.hot.getDataAtCol(selectedColumn.visualIndex), (v) => toEmptyString(v));
  }
};
var value_default = ValueComponent;

// node_modules/handsontable/plugins/filters/component/actionBar.mjs
var ActionBarComponent = class _ActionBarComponent extends base_default3 {
  static get BUTTON_OK() {
    return "ok";
  }
  static get BUTTON_CANCEL() {
    return "cancel";
  }
  constructor(hotInstance, options) {
    super(hotInstance, {
      id: options.id,
      stateless: true
    });
    this.name = options.name;
    this.elements.push(new input_default(this.hot, {
      type: "button",
      value: FILTERS_BUTTONS_OK,
      className: "htUIButton htUIButtonOK",
      identifier: _ActionBarComponent.BUTTON_OK
    }));
    this.elements.push(new input_default(this.hot, {
      type: "button",
      value: FILTERS_BUTTONS_CANCEL,
      className: "htUIButton htUIButtonCancel",
      identifier: _ActionBarComponent.BUTTON_CANCEL
    }));
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   *
   * @private
   */
  registerHooks() {
    arrayEach(this.elements, (element) => {
      element.addLocalHook("click", (event2, button) => this.onButtonClick(event2, button));
    });
  }
  /**
   * Get menu object descriptor.
   *
   * @returns {object}
   */
  getMenuItemDescriptor() {
    return {
      key: this.id,
      name: this.name,
      isCommand: false,
      disableSelection: true,
      hidden: () => this.isHidden(),
      renderer: (hot, wrapper) => {
        addClass(wrapper.parentNode, "htFiltersMenuActionBar");
        if (!wrapper.parentNode.hasAttribute("ghost-table")) {
          arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));
        }
        return wrapper;
      }
    };
  }
  /**
   * Fire accept event.
   */
  accept() {
    this.runLocalHooks("accept");
  }
  /**
   * Fire cancel event.
   */
  cancel() {
    this.runLocalHooks("cancel");
  }
  /**
   * On button click listener.
   *
   * @private
   * @param {Event} event DOM event.
   * @param {InputUI} button InputUI object.
   */
  onButtonClick(event2, button) {
    if (button.options.identifier === _ActionBarComponent.BUTTON_OK) {
      this.accept();
    } else {
      this.cancel();
    }
  }
};
var actionBar_default = ActionBarComponent;

// node_modules/handsontable/plugins/filters/conditionCollection.mjs
var MAP_NAME = "ConditionCollection.filteringStates";
var ConditionCollection = class {
  constructor(hot) {
    let isMapRegistrable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    this.hot = hot;
    this.isMapRegistrable = isMapRegistrable;
    this.filteringStates = new LinkedPhysicalIndexToValueMap();
    if (this.isMapRegistrable === true) {
      this.hot.columnIndexMapper.registerMap(MAP_NAME, this.filteringStates);
    } else {
      this.filteringStates.init(this.hot.columnIndexMapper.getNumberOfIndexes());
    }
  }
  /**
   * Check if condition collection is empty (so no needed to filter data).
   *
   * @returns {boolean}
   */
  isEmpty() {
    return this.getFilteredColumns().length === 0;
  }
  /**
   * Check if value is matched to the criteria of conditions chain.
   *
   * @param {object} value Object with `value` and `meta` keys.
   * @param {number} column The physical column index.
   * @returns {boolean}
   */
  isMatch(value, column) {
    var _stateForColumn$condi;
    const stateForColumn = this.filteringStates.getValueAtIndex(column);
    const conditions2 = (_stateForColumn$condi = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.conditions) !== null && _stateForColumn$condi !== void 0 ? _stateForColumn$condi : [];
    const operation = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.operation;
    return this.isMatchInConditions(conditions2, value, operation);
  }
  /**
   * Check if the value is matches the conditions.
   *
   * @param {Array} conditions List of conditions.
   * @param {object} value Object with `value` and `meta` keys.
   * @param {string} [operationType='conjunction'] Type of conditions operation.
   * @returns {boolean}
   */
  isMatchInConditions(conditions2, value) {
    let operationType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OPERATION_ID;
    if (conditions2.length) {
      return getOperationFunc(operationType)(conditions2, value);
    }
    return true;
  }
  /**
   * Add condition to the collection.
   *
   * @param {number} column The physical column index.
   * @param {object} conditionDefinition Object with keys:
   *  * `command` Object, Command object with condition name as `key` property.
   *  * `args` Array, Condition arguments.
   * @param {string} [operation='conjunction'] Type of conditions operation.
   * @param {number} [position] Position to which condition will be added. When argument is undefined
   * the condition will be processed as the last condition.
   * @fires ConditionCollection#beforeAdd
   * @fires ConditionCollection#afterAdd
   */
  addCondition(column, conditionDefinition) {
    let operation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OPERATION_ID;
    let position = arguments.length > 3 ? arguments[3] : void 0;
    const localeForColumn = this.hot.getCellMeta(0, column).locale;
    const args = arrayMap(conditionDefinition.args, (v) => typeof v === "string" ? v.toLocaleLowerCase(localeForColumn) : v);
    const name = conditionDefinition.name || conditionDefinition.command.key;
    this.runLocalHooks("beforeAdd", column);
    const columnType = this.getOperation(column);
    if (columnType) {
      if (columnType !== operation) {
        throw Error(toSingleLine`The column of index ${column} has been already applied with a \`${columnType}\`\x20
        filter operation. Use \`removeConditions\` to clear the current conditions and then add new ones.\x20
        Mind that you cannot mix different types of operations (for instance, if you use \`conjunction\`,\x20
        use it consequently for a particular column).`);
      }
    } else if (isUndefined2(operations[operation])) {
      throw new Error(toSingleLine`Unexpected operation named \`${operation}\`. Possible ones are\x20
        \`disjunction\` and \`conjunction\`.`);
    }
    const conditionsForColumn = this.getConditions(column);
    if (conditionsForColumn.length === 0) {
      this.filteringStates.setValueAtIndex(column, {
        operation,
        conditions: [{
          name,
          args,
          func: getCondition(name, args)
        }]
      }, position);
    } else {
      conditionsForColumn.push({
        name,
        args,
        func: getCondition(name, args)
      });
    }
    this.runLocalHooks("afterAdd", column);
  }
  /**
   * Get all added conditions from the collection at specified column index.
   *
   * @param {number} column The physical column index.
   * @returns {Array} Returns conditions collection as an array.
   */
  getConditions(column) {
    var _this$filteringStates, _this$filteringStates2;
    return (_this$filteringStates = (_this$filteringStates2 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates2 === void 0 ? void 0 : _this$filteringStates2.conditions) !== null && _this$filteringStates !== void 0 ? _this$filteringStates : [];
  }
  /**
   * Get operation for particular column.
   *
   * @param {number} column The physical column index.
   * @returns {string|undefined}
   */
  getOperation(column) {
    var _this$filteringStates3;
    return (_this$filteringStates3 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates3 === void 0 ? void 0 : _this$filteringStates3.operation;
  }
  /**
   * Get all filtered physical columns in the order in which actions are performed.
   *
   * @returns {Array}
   */
  getFilteredColumns() {
    return this.filteringStates.getEntries().map((_ref2) => {
      let [physicalColumn] = _ref2;
      return physicalColumn;
    });
  }
  /**
   * Gets position in the filtering states stack for the specific column.
   *
   * @param {number} column The physical column index.
   * @returns {number} Returns -1 when the column doesn't exist in the stack.
   */
  getColumnStackPosition(column) {
    return this.getFilteredColumns().indexOf(column);
  }
  /**
   * Export all previously added conditions.
   *
   * @returns {Array}
   */
  exportAllConditions() {
    return arrayReduce(this.filteringStates.getEntries(), (allConditions, _ref2) => {
      let [column, {
        operation,
        conditions: conditions2
      }] = _ref2;
      allConditions.push({
        column,
        operation,
        conditions: arrayMap(conditions2, (_ref3) => {
          let {
            name,
            args
          } = _ref3;
          return {
            name,
            args
          };
        })
      });
      return allConditions;
    }, []);
  }
  /**
   * Import conditions to the collection.
   *
   * @param {Array} conditions The collection of the conditions.
   */
  importAllConditions(conditions2) {
    this.clean();
    arrayEach(conditions2, (stack) => {
      arrayEach(stack.conditions, (condition24) => this.addCondition(stack.column, condition24));
    });
  }
  /**
   * Remove conditions at given column index.
   *
   * @param {number} column The physical column index.
   * @fires ConditionCollection#beforeRemove
   * @fires ConditionCollection#afterRemove
   */
  removeConditions(column) {
    this.runLocalHooks("beforeRemove", column);
    this.filteringStates.clearValue(column);
    this.runLocalHooks("afterRemove", column);
  }
  /**
   * Clean all conditions collection and reset order stack.
   *
   * @fires ConditionCollection#beforeClean
   * @fires ConditionCollection#afterClean
   */
  clean() {
    this.runLocalHooks("beforeClean");
    this.filteringStates.clear();
    this.runLocalHooks("afterClean");
  }
  /**
   * Check if at least one condition was added at specified column index. And if second parameter is passed then additionally
   * check if condition exists under its name.
   *
   * @param {number} column The physical column index.
   * @param {string} [name] Condition name.
   * @returns {boolean}
   */
  hasConditions(column, name) {
    const conditions2 = this.getConditions(column);
    if (name) {
      return conditions2.some((condition24) => condition24.name === name);
    }
    return conditions2.length > 0;
  }
  /**
   * Destroy object.
   */
  destroy() {
    if (this.isMapRegistrable) {
      this.hot.columnIndexMapper.unregisterMap(MAP_NAME);
    }
    this.filteringStates = null;
    this.clearLocalHooks();
  }
};
mixin(ConditionCollection, localHooks_default);
var conditionCollection_default = ConditionCollection;

// node_modules/handsontable/plugins/filters/dataFilter.mjs
var DataFilter = class {
  constructor(conditionCollection) {
    let columnDataFactory = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => [];
    this.conditionCollection = conditionCollection;
    this.columnDataFactory = columnDataFactory;
  }
  /**
   * Filter data based on the conditions collection.
   *
   * @returns {Array}
   */
  filter() {
    let filteredData = [];
    arrayEach(this.conditionCollection.getFilteredColumns(), (physicalColumn, index2) => {
      let columnData = this.columnDataFactory(physicalColumn);
      if (index2) {
        columnData = this._getIntersectData(columnData, filteredData);
      }
      filteredData = this.filterByColumn(physicalColumn, columnData);
    });
    return filteredData;
  }
  /**
   * Filter data based on specified physical column index.
   *
   * @param {number} column The physical column index.
   * @param {Array} [dataSource] Data source as array of objects with `value` and `meta` keys (e.g. `{value: 'foo', meta: {}}`).
   * @returns {Array} Returns filtered data.
   */
  filterByColumn(column) {
    let dataSource = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const filteredData = [];
    arrayEach(dataSource, (dataRow) => {
      if (dataRow !== void 0 && this.conditionCollection.isMatch(dataRow, column)) {
        filteredData.push(dataRow);
      }
    });
    return filteredData;
  }
  /**
   * Intersect data.
   *
   * @private
   * @param {Array} data The data to intersect.
   * @param {Array} needles The collection intersected rows with the data.
   * @returns {Array}
   */
  _getIntersectData(data, needles) {
    const result = [];
    arrayEach(needles, (needleRow) => {
      const row = needleRow.meta.visualRow;
      if (data[row] !== void 0) {
        result[row] = data[row];
      }
    });
    return result;
  }
};
var dataFilter_default = DataFilter;

// node_modules/handsontable/plugins/filters/conditionUpdateObserver.mjs
var ConditionUpdateObserver = class {
  constructor(hot, conditionCollection) {
    let columnDataFactory = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => [];
    this.hot = hot;
    this.conditionCollection = conditionCollection;
    this.columnDataFactory = columnDataFactory;
    this.changes = [];
    this.grouping = false;
    this.latestEditedColumnPosition = -1;
    this.latestOrderStack = [];
    this.conditionCollection.addLocalHook("beforeRemove", (column) => this._onConditionBeforeModify(column));
    this.conditionCollection.addLocalHook("afterRemove", (column) => this.updateStatesAtColumn(column));
    this.conditionCollection.addLocalHook("afterAdd", (column) => this.updateStatesAtColumn(column));
    this.conditionCollection.addLocalHook("beforeClean", () => this._onConditionBeforeClean());
    this.conditionCollection.addLocalHook("afterClean", () => this._onConditionAfterClean());
  }
  /**
   * Enable grouping changes. Grouping is helpful in situations when a lot of conditions is added in one moment. Instead of
   * trigger `update` hook for every condition by adding/removing you can group this changes and call `flush` method to trigger
   * it once.
   */
  groupChanges() {
    this.grouping = true;
  }
  /**
   * Flush all collected changes. This trigger `update` hook for every previously collected change from condition collection.
   */
  flush() {
    this.grouping = false;
    arrayEach(this.changes, (column) => {
      this.updateStatesAtColumn(column);
    });
    this.changes.length = 0;
  }
  /**
   * On before modify condition (add or remove from collection),.
   *
   * @param {number} column Column index.
   * @private
   */
  _onConditionBeforeModify(column) {
    this.latestEditedColumnPosition = this.conditionCollection.getColumnStackPosition(column);
  }
  /**
   * Update all related states which should be changed after invoking changes applied to current column.
   *
   * @param {number} column The column index.
   * @param {object} conditionArgsChange Object describing condition changes which can be handled by filters on `update` hook.
   * It contains keys `conditionKey` and `conditionValue` which refers to change specified key of condition to specified value
   * based on referred keys.
   */
  updateStatesAtColumn(column, conditionArgsChange) {
    var _this = this;
    if (this.grouping) {
      if (this.changes.indexOf(column) === -1) {
        this.changes.push(column);
      }
      return;
    }
    const allConditions = this.conditionCollection.exportAllConditions();
    let editedColumnPosition = this.conditionCollection.getColumnStackPosition(column);
    if (editedColumnPosition === -1) {
      editedColumnPosition = this.latestEditedColumnPosition;
    }
    const conditionsBefore = allConditions.slice(0, editedColumnPosition);
    const conditionsAfter = allConditions.slice(editedColumnPosition);
    if (conditionsAfter.length && conditionsAfter[0].column === column) {
      conditionsAfter.shift();
    }
    const visibleDataFactory = curry(function(curriedConditionsBefore, curriedColumn) {
      let conditionsStack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      const splitConditionCollection = new conditionCollection_default(_this.hot, false);
      const curriedConditionsBeforeArray = [].concat(curriedConditionsBefore, conditionsStack);
      splitConditionCollection.importAllConditions(curriedConditionsBeforeArray);
      const allRows = _this.columnDataFactory(curriedColumn);
      let visibleRows;
      if (splitConditionCollection.isEmpty()) {
        visibleRows = allRows;
      } else {
        visibleRows = new dataFilter_default(splitConditionCollection, (columnData) => _this.columnDataFactory(columnData)).filter();
      }
      visibleRows = arrayMap(visibleRows, (rowData) => rowData.meta.visualRow);
      const visibleRowsAssertion = createArrayAssertion(visibleRows);
      splitConditionCollection.destroy();
      return arrayFilter(allRows, (rowData) => visibleRowsAssertion(rowData.meta.visualRow));
    })(conditionsBefore);
    const editedConditions = [].concat(this.conditionCollection.getConditions(column));
    this.runLocalHooks("update", {
      editedConditionStack: {
        column,
        conditions: editedConditions
      },
      dependentConditionStacks: conditionsAfter,
      filteredRowsFactory: visibleDataFactory,
      conditionArgsChange
    });
  }
  /**
   * On before conditions clean listener.
   *
   * @private
   */
  _onConditionBeforeClean() {
    this.latestOrderStack = this.conditionCollection.getFilteredColumns();
  }
  /**
   * On after conditions clean listener.
   *
   * @private
   */
  _onConditionAfterClean() {
    arrayEach(this.latestOrderStack, (column) => {
      this.updateStatesAtColumn(column);
    });
  }
  /**
   * Destroy instance.
   */
  destroy() {
    this.clearLocalHooks();
    objectEach(this, (value, property) => {
      this[property] = null;
    });
  }
};
mixin(ConditionUpdateObserver, localHooks_default);
var conditionUpdateObserver_default = ConditionUpdateObserver;

// node_modules/handsontable/plugins/filters/filters.mjs
var PLUGIN_KEY16 = "filters";
var PLUGIN_PRIORITY15 = 250;
var Filters = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY16;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY15;
  }
  static get PLUGIN_DEPS() {
    return ["plugin:DropdownMenu", "plugin:HiddenRows", "cell-type:checkbox"];
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.eventManager = new eventManager_default(this);
    this.dropdownMenuPlugin = null;
    this.conditionCollection = null;
    this.conditionUpdateObserver = null;
    this.components = /* @__PURE__ */ new Map([["filter_by_condition", null], ["filter_operators", null], ["filter_by_condition2", null], ["filter_by_value", null], ["filter_action_bar", null]]);
    this.filtersRowsMap = null;
    this.hot.addHook("afterGetColHeader", (col, TH) => this.onAfterGetColHeader(col, TH));
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link Filters#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY16] ? true : false;
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.filtersRowsMap = this.hot.rowIndexMapper.registerMap(this.pluginName, new TrimmingMap());
    this.dropdownMenuPlugin = this.hot.getPlugin("dropdownMenu");
    const dropdownSettings = this.hot.getSettings().dropdownMenu;
    const menuContainer = dropdownSettings && dropdownSettings.uiContainer || this.hot.rootDocument.body;
    const addConfirmationHooks = (component) => {
      component.addLocalHook("accept", () => this.onActionBarSubmit("accept"));
      component.addLocalHook("cancel", () => this.onActionBarSubmit("cancel"));
      component.addLocalHook("change", (command) => this.onComponentChange(component, command));
      return component;
    };
    const filterByConditionLabel = () => `${this.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_CONDITION)}:`;
    const filterValueLabel = () => `${this.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_VALUE)}:`;
    if (!this.components.get("filter_by_condition")) {
      const conditionComponent = new condition_default(this.hot, {
        id: "filter_by_condition",
        name: filterByConditionLabel,
        addSeparator: false,
        menuContainer
      });
      conditionComponent.addLocalHook("afterClose", () => this.onSelectUIClosed());
      this.components.set("filter_by_condition", addConfirmationHooks(conditionComponent));
    }
    if (!this.components.get("filter_operators")) {
      this.components.set("filter_operators", new operators_default(this.hot, {
        id: "filter_operators",
        name: "Operators"
      }));
    }
    if (!this.components.get("filter_by_condition2")) {
      const conditionComponent = new condition_default(this.hot, {
        id: "filter_by_condition2",
        name: "",
        addSeparator: true,
        menuContainer
      });
      conditionComponent.addLocalHook("afterClose", () => this.onSelectUIClosed());
      this.components.set("filter_by_condition2", addConfirmationHooks(conditionComponent));
    }
    if (!this.components.get("filter_by_value")) {
      this.components.set("filter_by_value", addConfirmationHooks(new value_default(this.hot, {
        id: "filter_by_value",
        name: filterValueLabel
      })));
    }
    if (!this.components.get("filter_action_bar")) {
      this.components.set("filter_action_bar", addConfirmationHooks(new actionBar_default(this.hot, {
        id: "filter_action_bar",
        name: "Action bar"
      })));
    }
    if (!this.conditionCollection) {
      this.conditionCollection = new conditionCollection_default(this.hot);
    }
    if (!this.conditionUpdateObserver) {
      this.conditionUpdateObserver = new conditionUpdateObserver_default(this.hot, this.conditionCollection, (physicalColumn) => this.getDataMapAtColumn(physicalColumn));
      this.conditionUpdateObserver.addLocalHook("update", (conditionState) => this.updateComponents(conditionState));
    }
    this.components.forEach((component) => component.show());
    this.addHook("beforeDropdownMenuSetItems", (items) => this.onBeforeDropdownMenuSetItems(items));
    this.addHook("afterDropdownMenuDefaultOptions", (defaultOptions) => this.onAfterDropdownMenuDefaultOptions(defaultOptions));
    this.addHook("afterDropdownMenuShow", () => this.onAfterDropdownMenuShow());
    this.addHook("afterDropdownMenuHide", () => this.onAfterDropdownMenuHide());
    this.addHook("afterChange", (changes) => this.onAfterChange(changes));
    if (this.hot.getSettings().dropdownMenu && this.dropdownMenuPlugin) {
      this.dropdownMenuPlugin.disablePlugin();
      this.dropdownMenuPlugin.enablePlugin();
    }
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    if (this.enabled) {
      var _this$dropdownMenuPlu;
      if ((_this$dropdownMenuPlu = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu !== void 0 && _this$dropdownMenuPlu.enabled) {
        this.dropdownMenuPlugin.menu.clearLocalHooks();
      }
      this.components.forEach((component, key) => {
        component.destroy();
        this.components.set(key, null);
      });
      this.conditionCollection.destroy();
      this.conditionCollection = null;
      this.hot.rowIndexMapper.unregisterMap(this.pluginName);
    }
    super.disablePlugin();
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @memberof Filters#
   * @function addCondition
   * @description
   * Adds condition to the conditions collection at specified column index.
   *
   * Possible predefined conditions:
   *  * `begins_with` - Begins with
   *  * `between` - Between
   *  * `by_value` - By value
   *  * `contains` - Contains
   *  * `date_after` - After a date
   *  * `date_before` - Before a date
   *  * `date_today` - Today
   *  * `date_tomorrow` - Tomorrow
   *  * `date_yesterday` - Yesterday
   *  * `empty` - Empty
   *  * `ends_with` - Ends with
   *  * `eq` - Equal
   *  * `gt` - Greater than
   *  * `gte` - Greater than or equal
   *  * `lt` - Less than
   *  * `lte` - Less than or equal
   *  * `none` - None (no filter)
   *  * `not_between` - Not between
   *  * `not_contains` - Not contains
   *  * `not_empty` - Not empty
   *  * `neq` - Not equal.
   *
   * Possible operations on collection of conditions:
   *  * `conjunction` - [**Conjunction**](https://en.wikipedia.org/wiki/Logical_conjunction) on conditions collection (by default), i.e. for such operation: <br/> c1 AND c2 AND c3 AND c4 ... AND cn === TRUE, where c1 ... cn are conditions.
   *  * `disjunction` - [**Disjunction**](https://en.wikipedia.org/wiki/Logical_disjunction) on conditions collection, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 ... OR cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.
   *  * `disjunctionWithExtraCondition` - **Disjunction** on first `n - 1`\* conditions from collection with an extra requirement computed from the last condition, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 ... OR cn-1 AND cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.
   *
   * \* when `n` is collection size; it's used i.e. for one operation introduced from UI (when choosing from filter's drop-down menu two conditions with OR operator between them, mixed with choosing values from the multiple choice select)
   *
   * **Note**: Mind that you cannot mix different types of operations (for instance, if you use `conjunction`, use it consequently for a particular column).
   *
   * @example
   * ::: only-for javascript
   * ```js
   * const container = document.getElementById('example');
   * const hot = new Handsontable(container, {
   *   data: getData(),
   *   filters: true
   * });
   *
   * // access to filters plugin instance
   * const filtersPlugin = hot.getPlugin('filters');
   *
   * // add filter "Greater than" 95 to column at index 1
   * filtersPlugin.addCondition(1, 'gt', [95]);
   * filtersPlugin.filter();
   *
   * // add filter "By value" to column at index 1
   * // in this case all value's that don't match will be filtered.
   * filtersPlugin.addCondition(1, 'by_value', [['ing', 'ed', 'as', 'on']]);
   * filtersPlugin.filter();
   *
   * // add filter "Begins with" with value "de" AND "Not contains" with value "ing"
   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'conjunction');
   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'conjunction');
   * filtersPlugin.filter();
   *
   * // add filter "Begins with" with value "de" OR "Not contains" with value "ing"
   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'disjunction');
   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'disjunction');
   * filtersPlugin.filter();
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * const hotRef = useRef(null);
   *
   * ...
   *
   * <HotTable
   *   ref={hotRef}
   *   data={getData()}
   *   filters={true}
   * />
   *
   * // access to filters plugin instance
   * const hot = hotRef.current.hotInstance;
   * const filtersPlugin = hot.getPlugin('filters');
   *
   * // add filter "Greater than" 95 to column at index 1
   * filtersPlugin.addCondition(1, 'gt', [95]);
   * filtersPlugin.filter();
   *
   * // add filter "By value" to column at index 1
   * // in this case all value's that don't match will be filtered.
   * filtersPlugin.addCondition(1, 'by_value', [['ing', 'ed', 'as', 'on']]);
   * filtersPlugin.filter();
   *
   * // add filter "Begins with" with value "de" AND "Not contains" with value "ing"
   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'conjunction');
   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'conjunction');
   * filtersPlugin.filter();
   *
   * // add filter "Begins with" with value "de" OR "Not contains" with value "ing"
   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'disjunction');
   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'disjunction');
   * filtersPlugin.filter();
   * ```
   * :::
   *
   * @param {number} column Visual column index.
   * @param {string} name Condition short name.
   * @param {Array} args Condition arguments.
   * @param {string} [operationId=conjunction] `id` of operation which is performed on the column.
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  addCondition(column, name, args) {
    let operationId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : OPERATION_ID;
    const physicalColumn = this.hot.toPhysicalColumn(column);
    this.conditionCollection.addCondition(physicalColumn, {
      command: {
        key: name
      },
      args
    }, operationId);
  }
  /**
   * Removes conditions at specified column index.
   *
   * @param {number} column Visual column index.
   */
  removeConditions(column) {
    const physicalColumn = this.hot.toPhysicalColumn(column);
    this.conditionCollection.removeConditions(physicalColumn);
  }
  /**
   * Clears all conditions previously added to the collection for the specified column index or, if the column index
   * was not passed, clear the conditions for all columns.
   *
   * @param {number} [column] Visual column index.
   */
  clearConditions(column) {
    if (column === void 0) {
      this.conditionCollection.clean();
    } else {
      const physicalColumn = this.hot.toPhysicalColumn(column);
      this.conditionCollection.removeConditions(physicalColumn);
    }
  }
  /**
   * Filters data based on added filter conditions.
   *
   * @fires Hooks#beforeFilter
   * @fires Hooks#afterFilter
   */
  filter() {
    const dataFilter = this._createDataFilter();
    const needToFilter = !this.conditionCollection.isEmpty();
    let visibleVisualRows = [];
    const conditions2 = this.conditionCollection.exportAllConditions();
    const allowFiltering = this.hot.runHooks("beforeFilter", conditions2);
    if (allowFiltering !== false) {
      if (needToFilter) {
        const trimmedRows = [];
        this.hot.batchExecution(() => {
          this.filtersRowsMap.clear();
          visibleVisualRows = arrayMap(dataFilter.filter(), (rowData) => rowData.meta.visualRow);
          const visibleVisualRowsAssertion = createArrayAssertion(visibleVisualRows);
          rangeEach(this.hot.countSourceRows() - 1, (row) => {
            if (!visibleVisualRowsAssertion(row)) {
              trimmedRows.push(row);
            }
          });
          arrayEach(trimmedRows, (physicalRow) => {
            this.filtersRowsMap.setValueAtIndex(physicalRow, true);
          });
        }, true);
        if (!visibleVisualRows.length) {
          this.hot.deselectCell();
        }
      } else {
        this.filtersRowsMap.clear();
      }
    }
    this.hot.runHooks("afterFilter", conditions2);
    this.hot.view.adjustElementsSize(true);
    this.hot.render();
    this.clearColumnSelection();
  }
  /**
   * Gets last selected column index.
   *
   * @returns {{visualIndex: number, physicalIndex: number} | null} Returns `null` when a column is
   * not selected. Otherwise, returns an object with `visualIndex` and `physicalIndex` properties containing
   * the index of the column.
   */
  getSelectedColumn() {
    var _this$hot$getSelected;
    const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
    if (!highlight) {
      return null;
    }
    return {
      visualIndex: highlight.col,
      physicalIndex: this.hot.toPhysicalColumn(highlight.col)
    };
  }
  /**
   * Clears column selection.
   *
   * @private
   */
  clearColumnSelection() {
    const selectedColumn = this.getSelectedColumn();
    if (selectedColumn !== null) {
      this.hot.selectCell(0, selectedColumn.visualIndex);
    }
  }
  /**
   * Returns handsontable source data with cell meta based on current selection.
   *
   * @param {number} [column] The physical column index. By default column index accept the value of the selected column.
   * @returns {Array} Returns array of objects where keys as row index.
   */
  getDataMapAtColumn(column) {
    const visualColumn = this.hot.toVisualColumn(column);
    const data = [];
    arrayEach(this.hot.getSourceDataAtCol(visualColumn), (value, rowIndex) => {
      var _this$hot$getDataAtCe;
      const {
        row,
        col,
        visualCol,
        visualRow,
        type,
        instance,
        dateFormat,
        locale: locale2
      } = this.hot.getCellMeta(rowIndex, visualColumn);
      const dataValue = (_this$hot$getDataAtCe = this.hot.getDataAtCell(this.hot.toVisualRow(rowIndex), visualColumn)) !== null && _this$hot$getDataAtCe !== void 0 ? _this$hot$getDataAtCe : value;
      data.push({
        meta: {
          row,
          col,
          visualCol,
          visualRow,
          type,
          instance,
          dateFormat,
          locale: locale2
        },
        value: toEmptyString(dataValue)
      });
    });
    return data;
  }
  /**
   * `afterChange` listener.
   *
   * @private
   * @param {Array} changes Array of changes.
   */
  onAfterChange(changes) {
    if (changes) {
      arrayEach(changes, (change) => {
        const [, prop] = change;
        const columnIndex = this.hot.propToCol(prop);
        if (this.conditionCollection.hasConditions(columnIndex)) {
          this.updateValueComponentCondition(columnIndex);
        }
      });
    }
  }
  /**
   * Update the condition of ValueComponent, based on the handled changes.
   *
   * @private
   * @param {number} columnIndex Column index of handled ValueComponent condition.
   */
  updateValueComponentCondition(columnIndex) {
    const dataAtCol = this.hot.getDataAtCol(columnIndex);
    const selectedValues = unifyColumnValues(dataAtCol);
    this.conditionUpdateObserver.updateStatesAtColumn(columnIndex, selectedValues);
  }
  /**
   * Restores components to its saved state.
   *
   * @private
   * @param {Array} components List of components.
   */
  restoreComponents(components) {
    var _this$getSelectedColu;
    const physicalIndex = (_this$getSelectedColu = this.getSelectedColumn()) === null || _this$getSelectedColu === void 0 ? void 0 : _this$getSelectedColu.physicalIndex;
    components.forEach((component) => {
      if (component.isHidden()) {
        return;
      }
      component.restoreState(physicalIndex);
    });
    this.updateDependentComponentsVisibility();
  }
  /**
   * After dropdown menu show listener.
   *
   * @private
   */
  onAfterDropdownMenuShow() {
    this.restoreComponents(Array.from(this.components.values()));
  }
  /**
   * After dropdown menu hide listener.
   *
   * @private
   */
  onAfterDropdownMenuHide() {
    this.components.get("filter_by_condition").getSelectElement().closeOptions();
    this.components.get("filter_by_condition2").getSelectElement().closeOptions();
  }
  /**
   * Before dropdown menu set menu items listener.
   *
   * @private
   */
  onBeforeDropdownMenuSetItems() {
    if (this.dropdownMenuPlugin) {
      this.dropdownMenuPlugin.menu.addLocalHook("afterOpen", () => {
        this.dropdownMenuPlugin.menu.hotMenu.updateSettings({
          hiddenRows: true
        });
      });
    }
  }
  /**
   * After dropdown menu default options listener.
   *
   * @private
   * @param {object} defaultOptions ContextMenu default item options.
   */
  onAfterDropdownMenuDefaultOptions(defaultOptions) {
    defaultOptions.items.push({
      name: KEY
    });
    this.components.forEach((component) => {
      defaultOptions.items.push(component.getMenuItemDescriptor());
    });
  }
  /**
   * Get an operation, based on the number and types of arguments (where arguments are states of components).
   *
   * @param {string} suggestedOperation Operation which was chosen by user from UI.
   * @param {object} byConditionState1 State of first condition component.
   * @param {object} byConditionState2 State of second condition component.
   * @param {object} byValueState State of value component.
   * @private
   * @returns {string}
   */
  getOperationBasedOnArguments(suggestedOperation, byConditionState1, byConditionState2, byValueState) {
    let operation = suggestedOperation;
    if (operation === OPERATION_ID2 && byConditionState1.command.key !== CONDITION_NAME && byConditionState2.command.key !== CONDITION_NAME && byValueState.command.key !== CONDITION_NAME) {
      operation = OPERATION_ID3;
    } else if (byValueState.command.key !== CONDITION_NAME) {
      if (byConditionState1.command.key === CONDITION_NAME || byConditionState2.command.key === CONDITION_NAME) {
        operation = OPERATION_ID;
      }
    }
    return operation;
  }
  /**
   * On action bar submit listener.
   *
   * @private
   * @param {string} submitType The submit type.
   */
  onActionBarSubmit(submitType) {
    var _this$dropdownMenuPlu3;
    if (submitType === "accept") {
      const selectedColumn = this.getSelectedColumn();
      if (selectedColumn === null) {
        var _this$dropdownMenuPlu2;
        (_this$dropdownMenuPlu2 = this.dropdownMenuPlugin) === null || _this$dropdownMenuPlu2 === void 0 || _this$dropdownMenuPlu2.close();
        return;
      }
      const {
        physicalIndex
      } = selectedColumn;
      const byConditionState1 = this.components.get("filter_by_condition").getState();
      const byConditionState2 = this.components.get("filter_by_condition2").getState();
      const byValueState = this.components.get("filter_by_value").getState();
      const operation = this.getOperationBasedOnArguments(this.components.get("filter_operators").getActiveOperationId(), byConditionState1, byConditionState2, byValueState);
      this.conditionUpdateObserver.groupChanges();
      let columnStackPosition = this.conditionCollection.getColumnStackPosition(physicalIndex);
      if (columnStackPosition === -1) {
        columnStackPosition = void 0;
      }
      this.conditionCollection.removeConditions(physicalIndex);
      if (byConditionState1.command.key !== CONDITION_NAME) {
        this.conditionCollection.addCondition(physicalIndex, byConditionState1, operation, columnStackPosition);
        if (byConditionState2.command.key !== CONDITION_NAME) {
          this.conditionCollection.addCondition(physicalIndex, byConditionState2, operation, columnStackPosition);
        }
      }
      if (byValueState.command.key !== CONDITION_NAME) {
        this.conditionCollection.addCondition(physicalIndex, byValueState, operation, columnStackPosition);
      }
      this.conditionUpdateObserver.flush();
      this.components.forEach((component) => component.saveState(physicalIndex));
      this.filtersRowsMap.clear();
      this.filter();
    }
    (_this$dropdownMenuPlu3 = this.dropdownMenuPlugin) === null || _this$dropdownMenuPlu3 === void 0 || _this$dropdownMenuPlu3.close();
  }
  /**
   * On component change listener.
   *
   * @private
   * @param {BaseComponent} component Component inheriting BaseComponent.
   * @param {object} command Menu item object (command).
   */
  onComponentChange(component, command) {
    this.updateDependentComponentsVisibility();
    if (component.constructor === condition_default && !command.inputsCount) {
      this.setListeningDropdownMenu();
    }
  }
  /**
   * On component SelectUI closed listener.
   *
   * @private
   */
  onSelectUIClosed() {
    this.setListeningDropdownMenu();
  }
  /**
   * Listen to the keyboard input on document body and forward events to instance of Handsontable
   * created by DropdownMenu plugin.
   *
   * @private
   */
  setListeningDropdownMenu() {
    if (this.dropdownMenuPlugin) {
      this.dropdownMenuPlugin.setListening();
    }
  }
  /**
   * Updates visibility of some of the components, based on the state of the parent component.
   *
   * @private
   */
  updateDependentComponentsVisibility() {
    const component = this.components.get("filter_by_condition");
    const {
      command
    } = component.getState();
    const componentsToShow = [this.components.get("filter_by_condition2"), this.components.get("filter_operators")];
    if (command.showOperators) {
      this.showComponents(...componentsToShow);
    } else {
      this.hideComponents(...componentsToShow);
    }
  }
  /**
   * On after get column header listener.
   *
   * @private
   * @param {number} col Visual column index.
   * @param {HTMLTableCellElement} TH Header's TH element.
   */
  onAfterGetColHeader(col, TH) {
    const physicalColumn = this.hot.toPhysicalColumn(col);
    if (this.enabled && this.conditionCollection.hasConditions(physicalColumn)) {
      addClass(TH, "htFiltersActive");
    } else {
      removeClass(TH, "htFiltersActive");
    }
  }
  /**
   * Creates DataFilter instance based on condition collection.
   *
   * @private
   * @param {ConditionCollection} conditionCollection Condition collection object.
   * @returns {DataFilter}
   */
  _createDataFilter() {
    let conditionCollection = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.conditionCollection;
    return new dataFilter_default(conditionCollection, (physicalColumn) => this.getDataMapAtColumn(physicalColumn));
  }
  /**
   * It updates the components state. The state is triggered by ConditionUpdateObserver, which
   * reacts to any condition added to the condition collection. It may be added through the UI
   * components or by API call.
   *
   * @private
   * @param {object} conditionsState An object with the state generated by UI components.
   */
  updateComponents(conditionsState) {
    var _this$dropdownMenuPlu4;
    if (!((_this$dropdownMenuPlu4 = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu4 !== void 0 && _this$dropdownMenuPlu4.enabled)) {
      return;
    }
    const {
      editedConditionStack: {
        conditions: conditions2,
        column
      }
    } = conditionsState;
    const conditionsByValue = conditions2.filter((condition24) => condition24.name === CONDITION_NAME21);
    const conditionsWithoutByValue = conditions2.filter((condition24) => condition24.name !== CONDITION_NAME21);
    if (conditionsByValue.length >= 2 || conditionsWithoutByValue.length >= 3) {
      warn2(toSingleLine`The filter conditions have been applied properly, but couldn’t be displayed visually.\x20
        The overall amount of conditions exceed the capability of the dropdown menu.\x20
        For more details see the documentation.`);
    } else {
      const operationType = this.conditionCollection.getOperation(column);
      this.components.get("filter_by_condition").updateState(conditionsWithoutByValue[0], column);
      this.components.get("filter_by_condition2").updateState(conditionsWithoutByValue[1], column);
      this.components.get("filter_operators").updateState(operationType, column);
      this.components.get("filter_by_value").updateState(conditionsState);
    }
  }
  /**
   * Returns indexes of passed components inside list of `dropdownMenu` items.
   *
   * @private
   * @param {...BaseComponent} components List of components.
   * @returns {Array}
   */
  getIndexesOfComponents() {
    const indexes = [];
    if (!this.dropdownMenuPlugin) {
      return indexes;
    }
    const menu = this.dropdownMenuPlugin.menu;
    for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {
      components[_key] = arguments[_key];
    }
    arrayEach(components, (component) => {
      arrayEach(menu.menuItems, (item, index2) => {
        if (item.key === component.getMenuItemDescriptor().key) {
          indexes.push(index2);
        }
      });
    });
    return indexes;
  }
  /**
   * Changes visibility of component.
   *
   * @private
   * @param {boolean} visible Determine if components should be visible.
   * @param {...BaseComponent} components List of components.
   */
  changeComponentsVisibility() {
    let visible = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (!this.dropdownMenuPlugin) {
      return;
    }
    const menu = this.dropdownMenuPlugin.menu;
    const hotMenu = menu.hotMenu;
    const hiddenRows = hotMenu.getPlugin("hiddenRows");
    for (var _len2 = arguments.length, components = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      components[_key2 - 1] = arguments[_key2];
    }
    const indexes = this.getIndexesOfComponents(...components);
    if (visible) {
      hiddenRows.showRows(indexes);
    } else {
      hiddenRows.hideRows(indexes);
    }
    hotMenu.render();
  }
  /**
   * Hides components of filters `dropdownMenu`.
   *
   * @private
   * @param {...BaseComponent} components List of components.
   */
  hideComponents() {
    for (var _len3 = arguments.length, components = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      components[_key3] = arguments[_key3];
    }
    this.changeComponentsVisibility(false, ...components);
  }
  /**
   * Shows components of filters `dropdownMenu`.
   *
   * @private
   * @param {...BaseComponent} components List of components.
   */
  showComponents() {
    for (var _len4 = arguments.length, components = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      components[_key4] = arguments[_key4];
    }
    this.changeComponentsVisibility(true, ...components);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    if (this.enabled) {
      this.components.forEach((component, key) => {
        if (component !== null) {
          component.destroy();
          this.components.set(key, null);
        }
      });
      this.conditionCollection.destroy();
      this.conditionUpdateObserver.destroy();
      this.hot.rowIndexMapper.unregisterMap(this.pluginName);
    }
    super.destroy();
  }
};

// node_modules/handsontable/plugins/formulas/engine/settings.mjs
var DEFAULT_LICENSE_KEY = "internal-use-in-handsontable";
var DEFAULT_SETTINGS = {
  licenseKey: DEFAULT_LICENSE_KEY,
  useArrayArithmetic: true,
  useColumnIndex: false,
  useStats: false,
  evaluateNullToZero: true,
  precisionEpsilon: 1e-13,
  precisionRounding: 14,
  smartRounding: true,
  leapYear1900: false,
  nullDate: {
    year: 1899,
    month: 12,
    day: 30
  },
  nullYear: 30,
  dateFormats: ["DD/MM/YYYY", "DD/MM/YY"],
  timeFormats: ["hh:mm", "hh:mm:ss.sss"],
  matchWholeCell: true,
  useRegularExpressions: false,
  useWildcards: true,
  functionArgSeparator: ",",
  thousandSeparator: "",
  decimalSeparator: ".",
  language: "enGB"
};
function getEngineSettingsOverrides(hotSettings) {
  var _hotSettings$PLUGIN_K;
  return {
    maxColumns: hotSettings.maxColumns,
    maxRows: hotSettings.maxRows,
    language: (_hotSettings$PLUGIN_K = hotSettings[PLUGIN_KEY17]) === null || _hotSettings$PLUGIN_K === void 0 || (_hotSettings$PLUGIN_K = _hotSettings$PLUGIN_K.language) === null || _hotSettings$PLUGIN_K === void 0 ? void 0 : _hotSettings$PLUGIN_K.langCode
  };
}
function cleanEngineSettings(pluginSettings) {
  return Object.keys(pluginSettings).reduce((obj, key) => {
    if (key !== "hyperformula") {
      obj[key] = pluginSettings[key];
    }
    return obj;
  }, {});
}
function getEngineSettingsWithDefaultsAndOverrides(hotSettings) {
  var _pluginSettings$engin;
  const pluginSettings = hotSettings[PLUGIN_KEY17];
  const userSettings = cleanEngineSettings(pluginSettings !== null && pluginSettings !== void 0 && (_pluginSettings$engin = pluginSettings.engine) !== null && _pluginSettings$engin !== void 0 && _pluginSettings$engin.hyperformula ? pluginSettings.engine : {});
  const overrides = getEngineSettingsOverrides(hotSettings);
  return {
    ...DEFAULT_SETTINGS,
    ...userSettings,
    ...overrides
  };
}
function getEngineSettingsWithOverrides(hotSettings) {
  var _pluginSettings$engin2;
  const pluginSettings = hotSettings[PLUGIN_KEY17];
  const userSettings = cleanEngineSettings(pluginSettings !== null && pluginSettings !== void 0 && (_pluginSettings$engin2 = pluginSettings.engine) !== null && _pluginSettings$engin2 !== void 0 && _pluginSettings$engin2.hyperformula ? pluginSettings.engine : {});
  const overrides = getEngineSettingsOverrides(hotSettings);
  return {
    ...userSettings,
    ...overrides
  };
}
function haveEngineSettingsChanged(currentEngineSettings, newEngineSettings) {
  return Object.keys(newEngineSettings).some((settingOption) => {
    return newEngineSettings[settingOption] !== void 0 && newEngineSettings[settingOption] !== currentEngineSettings[settingOption];
  });
}

// node_modules/handsontable/plugins/formulas/engine/register.mjs
function getEngineRelationshipRegistry() {
  const registryKey = "engine_relationship";
  const pluginStaticRegistry = staticRegister(PLUGIN_KEY17);
  if (!pluginStaticRegistry.hasItem(registryKey)) {
    pluginStaticRegistry.register(registryKey, /* @__PURE__ */ new Map());
  }
  return pluginStaticRegistry.getItem(registryKey);
}
function getSharedEngineUsageRegistry() {
  const registryKey = "shared_engine_usage";
  const pluginStaticRegistry = staticRegister(PLUGIN_KEY17);
  if (!pluginStaticRegistry.hasItem(registryKey)) {
    pluginStaticRegistry.register(registryKey, /* @__PURE__ */ new Map());
  }
  return pluginStaticRegistry.getItem(registryKey);
}
function setupEngine(hotInstance) {
  const hotSettings = hotInstance.getSettings();
  const pluginSettings = hotSettings[PLUGIN_KEY17];
  const engineConfigItem = pluginSettings === null || pluginSettings === void 0 ? void 0 : pluginSettings.engine;
  if (pluginSettings === true) {
    return null;
  }
  if (isUndefined2(engineConfigItem)) {
    return null;
  }
  if (typeof engineConfigItem.hyperformula === "function" || typeof engineConfigItem === "function") {
    var _engineConfigItem$hyp;
    return registerEngine((_engineConfigItem$hyp = engineConfigItem.hyperformula) !== null && _engineConfigItem$hyp !== void 0 ? _engineConfigItem$hyp : engineConfigItem, hotSettings, hotInstance);
  } else if (typeof engineConfigItem === "object" && isUndefined2(engineConfigItem.hyperformula)) {
    const engineRelationship = getEngineRelationshipRegistry();
    const sharedEngineUsage = getSharedEngineUsageRegistry().get(engineConfigItem);
    if (!engineRelationship.has(engineConfigItem)) {
      engineRelationship.set(engineConfigItem, []);
    }
    engineRelationship.get(engineConfigItem).push(hotInstance);
    if (sharedEngineUsage) {
      sharedEngineUsage.push(hotInstance.guid);
    }
    if (!engineConfigItem.getConfig().licenseKey) {
      engineConfigItem.updateConfig({
        licenseKey: DEFAULT_LICENSE_KEY
      });
    }
    if (engineConfigItem.getConfig().leapYear1900 !== DEFAULT_SETTINGS.leapYear1900 || isObjectEqual(engineConfigItem.getConfig().nullDate, DEFAULT_SETTINGS.nullDate) === false) {
      warn2(toSingleLine`If you use HyperFormula with Handsontable, keep the default \`leapYear1900\` and \`nullDate\` 
      settings. Otherwise, HyperFormula's dates may not sync correctly with Handsontable's dates.`);
    }
    return engineConfigItem;
  }
  return null;
}
function registerEngine(engineClass, hotSettings, hotInstance) {
  const pluginSettings = hotSettings[PLUGIN_KEY17];
  const engineSettings = getEngineSettingsWithDefaultsAndOverrides(hotSettings);
  const engineRegistry = getEngineRelationshipRegistry();
  const sharedEngineRegistry = getSharedEngineUsageRegistry();
  registerCustomFunctions(engineClass, pluginSettings.functions);
  registerLanguage(engineClass, pluginSettings.language);
  const engineInstance = engineClass.buildEmpty(engineSettings);
  engineRegistry.set(engineInstance, [hotInstance]);
  sharedEngineRegistry.set(engineInstance, [hotInstance.guid]);
  registerNamedExpressions(engineInstance, pluginSettings.namedExpressions);
  engineInstance.on("sheetAdded", () => {
    engineInstance.rebuildAndRecalculate();
  });
  engineInstance.on("sheetRemoved", () => {
    engineInstance.rebuildAndRecalculate();
  });
  return engineInstance;
}
function getRegisteredHotInstances(engine) {
  var _engineRegistry$get;
  const engineRegistry = getEngineRelationshipRegistry();
  const hotInstances = engineRegistry.size === 0 ? [] : Array.from((_engineRegistry$get = engineRegistry.get(engine)) !== null && _engineRegistry$get !== void 0 ? _engineRegistry$get : []);
  return new Map(hotInstances.map((hot) => [hot.getPlugin("formulas").sheetId, hot]));
}
function unregisterEngine(engine, hotInstance) {
  if (engine) {
    const engineRegistry = getEngineRelationshipRegistry();
    const engineHotRelationship = engineRegistry.get(engine);
    const sharedEngineRegistry = getSharedEngineUsageRegistry();
    const sharedEngineUsage = sharedEngineRegistry.get(engine);
    if (engineHotRelationship && engineHotRelationship.includes(hotInstance)) {
      engineHotRelationship.splice(engineHotRelationship.indexOf(hotInstance), 1);
      if (engineHotRelationship.length === 0) {
        engineRegistry.delete(engine);
      }
    }
    if (sharedEngineUsage && sharedEngineUsage.includes(hotInstance.guid)) {
      sharedEngineUsage.splice(sharedEngineUsage.indexOf(hotInstance.guid), 1);
      if (sharedEngineUsage.length === 0) {
        sharedEngineRegistry.delete(engine);
        engine.destroy();
      }
    }
  }
}
function registerCustomFunctions(engineClass, customFunctions) {
  if (customFunctions) {
    customFunctions.forEach((func) => {
      const {
        name,
        plugin,
        translations
      } = func;
      try {
        engineClass.registerFunction(name, plugin, translations);
      } catch (e) {
        warn2(e.message);
      }
    });
  }
}
function registerLanguage(engineClass, languageSetting) {
  if (languageSetting) {
    const {
      langCode
    } = languageSetting;
    try {
      engineClass.registerLanguage(langCode, languageSetting);
    } catch (e) {
      warn2(e.message);
    }
  }
}
function registerNamedExpressions(engineInstance, namedExpressions) {
  if (namedExpressions) {
    engineInstance.suspendEvaluation();
    namedExpressions.forEach((namedExp) => {
      const {
        name,
        expression,
        scope,
        options
      } = namedExp;
      try {
        engineInstance.addNamedExpression(name, expression, scope, options);
      } catch (e) {
        warn2(e.message);
      }
    });
    engineInstance.resumeEvaluation();
  }
}
function setupSheet(engineInstance, sheetName) {
  if (isUndefined2(sheetName) || !engineInstance.doesSheetExist(sheetName)) {
    sheetName = engineInstance.addSheet(sheetName);
  }
  return sheetName;
}

// node_modules/handsontable/plugins/formulas/utils.mjs
init_moment();
var DEFAULT_DATE_FORMAT_HYPERFORMULA = "DD/MM/YYYY";
function isEscapedFormulaExpression(expression) {
  return typeof expression === "string" && expression.charAt(0) === "'" && expression.charAt(1) === "=";
}
function unescapeFormulaExpression(expression) {
  return isEscapedFormulaExpression(expression) ? expression.substr(1) : expression;
}
function isFormula(value) {
  return typeof value === "string" && value.startsWith("=");
}
function isDate2(value, cellType) {
  return typeof value === "string" && cellType === "date";
}
function isDateValid(date, dateFormat) {
  return moment_default(date, dateFormat, true).isValid();
}
function getDateInHfFormat(date, dateFormat) {
  return moment_default(date, dateFormat, true).format(DEFAULT_DATE_FORMAT_HYPERFORMULA);
}
function getDateInHotFormat(date, dateFormat) {
  return moment_default(date, DEFAULT_DATE_FORMAT_HYPERFORMULA, true).format(dateFormat);
}
function getDateFromExcelDate(numericDate, dateFormat) {
  const dateOffset = -1;
  const dateForFormatting = new Date(Date.UTC(0, 0, numericDate + dateOffset));
  return moment_default(dateForFormatting).format(dateFormat);
}

// node_modules/handsontable/plugins/formulas/indexSyncer/axisSyncer.mjs
function _classPrivateFieldInitSpec9(obj, privateMap, value) {
  _checkPrivateRedeclaration10(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration10(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet9(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor9(receiver, privateMap, "get");
  return _classApplyDescriptorGet9(receiver, descriptor);
}
function _classApplyDescriptorGet9(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet9(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor9(receiver, privateMap, "set");
  _classApplyDescriptorSet9(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor9(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet9(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _axis = /* @__PURE__ */ new WeakMap();
var _indexMapper = /* @__PURE__ */ new WeakMap();
var _indexSyncer = /* @__PURE__ */ new WeakMap();
var _indexesSequence = /* @__PURE__ */ new WeakMap();
var _movedIndexes = /* @__PURE__ */ new WeakMap();
var _finalIndex = /* @__PURE__ */ new WeakMap();
var _removedIndexes = /* @__PURE__ */ new WeakMap();
var AxisSyncer = class {
  constructor(axis, indexMapper, indexSyncer) {
    _classPrivateFieldInitSpec9(this, _axis, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec9(this, _indexMapper, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec9(this, _indexSyncer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec9(this, _indexesSequence, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec9(this, _movedIndexes, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec9(this, _finalIndex, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec9(this, _removedIndexes, {
      writable: true,
      value: []
    });
    _classPrivateFieldSet9(this, _axis, axis);
    _classPrivateFieldSet9(this, _indexMapper, indexMapper);
    _classPrivateFieldSet9(this, _indexSyncer, indexSyncer);
  }
  /**
   * Sets removed HF indexes (it should be done right before performing move on HOT).
   *
   * @param {Array<number>} removedIndexes List of removed physical indexes.
   * @returns {Array<number>} List of removed visual indexes.
   */
  setRemovedHfIndexes(removedIndexes) {
    _classPrivateFieldSet9(this, _removedIndexes, removedIndexes.map((physicalIndex) => {
      const visualIndex = _classPrivateFieldGet9(this, _indexMapper).getVisualFromPhysicalIndex(physicalIndex);
      return this.getHfIndexFromVisualIndex(visualIndex);
    }));
    return _classPrivateFieldGet9(this, _removedIndexes);
  }
  /**
   * Gets removed HF indexes (right before performing removal on HOT).
   *
   * @returns {Array<number>} List of removed HF indexes.
   */
  getRemovedHfIndexes() {
    return _classPrivateFieldGet9(this, _removedIndexes);
  }
  /**
   * Gets corresponding HyperFormula index for particular visual index. It's respecting the idea that HF's engine
   * is fed also with trimmed indexes (business requirements for formula result calculation also for trimmed elements).
   *
   * @param {number} visualIndex Visual index.
   * @returns {number}
   */
  getHfIndexFromVisualIndex(visualIndex) {
    const indexesSequence = _classPrivateFieldGet9(this, _indexMapper).getIndexesSequence();
    const notTrimmedIndexes = _classPrivateFieldGet9(this, _indexMapper).getNotTrimmedIndexes();
    return indexesSequence.indexOf(notTrimmedIndexes[visualIndex]);
  }
  /**
   * Synchronizes moves done on HOT to HF engine (based on previously calculated positions).
   *
   * @private
   * @param {Array<{from: number, to: number}>} moves Calculated HF's move positions.
   */
  syncMoves(moves) {
    const NUMBER_OF_MOVED_INDEXES = 1;
    const SYNC_MOVE_METHOD_NAME = `move${toUpperCaseFirst(_classPrivateFieldGet9(this, _axis))}s`;
    _classPrivateFieldGet9(this, _indexSyncer).getEngine().batch(() => {
      moves.forEach((move) => {
        const moveToTheSamePosition = move.from !== move.to;
        const anotherMoveWithoutEffect = move.from + 1 !== move.to;
        if (moveToTheSamePosition && anotherMoveWithoutEffect) {
          _classPrivateFieldGet9(this, _indexSyncer).getEngine()[SYNC_MOVE_METHOD_NAME](_classPrivateFieldGet9(this, _indexSyncer).getSheetId(), move.from, NUMBER_OF_MOVED_INDEXES, move.to);
        }
      });
    });
  }
  /**
   * Stores information about performed HOT moves for purpose of calculating where to move HF elements.
   *
   * @param {Array<number>} movedVisualIndexes Sequence of moved visual indexes for certain axis.
   * @param {number} visualFinalIndex Final visual place where to move HOT indexes.
   * @param {boolean} movePossible Indicates if it's possible to move HOT indexes to the desired position.
   */
  storeMovesInformation(movedVisualIndexes, visualFinalIndex, movePossible) {
    if (movePossible === false) {
      return;
    }
    _classPrivateFieldSet9(this, _movedIndexes, movedVisualIndexes.map((index2) => this.getHfIndexFromVisualIndex(index2)));
    _classPrivateFieldSet9(this, _finalIndex, this.getHfIndexFromVisualIndex(visualFinalIndex));
  }
  /**
   * Gets first position where to move element (respecting the fact that some element will be sooner or later
   * taken out of the dataset in order to move them).
   *
   * @param {Array<number>} movedHfIndexes Sequence of moved HF indexes for certain axis.
   * @param {number} finalHfIndex Final HF place where to move rows.
   * @returns {number} HF's index informing where to move the first element.
   * @private
   */
  getMoveLine(movedHfIndexes, finalHfIndex) {
    const numberOfElements = _classPrivateFieldGet9(this, _indexMapper).getNumberOfIndexes();
    const notMovedElements = Array.from(Array(numberOfElements).keys()).filter((index2) => movedHfIndexes.includes(index2) === false);
    if (finalHfIndex === 0) {
      var _notMovedElements$fin;
      return (_notMovedElements$fin = notMovedElements[finalHfIndex]) !== null && _notMovedElements$fin !== void 0 ? _notMovedElements$fin : 0;
    }
    return notMovedElements[finalHfIndex - 1] + 1;
  }
  /**
   * Gets initially calculated HF's move positions.
   *
   * @private
   * @param {Array<number>} movedHfIndexes Sequence of moved HF indexes for certain axis.
   * @param {number} finalHfIndex Final HF place where to move rows.
   * @returns {Array<{from: number, to: number}>} Initially calculated HF's move positions.
   */
  getInitiallyCalculatedMoves(movedHfIndexes, finalHfIndex) {
    let moveLine = this.getMoveLine(movedHfIndexes, finalHfIndex);
    const moves = [];
    movedHfIndexes.forEach((movedHfIndex) => {
      const move = {
        from: movedHfIndex,
        to: moveLine
      };
      moves.forEach((previouslyMovedIndex) => {
        const isMovingFromEndToStart = previouslyMovedIndex.from > previouslyMovedIndex.to;
        const isMovingElementBefore = previouslyMovedIndex.to <= move.from;
        const isMovingAfterElement = previouslyMovedIndex.from > move.from;
        if (isMovingAfterElement && isMovingElementBefore && isMovingFromEndToStart) {
          move.from += 1;
        }
      });
      if (move.from >= moveLine) {
        moveLine += 1;
      }
      moves.push(move);
    });
    return moves;
  }
  /**
   * Gets finally calculated HF's move positions (after adjusting).
   *
   * @private
   * @param {Array<{from: number, to: number}>} moves Initially calculated HF's move positions.
   * @returns {Array<{from: number, to: number}>} Finally calculated HF's move positions (after adjusting).
   */
  adjustedCalculatedMoves(moves) {
    moves.forEach((move, index2) => {
      const nextMoved = moves.slice(index2 + 1);
      nextMoved.forEach((nextMovedIndex) => {
        const isMovingFromStartToEnd = nextMovedIndex.from < nextMovedIndex.to;
        if (nextMovedIndex.from > move.from && isMovingFromStartToEnd) {
          nextMovedIndex.from -= 1;
        }
      });
    });
    return moves;
  }
  /**
   * Calculating where to move HF elements and performing already calculated moves.
   *
   * @param {boolean} movePossible Indicates if it was possible to move HOT indexes to the desired position.
   * @param {boolean} orderChanged Indicates if order of HOT indexes was changed by move.
   */
  calculateAndSyncMoves(movePossible, orderChanged) {
    if (_classPrivateFieldGet9(this, _indexSyncer).isPerformingUndoRedo()) {
      return;
    }
    if (movePossible === false || orderChanged === false) {
      return;
    }
    const calculatedMoves = this.adjustedCalculatedMoves(this.getInitiallyCalculatedMoves(_classPrivateFieldGet9(this, _movedIndexes), _classPrivateFieldGet9(this, _finalIndex)));
    if (_classPrivateFieldGet9(this, _indexSyncer).getSheetId() === null) {
      _classPrivateFieldGet9(this, _indexSyncer).getPostponeAction(() => this.syncMoves(calculatedMoves));
    } else {
      this.syncMoves(calculatedMoves);
    }
  }
  /**
   * Gets callback for hook triggered after performing change of indexes order.
   *
   * @returns {Function}
   */
  getIndexesChangeSyncMethod() {
    const SYNC_ORDER_CHANGE_METHOD_NAME = `set${toUpperCaseFirst(_classPrivateFieldGet9(this, _axis))}Order`;
    return (source) => {
      if (_classPrivateFieldGet9(this, _indexSyncer).isPerformingUndoRedo()) {
        return;
      }
      const newSequence = _classPrivateFieldGet9(this, _indexMapper).getIndexesSequence();
      if (source === "update") {
        const relativeTransformation = _classPrivateFieldGet9(this, _indexesSequence).map((index2) => newSequence.indexOf(index2));
        const sheetDimensions = _classPrivateFieldGet9(this, _indexSyncer).getEngine().getSheetDimensions(_classPrivateFieldGet9(this, _indexSyncer).getSheetId());
        let sizeForAxis;
        if (_classPrivateFieldGet9(this, _axis) === "row") {
          sizeForAxis = sheetDimensions.height;
        } else {
          sizeForAxis = sheetDimensions.width;
        }
        const numberOfReorganisedIndexes = relativeTransformation.length;
        for (let i = numberOfReorganisedIndexes; i < sizeForAxis; i += 1) {
          relativeTransformation.push(i);
        }
        _classPrivateFieldGet9(this, _indexSyncer).getEngine()[SYNC_ORDER_CHANGE_METHOD_NAME](_classPrivateFieldGet9(this, _indexSyncer).getSheetId(), relativeTransformation);
      }
      _classPrivateFieldSet9(this, _indexesSequence, newSequence);
    };
  }
  /**
   * Initialize the AxisSyncer.
   */
  init() {
    _classPrivateFieldSet9(this, _indexesSequence, _classPrivateFieldGet9(this, _indexMapper).getIndexesSequence());
  }
};
var axisSyncer_default = AxisSyncer;

// node_modules/handsontable/plugins/formulas/indexSyncer/index.mjs
function _classPrivateFieldInitSpec10(obj, privateMap, value) {
  _checkPrivateRedeclaration11(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration11(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet10(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor10(receiver, privateMap, "get");
  return _classApplyDescriptorGet10(receiver, descriptor);
}
function _classApplyDescriptorGet10(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet10(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor10(receiver, privateMap, "set");
  _classApplyDescriptorSet10(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor10(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet10(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _rowIndexSyncer = /* @__PURE__ */ new WeakMap();
var _columnIndexSyncer = /* @__PURE__ */ new WeakMap();
var _postponeAction = /* @__PURE__ */ new WeakMap();
var _isPerformingUndo = /* @__PURE__ */ new WeakMap();
var _isPerformingRedo = /* @__PURE__ */ new WeakMap();
var _engine = /* @__PURE__ */ new WeakMap();
var _sheetId = /* @__PURE__ */ new WeakMap();
var IndexSyncer = class {
  constructor(rowIndexMapper, columnIndexMapper, postponeAction) {
    _classPrivateFieldInitSpec10(this, _rowIndexSyncer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec10(this, _columnIndexSyncer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec10(this, _postponeAction, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec10(this, _isPerformingUndo, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec10(this, _isPerformingRedo, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec10(this, _engine, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec10(this, _sheetId, {
      writable: true,
      value: null
    });
    _classPrivateFieldSet10(this, _rowIndexSyncer, new axisSyncer_default("row", rowIndexMapper, this));
    _classPrivateFieldSet10(this, _columnIndexSyncer, new axisSyncer_default("column", columnIndexMapper, this));
    _classPrivateFieldSet10(this, _postponeAction, postponeAction);
  }
  /**
   * Gets index synchronizer for a particular axis.
   *
   * @param {'row'|'column'} indexType Type of indexes.
   * @returns {AxisSyncer}
   */
  getForAxis(indexType) {
    if (indexType === "row") {
      return _classPrivateFieldGet10(this, _rowIndexSyncer);
    }
    return _classPrivateFieldGet10(this, _columnIndexSyncer);
  }
  /**
   * Sets flag informing whether an undo action is already performed (we don't execute synchronization in such case).
   *
   * @param {boolean} flagValue Boolean value for the flag.
   */
  setPerformUndo(flagValue) {
    _classPrivateFieldSet10(this, _isPerformingUndo, flagValue);
  }
  /**
   * Sets flag informing whether a redo action is already performed (we don't execute synchronization in such case).
   *
   * @param {boolean} flagValue Boolean value for the flag.
   */
  setPerformRedo(flagValue) {
    _classPrivateFieldSet10(this, _isPerformingRedo, flagValue);
  }
  /**
   * Gets information whether redo or undo action is already performed (we don't execute synchronization in such case).
   *
   * @private
   * @returns {boolean}
   */
  isPerformingUndoRedo() {
    return _classPrivateFieldGet10(this, _isPerformingUndo) || _classPrivateFieldGet10(this, _isPerformingRedo);
  }
  /**
   * Gets HyperFormula's sheet id.
   *
   * @returns {string|null}
   */
  getSheetId() {
    return _classPrivateFieldGet10(this, _sheetId);
  }
  /**
   * Gets engine instance that will be used for handled instance of Handsontable.
   *
   * @type {HyperFormula|null}
   */
  getEngine() {
    return _classPrivateFieldGet10(this, _engine);
  }
  /**
   * Gets method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).
   *
   * @returns {Function}
   */
  getPostponeAction() {
    return _classPrivateFieldGet10(this, _postponeAction);
  }
  /**
   * Setups a synchronization endpoint.
   *
   * @param {HyperFormula|null} engine The HF's engine instance which will be synced.
   * @param {string|null} sheetId HyperFormula's sheet name.
   */
  setupSyncEndpoint(engine, sheetId) {
    _classPrivateFieldSet10(this, _engine, engine);
    _classPrivateFieldSet10(this, _sheetId, sheetId);
    _classPrivateFieldGet10(this, _rowIndexSyncer).init();
    _classPrivateFieldGet10(this, _columnIndexSyncer).init();
  }
};
var indexSyncer_default = IndexSyncer;

// node_modules/handsontable/plugins/formulas/formulas.mjs
function _defineProperty20(obj, key, value) {
  key = _toPropertyKey20(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey20(arg) {
  var key = _toPrimitive20(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive20(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldInitSpec11(obj, privateMap, value) {
  _checkPrivateRedeclaration12(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration12(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet11(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor11(receiver, privateMap, "set");
  _classApplyDescriptorSet11(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet11(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet11(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor11(receiver, privateMap, "get");
  return _classApplyDescriptorGet11(receiver, descriptor);
}
function _classExtractFieldDescriptor11(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet11(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var PLUGIN_KEY17 = "formulas";
var SETTING_KEYS4 = ["maxRows", "maxColumns", "language"];
var PLUGIN_PRIORITY16 = 260;
pluginHooks_default.getSingleton().register("afterNamedExpressionAdded");
pluginHooks_default.getSingleton().register("afterNamedExpressionRemoved");
pluginHooks_default.getSingleton().register("afterSheetAdded");
pluginHooks_default.getSingleton().register("afterSheetRemoved");
pluginHooks_default.getSingleton().register("afterSheetRenamed");
pluginHooks_default.getSingleton().register("afterFormulasValuesUpdate");
var isBlockedSource = (source) => source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto";
var _internalOperationPending = /* @__PURE__ */ new WeakMap();
var _hotWasInitializedWithEmptyData = /* @__PURE__ */ new WeakMap();
var _engineListeners = /* @__PURE__ */ new WeakMap();
var Formulas = class extends BasePlugin {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _classPrivateFieldInitSpec11(this, _internalOperationPending, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec11(this, _hotWasInitializedWithEmptyData, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec11(this, _engineListeners, {
      writable: true,
      value: [["valuesUpdated", function() {
        return _this.onEngineValuesUpdated(...arguments);
      }], ["namedExpressionAdded", function() {
        return _this.onEngineNamedExpressionsAdded(...arguments);
      }], ["namedExpressionRemoved", function() {
        return _this.onEngineNamedExpressionsRemoved(...arguments);
      }], ["sheetAdded", function() {
        return _this.onEngineSheetAdded(...arguments);
      }], ["sheetRenamed", function() {
        return _this.onEngineSheetRenamed(...arguments);
      }], ["sheetRemoved", function() {
        return _this.onEngineSheetRemoved(...arguments);
      }]]
    });
    _defineProperty20(this, "staticRegister", staticRegister("formulas"));
    _defineProperty20(this, "engine", null);
    _defineProperty20(this, "sheetName", null);
    _defineProperty20(this, "indexSyncer", null);
    _defineProperty20(this, "rowAxisSyncer", null);
    _defineProperty20(this, "columnAxisSyncer", null);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY17;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY16;
  }
  static get SETTING_KEYS() {
    return [PLUGIN_KEY17, ...SETTING_KEYS4];
  }
  /**
   * HyperFormula's sheet id.
   *
   * @type {number|null}
   */
  get sheetId() {
    return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY17] ? true : false;
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _setupEngine, _this2 = this;
    if (this.enabled) {
      return;
    }
    this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;
    if (!this.engine) {
      warn2("Missing the required `engine` key in the Formulas settings. Please fill it with either an engine class or an engine instance.");
      return;
    }
    if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {
      const newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());
      if (newSheetName !== false) {
        this.sheetName = newSheetName;
      }
    }
    this.addHook("beforeLoadData", function() {
      return _this2.onBeforeLoadData(...arguments);
    });
    this.addHook("afterLoadData", function() {
      return _this2.onAfterLoadData(...arguments);
    });
    this.addHook("beforeUpdateData", function() {
      return _this2.onBeforeLoadData(...arguments);
    });
    this.addHook("afterUpdateData", function() {
      return _this2.onAfterLoadData(...arguments);
    });
    this.addHook("modifyData", function() {
      return _this2.onModifyData(...arguments);
    });
    this.addHook("modifySourceData", function() {
      return _this2.onModifySourceData(...arguments);
    });
    this.addHook("beforeValidate", function() {
      return _this2.onBeforeValidate(...arguments);
    });
    this.addHook("afterSetSourceDataAtCell", function() {
      return _this2.onAfterSetSourceDataAtCell(...arguments);
    });
    this.addHook("afterSetDataAtCell", function() {
      return _this2.onAfterSetDataAtCell(...arguments);
    });
    this.addHook("afterSetDataAtRowProp", function() {
      return _this2.onAfterSetDataAtCell(...arguments);
    });
    this.addHook("beforeCreateRow", function() {
      return _this2.onBeforeCreateRow(...arguments);
    });
    this.addHook("beforeCreateCol", function() {
      return _this2.onBeforeCreateCol(...arguments);
    });
    this.addHook("afterCreateRow", function() {
      return _this2.onAfterCreateRow(...arguments);
    });
    this.addHook("afterCreateCol", function() {
      return _this2.onAfterCreateCol(...arguments);
    });
    this.addHook("beforeRemoveRow", function() {
      return _this2.onBeforeRemoveRow(...arguments);
    });
    this.addHook("beforeRemoveCol", function() {
      return _this2.onBeforeRemoveCol(...arguments);
    });
    this.addHook("afterRemoveRow", function() {
      return _this2.onAfterRemoveRow(...arguments);
    });
    this.addHook("afterRemoveCol", function() {
      return _this2.onAfterRemoveCol(...arguments);
    });
    this.indexSyncer = new indexSyncer_default(this.hot.rowIndexMapper, this.hot.columnIndexMapper, (postponedAction) => {
      this.hot.addHookOnce("init", () => {
        postponedAction();
      });
    });
    this.rowAxisSyncer = this.indexSyncer.getForAxis("row");
    this.columnAxisSyncer = this.indexSyncer.getForAxis("column");
    this.hot.addHook("afterRowSequenceChange", this.rowAxisSyncer.getIndexesChangeSyncMethod());
    this.hot.addHook("afterColumnSequenceChange", this.columnAxisSyncer.getIndexesChangeSyncMethod());
    this.hot.addHook("beforeRowMove", (movedRows, finalIndex, _, movePossible) => {
      this.rowAxisSyncer.storeMovesInformation(movedRows, finalIndex, movePossible);
    });
    this.hot.addHook("beforeColumnMove", (movedColumns, finalIndex, _, movePossible) => {
      this.columnAxisSyncer.storeMovesInformation(movedColumns, finalIndex, movePossible);
    });
    this.hot.addHook("afterRowMove", (movedRows, finalIndex, dropIndex, movePossible, orderChanged) => {
      this.rowAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);
    });
    this.hot.addHook("afterColumnMove", (movedColumns, finalIndex, dropIndex, movePossible, orderChanged) => {
      this.columnAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);
    });
    this.hot.addHook("beforeColumnFreeze", (column, freezePerformed) => {
      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart, freezePerformed);
    });
    this.hot.addHook("afterColumnFreeze", (_, freezePerformed) => {
      this.columnAxisSyncer.calculateAndSyncMoves(freezePerformed, freezePerformed);
    });
    this.hot.addHook("beforeColumnUnfreeze", (column, unfreezePerformed) => {
      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart - 1, unfreezePerformed);
    });
    this.hot.addHook("afterColumnUnfreeze", (_, unfreezePerformed) => {
      this.columnAxisSyncer.calculateAndSyncMoves(unfreezePerformed, unfreezePerformed);
    });
    this.addHook("afterCellMetaReset", function() {
      return _this2.onAfterCellMetaReset(...arguments);
    });
    this.addHook("beforeUndo", () => {
      this.indexSyncer.setPerformUndo(true);
      this.engine.undo();
    });
    this.addHook("beforeRedo", () => {
      this.indexSyncer.setPerformRedo(true);
      this.engine.redo();
    });
    this.addHook("afterUndo", () => {
      this.indexSyncer.setPerformUndo(false);
    });
    this.addHook("afterUndo", () => {
      this.indexSyncer.setPerformRedo(false);
    });
    this.addHook("afterDetachChild", function() {
      return _this2.onAfterDetachChild(...arguments);
    });
    this.addHook("beforeAutofill", function() {
      return _this2.onBeforeAutofill(...arguments);
    });
    _classPrivateFieldGet11(this, _engineListeners).forEach((_ref2) => {
      let [eventName, listener] = _ref2;
      return this.engine.on(eventName, listener);
    });
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    _classPrivateFieldGet11(this, _engineListeners).forEach((_ref2) => {
      let [eventName, listener] = _ref2;
      return this.engine.off(eventName, listener);
    });
    unregisterEngine(this.engine, this.hot);
    this.engine = null;
    super.disablePlugin();
  }
  /**
   * Triggered on `updateSettings`.
   *
   * @private
   * @param {object} newSettings New set of settings passed to the `updateSettings` method.
   */
  updatePlugin(newSettings) {
    const newEngineSettings = getEngineSettingsWithOverrides(this.hot.getSettings());
    if (haveEngineSettingsChanged(this.engine.getConfig(), newEngineSettings)) {
      this.engine.updateConfig(newEngineSettings);
    }
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY17];
    if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {
      this.switchSheet(pluginSettings.sheetName);
    }
    if (!newSettings.data && this.sheetName === null) {
      const sheetName = this.hot.getSettings()[PLUGIN_KEY17].sheetName;
      if (sheetName && this.engine.doesSheetExist(sheetName)) {
        this.switchSheet(this.sheetName);
      } else {
        this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());
      }
    }
    super.updatePlugin(newSettings);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldGet11(this, _engineListeners).forEach((_ref3) => {
      var _this$engine;
      let [eventName, listener] = _ref3;
      return (_this$engine = this.engine) === null || _this$engine === void 0 ? void 0 : _this$engine.off(eventName, listener);
    });
    _classPrivateFieldSet11(this, _engineListeners, null);
    unregisterEngine(this.engine, this.hot);
    this.engine = null;
    super.destroy();
  }
  /**
   * Add a sheet to the shared HyperFormula instance.
   *
   * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be
   * auto-generated by HyperFormula.
   * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of
   * arrays - array of objects is not supported in this scenario.
   * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the
   * engine, the created sheet name otherwise.
   */
  addSheet(sheetName, sheetData) {
    if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {
      warn2("The provided data should be an array of arrays.");
      return false;
    }
    if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {
      warn2("Sheet with the provided name already exists.");
      return false;
    }
    try {
      const actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);
      if (sheetData) {
        this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);
      }
      return actualSheetName;
    } catch (e) {
      warn2(e.message);
      return false;
    }
  }
  /**
   * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula
   * instance).
   *
   * @param {string} sheetName Sheet name used in the shared HyperFormula instance.
   */
  switchSheet(sheetName) {
    if (!this.engine.doesSheetExist(sheetName)) {
      error(`The sheet named \`${sheetName}\` does not exist, switch aborted.`);
      return;
    }
    this.sheetName = sheetName;
    const serialized = this.engine.getSheetSerialized(this.sheetId);
    if (serialized.length > 0) {
      this.hot.loadData(serialized, `${toUpperCaseFirst(PLUGIN_KEY17)}.switchSheet`);
    }
  }
  /**
   * Get the cell type under specified visual coordinates.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {number} [sheet] The target sheet id, defaults to the current sheet.
   * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.
   */
  getCellType(row, column) {
    let sheet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.sheetId;
    const physicalRow = this.hot.toPhysicalRow(row);
    const physicalColumn = this.hot.toPhysicalColumn(column);
    if (physicalRow !== null && physicalColumn !== null) {
      return this.engine.getCellType({
        sheet,
        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),
        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)
      });
    } else {
      return "EMPTY";
    }
  }
  /**
   * Returns `true` if under specified visual coordinates is formula.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {number} [sheet] The target sheet id, defaults to the current sheet.
   * @returns {boolean}
   */
  isFormulaCellType(row, column) {
    let sheet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.sheetId;
    return this.engine.doesCellHaveFormula({
      sheet,
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)
    });
  }
  /**
   * Renders dependent sheets (handsontable instances) based on the changes - list of the
   * recalculated dependent cells.
   *
   * @private
   * @param {object[]} dependentCells The values and location of applied changes within HF engine.
   * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.
   */
  renderDependentSheets(dependentCells) {
    let renderSelf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const affectedSheetIds = /* @__PURE__ */ new Set();
    dependentCells.forEach((change) => {
      var _change$address;
      const sheetId = change === null || change === void 0 || (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;
      if (sheetId !== void 0) {
        if (!affectedSheetIds.has(sheetId)) {
          affectedSheetIds.add(sheetId);
        }
      }
    });
    getRegisteredHotInstances(this.engine).forEach((relatedHot, sheetId) => {
      if ((renderSelf || sheetId !== this.sheetId) && affectedSheetIds.has(sheetId)) {
        var _relatedHot$view;
        relatedHot.render();
        (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 || _relatedHot$view.adjustElementsSize();
      }
    });
  }
  /**
   * Validates dependent cells based on the cells that are modified by the change.
   *
   * @private
   * @param {object[]} dependentCells The values and location of applied changes within HF engine.
   * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).
   */
  validateDependentCells(dependentCells) {
    let changedCells = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const stringifyAddress = (change) => {
      var _change$address2;
      const {
        row,
        col,
        sheet
      } = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {};
      return isDefined(sheet) ? `${sheet}:${row}x${col}` : "";
    };
    const changedCellsSet = new Set(changedCells.map((change) => stringifyAddress(change)));
    dependentCells.forEach((change) => {
      var _change$address3, _change$address4;
      const {
        row,
        col
      } = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {};
      if (isDefined(row) === false || isDefined(col) === false || row >= this.hot.countRows() || col >= this.hot.countCols()) {
        return;
      }
      const sheetId = change === null || change === void 0 || (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;
      const addressId = stringifyAddress(change);
      if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {
        const boundHot = getRegisteredHotInstances(this.engine).get(sheetId);
        if (!boundHot) {
          return;
        }
        boundHot.validateCell(boundHot.getDataAtCell(row, col), boundHot.getCellMeta(row, col), () => {
        });
      }
    });
  }
  /**
   * Sync a change from the change-related hooks with the engine.
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {Handsontable.CellValue} newValue New value.
   * @returns {Array} Array of changes exported from the engine.
   */
  syncChangeWithEngine(row, column, newValue) {
    const address = {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column),
      sheet: this.sheetId
    };
    if (!this.engine.isItPossibleToSetCellContents(address)) {
      warn2(`Not possible to set cell data at ${JSON.stringify(address)}`);
      return;
    }
    const cellMeta = this.hot.getCellMeta(row, column);
    if (isDate2(newValue, cellMeta.type)) {
      if (isDateValid(newValue, cellMeta.dateFormat)) {
        newValue = getDateInHfFormat(newValue, cellMeta.dateFormat);
      } else if (isFormula(newValue) === false) {
        newValue = `'${newValue}`;
      }
    }
    return this.engine.setCellContents(address, newValue);
  }
  /**
   * The hook allows to translate the formula value to calculated value before it goes to the
   * validator function.
   *
   * @private
   * @param {*} value The cell value to validate.
   * @param {number} visualRow The visual row index.
   * @param {number|string} prop The visual column index or property name of the column.
   * @returns {*} Returns value to validate.
   */
  onBeforeValidate(value, visualRow, prop) {
    const visualColumn = this.hot.propToCol(prop);
    if (this.isFormulaCellType(visualRow, visualColumn)) {
      const address = {
        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
        sheet: this.sheetId
      };
      const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);
      let cellValue = this.engine.getCellValue(address);
      if (cellMeta.type === "date" && isNumeric(cellValue)) {
        cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);
      }
      return typeof cellValue === "object" && cellValue !== null ? cellValue.value : cellValue;
    }
    return value;
  }
  /**
   * `onBeforeAutofill` hook callback.
   *
   * @private
   * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used
   * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.
   * @param {CellRange} sourceRange The range values will be filled from.
   * @param {CellRange} targetRange The range new values will be filled into.
   * @returns {boolean|*}
   */
  onBeforeAutofill(fillData, sourceRange, targetRange) {
    const {
      row: sourceTopStartRow,
      col: sourceTopStartColumn
    } = sourceRange.getTopStartCorner();
    const {
      row: sourceBottomEndRow,
      col: sourceBottomEndColumn
    } = sourceRange.getBottomEndCorner();
    const {
      row: targetTopStartRow,
      col: targetTopStartColumn
    } = targetRange.getTopStartCorner();
    const {
      row: targetBottomEndRow,
      col: targetBottomEndColumn
    } = targetRange.getBottomEndCorner();
    const engineSourceRange = {
      start: {
        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartRow),
        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartColumn),
        sheet: this.sheetId
      },
      end: {
        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndRow),
        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndColumn),
        sheet: this.sheetId
      }
    };
    const engineTargetRange = {
      start: {
        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetTopStartRow),
        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetTopStartColumn),
        sheet: this.sheetId
      },
      end: {
        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndRow),
        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndColumn),
        sheet: this.sheetId
      }
    };
    if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {
      return false;
    }
    const fillRangeData = this.engine.getFillRangeData(engineSourceRange, engineTargetRange);
    const {
      row: sourceStartRow,
      col: sourceStartColumn
    } = engineSourceRange.start;
    const {
      row: sourceEndRow,
      col: sourceEndColumn
    } = engineSourceRange.end;
    const populationRowLength = sourceEndRow - sourceStartRow + 1;
    const populationColumnLength = sourceEndColumn - sourceStartColumn + 1;
    for (let populatedRowIndex = 0; populatedRowIndex < fillRangeData.length; populatedRowIndex += 1) {
      for (let populatedColumnIndex = 0; populatedColumnIndex < fillRangeData[populatedRowIndex].length; populatedColumnIndex += 1) {
        const populatedValue = fillRangeData[populatedRowIndex][populatedColumnIndex];
        const sourceRow = populatedRowIndex % populationRowLength;
        const sourceColumn = populatedColumnIndex % populationColumnLength;
        const sourceCellMeta = this.hot.getCellMeta(sourceRow, sourceColumn);
        if (isDate2(populatedValue, sourceCellMeta.type)) {
          if (populatedValue.startsWith("'")) {
            fillRangeData[populatedRowIndex][populatedColumnIndex] = populatedValue.slice(1);
          } else if (this.isFormulaCellType(sourceRow, sourceColumn, this.sheetId) === false) {
            fillRangeData[populatedRowIndex][populatedColumnIndex] = getDateInHotFormat(populatedValue, sourceCellMeta.dateFormat);
          }
        }
      }
    }
    return fillRangeData;
  }
  /**
   * `beforeLoadData` hook callback.
   *
   * @param {Array} sourceData Array of arrays or array of objects containing data.
   * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.
   * @param {string} [source] Source of the call.
   * @private
   */
  onBeforeLoadData(sourceData, initialLoad) {
    let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    if (source.includes(toUpperCaseFirst(PLUGIN_KEY17))) {
      return;
    }
    _classPrivateFieldSet11(this, _hotWasInitializedWithEmptyData, isUndefined2(this.hot.getSettings().data));
  }
  /**
   * Callback to `afterCellMetaReset` hook which is triggered after setting cell meta.
   *
   * @private
   */
  onAfterCellMetaReset() {
    const sourceDataArray = this.hot.getSourceDataArray();
    let valueChanged = false;
    sourceDataArray.forEach((rowData, rowIndex) => {
      rowData.forEach((cellValue, columnIndex) => {
        const cellMeta = this.hot.getCellMeta(rowIndex, columnIndex);
        const dateFormat = cellMeta.dateFormat;
        if (isDate2(cellValue, cellMeta.type)) {
          valueChanged = true;
          if (isDateValid(cellValue, dateFormat)) {
            sourceDataArray[rowIndex][columnIndex] = getDateInHfFormat(cellValue, dateFormat);
          } else if (this.isFormulaCellType(rowIndex, columnIndex) === false) {
            sourceDataArray[rowIndex][columnIndex] = `'${cellValue}`;
          }
        }
      });
    });
    if (valueChanged === true) {
      _classPrivateFieldSet11(this, _internalOperationPending, true);
      this.engine.setSheetContent(this.sheetId, sourceDataArray);
      _classPrivateFieldSet11(this, _internalOperationPending, false);
    }
  }
  /**
   * `afterLoadData` hook callback.
   *
   * @param {Array} sourceData Array of arrays or array of objects containing data.
   * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.
   * @param {string} [source] Source of the call.
   * @private
   */
  onAfterLoadData(sourceData, initialLoad) {
    let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    if (source.includes(toUpperCaseFirst(PLUGIN_KEY17))) {
      return;
    }
    this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY17].sheetName);
    if (!_classPrivateFieldGet11(this, _hotWasInitializedWithEmptyData)) {
      const sourceDataArray = this.hot.getSourceDataArray();
      if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {
        _classPrivateFieldSet11(this, _internalOperationPending, true);
        const dependentCells = this.engine.setSheetContent(this.sheetId, sourceDataArray);
        this.indexSyncer.setupSyncEndpoint(this.engine, this.sheetId);
        this.renderDependentSheets(dependentCells);
        _classPrivateFieldSet11(this, _internalOperationPending, false);
      }
    } else {
      this.switchSheet(this.sheetName);
    }
  }
  /**
   * `modifyData` hook callback.
   *
   * @private
   * @param {number} physicalRow Physical row index.
   * @param {number} visualColumn Visual column index.
   * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`
   *   property.
   * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
   */
  onModifyData(physicalRow, visualColumn, valueHolder, ioMode) {
    if (ioMode !== "get" || _classPrivateFieldGet11(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {
      return;
    }
    const visualRow = this.hot.toVisualRow(physicalRow);
    if (visualRow === null || visualColumn === null) {
      return;
    }
    const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);
    if (!isFormulaCellType) {
      const cellType = this.getCellType(visualRow, visualColumn);
      if (cellType !== "ARRAY") {
        if (isEscapedFormulaExpression(valueHolder.value)) {
          valueHolder.value = unescapeFormulaExpression(valueHolder.value);
        }
        return;
      }
    }
    const address = {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
      sheet: this.sheetId
    };
    let cellValue = this.engine.getCellValue(address);
    const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);
    if (cellMeta.type === "date" && isNumeric(cellValue)) {
      cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);
    }
    const value = typeof cellValue === "object" && cellValue !== null ? cellValue.value : cellValue;
    valueHolder.value = value;
  }
  /**
   * `modifySourceData` hook callback.
   *
   * @private
   * @param {number} row Physical row index.
   * @param {number|string} columnOrProp Physical column index or prop.
   * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`
   *   property.
   * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
   */
  onModifySourceData(row, columnOrProp, valueHolder, ioMode) {
    if (ioMode !== "get" || _classPrivateFieldGet11(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {
      return;
    }
    const visualRow = this.hot.toVisualRow(row);
    const visualColumn = this.hot.propToCol(columnOrProp);
    if (visualRow === null || visualColumn === null) {
      return;
    }
    const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);
    if (!isFormulaCellType) {
      const cellType = this.getCellType(visualRow, visualColumn);
      if (cellType !== "ARRAY") {
        return;
      }
    }
    const dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));
    if (dimensions.width === 0 && dimensions.height === 0) {
      return;
    }
    const address = {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
      sheet: this.sheetId
    };
    valueHolder.value = this.engine.getCellSerialized(address);
  }
  /**
   * `onAfterSetDataAtCell` hook callback.
   *
   * @private
   * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).
   */
  onAfterSetDataAtCell(changes, source) {
    if (isBlockedSource(source)) {
      return;
    }
    const outOfBoundsChanges = [];
    const changedCells = [];
    const dependentCells = this.engine.batch(() => {
      changes.forEach((_ref4) => {
        let [visualRow, prop, , newValue] = _ref4;
        const visualColumn = this.hot.propToCol(prop);
        const physicalRow = this.hot.toPhysicalRow(visualRow);
        const physicalColumn = this.hot.toPhysicalColumn(visualColumn);
        const address = {
          row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
          col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
          sheet: this.sheetId
        };
        if (physicalRow !== null && physicalColumn !== null) {
          this.syncChangeWithEngine(visualRow, visualColumn, newValue);
        } else {
          outOfBoundsChanges.push([visualRow, visualColumn, newValue]);
        }
        changedCells.push({
          address
        });
      });
    });
    if (outOfBoundsChanges.length) {
      this.hot.addHookOnce("afterChange", () => {
        const outOfBoundsDependentCells = this.engine.batch(() => {
          outOfBoundsChanges.forEach((_ref5) => {
            let [row, column, newValue] = _ref5;
            this.syncChangeWithEngine(row, column, newValue);
          });
        });
        this.renderDependentSheets(outOfBoundsDependentCells, true);
      });
    }
    this.renderDependentSheets(dependentCells);
    this.validateDependentCells(dependentCells, changedCells);
  }
  /**
   * `onAfterSetSourceDataAtCell` hook callback.
   *
   * @private
   * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).
   */
  onAfterSetSourceDataAtCell(changes, source) {
    if (isBlockedSource(source)) {
      return;
    }
    const dependentCells = [];
    const changedCells = [];
    changes.forEach((_ref6) => {
      let [visualRow, prop, , newValue] = _ref6;
      const visualColumn = this.hot.propToCol(prop);
      if (!isNumeric(visualColumn)) {
        return;
      }
      const address = {
        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
        sheet: this.sheetId
      };
      if (!this.engine.isItPossibleToSetCellContents(address)) {
        warn2(`Not possible to set source cell data at ${JSON.stringify(address)}`);
        return;
      }
      changedCells.push({
        address
      });
      dependentCells.push(...this.engine.setCellContents(address, newValue));
    });
    this.renderDependentSheets(dependentCells);
    this.validateDependentCells(dependentCells, changedCells);
  }
  /**
   * `beforeCreateRow` hook callback.
   *
   * @private
   * @param {number} visualRow Represents the visual index of first newly created row in the data source array.
   * @param {number} amount Number of newly created rows in the data source array.
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  onBeforeCreateRow(visualRow, amount) {
    let hfRowIndex = this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow);
    if (visualRow >= this.hot.countRows()) {
      hfRowIndex = visualRow;
    }
    if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [hfRowIndex, amount])) {
      return false;
    }
  }
  /**
   * `beforeCreateCol` hook callback.
   *
   * @private
   * @param {number} visualColumn Represents the visual index of first newly created column in the data source.
   * @param {number} amount Number of newly created columns in the data source.
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  onBeforeCreateCol(visualColumn, amount) {
    let hfColumnIndex = this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn);
    if (visualColumn >= this.hot.countCols()) {
      hfColumnIndex = visualColumn;
    }
    if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [hfColumnIndex, amount])) {
      return false;
    }
  }
  /**
   * `beforeRemoveRow` hook callback.
   *
   * @private
   * @param {number} row Visual index of starter row.
   * @param {number} amount Amount of rows to be removed.
   * @param {number[]} physicalRows An array of physical rows removed from the data source.
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  onBeforeRemoveRow(row, amount, physicalRows) {
    const hfRows = this.rowAxisSyncer.setRemovedHfIndexes(physicalRows);
    const possible = hfRows.every((hfRow) => {
      return this.engine.isItPossibleToRemoveRows(this.sheetId, [hfRow, 1]);
    });
    return possible === false ? false : void 0;
  }
  /**
   * `beforeRemoveCol` hook callback.
   *
   * @private
   * @param {number} col Visual index of starter column.
   * @param {number} amount Amount of columns to be removed.
   * @param {number[]} physicalColumns An array of physical columns removed from the data source.
   * @returns {*|boolean} If false is returned the action is canceled.
   */
  onBeforeRemoveCol(col, amount, physicalColumns) {
    const hfColumns = this.columnAxisSyncer.setRemovedHfIndexes(physicalColumns);
    const possible = hfColumns.every((hfColumn) => {
      return this.engine.isItPossibleToRemoveColumns(this.sheetId, [hfColumn, 1]);
    });
    return possible === false ? false : void 0;
  }
  /**
   * `afterCreateRow` hook callback.
   *
   * @private
   * @param {number} visualRow Represents the visual index of first newly created row in the data source array.
   * @param {number} amount Number of newly created rows in the data source array.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).
   */
  onAfterCreateRow(visualRow, amount, source) {
    if (isBlockedSource(source)) {
      return;
    }
    const changes = this.engine.addRows(this.sheetId, [this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow), amount]);
    this.renderDependentSheets(changes);
  }
  /**
   * `afterCreateCol` hook callback.
   *
   * @private
   * @param {number} visualColumn Represents the visual index of first newly created column in the data source.
   * @param {number} amount Number of newly created columns in the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).
   */
  onAfterCreateCol(visualColumn, amount, source) {
    if (isBlockedSource(source)) {
      return;
    }
    const changes = this.engine.addColumns(this.sheetId, [this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn), amount]);
    this.renderDependentSheets(changes);
  }
  /**
   * `afterRemoveRow` hook callback.
   *
   * @private
   * @param {number} row Visual index of starter row.
   * @param {number} amount An amount of removed rows.
   * @param {number[]} physicalRows An array of physical rows removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).
   */
  onAfterRemoveRow(row, amount, physicalRows, source) {
    if (isBlockedSource(source)) {
      return;
    }
    const descendingHfRows = this.rowAxisSyncer.getRemovedHfIndexes().sort().reverse();
    const changes = this.engine.batch(() => {
      descendingHfRows.forEach((hfRow) => {
        this.engine.removeRows(this.sheetId, [hfRow, 1]);
      });
    });
    this.renderDependentSheets(changes);
  }
  /**
   * `afterRemoveCol` hook callback.
   *
   * @private
   * @param {number} col Visual index of starter column.
   * @param {number} amount An amount of removed columns.
   * @param {number[]} physicalColumns An array of physical columns removed from the data source.
   * @param {string} [source] String that identifies source of hook call
   *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).
   */
  onAfterRemoveCol(col, amount, physicalColumns, source) {
    if (isBlockedSource(source)) {
      return;
    }
    const descendingHfColumns = this.columnAxisSyncer.getRemovedHfIndexes().sort().reverse();
    const changes = this.engine.batch(() => {
      descendingHfColumns.forEach((hfColumn) => {
        this.engine.removeColumns(this.sheetId, [hfColumn, 1]);
      });
    });
    this.renderDependentSheets(changes);
  }
  /**
   * `afterDetachChild` hook callback.
   * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.
   *
   * @private
   * @param {object} parent An object representing the parent from which the element was detached.
   * @param {object} element The detached element.
   * @param {number} finalElementRowIndex The final row index of the detached element.
   */
  onAfterDetachChild(parent, element, finalElementRowIndex) {
    var _element$__children;
    _classPrivateFieldSet11(this, _internalOperationPending, true);
    const rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());
    _classPrivateFieldSet11(this, _internalOperationPending, false);
    rowsData.forEach((row, relativeRowIndex) => {
      row.forEach((value, colIndex) => {
        this.engine.setCellContents({
          col: colIndex,
          row: finalElementRowIndex + relativeRowIndex,
          sheet: this.sheetId
        }, [[value]]);
      });
    });
  }
  /**
   * Called when a value is updated in the engine.
   *
   * @private
   * @fires Hooks#afterFormulasValuesUpdate
   * @param {Array} changes The values and location of applied changes.
   */
  onEngineValuesUpdated(changes) {
    this.hot.runHooks("afterFormulasValuesUpdate", changes);
  }
  /**
   * Called when a named expression is added to the engine instance.
   *
   * @private
   * @fires Hooks#afterNamedExpressionAdded
   * @param {string} namedExpressionName The name of the added expression.
   * @param {Array} changes The values and location of applied changes.
   */
  onEngineNamedExpressionsAdded(namedExpressionName, changes) {
    this.hot.runHooks("afterNamedExpressionAdded", namedExpressionName, changes);
  }
  /**
   * Called when a named expression is removed from the engine instance.
   *
   * @private
   * @fires Hooks#afterNamedExpressionRemoved
   * @param {string} namedExpressionName The name of the removed expression.
   * @param {Array} changes The values and location of applied changes.
   */
  onEngineNamedExpressionsRemoved(namedExpressionName, changes) {
    this.hot.runHooks("afterNamedExpressionRemoved", namedExpressionName, changes);
  }
  /**
   * Called when a new sheet is added to the engine instance.
   *
   * @private
   * @fires Hooks#afterSheetAdded
   * @param {string} addedSheetDisplayName The name of the added sheet.
   */
  onEngineSheetAdded(addedSheetDisplayName) {
    this.hot.runHooks("afterSheetAdded", addedSheetDisplayName);
  }
  /**
   * Called when a sheet in the engine instance is renamed.
   *
   * @private
   * @fires Hooks#afterSheetRenamed
   * @param {string} oldDisplayName The old name of the sheet.
   * @param {string} newDisplayName The new name of the sheet.
   */
  onEngineSheetRenamed(oldDisplayName, newDisplayName) {
    this.hot.runHooks("afterSheetRenamed", oldDisplayName, newDisplayName);
  }
  /**
   * Called when a sheet is removed from the engine instance.
   *
   * @private
   * @fires Hooks#afterSheetRemoved
   * @param {string} removedSheetDisplayName The removed sheet name.
   * @param {Array} changes The values and location of applied changes.
   */
  onEngineSheetRemoved(removedSheetDisplayName, changes) {
    this.hot.runHooks("afterSheetRemoved", removedSheetDisplayName, changes);
  }
};

// node_modules/handsontable/plugins/hiddenColumns/contextMenuItem/hideColumn.mjs
function hideColumnItem(hiddenColumnsPlugin) {
  return {
    key: "hidden_columns_hide",
    name() {
      const selection = this.getSelectedLast();
      let pluralForm = 0;
      if (Array.isArray(selection)) {
        const [, fromColumn, , toColumn] = selection;
        if (fromColumn - toColumn !== 0) {
          pluralForm = 1;
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_COLUMN, pluralForm);
    },
    callback() {
      const {
        from: from2,
        to: to2
      } = this.getSelectedRangeLast();
      const start = Math.max(Math.min(from2.col, to2.col), 0);
      const end = Math.max(from2.col, to2.col);
      const columnsToHide = [];
      for (let visualColumn = start; visualColumn <= end; visualColumn += 1) {
        columnsToHide.push(visualColumn);
      }
      hiddenColumnsPlugin.hideColumns(columnsToHide);
      const lastHiddenColumn = columnsToHide[columnsToHide.length - 1];
      const columnToSelect = this.columnIndexMapper.getNearestNotHiddenIndex(lastHiddenColumn, 1, true);
      if (Number.isInteger(columnToSelect) && columnToSelect >= 0) {
        this.selectColumns(columnToSelect);
      } else {
        this.deselectCell();
      }
      this.render();
      this.view.adjustElementsSize(true);
    },
    disabled: false,
    hidden() {
      return !(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner());
    }
  };
}

// node_modules/handsontable/plugins/hiddenColumns/contextMenuItem/showColumn.mjs
function showColumnItem(hiddenColumnsPlugin) {
  const columns = [];
  return {
    key: "hidden_columns_show",
    name() {
      const pluralForm = columns.length > 1 ? 1 : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_COLUMN, pluralForm);
    },
    callback() {
      var _this$columnIndexMapp, _this$columnIndexMapp2;
      if (columns.length === 0) {
        return;
      }
      let startVisualColumn = columns[0];
      let endVisualColumn = columns[columns.length - 1];
      startVisualColumn = (_this$columnIndexMapp = this.columnIndexMapper.getNearestNotHiddenIndex(startVisualColumn - 1, -1)) !== null && _this$columnIndexMapp !== void 0 ? _this$columnIndexMapp : 0;
      endVisualColumn = (_this$columnIndexMapp2 = this.columnIndexMapper.getNearestNotHiddenIndex(endVisualColumn + 1, 1)) !== null && _this$columnIndexMapp2 !== void 0 ? _this$columnIndexMapp2 : this.countCols() - 1;
      hiddenColumnsPlugin.showColumns(columns);
      this.render();
      this.view.adjustElementsSize(true);
      const allColumnsSelected = endVisualColumn - startVisualColumn + 1 === this.countCols();
      if (!allColumnsSelected) {
        this.selectColumns(startVisualColumn, endVisualColumn);
      }
    },
    disabled: false,
    hidden() {
      const hiddenPhysicalColumns = arrayMap(hiddenColumnsPlugin.getHiddenColumns(), (visualColumnIndex) => {
        return this.toPhysicalColumn(visualColumnIndex);
      });
      if (!(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalColumns.length < 1) {
        return true;
      }
      columns.length = 0;
      const selectedRangeLast = this.getSelectedRangeLast();
      const visualStartColumn = selectedRangeLast.getTopStartCorner().col;
      const visualEndColumn = selectedRangeLast.getBottomEndCorner().col;
      const columnIndexMapper = this.columnIndexMapper;
      const renderableStartColumn = columnIndexMapper.getRenderableFromVisualIndex(visualStartColumn);
      const renderableEndColumn = columnIndexMapper.getRenderableFromVisualIndex(visualEndColumn);
      const notTrimmedColumnIndexes = columnIndexMapper.getNotTrimmedIndexes();
      const physicalColumnIndexes = [];
      if (visualStartColumn !== visualEndColumn) {
        const visualColumnsInRange = visualEndColumn - visualStartColumn + 1;
        const renderedColumnsInRange = renderableEndColumn - renderableStartColumn + 1;
        if (visualColumnsInRange > renderedColumnsInRange) {
          const physicalIndexesInRange = notTrimmedColumnIndexes.slice(visualStartColumn, visualEndColumn + 1);
          physicalColumnIndexes.push(...physicalIndexesInRange.filter((physicalIndex) => hiddenPhysicalColumns.includes(physicalIndex)));
        }
      } else if (renderableStartColumn === 0 && renderableStartColumn < visualStartColumn) {
        physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, visualStartColumn));
      } else if (renderableStartColumn === null) {
        physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, this.countCols()));
      } else {
        const lastVisualIndex = this.countCols() - 1;
        const lastRenderableIndex = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(lastVisualIndex, -1));
        if (renderableEndColumn === lastRenderableIndex && lastVisualIndex > visualEndColumn) {
          physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(visualEndColumn + 1));
        }
      }
      arrayEach(physicalColumnIndexes, (physicalColumnIndex) => {
        columns.push(this.toVisualColumn(physicalColumnIndex));
      });
      return columns.length === 0;
    }
  };
}

// node_modules/handsontable/plugins/hiddenColumns/hiddenColumns.mjs
function _classPrivateFieldInitSpec12(obj, privateMap, value) {
  _checkPrivateRedeclaration13(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration13(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet12(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor12(receiver, privateMap, "get");
  return _classApplyDescriptorGet12(receiver, descriptor);
}
function _classApplyDescriptorGet12(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet12(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor12(receiver, privateMap, "set");
  _classApplyDescriptorSet12(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor12(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet12(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
pluginHooks_default.getSingleton().register("beforeHideColumns");
pluginHooks_default.getSingleton().register("afterHideColumns");
pluginHooks_default.getSingleton().register("beforeUnhideColumns");
pluginHooks_default.getSingleton().register("afterUnhideColumns");
var PLUGIN_KEY18 = "hiddenColumns";
var PLUGIN_PRIORITY17 = 310;
var _settings = /* @__PURE__ */ new WeakMap();
var _hiddenColumnsMap = /* @__PURE__ */ new WeakMap();
var HiddenColumns = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateFieldInitSpec12(this, _settings, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec12(this, _hiddenColumnsMap, {
      writable: true,
      value: null
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY18;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY17;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link HiddenColumns#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY18];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY18];
    if (isObject2(pluginSettings)) {
      _classPrivateFieldSet12(this, _settings, pluginSettings);
      if (isUndefined2(pluginSettings.copyPasteEnabled)) {
        pluginSettings.copyPasteEnabled = true;
      }
    }
    _classPrivateFieldSet12(this, _hiddenColumnsMap, new HidingMap());
    _classPrivateFieldGet12(this, _hiddenColumnsMap).addLocalHook("init", () => this.onMapInit());
    this.hot.columnIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet12(this, _hiddenColumnsMap));
    this.addHook("afterContextMenuDefaultOptions", function() {
      return _this.onAfterContextMenuDefaultOptions(...arguments);
    });
    this.addHook("afterGetCellMeta", (row, col, cellProperties) => this.onAfterGetCellMeta(row, col, cellProperties));
    this.addHook("modifyColWidth", (width, col) => this.onModifyColWidth(width, col));
    this.addHook("afterGetColHeader", function() {
      return _this.onAfterGetColHeader(...arguments);
    });
    this.addHook("modifyCopyableRange", (ranges) => this.onModifyCopyableRange(ranges));
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`hiddenColumns`](@/api/options.md#hiddencolumns)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.columnIndexMapper.unregisterMap(this.pluginName);
    _classPrivateFieldSet12(this, _settings, {});
    super.disablePlugin();
    this.resetCellsMeta();
  }
  /**
   * Shows the provided columns.
   *
   * @param {number[]} columns Array of visual column indexes.
   */
  showColumns(columns) {
    const currentHideConfig = this.getHiddenColumns();
    const isValidConfig = this.isValidConfig(columns);
    let destinationHideConfig = currentHideConfig;
    const hidingMapValues = _classPrivateFieldGet12(this, _hiddenColumnsMap).getValues().slice();
    const isAnyColumnShowed = columns.length > 0;
    if (isValidConfig && isAnyColumnShowed) {
      const physicalColumns = columns.map((visualColumn) => this.hot.toPhysicalColumn(visualColumn));
      arrayEach(physicalColumns, (physicalColumn) => {
        hidingMapValues[physicalColumn] = false;
      });
      destinationHideConfig = arrayReduce(hidingMapValues, (hiddenIndexes, isHidden, physicalIndex) => {
        if (isHidden) {
          hiddenIndexes.push(this.hot.toVisualColumn(physicalIndex));
        }
        return hiddenIndexes;
      }, []);
    }
    const continueHiding = this.hot.runHooks("beforeUnhideColumns", currentHideConfig, destinationHideConfig, isValidConfig && isAnyColumnShowed);
    if (continueHiding === false) {
      return;
    }
    if (isValidConfig && isAnyColumnShowed) {
      _classPrivateFieldGet12(this, _hiddenColumnsMap).setValues(hidingMapValues);
    }
    this.hot.view.adjustElementsSize();
    this.hot.runHooks("afterUnhideColumns", currentHideConfig, destinationHideConfig, isValidConfig && isAnyColumnShowed, isValidConfig && destinationHideConfig.length < currentHideConfig.length);
  }
  /**
   * Shows a single column.
   *
   * @param {...number} column Visual column index.
   */
  showColumn() {
    for (var _len = arguments.length, column = new Array(_len), _key = 0; _key < _len; _key++) {
      column[_key] = arguments[_key];
    }
    this.showColumns(column);
  }
  /**
   * Hides the columns provided in the array.
   *
   * @param {number[]} columns Array of visual column indexes.
   */
  hideColumns(columns) {
    const currentHideConfig = this.getHiddenColumns();
    const isConfigValid = this.isValidConfig(columns);
    let destinationHideConfig = currentHideConfig;
    if (isConfigValid) {
      destinationHideConfig = Array.from(new Set(currentHideConfig.concat(columns)));
    }
    const continueHiding = this.hot.runHooks("beforeHideColumns", currentHideConfig, destinationHideConfig, isConfigValid);
    if (continueHiding === false) {
      return;
    }
    if (isConfigValid) {
      this.hot.batchExecution(() => {
        arrayEach(columns, (visualColumn) => {
          _classPrivateFieldGet12(this, _hiddenColumnsMap).setValueAtIndex(this.hot.toPhysicalColumn(visualColumn), true);
        });
      }, true);
    }
    this.hot.runHooks("afterHideColumns", currentHideConfig, destinationHideConfig, isConfigValid, isConfigValid && destinationHideConfig.length > currentHideConfig.length);
  }
  /**
   * Hides a single column.
   *
   * @param {...number} column Visual column index.
   */
  hideColumn() {
    for (var _len2 = arguments.length, column = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      column[_key2] = arguments[_key2];
    }
    this.hideColumns(column);
  }
  /**
   * Returns an array of visual indexes of hidden columns.
   *
   * @returns {number[]}
   */
  getHiddenColumns() {
    return arrayMap(_classPrivateFieldGet12(this, _hiddenColumnsMap).getHiddenIndexes(), (physicalColumnIndex) => {
      return this.hot.toVisualColumn(physicalColumnIndex);
    });
  }
  /**
   * Checks if the provided column is hidden.
   *
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  isHidden(column) {
    return _classPrivateFieldGet12(this, _hiddenColumnsMap).getValueAtIndex(this.hot.toPhysicalColumn(column)) || false;
  }
  /**
   * Get if trim config is valid. Check whether all of the provided column indexes are within the bounds of the table.
   *
   * @param {Array} hiddenColumns List of hidden column indexes.
   * @returns {boolean}
   */
  isValidConfig(hiddenColumns) {
    const nrOfColumns = this.hot.countCols();
    if (Array.isArray(hiddenColumns) && hiddenColumns.length > 0) {
      return hiddenColumns.every((visualColumn) => Number.isInteger(visualColumn) && visualColumn >= 0 && visualColumn < nrOfColumns);
    }
    return false;
  }
  /**
   * Reset all rendered cells meta.
   *
   * @private
   */
  resetCellsMeta() {
    arrayEach(this.hot.getCellsMeta(), (meta) => {
      if (meta) {
        meta.skipColumnOnPaste = false;
      }
    });
  }
  /**
   * Adds the additional column width for the hidden column indicators.
   *
   * @private
   * @param {number|undefined} width Column width.
   * @param {number} column Visual column index.
   * @returns {number}
   */
  onModifyColWidth(width, column) {
    if (this.isHidden(column)) {
      return 0;
    }
    if (_classPrivateFieldGet12(this, _settings).indicators && (this.isHidden(column + 1) || this.isHidden(column - 1))) {
      if (typeof width === "number" && this.hot.hasColHeaders()) {
        return width + 15;
      }
    }
  }
  /**
   * Sets the copy-related cell meta.
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} cellProperties Object containing the cell properties.
   */
  onAfterGetCellMeta(row, column, cellProperties) {
    if (_classPrivateFieldGet12(this, _settings).copyPasteEnabled === false && this.isHidden(column)) {
      cellProperties.skipColumnOnPaste = true;
    }
    if (this.isHidden(column - 1)) {
      cellProperties.className = cellProperties.className || "";
      if (cellProperties.className.indexOf("afterHiddenColumn") === -1) {
        cellProperties.className += " afterHiddenColumn";
      }
    } else if (cellProperties.className) {
      const classArr = cellProperties.className.split(" ");
      if (classArr.length > 0) {
        const containAfterHiddenColumn = classArr.indexOf("afterHiddenColumn");
        if (containAfterHiddenColumn > -1) {
          classArr.splice(containAfterHiddenColumn, 1);
        }
        cellProperties.className = classArr.join(" ");
      }
    }
  }
  /**
   * Modifies the copyable range, accordingly to the provided config.
   *
   * @private
   * @param {Array} ranges An array of objects defining copyable cells.
   * @returns {Array}
   */
  onModifyCopyableRange(ranges) {
    if (_classPrivateFieldGet12(this, _settings).copyPasteEnabled) {
      return ranges;
    }
    const newRanges = [];
    const pushRange = (startRow, endRow, startCol, endCol) => {
      newRanges.push({
        startRow,
        endRow,
        startCol,
        endCol
      });
    };
    arrayEach(ranges, (range) => {
      let isHidden = true;
      let rangeStart = 0;
      rangeEach(range.startCol, range.endCol, (visualColumn) => {
        if (this.isHidden(visualColumn)) {
          if (!isHidden) {
            pushRange(range.startRow, range.endRow, rangeStart, visualColumn - 1);
          }
          isHidden = true;
        } else {
          if (isHidden) {
            rangeStart = visualColumn;
          }
          if (visualColumn === range.endCol) {
            pushRange(range.startRow, range.endRow, rangeStart, visualColumn);
          }
          isHidden = false;
        }
      });
    });
    return newRanges;
  }
  /**
   * Adds the needed classes to the headers.
   *
   * @private
   * @param {number} column Visual column index.
   * @param {HTMLElement} TH Header's TH element.
   */
  onAfterGetColHeader(column, TH) {
    if (!_classPrivateFieldGet12(this, _settings).indicators || column < 0) {
      return;
    }
    const classList = [];
    if (column >= 1 && this.isHidden(column - 1)) {
      classList.push("afterHiddenColumn");
    }
    if (column < this.hot.countCols() - 1 && this.isHidden(column + 1)) {
      classList.push("beforeHiddenColumn");
    }
    addClass(TH, classList);
  }
  /**
   * Add Show-hide columns to context menu.
   *
   * @private
   * @param {object} options An array of objects containing information about the pre-defined Context Menu items.
   */
  onAfterContextMenuDefaultOptions(options) {
    options.items.push({
      name: KEY
    }, hideColumnItem(this), showColumnItem(this));
  }
  /**
   * On map initialized hook callback.
   *
   * @private
   */
  onMapInit() {
    if (Array.isArray(_classPrivateFieldGet12(this, _settings).columns)) {
      this.hideColumns(_classPrivateFieldGet12(this, _settings).columns);
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldSet12(this, _settings, null);
    _classPrivateFieldSet12(this, _hiddenColumnsMap, null);
    super.destroy();
  }
};

// node_modules/handsontable/plugins/hiddenRows/contextMenuItem/hideRow.mjs
function hideRowItem(hiddenRowsPlugin) {
  return {
    key: "hidden_rows_hide",
    name() {
      const selection = this.getSelectedLast();
      let pluralForm = 0;
      if (Array.isArray(selection)) {
        const [fromRow, , toRow] = selection;
        if (fromRow - toRow !== 0) {
          pluralForm = 1;
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_ROW, pluralForm);
    },
    callback() {
      const {
        from: from2,
        to: to2
      } = this.getSelectedRangeLast();
      const start = Math.max(Math.min(from2.row, to2.row), 0);
      const end = Math.max(from2.row, to2.row);
      const rowsToHide = [];
      for (let visualRow = start; visualRow <= end; visualRow += 1) {
        rowsToHide.push(visualRow);
      }
      hiddenRowsPlugin.hideRows(rowsToHide);
      const lastHiddenRow = rowsToHide[rowsToHide.length - 1];
      const rowToSelect = this.rowIndexMapper.getNearestNotHiddenIndex(lastHiddenRow, 1, true);
      if (Number.isInteger(rowToSelect) && rowToSelect >= 0) {
        this.selectRows(rowToSelect);
      } else {
        this.deselectCell();
      }
      this.render();
      this.view.adjustElementsSize(true);
    },
    disabled: false,
    hidden() {
      return !(this.selection.isSelectedByRowHeader() || this.selection.isSelectedByCorner());
    }
  };
}

// node_modules/handsontable/plugins/hiddenRows/contextMenuItem/showRow.mjs
function showRowItem(hiddenRowsPlugin) {
  const rows = [];
  return {
    key: "hidden_rows_show",
    name() {
      const pluralForm = rows.length > 1 ? 1 : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_ROW, pluralForm);
    },
    callback() {
      var _this$rowIndexMapper$, _this$rowIndexMapper$2;
      if (rows.length === 0) {
        return;
      }
      let startVisualRow = rows[0];
      let endVisualRow = rows[rows.length - 1];
      startVisualRow = (_this$rowIndexMapper$ = this.rowIndexMapper.getNearestNotHiddenIndex(startVisualRow - 1, -1)) !== null && _this$rowIndexMapper$ !== void 0 ? _this$rowIndexMapper$ : 0;
      endVisualRow = (_this$rowIndexMapper$2 = this.rowIndexMapper.getNearestNotHiddenIndex(endVisualRow + 1, 1)) !== null && _this$rowIndexMapper$2 !== void 0 ? _this$rowIndexMapper$2 : this.countRows() - 1;
      hiddenRowsPlugin.showRows(rows);
      this.render();
      this.view.adjustElementsSize(true);
      const allRowsSelected = endVisualRow - startVisualRow + 1 === this.countRows();
      if (!allRowsSelected) {
        this.selectRows(startVisualRow, endVisualRow);
      }
    },
    disabled: false,
    hidden() {
      const hiddenPhysicalRows = arrayMap(hiddenRowsPlugin.getHiddenRows(), (visualRowIndex) => {
        return this.toPhysicalRow(visualRowIndex);
      });
      if (!(this.selection.isSelectedByRowHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalRows.length < 1) {
        return true;
      }
      rows.length = 0;
      const selectedRangeLast = this.getSelectedRangeLast();
      const visualStartRow = selectedRangeLast.getTopStartCorner().row;
      const visualEndRow = selectedRangeLast.getBottomEndCorner().row;
      const rowIndexMapper = this.rowIndexMapper;
      const renderableStartRow = rowIndexMapper.getRenderableFromVisualIndex(visualStartRow);
      const renderableEndRow = rowIndexMapper.getRenderableFromVisualIndex(visualEndRow);
      const notTrimmedRowIndexes = rowIndexMapper.getNotTrimmedIndexes();
      const physicalRowIndexes = [];
      if (visualStartRow !== visualEndRow) {
        const visualRowsInRange = visualEndRow - visualStartRow + 1;
        const renderedRowsInRange = renderableEndRow - renderableStartRow + 1;
        if (visualRowsInRange > renderedRowsInRange) {
          const physicalIndexesInRange = notTrimmedRowIndexes.slice(visualStartRow, visualEndRow + 1);
          physicalRowIndexes.push(...physicalIndexesInRange.filter((physicalIndex) => hiddenPhysicalRows.includes(physicalIndex)));
        }
      } else if (renderableStartRow === 0 && renderableStartRow < visualStartRow) {
        physicalRowIndexes.push(...notTrimmedRowIndexes.slice(0, visualStartRow));
      } else if (renderableStartRow === null) {
        physicalRowIndexes.push(...notTrimmedRowIndexes.slice(0, this.countRows()));
      } else {
        const lastVisualIndex = this.countRows() - 1;
        const lastRenderableIndex = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHiddenIndex(lastVisualIndex, -1));
        if (renderableEndRow === lastRenderableIndex && lastVisualIndex > visualEndRow) {
          physicalRowIndexes.push(...notTrimmedRowIndexes.slice(visualEndRow + 1));
        }
      }
      arrayEach(physicalRowIndexes, (physicalRowIndex) => {
        rows.push(this.toVisualRow(physicalRowIndex));
      });
      return rows.length === 0;
    }
  };
}

// node_modules/handsontable/plugins/hiddenRows/hiddenRows.mjs
function _classPrivateFieldInitSpec13(obj, privateMap, value) {
  _checkPrivateRedeclaration14(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration14(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet13(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor13(receiver, privateMap, "get");
  return _classApplyDescriptorGet13(receiver, descriptor);
}
function _classApplyDescriptorGet13(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet13(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor13(receiver, privateMap, "set");
  _classApplyDescriptorSet13(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor13(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet13(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
pluginHooks_default.getSingleton().register("beforeHideRows");
pluginHooks_default.getSingleton().register("afterHideRows");
pluginHooks_default.getSingleton().register("beforeUnhideRows");
pluginHooks_default.getSingleton().register("afterUnhideRows");
var PLUGIN_KEY19 = "hiddenRows";
var PLUGIN_PRIORITY18 = 320;
var _settings2 = /* @__PURE__ */ new WeakMap();
var _hiddenRowsMap = /* @__PURE__ */ new WeakMap();
var HiddenRows = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateFieldInitSpec13(this, _settings2, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec13(this, _hiddenRowsMap, {
      writable: true,
      value: null
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY19;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY18;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link HiddenRows#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY19];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY19];
    if (isObject2(pluginSettings)) {
      _classPrivateFieldSet13(this, _settings2, pluginSettings);
      if (isUndefined2(pluginSettings.copyPasteEnabled)) {
        pluginSettings.copyPasteEnabled = true;
      }
    }
    _classPrivateFieldSet13(this, _hiddenRowsMap, new HidingMap());
    _classPrivateFieldGet13(this, _hiddenRowsMap).addLocalHook("init", () => this.onMapInit());
    this.hot.rowIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet13(this, _hiddenRowsMap));
    this.addHook("afterContextMenuDefaultOptions", function() {
      return _this.onAfterContextMenuDefaultOptions(...arguments);
    });
    this.addHook("afterGetCellMeta", (row, col, cellProperties) => this.onAfterGetCellMeta(row, col, cellProperties));
    this.addHook("modifyRowHeight", (height, row) => this.onModifyRowHeight(height, row));
    this.addHook("afterGetRowHeader", function() {
      return _this.onAfterGetRowHeader(...arguments);
    });
    this.addHook("modifyCopyableRange", (ranges) => this.onModifyCopyableRange(ranges));
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`hiddenRows`](@/api/options.md#hiddenrows)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.rowIndexMapper.unregisterMap(this.pluginName);
    _classPrivateFieldSet13(this, _settings2, {});
    super.disablePlugin();
    this.resetCellsMeta();
  }
  /**
   * Shows the rows provided in the array.
   *
   * @param {number[]} rows Array of visual row indexes.
   */
  showRows(rows) {
    const currentHideConfig = this.getHiddenRows();
    const isValidConfig = this.isValidConfig(rows);
    let destinationHideConfig = currentHideConfig;
    const hidingMapValues = _classPrivateFieldGet13(this, _hiddenRowsMap).getValues().slice();
    const isAnyRowShowed = rows.length > 0;
    if (isValidConfig && isAnyRowShowed) {
      const physicalRows = rows.map((visualRow) => this.hot.toPhysicalRow(visualRow));
      arrayEach(physicalRows, (physicalRow) => {
        hidingMapValues[physicalRow] = false;
      });
      destinationHideConfig = arrayReduce(hidingMapValues, (hiddenIndexes, isHidden, physicalIndex) => {
        if (isHidden) {
          hiddenIndexes.push(this.hot.toVisualRow(physicalIndex));
        }
        return hiddenIndexes;
      }, []);
    }
    const continueHiding = this.hot.runHooks("beforeUnhideRows", currentHideConfig, destinationHideConfig, isValidConfig && isAnyRowShowed);
    if (continueHiding === false) {
      return;
    }
    if (isValidConfig && isAnyRowShowed) {
      _classPrivateFieldGet13(this, _hiddenRowsMap).setValues(hidingMapValues);
    }
    this.hot.runHooks("afterUnhideRows", currentHideConfig, destinationHideConfig, isValidConfig && isAnyRowShowed, isValidConfig && destinationHideConfig.length < currentHideConfig.length);
  }
  /**
   * Shows the row provided as row index (counting from 0).
   *
   * @param {...number} row Visual row index.
   */
  showRow() {
    for (var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {
      row[_key] = arguments[_key];
    }
    this.showRows(row);
  }
  /**
   * Hides the rows provided in the array.
   *
   * @param {number[]} rows Array of visual row indexes.
   */
  hideRows(rows) {
    const currentHideConfig = this.getHiddenRows();
    const isConfigValid = this.isValidConfig(rows);
    let destinationHideConfig = currentHideConfig;
    if (isConfigValid) {
      destinationHideConfig = Array.from(new Set(currentHideConfig.concat(rows)));
    }
    const continueHiding = this.hot.runHooks("beforeHideRows", currentHideConfig, destinationHideConfig, isConfigValid);
    if (continueHiding === false) {
      return;
    }
    if (isConfigValid) {
      this.hot.batchExecution(() => {
        arrayEach(rows, (visualRow) => {
          _classPrivateFieldGet13(this, _hiddenRowsMap).setValueAtIndex(this.hot.toPhysicalRow(visualRow), true);
        });
      }, true);
    }
    this.hot.runHooks("afterHideRows", currentHideConfig, destinationHideConfig, isConfigValid, isConfigValid && destinationHideConfig.length > currentHideConfig.length);
  }
  /**
   * Hides the row provided as row index (counting from 0).
   *
   * @param {...number} row Visual row index.
   */
  hideRow() {
    for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      row[_key2] = arguments[_key2];
    }
    this.hideRows(row);
  }
  /**
   * Returns an array of visual indexes of hidden rows.
   *
   * @returns {number[]}
   */
  getHiddenRows() {
    return arrayMap(_classPrivateFieldGet13(this, _hiddenRowsMap).getHiddenIndexes(), (physicalRowIndex) => {
      return this.hot.toVisualRow(physicalRowIndex);
    });
  }
  /**
   * Checks if the provided row is hidden.
   *
   * @param {number} row Visual row index.
   * @returns {boolean}
   */
  isHidden(row) {
    return _classPrivateFieldGet13(this, _hiddenRowsMap).getValueAtIndex(this.hot.toPhysicalRow(row)) || false;
  }
  /**
   * Checks whether all of the provided row indexes are within the bounds of the table.
   *
   * @param {Array} hiddenRows List of hidden visual row indexes.
   * @returns {boolean}
   */
  isValidConfig(hiddenRows) {
    const nrOfRows = this.hot.countRows();
    if (Array.isArray(hiddenRows) && hiddenRows.length > 0) {
      return hiddenRows.every((visualRow) => Number.isInteger(visualRow) && visualRow >= 0 && visualRow < nrOfRows);
    }
    return false;
  }
  /**
   * Resets all rendered cells meta.
   *
   * @private
   */
  resetCellsMeta() {
    arrayEach(this.hot.getCellsMeta(), (meta) => {
      if (meta) {
        meta.skipRowOnPaste = false;
      }
    });
  }
  /**
   * Adds the additional row height for the hidden row indicators.
   *
   * @private
   * @param {number|undefined} height Row height.
   * @param {number} row Visual row index.
   * @returns {number}
   */
  onModifyRowHeight(height, row) {
    if (this.isHidden(row)) {
      return 0;
    }
    return height;
  }
  /**
   * Sets the copy-related cell meta.
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} cellProperties Object containing the cell properties.
   */
  onAfterGetCellMeta(row, column, cellProperties) {
    if (_classPrivateFieldGet13(this, _settings2).copyPasteEnabled === false && this.isHidden(row)) {
      cellProperties.skipRowOnPaste = true;
    }
    if (this.isHidden(row - 1)) {
      cellProperties.className = cellProperties.className || "";
      if (cellProperties.className.indexOf("afterHiddenRow") === -1) {
        cellProperties.className += " afterHiddenRow";
      }
    } else if (cellProperties.className) {
      const classArr = cellProperties.className.split(" ");
      if (classArr.length > 0) {
        const containAfterHiddenRow = classArr.indexOf("afterHiddenRow");
        if (containAfterHiddenRow > -1) {
          classArr.splice(containAfterHiddenRow, 1);
        }
        cellProperties.className = classArr.join(" ");
      }
    }
  }
  /**
   * Modifies the copyable range, accordingly to the provided config.
   *
   * @private
   * @param {Array} ranges An array of objects defining copyable cells.
   * @returns {Array}
   */
  onModifyCopyableRange(ranges) {
    if (_classPrivateFieldGet13(this, _settings2).copyPasteEnabled) {
      return ranges;
    }
    const newRanges = [];
    const pushRange = (startRow, endRow, startCol, endCol) => {
      newRanges.push({
        startRow,
        endRow,
        startCol,
        endCol
      });
    };
    arrayEach(ranges, (range) => {
      let isHidden = true;
      let rangeStart = 0;
      rangeEach(range.startRow, range.endRow, (visualRow) => {
        if (this.isHidden(visualRow)) {
          if (!isHidden) {
            pushRange(rangeStart, visualRow - 1, range.startCol, range.endCol);
          }
          isHidden = true;
        } else {
          if (isHidden) {
            rangeStart = visualRow;
          }
          if (visualRow === range.endRow) {
            pushRange(rangeStart, visualRow, range.startCol, range.endCol);
          }
          isHidden = false;
        }
      });
    });
    return newRanges;
  }
  /**
   * Adds the needed classes to the headers.
   *
   * @private
   * @param {number} row Visual row index.
   * @param {HTMLElement} TH Header's TH element.
   */
  onAfterGetRowHeader(row, TH) {
    if (!_classPrivateFieldGet13(this, _settings2).indicators || row < 0) {
      return;
    }
    const classList = [];
    if (row >= 1 && this.isHidden(row - 1)) {
      classList.push("afterHiddenRow");
    }
    if (row < this.hot.countRows() - 1 && this.isHidden(row + 1)) {
      classList.push("beforeHiddenRow");
    }
    addClass(TH, classList);
  }
  /**
   * Add Show-hide rows to context menu.
   *
   * @private
   * @param {object} options An array of objects containing information about the pre-defined Context Menu items.
   */
  onAfterContextMenuDefaultOptions(options) {
    options.items.push({
      name: KEY
    }, hideRowItem(this), showRowItem(this));
  }
  /**
   * On map initialized hook callback.
   *
   * @private
   */
  onMapInit() {
    if (Array.isArray(_classPrivateFieldGet13(this, _settings2).rows)) {
      this.hideRows(_classPrivateFieldGet13(this, _settings2).rows);
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldSet13(this, _settings2, null);
    _classPrivateFieldSet13(this, _hiddenRowsMap, null);
    super.destroy();
  }
};

// node_modules/handsontable/plugins/manualColumnFreeze/contextMenuItem/freezeColumn.mjs
function freezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "freeze_column",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_FREEZE_COLUMN);
    },
    callback(key, selected) {
      const [{
        start: {
          col: selectedColumn
        }
      }] = selected;
      manualColumnFreezePlugin.freezeColumn(selectedColumn);
      this.render();
      this.view.adjustElementsSize(true);
    },
    hidden() {
      const selection = this.getSelectedRange();
      let hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col <= this.getSettings().fixedColumnsStart - 1) {
        hide = true;
      }
      return hide;
    }
  };
}

// node_modules/handsontable/plugins/manualColumnFreeze/contextMenuItem/unfreezeColumn.mjs
function unfreezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "unfreeze_column",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNFREEZE_COLUMN);
    },
    callback(key, selected) {
      const [{
        start: {
          col: selectedColumn
        }
      }] = selected;
      manualColumnFreezePlugin.unfreezeColumn(selectedColumn);
      this.render();
      this.view.adjustElementsSize(true);
    },
    hidden() {
      const selection = this.getSelectedRange();
      let hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col >= this.getSettings().fixedColumnsStart) {
        hide = true;
      }
      return hide;
    }
  };
}

// node_modules/handsontable/plugins/manualColumnFreeze/manualColumnFreeze.mjs
pluginHooks_default.getSingleton().register("beforeColumnFreeze");
pluginHooks_default.getSingleton().register("afterColumnFreeze");
pluginHooks_default.getSingleton().register("beforeColumnUnfreeze");
pluginHooks_default.getSingleton().register("afterColumnUnfreeze");
var PLUGIN_KEY20 = "manualColumnFreeze";
var PLUGIN_PRIORITY19 = 110;
var privatePool14 = /* @__PURE__ */ new WeakMap();
var ManualColumnFreeze = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY20;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY19;
  }
  constructor(hotInstance) {
    super(hotInstance);
    privatePool14.set(this, {
      afterFirstUse: false
    });
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualColumnFreeze#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY20];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.addHook("afterContextMenuDefaultOptions", (options) => this.addContextMenuEntry(options));
    this.addHook("beforeColumnMove", (columns, finalIndex) => this.onBeforeColumnMove(columns, finalIndex));
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    const priv = privatePool14.get(this);
    priv.afterFirstUse = false;
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualColumnFreeze`](@/api/options.md#manualcolumnfreeze)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Freezes the specified column (adds it to fixed columns).
   *
   * `freezeColumn()` doesn't re-render the table,
   * so you need to call the `render()` method afterward.
   *
   * @param {number} column Visual column index.
   */
  freezeColumn(column) {
    const priv = privatePool14.get(this);
    const settings = this.hot.getSettings();
    const freezePerformed = settings.fixedColumnsStart < this.hot.countCols() && column > settings.fixedColumnsStart - 1;
    if (!priv.afterFirstUse) {
      priv.afterFirstUse = true;
    }
    const beforeColumnFreezeHook = this.hot.runHooks("beforeColumnFreeze", column, freezePerformed);
    if (beforeColumnFreezeHook === false) {
      return;
    }
    if (freezePerformed) {
      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);
      settings._fixedColumnsStart += 1;
    }
    this.hot.runHooks("afterColumnFreeze", column, freezePerformed);
  }
  /**
   * Unfreezes the given column (remove it from fixed columns and bring to it's previous position).
   *
   * @param {number} column Visual column index.
   */
  unfreezeColumn(column) {
    const priv = privatePool14.get(this);
    const settings = this.hot.getSettings();
    const unfreezePerformed = settings.fixedColumnsStart > 0 && column <= settings.fixedColumnsStart - 1;
    if (!priv.afterFirstUse) {
      priv.afterFirstUse = true;
    }
    const beforeColumnUnfreezeHook = this.hot.runHooks("beforeColumnUnfreeze", column, unfreezePerformed);
    if (beforeColumnUnfreezeHook === false) {
      return;
    }
    if (unfreezePerformed) {
      settings._fixedColumnsStart -= 1;
      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);
    }
    this.hot.runHooks("afterColumnUnfreeze", column, unfreezePerformed);
  }
  /**
   * Adds the manualColumnFreeze context menu entries.
   *
   * @private
   * @param {object} options Context menu options.
   */
  addContextMenuEntry(options) {
    options.items.push({
      name: "---------"
    }, freezeColumnItem(this), unfreezeColumnItem(this));
  }
  /**
   * Prevents moving the columns from/to fixed area.
   *
   * @private
   * @param {Array} columns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
   * @returns {boolean|undefined}
   */
  onBeforeColumnMove(columns, finalIndex) {
    const priv = privatePool14.get(this);
    if (priv.afterFirstUse) {
      const freezeLine = this.hot.getSettings().fixedColumnsStart;
      if (finalIndex < freezeLine) {
        return false;
      }
      if (columns.some((column) => column < freezeLine)) {
        return false;
      }
    }
  }
};

// node_modules/handsontable/plugins/manualColumnMove/ui/_base.mjs
var STATE_INITIALIZED = 0;
var STATE_BUILT2 = 1;
var STATE_APPENDED = 2;
var UNIT = "px";
var BaseUI2 = class {
  constructor(hotInstance) {
    this.hot = hotInstance;
    this._element = null;
    this.state = STATE_INITIALIZED;
    this.inlineProperty = hotInstance.isRtl() ? "right" : "left";
  }
  /**
   * Add created UI elements to table.
   *
   * @param {HTMLElement} wrapper Element which are parent for our UI element.
   */
  appendTo(wrapper) {
    wrapper.appendChild(this._element);
    this.state = STATE_APPENDED;
  }
  /**
   * Method for create UI element. Only create, without append to table.
   */
  build() {
    if (this.state !== STATE_INITIALIZED) {
      return;
    }
    this._element = this.hot.rootDocument.createElement("div");
    this.state = STATE_BUILT2;
  }
  /**
   * Method for remove UI element.
   */
  destroy() {
    if (this.isAppended()) {
      this._element.parentElement.removeChild(this._element);
    }
    this._element = null;
    this.state = STATE_INITIALIZED;
  }
  /**
   * Check if UI element are appended.
   *
   * @returns {boolean}
   */
  isAppended() {
    return this.state === STATE_APPENDED;
  }
  /**
   * Check if UI element are built.
   *
   * @returns {boolean}
   */
  isBuilt() {
    return this.state >= STATE_BUILT2;
  }
  /**
   * Setter for position.
   *
   * @param {number} top New top position of the element.
   * @param {number} inlinePosition New left/right (depends on LTR/RTL document mode) position of the element.
   */
  setPosition(top2, inlinePosition) {
    if (isNumeric(top2)) {
      this._element.style.top = top2 + UNIT;
    }
    if (isNumeric(inlinePosition)) {
      this._element.style[this.inlineProperty] = inlinePosition + UNIT;
    }
  }
  /**
   * Getter for the element position.
   *
   * @returns {object} Object contains left and top position of the element.
   */
  getPosition() {
    const style = this._element.style;
    return {
      top: style.top ? parseInt(style.top, 10) : 0,
      start: style[this.inlineProperty] ? parseInt(style[this.inlineProperty], 10) : 0
    };
  }
  /**
   * Setter for the element size.
   *
   * @param {number} width New width of the element.
   * @param {number} height New height of the element.
   */
  setSize(width, height) {
    if (isNumeric(width)) {
      this._element.style.width = width + UNIT;
    }
    if (isNumeric(height)) {
      this._element.style.height = height + UNIT;
    }
  }
  /**
   * Getter for the element position.
   *
   * @returns {object} Object contains height and width of the element.
   */
  getSize() {
    return {
      width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
      height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
    };
  }
  /**
   * Setter for the element offset. Offset means marginTop and marginLeft of the element.
   *
   * @param {number} top New margin top of the element.
   * @param {number} inlineOffset New margin left/right (depends on LTR/RTL document mode) of the element.
   */
  setOffset(top2, inlineOffset) {
    if (isNumeric(top2)) {
      this._element.style.marginTop = top2 + UNIT;
    }
    if (isNumeric(inlineOffset)) {
      this._element.style[`margin${toUpperCaseFirst(this.inlineProperty)}`] = inlineOffset + UNIT;
    }
  }
  /**
   * Getter for the element offset.
   *
   * @returns {object} Object contains top and left offset of the element.
   */
  getOffset() {
    const style = this._element.style;
    const inlineProp = `margin${toUpperCaseFirst(this.inlineProperty)}`;
    return {
      top: style.marginTop ? parseInt(style.marginTop, 10) : 0,
      start: style[inlineProp] ? parseInt(style[inlineProp], 10) : 0
    };
  }
};
var base_default5 = BaseUI2;

// node_modules/handsontable/plugins/manualColumnMove/ui/backlight.mjs
var CSS_CLASSNAME = "ht__manualColumnMove--backlight";
var BacklightUI = class extends base_default5 {
  /**
   * Custom className on build process.
   */
  build() {
    super.build();
    addClass(this._element, CSS_CLASSNAME);
  }
};
var backlight_default = BacklightUI;

// node_modules/handsontable/plugins/manualColumnMove/ui/guideline.mjs
var CSS_CLASSNAME2 = "ht__manualColumnMove--guideline";
var GuidelineUI = class extends base_default5 {
  /**
   * Custom className on build process.
   */
  build() {
    super.build();
    addClass(this._element, CSS_CLASSNAME2);
  }
};
var guideline_default = GuidelineUI;

// node_modules/handsontable/plugins/manualColumnMove/manualColumnMove.mjs
pluginHooks_default.getSingleton().register("beforeColumnMove");
pluginHooks_default.getSingleton().register("afterColumnMove");
var PLUGIN_KEY21 = "manualColumnMove";
var PLUGIN_PRIORITY20 = 120;
var privatePool15 = /* @__PURE__ */ new WeakMap();
var CSS_PLUGIN = "ht__manualColumnMove";
var CSS_SHOW_UI = "show-ui";
var CSS_ON_MOVING = "on-moving--columns";
var CSS_AFTER_SELECTION = "after-selection--columns";
var ManualColumnMove = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY21;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY20;
  }
  constructor(hotInstance) {
    super(hotInstance);
    privatePool15.set(this, {
      columnsToMove: [],
      countCols: 0,
      fixedColumns: 0,
      pressed: void 0,
      target: {
        eventPageX: void 0,
        coords: void 0,
        TD: void 0,
        col: void 0
      },
      cachedDropIndex: void 0
    });
    this.eventManager = new eventManager_default(this);
    this.backlight = new backlight_default(hotInstance);
    this.guideline = new guideline_default(hotInstance);
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualColumnMove#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY21];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.addHook("beforeOnCellMouseDown", function() {
      return _this.onBeforeOnCellMouseDown(...arguments);
    });
    this.addHook("beforeOnCellMouseOver", function() {
      return _this.onBeforeOnCellMouseOver(...arguments);
    });
    this.addHook("afterScrollVertically", () => this.onAfterScrollVertically());
    this.addHook("afterLoadData", function() {
      return _this.onAfterLoadData(...arguments);
    });
    this.buildPluginUI();
    this.registerEvents();
    addClass(this.hot.rootElement, CSS_PLUGIN);
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualColumnMove`](@/api/options.md#manualcolumnmove)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    this.moveBySettingsOrLoad();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    removeClass(this.hot.rootElement, CSS_PLUGIN);
    this.unregisterEvents();
    this.backlight.destroy();
    this.guideline.destroy();
    super.disablePlugin();
  }
  /**
   * Moves a single column.
   *
   * @param {number} column Visual column index to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @fires Hooks#beforeColumnMove
   * @fires Hooks#afterColumnMove
   * @returns {boolean}
   */
  moveColumn(column, finalIndex) {
    return this.moveColumns([column], finalIndex);
  }
  /**
   * Moves a multiple columns.
   *
   * @param {Array} columns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @fires Hooks#beforeColumnMove
   * @fires Hooks#afterColumnMove
   * @returns {boolean}
   */
  moveColumns(columns, finalIndex) {
    const priv = privatePool15.get(this);
    const dropIndex = priv.cachedDropIndex;
    const movePossible = this.isMovePossible(columns, finalIndex);
    const beforeMoveHook = this.hot.runHooks("beforeColumnMove", columns, finalIndex, dropIndex, movePossible);
    priv.cachedDropIndex = void 0;
    if (beforeMoveHook === false) {
      return;
    }
    if (movePossible) {
      this.hot.columnIndexMapper.moveIndexes(columns, finalIndex);
    }
    const movePerformed = movePossible && this.isColumnOrderChanged(columns, finalIndex);
    this.hot.runHooks("afterColumnMove", columns, finalIndex, dropIndex, movePossible, movePerformed);
    return movePerformed;
  }
  /**
   * Drag a single column to drop index position.
   *
   * @param {number} column Visual column index to be dragged.
   * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.
   * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @fires Hooks#beforeColumnMove
   * @fires Hooks#afterColumnMove
   * @returns {boolean}
   */
  dragColumn(column, dropIndex) {
    return this.dragColumns([column], dropIndex);
  }
  /**
   * Drag multiple columns to drop index position.
   *
   * @param {Array} columns Array of visual column indexes to be dragged.
   * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.
   * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @fires Hooks#beforeColumnMove
   * @fires Hooks#afterColumnMove
   * @returns {boolean}
   */
  dragColumns(columns, dropIndex) {
    const finalIndex = this.countFinalIndex(columns, dropIndex);
    const priv = privatePool15.get(this);
    priv.cachedDropIndex = dropIndex;
    return this.moveColumns(columns, finalIndex);
  }
  /**
   * Indicates if it's possible to move columns to the desired position. Some of the actions aren't
   * possible, i.e. You can’t move more than one element to the last position.
   *
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @returns {boolean}
   */
  isMovePossible(movedColumns, finalIndex) {
    const length = this.hot.columnIndexMapper.getNotTrimmedIndexesLength();
    const tooHighDestinationIndex = movedColumns.length + finalIndex > length;
    const tooLowDestinationIndex = finalIndex < 0;
    const tooLowMovedColumnIndex = movedColumns.some((movedColumn) => movedColumn < 0);
    const tooHighMovedColumnIndex = movedColumns.some((movedColumn) => movedColumn >= length);
    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedColumnIndex || tooHighMovedColumnIndex) {
      return false;
    }
    return true;
  }
  /**
   * Indicates if order of columns was changed.
   *
   * @private
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @returns {boolean}
   */
  isColumnOrderChanged(movedColumns, finalIndex) {
    return movedColumns.some((column, nrOfMovedElement) => column - nrOfMovedElement !== finalIndex);
  }
  /**
   * Count the final column index from the drop index.
   *
   * @private
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} dropIndex Visual column index, being a drop index for the moved columns.
   * @returns {number} Visual column index, being a start index for the moved columns.
   */
  countFinalIndex(movedColumns, dropIndex) {
    const numberOfColumnsLowerThanDropIndex = arrayReduce(movedColumns, (numberOfColumns, currentColumnIndex) => {
      if (currentColumnIndex < dropIndex) {
        numberOfColumns += 1;
      }
      return numberOfColumns;
    }, 0);
    return dropIndex - numberOfColumnsLowerThanDropIndex;
  }
  /**
   * Gets the sum of the widths of columns in the provided range.
   *
   * @private
   * @param {number} fromColumn Visual column index.
   * @param {number} toColumn Visual column index.
   * @returns {number}
   */
  getColumnsWidth(fromColumn, toColumn) {
    const columnMapper = this.hot.columnIndexMapper;
    let columnsWidth = 0;
    for (let visualColumnIndex = fromColumn; visualColumnIndex <= toColumn; visualColumnIndex += 1) {
      const renderableIndex = columnMapper.getRenderableFromVisualIndex(visualColumnIndex);
      if (visualColumnIndex < 0) {
        columnsWidth += this.hot.view._wt.wtViewport.getRowHeaderWidth() || 0;
      } else if (renderableIndex !== null) {
        columnsWidth += this.hot.view._wt.wtTable.getStretchedColumnWidth(renderableIndex) || 0;
      }
    }
    return columnsWidth;
  }
  /**
   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.
   *
   * @private
   */
  moveBySettingsOrLoad() {
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY21];
    if (Array.isArray(pluginSettings)) {
      this.moveColumns(pluginSettings, 0);
    } else if (pluginSettings !== void 0) {
      const persistentState = this.persistentStateLoad();
      if (persistentState.length) {
        this.moveColumns(persistentState, 0);
      }
    }
  }
  /**
   * Checks if the provided column is in the fixedColumnsTop section.
   *
   * @private
   * @param {number} column Visual column index to check.
   * @returns {boolean}
   */
  isFixedColumnsStart(column) {
    return column < this.hot.getSettings().fixedColumnsStart;
  }
  /**
   * Saves the manual column positions to the persistent state (the {@link Options#persistentState} option has to be enabled).
   *
   * @private
   * @fires Hooks#persistentStateSave
   */
  persistentStateSave() {
    this.hot.runHooks("persistentStateSave", "manualColumnMove", this.hot.columnIndexMapper.getIndexesSequence());
  }
  /**
   * Loads the manual column positions from the persistent state (the {@link Options#persistentState} option has to be enabled).
   *
   * @private
   * @fires Hooks#persistentStateLoad
   * @returns {Array} Stored state.
   */
  persistentStateLoad() {
    const storedState = {};
    this.hot.runHooks("persistentStateLoad", "manualColumnMove", storedState);
    return storedState.value ? storedState.value : [];
  }
  /**
   * Prepares an array of indexes based on actual selection.
   *
   * @private
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array}
   */
  prepareColumnsToMoving(start, end) {
    const selectedColumns = [];
    rangeEach(start, end, (i) => {
      selectedColumns.push(i);
    });
    return selectedColumns;
  }
  /**
   * Update the UI visual position.
   *
   * @private
   */
  refreshPositions() {
    const priv = privatePool15.get(this);
    const firstVisible = this.hot.view.getFirstFullyVisibleColumn();
    if (this.isFixedColumnsStart(priv.hoveredColumn) && firstVisible > 0) {
      this.hot.scrollViewportTo(void 0, this.hot.columnIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));
    }
    const wtTable = this.hot.view._wt.wtTable;
    const scrollableElement = this.hot.view._wt.wtOverlays.scrollableElement;
    const scrollStart = typeof scrollableElement.scrollX === "number" ? scrollableElement.scrollX : scrollableElement.scrollLeft;
    let tdOffsetStart = this.hot.view.THEAD.offsetLeft + this.getColumnsWidth(0, priv.hoveredColumn - 1);
    const hiderWidth = wtTable.hider.offsetWidth;
    const tbodyOffsetLeft = wtTable.TBODY.offsetLeft;
    const backlightElemMarginStart = this.backlight.getOffset().start;
    const backlightElemWidth = this.backlight.getSize().width;
    let rowHeaderWidth = 0;
    let mouseOffsetStart = 0;
    if (this.hot.isRtl()) {
      const rootWindow = this.hot.rootWindow;
      const containerWidth = outerWidth(this.hot.rootElement);
      const gridMostRightPos = rootWindow.innerWidth - priv.rootElementOffset - containerWidth;
      mouseOffsetStart = rootWindow.innerWidth - priv.target.eventPageX - gridMostRightPos - (scrollableElement.scrollX === void 0 ? scrollStart : 0);
    } else {
      mouseOffsetStart = priv.target.eventPageX - (priv.rootElementOffset - (scrollableElement.scrollX === void 0 ? scrollStart : 0));
    }
    if (priv.hasRowHeaders) {
      rowHeaderWidth = this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.wtTable.getColumnHeader(-1).offsetWidth;
    }
    if (this.isFixedColumnsStart(priv.hoveredColumn)) {
      tdOffsetStart += scrollStart;
    }
    tdOffsetStart += rowHeaderWidth;
    if (priv.hoveredColumn < 0) {
      if (priv.fixedColumnsStart > 0) {
        priv.target.col = 0;
      } else {
        priv.target.col = firstVisible > 0 ? firstVisible - 1 : firstVisible;
      }
    } else if (priv.target.TD.offsetWidth / 2 + tdOffsetStart <= mouseOffsetStart) {
      const newCoordsCol = priv.hoveredColumn >= priv.countCols ? priv.countCols - 1 : priv.hoveredColumn;
      priv.target.col = newCoordsCol + 1;
      tdOffsetStart += priv.target.TD.offsetWidth;
    } else {
      priv.target.col = priv.hoveredColumn;
    }
    let backlightStart = mouseOffsetStart;
    let guidelineStart = tdOffsetStart;
    if (mouseOffsetStart + backlightElemWidth + backlightElemMarginStart >= hiderWidth) {
      backlightStart = hiderWidth - backlightElemWidth - backlightElemMarginStart;
    } else if (mouseOffsetStart + backlightElemMarginStart < tbodyOffsetLeft + rowHeaderWidth) {
      backlightStart = tbodyOffsetLeft + rowHeaderWidth + Math.abs(backlightElemMarginStart);
    }
    if (tdOffsetStart >= hiderWidth - 1) {
      guidelineStart = hiderWidth - 1;
    } else if (guidelineStart === 0) {
      guidelineStart = 1;
    } else if (scrollableElement.scrollX !== void 0 && priv.hoveredColumn < priv.fixedColumnsStart) {
      guidelineStart -= priv.rootElementOffset <= scrollableElement.scrollX ? priv.rootElementOffset : 0;
    }
    this.backlight.setPosition(null, backlightStart);
    this.guideline.setPosition(null, guidelineStart);
  }
  /**
   * Binds the events used by the plugin.
   *
   * @private
   */
  registerEvents() {
    const {
      documentElement
    } = this.hot.rootDocument;
    this.eventManager.addEventListener(documentElement, "mousemove", (event2) => this.onMouseMove(event2));
    this.eventManager.addEventListener(documentElement, "mouseup", () => this.onMouseUp());
  }
  /**
   * Unbinds the events used by the plugin.
   *
   * @private
   */
  unregisterEvents() {
    this.eventManager.clear();
  }
  /**
   * Change the behavior of selection / dragging.
   *
   * @private
   * @param {MouseEvent} event `mousedown` event properties.
   * @param {CellCoords} coords Visual cell coordinates where was fired event.
   * @param {HTMLElement} TD Cell represented as HTMLElement.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  onBeforeOnCellMouseDown(event2, coords, TD, controller) {
    const wtTable = this.hot.view._wt.wtTable;
    const isHeaderSelection = this.hot.selection.isSelectedByColumnHeader();
    const selection = this.hot.getSelectedRangeLast();
    const priv = privatePool15.get(this);
    const isSortingElement = hasClass(event2.target, "sortAction");
    if (!selection || !isHeaderSelection || priv.pressed || event2.button !== 0 || isSortingElement) {
      priv.pressed = false;
      priv.columnsToMove.length = 0;
      removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);
      return;
    }
    const guidelineIsNotReady = this.guideline.isBuilt() && !this.guideline.isAppended();
    const backlightIsNotReady = this.backlight.isBuilt() && !this.backlight.isAppended();
    if (guidelineIsNotReady && backlightIsNotReady) {
      this.guideline.appendTo(wtTable.hider);
      this.backlight.appendTo(wtTable.hider);
    }
    const {
      from: from2,
      to: to2
    } = selection;
    const start = Math.min(from2.col, to2.col);
    const end = Math.max(from2.col, to2.col);
    if (coords.row < 0 && coords.col >= start && coords.col <= end) {
      controller.column = true;
      priv.pressed = true;
      priv.target.eventPageX = event2.pageX;
      priv.target.eventOffsetX = event2.offsetX;
      priv.hoveredColumn = coords.col;
      priv.target.TD = TD;
      priv.target.col = coords.col;
      priv.columnsToMove = this.prepareColumnsToMoving(start, end);
      priv.hasRowHeaders = !!this.hot.getSettings().rowHeaders;
      priv.countCols = this.hot.countCols();
      priv.fixedColumnsStart = this.hot.getSettings().fixedColumnsStart;
      priv.rootElementOffset = offset2(this.hot.rootElement).left;
      const countColumnsFrom = priv.hasRowHeaders ? -1 : 0;
      const topPos = wtTable.holder.scrollTop + wtTable.getColumnHeaderHeight(0) + 1;
      const fixedColumnsStart = coords.col < priv.fixedColumnsStart;
      const horizontalScrollPosition = Math.abs(this.hot.view._wt.wtOverlays.inlineStartOverlay.getScrollPosition());
      const offsetX = Math.abs(event2.offsetX - (this.hot.isRtl() ? event2.target.offsetWidth : 0));
      const inlineOffset = this.getColumnsWidth(start, coords.col - 1) + offsetX;
      const inlinePos = this.getColumnsWidth(countColumnsFrom, start - 1) + (fixedColumnsStart ? horizontalScrollPosition : 0) + inlineOffset;
      this.backlight.setPosition(topPos, inlinePos);
      this.backlight.setSize(this.getColumnsWidth(start, end), wtTable.hider.offsetHeight - topPos);
      this.backlight.setOffset(null, -inlineOffset);
      addClass(this.hot.rootElement, CSS_ON_MOVING);
    } else {
      removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);
      priv.pressed = false;
      priv.columnsToMove.length = 0;
    }
  }
  /**
   * 'mouseMove' event callback. Fired when pointer move on document.documentElement.
   *
   * @private
   * @param {MouseEvent} event `mousemove` event properties.
   */
  onMouseMove(event2) {
    const priv = privatePool15.get(this);
    if (!priv.pressed) {
      return;
    }
    if (event2.target === this.backlight.element) {
      const width = this.backlight.getSize().width;
      this.backlight.setSize(0);
      setTimeout(function() {
        this.backlight.setPosition(width);
      });
    }
    priv.target.eventPageX = event2.pageX;
    this.refreshPositions();
  }
  /**
   * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.
   *
   * @private
   * @param {MouseEvent} event `mouseover` event properties.
   * @param {CellCoords} coords Visual cell coordinates where was fired event.
   * @param {HTMLElement} TD Cell represented as HTMLElement.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  onBeforeOnCellMouseOver(event2, coords, TD, controller) {
    const selectedRange = this.hot.getSelectedRangeLast();
    const priv = privatePool15.get(this);
    if (!selectedRange || !priv.pressed) {
      return;
    }
    if (priv.columnsToMove.indexOf(coords.col) > -1) {
      removeClass(this.hot.rootElement, CSS_SHOW_UI);
    } else {
      addClass(this.hot.rootElement, CSS_SHOW_UI);
    }
    controller.row = true;
    controller.column = true;
    controller.cell = true;
    priv.hoveredColumn = coords.col;
    priv.target.TD = TD;
  }
  /**
   * `onMouseUp` hook callback.
   *
   * @private
   */
  onMouseUp() {
    const priv = privatePool15.get(this);
    const target = priv.target.col;
    const columnsLen = priv.columnsToMove.length;
    priv.hoveredColumn = void 0;
    priv.pressed = false;
    priv.backlightWidth = 0;
    removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);
    if (this.hot.selection.isSelectedByColumnHeader()) {
      addClass(this.hot.rootElement, CSS_AFTER_SELECTION);
    }
    if (columnsLen < 1 || target === void 0) {
      return;
    }
    const firstMovedVisualColumn = priv.columnsToMove[0];
    const firstMovedPhysicalColumn = this.hot.toPhysicalColumn(firstMovedVisualColumn);
    const movePerformed = this.dragColumns(priv.columnsToMove, target);
    priv.columnsToMove.length = 0;
    if (movePerformed === true) {
      this.persistentStateSave();
      this.hot.render();
      this.hot.view.adjustElementsSize(true);
      const selectionStart = this.hot.toVisualColumn(firstMovedPhysicalColumn);
      const selectionEnd = selectionStart + columnsLen - 1;
      this.hot.selectColumns(selectionStart, selectionEnd);
    }
  }
  /**
   * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.
   *
   * @private
   */
  onAfterScrollVertically() {
    const wtTable = this.hot.view._wt.wtTable;
    const headerHeight = wtTable.getColumnHeaderHeight(0) + 1;
    const scrollTop = wtTable.holder.scrollTop;
    const posTop = headerHeight + scrollTop;
    this.backlight.setPosition(posTop);
    this.backlight.setSize(null, wtTable.hider.offsetHeight - posTop);
  }
  /**
   * Builds the plugin's UI.
   *
   * @private
   */
  buildPluginUI() {
    this.backlight.build();
    this.guideline.build();
  }
  /**
   * Callback for the `afterLoadData` hook.
   *
   * @private
   */
  onAfterLoadData() {
    this.moveBySettingsOrLoad();
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.backlight.destroy();
    this.guideline.destroy();
    super.destroy();
  }
};

// node_modules/handsontable/plugins/manualColumnResize/manualColumnResize.mjs
var PLUGIN_KEY22 = "manualColumnResize";
var PLUGIN_PRIORITY21 = 130;
var PERSISTENT_STATE_KEY = "manualColumnWidths";
var privatePool16 = /* @__PURE__ */ new WeakMap();
var ManualColumnResize = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY22;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY21;
  }
  constructor(hotInstance) {
    super(hotInstance);
    const {
      rootDocument
    } = this.hot;
    this.currentTH = null;
    this.currentCol = null;
    this.selectedCols = [];
    this.currentWidth = null;
    this.newSize = null;
    this.startY = null;
    this.startWidth = null;
    this.startOffset = null;
    this.handle = rootDocument.createElement("DIV");
    this.guide = rootDocument.createElement("DIV");
    this.eventManager = new eventManager_default(this);
    this.pressed = null;
    this.isTriggeredByRMB = false;
    this.dblclick = 0;
    this.autoresizeTimeout = null;
    this.columnWidthsMap = void 0;
    privatePool16.set(this, {
      config: void 0
    });
    addClass(this.handle, "manualColumnResizer");
    addClass(this.guide, "manualColumnResizerGuide");
  }
  /**
   * @private
   * @returns {string}
   */
  get inlineDir() {
    return this.hot.isRtl() ? "right" : "left";
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualColumnResize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY22];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.columnWidthsMap = new PhysicalIndexToValueMap();
    this.columnWidthsMap.addLocalHook("init", () => this.onMapInit());
    this.hot.columnIndexMapper.registerMap(this.pluginName, this.columnWidthsMap);
    this.addHook("modifyColWidth", (width, col) => this.onModifyColWidth(width, col));
    this.addHook("beforeStretchingColumnWidth", (stretchedWidth, column) => this.onBeforeStretchingColumnWidth(stretchedWidth, column));
    this.addHook("beforeColumnResize", (newSize, column, isDoubleClick) => this.onBeforeColumnResize(newSize, column, isDoubleClick));
    this.bindEvents();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualColumnResize`](@/api/options.md#manualcolumnresize)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    const priv = privatePool16.get(this);
    priv.config = this.columnWidthsMap.getValues();
    this.hot.columnIndexMapper.unregisterMap(this.pluginName);
    super.disablePlugin();
  }
  /**
   * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
   *
   * @fires Hooks#persistentStateSave
   */
  saveManualColumnWidths() {
    this.hot.runHooks("persistentStateSave", PERSISTENT_STATE_KEY, this.columnWidthsMap.getValues());
  }
  /**
   * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
   *
   * @returns {Array}
   * @fires Hooks#persistentStateLoad
   */
  loadManualColumnWidths() {
    const storedState = {};
    this.hot.runHooks("persistentStateLoad", PERSISTENT_STATE_KEY, storedState);
    return storedState.value;
  }
  /**
   * Sets the new width for specified column index.
   *
   * @param {number} column Visual column index.
   * @param {number} width Column width (no less than 20px).
   * @returns {number} Returns new width.
   */
  setManualSize(column, width) {
    const newWidth = Math.max(width, 20);
    const physicalColumn = this.hot.toPhysicalColumn(column);
    this.columnWidthsMap.setValueAtIndex(physicalColumn, newWidth);
    return newWidth;
  }
  /**
   * Clears the cache for the specified column index.
   *
   * @param {number} column Visual column index.
   */
  clearManualSize(column) {
    const physicalColumn = this.hot.toPhysicalColumn(column);
    this.columnWidthsMap.setValueAtIndex(physicalColumn, null);
  }
  /**
   * Callback to call on map's `init` local hook.
   *
   * @private
   */
  onMapInit() {
    const priv = privatePool16.get(this);
    const initialSetting = this.hot.getSettings()[PLUGIN_KEY22];
    const loadedManualColumnWidths = this.loadManualColumnWidths();
    if (typeof loadedManualColumnWidths !== "undefined") {
      this.hot.batchExecution(() => {
        loadedManualColumnWidths.forEach((width, physicalIndex) => {
          this.columnWidthsMap.setValueAtIndex(physicalIndex, width);
        });
      }, true);
    } else if (Array.isArray(initialSetting)) {
      this.hot.batchExecution(() => {
        initialSetting.forEach((width, physicalIndex) => {
          this.columnWidthsMap.setValueAtIndex(physicalIndex, width);
        });
      }, true);
      priv.config = initialSetting;
    } else if (initialSetting === true && Array.isArray(priv.config)) {
      this.hot.batchExecution(() => {
        priv.config.forEach((width, physicalIndex) => {
          this.columnWidthsMap.setValueAtIndex(physicalIndex, width);
        });
      }, true);
    }
  }
  /**
   * Set the resize handle position.
   *
   * @private
   * @param {HTMLCellElement} TH TH HTML element.
   */
  setupHandlePosition(TH) {
    if (!TH.parentNode) {
      return;
    }
    this.currentTH = TH;
    const {
      _wt: wt
    } = this.hot.view;
    const cellCoords = wt.wtTable.getCoords(this.currentTH);
    const col = cellCoords.col;
    if (col < 0) {
      return;
    }
    const headerHeight = outerHeight(this.currentTH);
    const box = this.currentTH.getBoundingClientRect();
    const fixedColumn = col < wt.getSetting("fixedColumnsStart");
    let relativeHeaderPosition;
    if (fixedColumn) {
      relativeHeaderPosition = wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
    }
    if (!relativeHeaderPosition) {
      relativeHeaderPosition = wt.wtOverlays.topOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
    }
    this.currentCol = this.hot.columnIndexMapper.getVisualFromRenderableIndex(col);
    this.selectedCols = [];
    const isFullColumnSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByColumnHeader();
    if (this.hot.selection.isSelected() && isFullColumnSelected) {
      const selectionRanges = this.hot.getSelectedRange();
      arrayEach(selectionRanges, (selectionRange) => {
        const fromColumn = selectionRange.getTopStartCorner().col;
        const toColumn = selectionRange.getBottomEndCorner().col;
        rangeEach(fromColumn, toColumn, (columnIndex) => {
          if (!this.selectedCols.includes(columnIndex)) {
            this.selectedCols.push(columnIndex);
          }
        });
      });
    }
    if (!this.selectedCols.includes(this.currentCol)) {
      this.selectedCols = [this.currentCol];
    }
    this.startOffset = relativeHeaderPosition.start - 6;
    this.startWidth = parseInt(box.width, 10);
    this.handle.style.top = `${relativeHeaderPosition.top}px`;
    this.handle.style[this.inlineDir] = `${this.startOffset + this.startWidth}px`;
    this.handle.style.height = `${headerHeight}px`;
    this.hot.rootElement.appendChild(this.handle);
  }
  /**
   * Refresh the resize handle position.
   *
   * @private
   */
  refreshHandlePosition() {
    this.handle.style[this.inlineDir] = `${this.startOffset + this.currentWidth}px`;
  }
  /**
   * Sets the resize guide position.
   *
   * @private
   */
  setupGuidePosition() {
    const handleHeight = parseInt(outerHeight(this.handle), 10);
    const handleBottomPosition = parseInt(this.handle.style.top, 10) + handleHeight;
    const maximumVisibleElementHeight = parseInt(this.hot.view.maximumVisibleElementHeight(0), 10);
    addClass(this.handle, "active");
    addClass(this.guide, "active");
    this.guide.style.top = `${handleBottomPosition}px`;
    this.refreshGuidePosition();
    this.guide.style.height = `${maximumVisibleElementHeight - handleHeight}px`;
    this.hot.rootElement.appendChild(this.guide);
  }
  /**
   * Refresh the resize guide position.
   *
   * @private
   */
  refreshGuidePosition() {
    this.guide.style[this.inlineDir] = this.handle.style[this.inlineDir];
  }
  /**
   * Hides both the resize handle and resize guide.
   *
   * @private
   */
  hideHandleAndGuide() {
    removeClass(this.handle, "active");
    removeClass(this.guide, "active");
  }
  /**
   * Checks if provided element is considered a column header.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {boolean}
   */
  checkIfColumnHeader(element) {
    return !!closest(element, ["THEAD"], this.hot.rootElement);
  }
  /**
   * Gets the TH element from the provided element.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {HTMLElement}
   */
  getClosestTHParent(element) {
    if (element.tagName !== "TABLE") {
      if (element.tagName === "TH") {
        return element;
      }
      return this.getClosestTHParent(element.parentNode);
    }
    return null;
  }
  /**
   * 'mouseover' event callback - set the handle position.
   *
   * @private
   * @param {MouseEvent} event The mouse event.
   */
  onMouseOver(event2) {
    if (isDetached(event2.target)) {
      return;
    }
    if (this.isTriggeredByRMB === true) {
      return;
    }
    if (this.checkIfColumnHeader(event2.target)) {
      const th = this.getClosestTHParent(event2.target);
      if (!th) {
        return;
      }
      const colspan = th.getAttribute("colspan");
      if (th && (colspan === null || colspan === "1")) {
        if (!this.pressed) {
          this.setupHandlePosition(th);
        }
      }
    }
  }
  /**
   * Auto-size row after doubleclick - callback.
   *
   * @private
   * @fires Hooks#beforeColumnResize
   * @fires Hooks#afterColumnResize
   */
  afterMouseDownTimeout() {
    const render = () => {
      this.hot.forceFullRender = true;
      this.hot.view.render();
      this.hot.view.adjustElementsSize(true);
    };
    const resize = (column, forceRender) => {
      const hookNewSize = this.hot.runHooks("beforeColumnResize", this.newSize, column, true);
      if (hookNewSize !== void 0) {
        this.newSize = hookNewSize;
      }
      if (this.hot.getSettings().stretchH === "all") {
        this.clearManualSize(column);
      } else {
        this.setManualSize(column, this.newSize);
      }
      this.saveManualColumnWidths();
      this.hot.runHooks("afterColumnResize", this.newSize, column, true);
      if (forceRender) {
        render();
      }
    };
    if (this.dblclick >= 2) {
      const selectedColsLength = this.selectedCols.length;
      if (selectedColsLength > 1) {
        arrayEach(this.selectedCols, (selectedCol) => {
          resize(selectedCol);
        });
        render();
      } else {
        arrayEach(this.selectedCols, (selectedCol) => {
          resize(selectedCol, true);
        });
      }
    }
    this.dblclick = 0;
    this.autoresizeTimeout = null;
  }
  /**
   * 'mousedown' event callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event.
   */
  onMouseDown(event2) {
    if (hasClass(event2.target, "manualColumnResizer")) {
      this.setupHandlePosition(this.currentTH);
      this.setupGuidePosition();
      this.pressed = true;
      if (this.autoresizeTimeout === null) {
        this.autoresizeTimeout = setTimeout(() => this.afterMouseDownTimeout(), 500);
        this.hot._registerTimeout(this.autoresizeTimeout);
      }
      this.dblclick += 1;
      this.startX = event2.pageX;
      this.newSize = this.startWidth;
    }
  }
  /**
   * 'mousemove' event callback - refresh the handle and guide positions, cache the new column width.
   *
   * @private
   * @param {MouseEvent} event The mouse event.
   */
  onMouseMove(event2) {
    if (this.pressed) {
      const change = (event2.pageX - this.startX) * this.hot.getDirectionFactor();
      this.currentWidth = this.startWidth + change;
      arrayEach(this.selectedCols, (selectedCol) => {
        this.newSize = this.setManualSize(selectedCol, this.currentWidth);
      });
      this.refreshHandlePosition();
      this.refreshGuidePosition();
    }
  }
  /**
   * 'mouseup' event callback - apply the column resizing.
   *
   * @private
   *
   * @fires Hooks#beforeColumnResize
   * @fires Hooks#afterColumnResize
   */
  onMouseUp() {
    const render = () => {
      this.hot.forceFullRender = true;
      this.hot.view.render();
      this.hot.view.adjustElementsSize(true);
    };
    const resize = (column, forceRender) => {
      this.hot.runHooks("beforeColumnResize", this.newSize, column, false);
      if (forceRender) {
        render();
      }
      this.saveManualColumnWidths();
      this.hot.runHooks("afterColumnResize", this.newSize, column, false);
    };
    if (this.pressed) {
      this.hideHandleAndGuide();
      this.pressed = false;
      if (this.newSize !== this.startWidth) {
        const selectedColsLength = this.selectedCols.length;
        if (selectedColsLength > 1) {
          arrayEach(this.selectedCols, (selectedCol) => {
            resize(selectedCol);
          });
          render();
        } else {
          arrayEach(this.selectedCols, (selectedCol) => {
            resize(selectedCol, true);
          });
        }
      }
      this.setupHandlePosition(this.currentTH);
    }
  }
  /**
   * Callback for "contextmenu" event triggered on element showing move handle. It removes handle and guide elements.
   *
   * @private
   */
  onContextMenu() {
    this.hideHandleAndGuide();
    this.hot.rootElement.removeChild(this.handle);
    this.hot.rootElement.removeChild(this.guide);
    this.pressed = false;
    this.isTriggeredByRMB = true;
    this.hot._registerImmediate(() => {
      this.isTriggeredByRMB = false;
    });
  }
  /**
   * Binds the mouse events.
   *
   * @private
   */
  bindEvents() {
    const {
      rootWindow,
      rootElement
    } = this.hot;
    this.eventManager.addEventListener(rootElement, "mouseover", (e) => this.onMouseOver(e));
    this.eventManager.addEventListener(rootElement, "mousedown", (e) => this.onMouseDown(e));
    this.eventManager.addEventListener(rootWindow, "mousemove", (e) => this.onMouseMove(e));
    this.eventManager.addEventListener(rootWindow, "mouseup", () => this.onMouseUp());
    this.eventManager.addEventListener(this.handle, "contextmenu", () => this.onContextMenu());
  }
  /**
   * Modifies the provided column width, based on the plugin settings.
   *
   * @private
   * @param {number} width Column width.
   * @param {number} column Visual column index.
   * @returns {number}
   */
  onModifyColWidth(width, column) {
    let newWidth = width;
    if (this.enabled) {
      const physicalColumn = this.hot.toPhysicalColumn(column);
      const columnWidth = this.columnWidthsMap.getValueAtIndex(physicalColumn);
      if (this.hot.getSettings()[PLUGIN_KEY22] && columnWidth) {
        newWidth = columnWidth;
      }
    }
    return newWidth;
  }
  /**
   * Modifies the provided column stretched width. This hook decides if specified column should be stretched or not.
   *
   * @private
   * @param {number} stretchedWidth Stretched width.
   * @param {number} column Visual column index.
   * @returns {number}
   */
  onBeforeStretchingColumnWidth(stretchedWidth, column) {
    let width = this.columnWidthsMap.getValueAtIndex(column);
    if (width === null) {
      width = stretchedWidth;
    }
    return width;
  }
  /**
   * `beforeColumnResize` hook callback.
   *
   * @private
   */
  onBeforeColumnResize() {
    this.hot.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/manualRowMove/ui/_base.mjs
var STATE_INITIALIZED2 = 0;
var STATE_BUILT3 = 1;
var STATE_APPENDED2 = 2;
var UNIT2 = "px";
var BaseUI3 = class {
  constructor(hotInstance) {
    this.hot = hotInstance;
    this._element = null;
    this.state = STATE_INITIALIZED2;
  }
  /**
   * Add created UI elements to table.
   *
   * @param {HTMLElement} wrapper Element which are parent for our UI element.
   */
  appendTo(wrapper) {
    wrapper.appendChild(this._element);
    this.state = STATE_APPENDED2;
  }
  /**
   * Method for create UI element. Only create, without append to table.
   */
  build() {
    if (this.state !== STATE_INITIALIZED2) {
      return;
    }
    this._element = this.hot.rootDocument.createElement("div");
    this.state = STATE_BUILT3;
  }
  /**
   * Method for remove UI element.
   */
  destroy() {
    if (this.isAppended()) {
      this._element.parentElement.removeChild(this._element);
    }
    this._element = null;
    this.state = STATE_INITIALIZED2;
  }
  /**
   * Check if UI element are appended.
   *
   * @returns {boolean}
   */
  isAppended() {
    return this.state === STATE_APPENDED2;
  }
  /**
   * Check if UI element are built.
   *
   * @returns {boolean}
   */
  isBuilt() {
    return this.state >= STATE_BUILT3;
  }
  /**
   * Setter for position.
   *
   * @param {number} top New top position of the element.
   * @param {number} left New left position of the element.
   */
  setPosition(top2, left2) {
    if (top2 !== void 0) {
      this._element.style.top = top2 + UNIT2;
    }
    if (left2 !== void 0) {
      this._element.style.left = left2 + UNIT2;
    }
  }
  /**
   * Getter for the element position.
   *
   * @returns {object} Object contains left and top position of the element.
   */
  getPosition() {
    return {
      top: this._element.style.top ? parseInt(this._element.style.top, 10) : 0,
      left: this._element.style.left ? parseInt(this._element.style.left, 10) : 0
    };
  }
  /**
   * Setter for the element size.
   *
   * @param {number} width New width of the element.
   * @param {number} height New height of the element.
   */
  setSize(width, height) {
    if (width) {
      this._element.style.width = width + UNIT2;
    }
    if (height) {
      this._element.style.height = height + UNIT2;
    }
  }
  /**
   * Getter for the element position.
   *
   * @returns {object} Object contains height and width of the element.
   */
  getSize() {
    return {
      width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
      height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
    };
  }
  /**
   * Setter for the element offset. Offset means marginTop and marginLeft of the element.
   *
   * @param {number} top New margin top of the element.
   * @param {number} left New margin left of the element.
   */
  setOffset(top2, left2) {
    if (top2) {
      this._element.style.marginTop = top2 + UNIT2;
    }
    if (left2) {
      this._element.style.marginLeft = left2 + UNIT2;
    }
  }
  /**
   * Getter for the element offset.
   *
   * @returns {object} Object contains top and left offset of the element.
   */
  getOffset() {
    return {
      top: this._element.style.marginTop ? parseInt(this._element.style.marginTop, 10) : 0,
      left: this._element.style.marginLeft ? parseInt(this._element.style.marginLeft, 10) : 0
    };
  }
};
var base_default6 = BaseUI3;

// node_modules/handsontable/plugins/manualRowMove/ui/backlight.mjs
var CSS_CLASSNAME3 = "ht__manualRowMove--backlight";
var BacklightUI2 = class extends base_default6 {
  /**
   * Custom className on build process.
   */
  build() {
    super.build();
    addClass(this._element, CSS_CLASSNAME3);
  }
};
var backlight_default2 = BacklightUI2;

// node_modules/handsontable/plugins/manualRowMove/ui/guideline.mjs
var CSS_CLASSNAME4 = "ht__manualRowMove--guideline";
var GuidelineUI2 = class extends base_default6 {
  /**
   * Custom className on build process.
   */
  build() {
    super.build();
    addClass(this._element, CSS_CLASSNAME4);
  }
};
var guideline_default2 = GuidelineUI2;

// node_modules/handsontable/plugins/manualRowMove/manualRowMove.mjs
pluginHooks_default.getSingleton().register("beforeRowMove");
pluginHooks_default.getSingleton().register("afterRowMove");
var PLUGIN_KEY23 = "manualRowMove";
var PLUGIN_PRIORITY22 = 140;
var privatePool17 = /* @__PURE__ */ new WeakMap();
var CSS_PLUGIN2 = "ht__manualRowMove";
var CSS_SHOW_UI2 = "show-ui";
var CSS_ON_MOVING2 = "on-moving--rows";
var CSS_AFTER_SELECTION2 = "after-selection--rows";
var ManualRowMove = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY23;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY22;
  }
  constructor(hotInstance) {
    super(hotInstance);
    privatePool17.set(this, {
      rowsToMove: [],
      pressed: void 0,
      target: {
        eventPageY: void 0,
        coords: void 0,
        TD: void 0,
        row: void 0
      },
      cachedDropIndex: void 0
    });
    this.eventManager = new eventManager_default(this);
    this.backlight = new backlight_default2(hotInstance);
    this.guideline = new guideline_default2(hotInstance);
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualRowMove#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY23];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.addHook("beforeOnCellMouseDown", function() {
      return _this.onBeforeOnCellMouseDown(...arguments);
    });
    this.addHook("beforeOnCellMouseOver", function() {
      return _this.onBeforeOnCellMouseOver(...arguments);
    });
    this.addHook("afterScrollHorizontally", () => this.onAfterScrollHorizontally());
    this.addHook("afterLoadData", function() {
      return _this.onAfterLoadData(...arguments);
    });
    this.buildPluginUI();
    this.registerEvents();
    addClass(this.hot.rootElement, CSS_PLUGIN2);
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualRowMove`](@/api/options.md#manualrowmove)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    this.moveBySettingsOrLoad();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    removeClass(this.hot.rootElement, CSS_PLUGIN2);
    this.unregisterEvents();
    this.backlight.destroy();
    this.guideline.destroy();
    super.disablePlugin();
  }
  /**
   * Moves a single row.
   *
   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).
   *
   * @param {number} row Visual row index to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @fires Hooks#beforeRowMove
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  moveRow(row, finalIndex) {
    return this.moveRows([row], finalIndex);
  }
  /**
   * Moves multiple rows.
   *
   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).
   *
   * @param {Array} rows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @fires Hooks#beforeRowMove
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  moveRows(rows, finalIndex) {
    const priv = privatePool17.get(this);
    const dropIndex = priv.cachedDropIndex;
    const movePossible = this.isMovePossible(rows, finalIndex);
    const beforeMoveHook = this.hot.runHooks("beforeRowMove", rows, finalIndex, dropIndex, movePossible);
    priv.cachedDropIndex = void 0;
    if (beforeMoveHook === false) {
      return;
    }
    if (movePossible) {
      this.hot.rowIndexMapper.moveIndexes(rows, finalIndex);
    }
    const movePerformed = movePossible && this.isRowOrderChanged(rows, finalIndex);
    this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, movePerformed);
    return movePerformed;
  }
  /**
   * Drag a single row to drop index position.
   *
   * @param {number} row Visual row index to be dragged.
   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.
   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @fires Hooks#beforeRowMove
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  dragRow(row, dropIndex) {
    return this.dragRows([row], dropIndex);
  }
  /**
   * Drag multiple rows to drop index position.
   *
   * @param {Array} rows Array of visual row indexes to be dragged.
   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.
   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @fires Hooks#beforeRowMove
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  dragRows(rows, dropIndex) {
    const finalIndex = this.countFinalIndex(rows, dropIndex);
    const priv = privatePool17.get(this);
    priv.cachedDropIndex = dropIndex;
    return this.moveRows(rows, finalIndex);
  }
  /**
   * Indicates if it's possible to move rows to the desired position. Some of the actions aren't possible, i.e. You can’t move more than one element to the last position.
   *
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @returns {boolean}
   */
  isMovePossible(movedRows, finalIndex) {
    const length = this.hot.rowIndexMapper.getNotTrimmedIndexesLength();
    const tooHighDestinationIndex = movedRows.length + finalIndex > length;
    const tooLowDestinationIndex = finalIndex < 0;
    const tooLowMovedRowIndex = movedRows.some((movedRow) => movedRow < 0);
    const tooHighMovedRowIndex = movedRows.some((movedRow) => movedRow >= length);
    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedRowIndex || tooHighMovedRowIndex) {
      return false;
    }
    return true;
  }
  /**
   * Indicates if order of rows was changed.
   *
   * @private
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @returns {boolean}
   */
  isRowOrderChanged(movedRows, finalIndex) {
    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);
  }
  /**
   * Count the final row index from the drop index.
   *
   * @private
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} dropIndex Visual row index, being a drop index for the moved rows.
   * @returns {number} Visual row index, being a start index for the moved rows.
   */
  countFinalIndex(movedRows, dropIndex) {
    const numberOfRowsLowerThanDropIndex = arrayReduce(movedRows, (numberOfRows, currentRowIndex) => {
      if (currentRowIndex < dropIndex) {
        numberOfRows += 1;
      }
      return numberOfRows;
    }, 0);
    return dropIndex - numberOfRowsLowerThanDropIndex;
  }
  /**
   * Gets the sum of the heights of rows in the provided range.
   *
   * @private
   * @param {number} fromRow Visual row index.
   * @param {number} toRow Visual row index.
   * @returns {number}
   */
  getRowsHeight(fromRow, toRow) {
    const rowMapper = this.hot.rowIndexMapper;
    let rowsHeight = 0;
    for (let visualRowIndex = fromRow; visualRowIndex <= toRow; visualRowIndex++) {
      const renderableIndex = rowMapper.getRenderableFromVisualIndex(visualRowIndex);
      if (renderableIndex !== null) {
        rowsHeight += this.hot.view._wt.wtTable.getRowHeight(renderableIndex) || 23;
      }
    }
    return rowsHeight;
  }
  /**
   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.
   *
   * @private
   */
  moveBySettingsOrLoad() {
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY23];
    if (Array.isArray(pluginSettings)) {
      this.moveRows(pluginSettings, 0);
    } else if (pluginSettings !== void 0) {
      const persistentState = this.persistentStateLoad();
      if (persistentState.length) {
        this.moveRows(persistentState, 0);
      }
    }
  }
  /**
   * Checks if the provided row is in the fixedRowsTop section.
   *
   * @private
   * @param {number} row Visual row index to check.
   * @returns {boolean}
   */
  isFixedRowTop(row) {
    return row < this.hot.getSettings().fixedRowsTop;
  }
  /**
   * Checks if the provided row is in the fixedRowsBottom section.
   *
   * @private
   * @param {number} row Visual row index to check.
   * @returns {boolean}
   */
  isFixedRowBottom(row) {
    return row > this.hot.countRows() - 1 - this.hot.getSettings().fixedRowsBottom;
  }
  /**
   * Saves the manual row positions to the persistent state (the {@link Options#persistentState} option has to be enabled).
   *
   * @private
   * @fires Hooks#persistentStateSave
   */
  persistentStateSave() {
    this.hot.runHooks("persistentStateSave", "manualRowMove", this.hot.rowIndexMapper.getIndexesSequence());
  }
  /**
   * Loads the manual row positions from the persistent state (the {@link Options#persistentState} option has to be enabled).
   *
   * @private
   * @fires Hooks#persistentStateLoad
   * @returns {Array} Stored state.
   */
  persistentStateLoad() {
    const storedState = {};
    this.hot.runHooks("persistentStateLoad", "manualRowMove", storedState);
    return storedState.value ? storedState.value : [];
  }
  /**
   * Prepares an array of indexes based on actual selection.
   *
   * @private
   * @returns {Array}
   */
  prepareRowsToMoving() {
    const selection = this.hot.getSelectedRangeLast();
    const selectedRows = [];
    if (!selection) {
      return selectedRows;
    }
    const {
      from: from2,
      to: to2
    } = selection;
    const start = Math.min(from2.row, to2.row);
    const end = Math.max(from2.row, to2.row);
    rangeEach(start, end, (i) => {
      selectedRows.push(i);
    });
    return selectedRows;
  }
  /**
   * Update the UI visual position.
   *
   * @private
   */
  refreshPositions() {
    const priv = privatePool17.get(this);
    const coords = priv.target.coords;
    const firstVisible = this.hot.view.getFirstFullyVisibleRow();
    const lastVisible = this.hot.view.getLastFullyVisibleRow();
    const countRows = this.hot.countRows();
    if (this.isFixedRowTop(coords.row) && firstVisible > 0) {
      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));
    }
    if (this.isFixedRowBottom(coords.row) && lastVisible < countRows) {
      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(lastVisible + 1, 1), void 0, true);
    }
    const wtTable = this.hot.view._wt.wtTable;
    const TD = priv.target.TD;
    const rootElement = this.hot.rootElement;
    const rootElementOffset = offset2(rootElement);
    const trimmingContainer = getTrimmingContainer(rootElement);
    const tableScroll = wtTable.holder.scrollTop;
    let trimmingContainerScroll;
    if (this.hot.rootWindow === trimmingContainer) {
      trimmingContainerScroll = trimmingContainer.scrollY;
    } else {
      trimmingContainerScroll = trimmingContainer.scrollTop;
    }
    const pixelsAbove = rootElementOffset.top - trimmingContainerScroll;
    const pixelsRelToTableStart = priv.target.eventPageY - pixelsAbove + tableScroll;
    const hiderHeight = wtTable.hider.offsetHeight;
    const tbodyOffsetTop = wtTable.TBODY.offsetTop;
    const backlightElemMarginTop = this.backlight.getOffset().top;
    const backlightElemHeight = this.backlight.getSize().height;
    const tdMiddle = TD.offsetHeight / 2;
    const tdHeight = TD.offsetHeight;
    let tdStartPixel = this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row - 1);
    const isBelowTable = pixelsRelToTableStart >= tdStartPixel + tdMiddle;
    if (this.isFixedRowTop(coords.row)) {
      tdStartPixel += wtTable.holder.scrollTop;
    }
    if (coords.row < 0) {
      priv.target.row = firstVisible > 0 ? firstVisible - 1 : firstVisible;
    } else if (isBelowTable) {
      priv.target.row = coords.row + 1;
      tdStartPixel += coords.row === 0 ? tdHeight - 1 : tdHeight;
    } else {
      priv.target.row = coords.row;
    }
    let backlightTop = pixelsRelToTableStart;
    let guidelineTop = tdStartPixel;
    if (pixelsRelToTableStart + backlightElemHeight + backlightElemMarginTop >= hiderHeight) {
      backlightTop = hiderHeight - backlightElemHeight - backlightElemMarginTop;
    } else if (pixelsRelToTableStart + backlightElemMarginTop < tbodyOffsetTop) {
      backlightTop = tbodyOffsetTop + Math.abs(backlightElemMarginTop);
    }
    if (tdStartPixel >= hiderHeight - 1) {
      guidelineTop = hiderHeight - 1;
    }
    this.backlight.setPosition(backlightTop);
    this.guideline.setPosition(guidelineTop);
  }
  /**
   * Binds the events used by the plugin.
   *
   * @private
   */
  registerEvents() {
    const {
      documentElement
    } = this.hot.rootDocument;
    this.eventManager.addEventListener(documentElement, "mousemove", (event2) => this.onMouseMove(event2));
    this.eventManager.addEventListener(documentElement, "mouseup", () => this.onMouseUp());
  }
  /**
   * Unbinds the events used by the plugin.
   *
   * @private
   */
  unregisterEvents() {
    this.eventManager.clear();
  }
  /**
   * Change the behavior of selection / dragging.
   *
   * @private
   * @param {MouseEvent} event `mousedown` event properties.
   * @param {CellCoords} coords Visual cell coordinates where was fired event.
   * @param {HTMLElement} TD Cell represented as HTMLElement.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  onBeforeOnCellMouseDown(event2, coords, TD, controller) {
    const {
      wtTable,
      wtViewport
    } = this.hot.view._wt;
    const isHeaderSelection = this.hot.selection.isSelectedByRowHeader();
    const selection = this.hot.getSelectedRangeLast();
    const priv = privatePool17.get(this);
    if (!selection || !isHeaderSelection || priv.pressed || event2.button !== 0) {
      priv.pressed = false;
      priv.rowsToMove.length = 0;
      removeClass(this.hot.rootElement, [CSS_ON_MOVING2, CSS_SHOW_UI2]);
      return;
    }
    const guidelineIsNotReady = this.guideline.isBuilt() && !this.guideline.isAppended();
    const backlightIsNotReady = this.backlight.isBuilt() && !this.backlight.isAppended();
    if (guidelineIsNotReady && backlightIsNotReady) {
      this.guideline.appendTo(wtTable.hider);
      this.backlight.appendTo(wtTable.hider);
    }
    const {
      from: from2,
      to: to2
    } = selection;
    const start = Math.min(from2.row, to2.row);
    const end = Math.max(from2.row, to2.row);
    if (coords.col < 0 && coords.row >= start && coords.row <= end) {
      controller.row = true;
      priv.pressed = true;
      priv.target.eventPageY = event2.pageY;
      priv.target.coords = coords;
      priv.target.TD = TD;
      priv.rowsToMove = this.prepareRowsToMoving();
      const leftPos = wtTable.holder.scrollLeft + wtViewport.getRowHeaderWidth();
      this.backlight.setPosition(null, leftPos);
      this.backlight.setSize(wtTable.hider.offsetWidth - leftPos, this.getRowsHeight(start, end));
      this.backlight.setOffset((this.getRowsHeight(start, coords.row - 1) + event2.offsetY) * -1, null);
      addClass(this.hot.rootElement, CSS_ON_MOVING2);
      this.refreshPositions();
    } else {
      removeClass(this.hot.rootElement, CSS_AFTER_SELECTION2);
      priv.pressed = false;
      priv.rowsToMove.length = 0;
    }
  }
  /**
   * 'mouseMove' event callback. Fired when pointer move on document.documentElement.
   *
   * @private
   * @param {MouseEvent} event `mousemove` event properties.
   */
  onMouseMove(event2) {
    const priv = privatePool17.get(this);
    if (!priv.pressed) {
      return;
    }
    if (event2.target === this.backlight.element) {
      const height = this.backlight.getSize().height;
      this.backlight.setSize(null, 0);
      setTimeout(function() {
        this.backlight.setPosition(null, height);
      });
    }
    priv.target.eventPageY = event2.pageY;
    this.refreshPositions();
  }
  /**
   * 'beforeOnCellMouseOver' hook callback. Fired when pointer was over cell.
   *
   * @private
   * @param {MouseEvent} event `mouseover` event properties.
   * @param {CellCoords} coords Visual cell coordinates where was fired event.
   * @param {HTMLElement} TD Cell represented as HTMLElement.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  onBeforeOnCellMouseOver(event2, coords, TD, controller) {
    const selectedRange = this.hot.getSelectedRangeLast();
    const priv = privatePool17.get(this);
    if (!selectedRange || !priv.pressed) {
      return;
    }
    if (priv.rowsToMove.indexOf(coords.row) > -1) {
      removeClass(this.hot.rootElement, CSS_SHOW_UI2);
    } else {
      addClass(this.hot.rootElement, CSS_SHOW_UI2);
    }
    controller.row = true;
    controller.column = true;
    controller.cell = true;
    priv.target.coords = coords;
    priv.target.TD = TD;
  }
  /**
   * `onMouseUp` hook callback.
   *
   * @private
   */
  onMouseUp() {
    const priv = privatePool17.get(this);
    const target = priv.target.row;
    const rowsLen = priv.rowsToMove.length;
    priv.pressed = false;
    priv.backlightHeight = 0;
    removeClass(this.hot.rootElement, [CSS_ON_MOVING2, CSS_SHOW_UI2, CSS_AFTER_SELECTION2]);
    if (this.hot.selection.isSelectedByRowHeader()) {
      addClass(this.hot.rootElement, CSS_AFTER_SELECTION2);
    }
    if (rowsLen < 1 || target === void 0) {
      return;
    }
    const firstMovedVisualRow = priv.rowsToMove[0];
    const firstMovedPhysicalRow = this.hot.toPhysicalRow(firstMovedVisualRow);
    const movePerformed = this.dragRows(priv.rowsToMove, target);
    priv.rowsToMove.length = 0;
    if (movePerformed === true) {
      this.persistentStateSave();
      this.hot.render();
      this.hot.view.adjustElementsSize(true);
      const selectionStart = this.hot.toVisualRow(firstMovedPhysicalRow);
      const selectionEnd = selectionStart + rowsLen - 1;
      this.hot.selectRows(selectionStart, selectionEnd);
    }
  }
  /**
   * `afterScrollHorizontally` hook callback. Fired the table was scrolled horizontally.
   *
   * @private
   */
  onAfterScrollHorizontally() {
    const wtTable = this.hot.view._wt.wtTable;
    const headerWidth = this.hot.view._wt.wtViewport.getRowHeaderWidth();
    const scrollLeft = wtTable.holder.scrollLeft;
    const posLeft = headerWidth + scrollLeft;
    this.backlight.setPosition(null, posLeft);
    this.backlight.setSize(wtTable.hider.offsetWidth - posLeft);
  }
  /**
   * Builds the plugin's UI.
   *
   * @private
   */
  buildPluginUI() {
    this.backlight.build();
    this.guideline.build();
  }
  /**
   * Callback for the `afterLoadData` hook.
   *
   * @private
   */
  onAfterLoadData() {
    this.moveBySettingsOrLoad();
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.backlight.destroy();
    this.guideline.destroy();
    super.destroy();
  }
};

// node_modules/handsontable/plugins/manualRowResize/manualRowResize.mjs
var PLUGIN_KEY24 = "manualRowResize";
var PLUGIN_PRIORITY23 = 30;
var PERSISTENT_STATE_KEY2 = "manualRowHeights";
var privatePool18 = /* @__PURE__ */ new WeakMap();
var ManualRowResize = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY24;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY23;
  }
  constructor(hotInstance) {
    super(hotInstance);
    const {
      rootDocument
    } = this.hot;
    this.currentTH = null;
    this.currentRow = null;
    this.selectedRows = [];
    this.currentHeight = null;
    this.newSize = null;
    this.startY = null;
    this.startHeight = null;
    this.startOffset = null;
    this.handle = rootDocument.createElement("DIV");
    this.guide = rootDocument.createElement("DIV");
    this.eventManager = new eventManager_default(this);
    this.pressed = null;
    this.isTriggeredByRMB = false;
    this.dblclick = 0;
    this.autoresizeTimeout = null;
    this.rowHeightsMap = void 0;
    privatePool18.set(this, {
      config: void 0
    });
    addClass(this.handle, "manualRowResizer");
    addClass(this.guide, "manualRowResizerGuide");
  }
  /**
   * @private
   * @returns {string}
   */
  get inlineDir() {
    return this.hot.isRtl() ? "right" : "left";
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualRowResize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY24];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.rowHeightsMap = new PhysicalIndexToValueMap();
    this.rowHeightsMap.addLocalHook("init", () => this.onMapInit());
    this.hot.rowIndexMapper.registerMap(this.pluginName, this.rowHeightsMap);
    this.addHook("modifyRowHeight", (height, row) => this.onModifyRowHeight(height, row));
    this.bindEvents();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualRowResize`](@/api/options.md#manualrowresize)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    const priv = privatePool18.get(this);
    priv.config = this.rowHeightsMap.getValues();
    this.hot.rowIndexMapper.unregisterMap(this.pluginName);
    super.disablePlugin();
  }
  /**
   * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be
   * enabled).
   *
   * @fires Hooks#persistentStateSave
   */
  saveManualRowHeights() {
    this.hot.runHooks("persistentStateSave", PERSISTENT_STATE_KEY2, this.rowHeightsMap.getValues());
  }
  /**
   * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option
   * has be enabled).
   *
   * @returns {Array}
   * @fires Hooks#persistentStateLoad
   */
  loadManualRowHeights() {
    const storedState = {};
    this.hot.runHooks("persistentStateLoad", PERSISTENT_STATE_KEY2, storedState);
    return storedState.value;
  }
  /**
   * Sets the new height for specified row index.
   *
   * @param {number} row Visual row index.
   * @param {number} height Row height.
   * @returns {number} Returns new height.
   */
  setManualSize(row, height) {
    const physicalRow = this.hot.toPhysicalRow(row);
    const newHeight = Math.max(height, viewportRows_default.DEFAULT_HEIGHT);
    this.rowHeightsMap.setValueAtIndex(physicalRow, newHeight);
    return newHeight;
  }
  /**
   * Sets the resize handle position.
   *
   * @private
   * @param {HTMLCellElement} TH TH HTML element.
   */
  setupHandlePosition(TH) {
    this.currentTH = TH;
    const {
      view
    } = this.hot;
    const {
      _wt: wt
    } = view;
    const cellCoords = wt.wtTable.getCoords(this.currentTH);
    const row = cellCoords.row;
    if (row < 0) {
      return;
    }
    const headerWidth = outerWidth(this.currentTH);
    const box = this.currentTH.getBoundingClientRect();
    const fixedRowTop = row < wt.getSetting("fixedRowsTop");
    const fixedRowBottom = row >= view.countNotHiddenRowIndexes(0, 1) - wt.getSetting("fixedRowsBottom");
    let relativeHeaderPosition;
    if (fixedRowTop) {
      relativeHeaderPosition = wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
    } else if (fixedRowBottom) {
      relativeHeaderPosition = wt.wtOverlays.bottomInlineStartCornerOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
    }
    if (!relativeHeaderPosition) {
      relativeHeaderPosition = wt.wtOverlays.inlineStartOverlay.getRelativeCellPosition(this.currentTH, cellCoords.row, cellCoords.col);
    }
    this.currentRow = this.hot.rowIndexMapper.getVisualFromRenderableIndex(row);
    this.selectedRows = [];
    const isFullRowSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByRowHeader();
    if (this.hot.selection.isSelected() && isFullRowSelected) {
      const selectionRanges = this.hot.getSelectedRange();
      arrayEach(selectionRanges, (selectionRange) => {
        const fromRow = selectionRange.getTopStartCorner().row;
        const toRow = selectionRange.getBottomStartCorner().row;
        rangeEach(fromRow, toRow, (rowIndex) => {
          if (!this.selectedRows.includes(rowIndex)) {
            this.selectedRows.push(rowIndex);
          }
        });
      });
    }
    if (!this.selectedRows.includes(this.currentRow)) {
      this.selectedRows = [this.currentRow];
    }
    this.startOffset = relativeHeaderPosition.top - 6;
    this.startHeight = parseInt(box.height, 10);
    this.handle.style.top = `${this.startOffset + this.startHeight}px`;
    this.handle.style[this.inlineDir] = `${relativeHeaderPosition.start}px`;
    this.handle.style.width = `${headerWidth}px`;
    this.hot.rootElement.appendChild(this.handle);
  }
  /**
   * Refresh the resize handle position.
   *
   * @private
   */
  refreshHandlePosition() {
    this.handle.style.top = `${this.startOffset + this.currentHeight}px`;
  }
  /**
   * Sets the resize guide position.
   *
   * @private
   */
  setupGuidePosition() {
    const handleWidth = parseInt(outerWidth(this.handle), 10);
    const handleEndPosition = parseInt(this.handle.style[this.inlineDir], 10) + handleWidth;
    const maximumVisibleElementWidth = parseInt(this.hot.view.maximumVisibleElementWidth(0), 10);
    addClass(this.handle, "active");
    addClass(this.guide, "active");
    this.guide.style.top = this.handle.style.top;
    this.guide.style[this.inlineDir] = `${handleEndPosition}px`;
    this.guide.style.width = `${maximumVisibleElementWidth - handleWidth}px`;
    this.hot.rootElement.appendChild(this.guide);
  }
  /**
   * Refresh the resize guide position.
   *
   * @private
   */
  refreshGuidePosition() {
    this.guide.style.top = this.handle.style.top;
  }
  /**
   * Hides both the resize handle and resize guide.
   *
   * @private
   */
  hideHandleAndGuide() {
    removeClass(this.handle, "active");
    removeClass(this.guide, "active");
  }
  /**
   * Checks if provided element is considered as a row header.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {boolean}
   */
  checkIfRowHeader(element) {
    var _element$parentNode;
    const thElement = closest(element, ["TH"], this.hot.rootElement);
    return thElement && ((_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 || (_element$parentNode = _element$parentNode.parentNode) === null || _element$parentNode === void 0 ? void 0 : _element$parentNode.tagName) === "TBODY";
  }
  /**
   * Gets the TH element from the provided element.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {HTMLElement}
   */
  getClosestTHParent(element) {
    if (element.tagName !== "TABLE") {
      if (element.tagName === "TH") {
        return element;
      }
      return this.getClosestTHParent(element.parentNode);
    }
    return null;
  }
  /**
   * Returns the actual height for the provided row index.
   *
   * @private
   * @param {number} row Visual row index.
   * @returns {number} Actual row height.
   */
  getActualRowHeight(row) {
    const walkontableHeight = this.hot.view._wt.wtTable.getRowHeight(row);
    if (walkontableHeight !== void 0 && this.newSize < walkontableHeight) {
      return walkontableHeight;
    }
    return this.newSize;
  }
  /**
   * 'mouseover' event callback - set the handle position.
   *
   * @private
   * @param {MouseEvent} event The mouse event.
   */
  onMouseOver(event2) {
    if (isDetached(event2.target)) {
      return;
    }
    if (this.isTriggeredByRMB === true) {
      return;
    }
    if (this.checkIfRowHeader(event2.target)) {
      const th = this.getClosestTHParent(event2.target);
      if (th) {
        if (!this.pressed) {
          this.setupHandlePosition(th);
        }
      }
    }
  }
  /**
   * Auto-size row after doubleclick - callback.
   *
   * @private
   * @fires Hooks#beforeRowResize
   * @fires Hooks#afterRowResize
   */
  afterMouseDownTimeout() {
    const render = () => {
      this.hot.forceFullRender = true;
      this.hot.view.render();
      this.hot.view.adjustElementsSize(true);
    };
    const resize = (row, forceRender) => {
      const hookNewSize = this.hot.runHooks("beforeRowResize", this.getActualRowHeight(row), row, true);
      if (hookNewSize !== void 0) {
        this.newSize = hookNewSize;
      }
      this.setManualSize(row, this.newSize);
      this.hot.runHooks("afterRowResize", this.getActualRowHeight(row), row, true);
      if (forceRender) {
        render();
      }
    };
    if (this.dblclick >= 2) {
      const selectedRowsLength = this.selectedRows.length;
      if (selectedRowsLength > 1) {
        arrayEach(this.selectedRows, (selectedRow) => {
          resize(selectedRow);
        });
        render();
      } else {
        arrayEach(this.selectedRows, (selectedRow) => {
          resize(selectedRow, true);
        });
      }
    }
    this.dblclick = 0;
    this.autoresizeTimeout = null;
  }
  /**
   * 'mousedown' event callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event.
   */
  onMouseDown(event2) {
    if (hasClass(event2.target, "manualRowResizer")) {
      this.setupHandlePosition(this.currentTH);
      this.setupGuidePosition();
      this.pressed = true;
      if (this.autoresizeTimeout === null) {
        this.autoresizeTimeout = setTimeout(() => this.afterMouseDownTimeout(), 500);
        this.hot._registerTimeout(this.autoresizeTimeout);
      }
      this.dblclick += 1;
      this.startY = event2.pageY;
      this.newSize = this.startHeight;
    }
  }
  /**
   * 'mousemove' event callback - refresh the handle and guide positions, cache the new row height.
   *
   * @private
   * @param {MouseEvent} event The mouse event.
   */
  onMouseMove(event2) {
    if (this.pressed) {
      this.currentHeight = this.startHeight + (event2.pageY - this.startY);
      arrayEach(this.selectedRows, (selectedRow) => {
        this.newSize = this.setManualSize(selectedRow, this.currentHeight);
      });
      this.refreshHandlePosition();
      this.refreshGuidePosition();
    }
  }
  /**
   * 'mouseup' event callback - apply the row resizing.
   *
   * @private
   *
   * @fires Hooks#beforeRowResize
   * @fires Hooks#afterRowResize
   */
  onMouseUp() {
    const render = () => {
      this.hot.forceFullRender = true;
      this.hot.view.render();
      this.hot.view.adjustElementsSize(true);
    };
    const runHooks = (row, forceRender) => {
      this.hot.runHooks("beforeRowResize", this.getActualRowHeight(row), row, false);
      if (forceRender) {
        render();
      }
      this.saveManualRowHeights();
      this.hot.runHooks("afterRowResize", this.getActualRowHeight(row), row, false);
    };
    if (this.pressed) {
      this.hideHandleAndGuide();
      this.pressed = false;
      if (this.newSize !== this.startHeight) {
        const selectedRowsLength = this.selectedRows.length;
        if (selectedRowsLength > 1) {
          arrayEach(this.selectedRows, (selectedRow) => {
            runHooks(selectedRow);
          });
          render();
        } else {
          arrayEach(this.selectedRows, (selectedRow) => {
            runHooks(selectedRow, true);
          });
        }
      }
      this.setupHandlePosition(this.currentTH);
    }
  }
  /**
   * Callback for "contextmenu" event triggered on element showing move handle. It removes handle and guide elements.
   *
   * @private
   */
  onContextMenu() {
    this.hideHandleAndGuide();
    this.hot.rootElement.removeChild(this.handle);
    this.hot.rootElement.removeChild(this.guide);
    this.pressed = false;
    this.isTriggeredByRMB = true;
    this.hot._registerImmediate(() => {
      this.isTriggeredByRMB = false;
    });
  }
  /**
   * Binds the mouse events.
   *
   * @private
   */
  bindEvents() {
    const {
      rootElement,
      rootWindow
    } = this.hot;
    this.eventManager.addEventListener(rootElement, "mouseover", (e) => this.onMouseOver(e));
    this.eventManager.addEventListener(rootElement, "mousedown", (e) => this.onMouseDown(e));
    this.eventManager.addEventListener(rootWindow, "mousemove", (e) => this.onMouseMove(e));
    this.eventManager.addEventListener(rootWindow, "mouseup", () => this.onMouseUp());
    this.eventManager.addEventListener(this.handle, "contextmenu", () => this.onContextMenu());
  }
  /**
   * Modifies the provided row height, based on the plugin settings.
   *
   * @private
   * @param {number} height Row height.
   * @param {number} row Visual row index.
   * @returns {number}
   */
  onModifyRowHeight(height, row) {
    let newHeight = height;
    if (this.enabled) {
      const physicalRow = this.hot.toPhysicalRow(row);
      const rowHeight = this.rowHeightsMap.getValueAtIndex(physicalRow);
      if (this.hot.getSettings()[PLUGIN_KEY24] && rowHeight) {
        newHeight = rowHeight;
      }
    }
    return newHeight;
  }
  /**
   * Callback to call on map's `init` local hook.
   *
   * @private
   */
  onMapInit() {
    const priv = privatePool18.get(this);
    const initialSetting = this.hot.getSettings()[PLUGIN_KEY24];
    const loadedManualRowHeights = this.loadManualRowHeights();
    this.hot.batchExecution(() => {
      if (typeof loadedManualRowHeights !== "undefined") {
        loadedManualRowHeights.forEach((height, index2) => {
          this.rowHeightsMap.setValueAtIndex(index2, height);
        });
      } else if (Array.isArray(initialSetting)) {
        initialSetting.forEach((height, index2) => {
          this.rowHeightsMap.setValueAtIndex(index2, height);
        });
        priv.config = initialSetting;
      } else if (initialSetting === true && Array.isArray(priv.config)) {
        priv.config.forEach((height, index2) => {
          this.rowHeightsMap.setValueAtIndex(index2, height);
        });
      }
    }, true);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/mergeCells/cellCoords.mjs
var MergedCellCoords = class {
  constructor(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {
    this.row = row;
    this.col = column;
    this.rowspan = rowspan;
    this.colspan = colspan;
    this.removed = false;
    this.cellCoordsFactory = cellCoordsFactory;
    this.cellRangeFactory = cellRangeFactory;
  }
  /**
   * Get a warning message for when the declared merged cell data contains negative values.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static NEGATIVE_VALUES_WARNING(newMergedCell) {
    return toSingleLine`The merged cell declared with {row: ${newMergedCell.row}, col: ${newMergedCell.col},\x20
      rowspan: ${newMergedCell.rowspan}, colspan: ${newMergedCell.colspan}} contains negative values, which is\x20
      not supported. It will not be added to the collection.`;
  }
  /**
   * Get a warning message for when the declared merged cell data contains values exceeding the table limits.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {
    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] is positioned\x20
      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.`;
  }
  /**
   * Get a warning message for when the declared merged cell data represents a single cell.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static IS_SINGLE_CELL(newMergedCell) {
    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] has both "rowspan"\x20
      and "colspan" declared as "1", which makes it a single cell. It cannot be added to the collection.`;
  }
  /**
   * Get a warning message for when the declared merged cell data contains "colspan" or "rowspan", that equals 0.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static ZERO_SPAN_WARNING(newMergedCell) {
    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] has "rowspan"\x20
      or "colspan" declared as "0", which is not supported. It cannot be added to the collection.`;
  }
  /**
   * Check whether the values provided for a merged cell contain any negative values.
   *
   * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.
   * @returns {boolean}
   */
  static containsNegativeValues(mergedCellInfo) {
    return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;
  }
  /**
   * Check whether the provided merged cell information object represents a single cell.
   *
   * @private
   * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.
   * @returns {boolean}
   */
  static isSingleCell(mergedCellInfo) {
    return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;
  }
  /**
   * Check whether the provided merged cell information object contains a rowspan or colspan of 0.
   *
   * @private
   * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.
   * @returns {boolean}
   */
  static containsZeroSpan(mergedCellInfo) {
    return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;
  }
  /**
   * Check whether the provided merged cell object is to be declared out of bounds of the table.
   *
   * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.
   * @param {number} rowCount Number of rows in the table.
   * @param {number} columnCount Number of rows in the table.
   * @returns {boolean}
   */
  static isOutOfBounds(mergeCell, rowCount, columnCount) {
    return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;
  }
  /**
   * Sanitize (prevent from going outside the boundaries) the merged cell.
   *
   * @param {Core} hotInstance The Handsontable instance.
   */
  normalize(hotInstance) {
    const totalRows = hotInstance.countRows();
    const totalColumns = hotInstance.countCols();
    if (this.row < 0) {
      this.row = 0;
    } else if (this.row > totalRows - 1) {
      this.row = totalRows - 1;
    }
    if (this.col < 0) {
      this.col = 0;
    } else if (this.col > totalColumns - 1) {
      this.col = totalColumns - 1;
    }
    if (this.row + this.rowspan > totalRows - 1) {
      this.rowspan = totalRows - this.row;
    }
    if (this.col + this.colspan > totalColumns - 1) {
      this.colspan = totalColumns - this.col;
    }
  }
  /**
   * Returns `true` if the provided coordinates are inside the merged cell.
   *
   * @param {number} row The row index.
   * @param {number} column The column index.
   * @returns {boolean}
   */
  includes(row, column) {
    return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;
  }
  /**
   * Returns `true` if the provided `column` property is within the column span of the merged cell.
   *
   * @param {number} column The column index.
   * @returns {boolean}
   */
  includesHorizontally(column) {
    return this.col <= column && this.col + this.colspan - 1 >= column;
  }
  /**
   * Returns `true` if the provided `row` property is within the row span of the merged cell.
   *
   * @param {number} row Row index.
   * @returns {boolean}
   */
  includesVertically(row) {
    return this.row <= row && this.row + this.rowspan - 1 >= row;
  }
  /**
   * Shift (and possibly resize, if needed) the merged cell.
   *
   * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.
   * @param {number} indexOfChange Index of the preceding change.
   * @returns {boolean} Returns `false` if the whole merged cell was removed.
   */
  shift(shiftVector, indexOfChange) {
    const shiftValue = shiftVector[0] || shiftVector[1];
    const shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;
    const span = shiftVector[0] ? "colspan" : "rowspan";
    const index2 = shiftVector[0] ? "col" : "row";
    const changeStart = Math.min(indexOfChange, shiftedIndex);
    const changeEnd = Math.max(indexOfChange, shiftedIndex);
    const mergeStart = this[index2];
    const mergeEnd = this[index2] + this[span] - 1;
    if (mergeStart >= indexOfChange) {
      this[index2] += shiftValue;
    }
    if (shiftValue > 0) {
      if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {
        this[span] += shiftValue;
      }
    } else if (shiftValue < 0) {
      if (changeStart <= mergeStart && changeEnd >= mergeEnd) {
        this.removed = true;
        return false;
      } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {
        const removedOffset = changeEnd - mergeStart + 1;
        const preRemovedOffset = Math.abs(shiftValue) - removedOffset;
        this[index2] -= preRemovedOffset + shiftValue;
        this[span] -= removedOffset;
      } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {
        this[span] += shiftValue;
      } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {
        const removedPart = mergeEnd - changeStart + 1;
        this[span] -= removedPart;
      }
    }
    return true;
  }
  /**
   * Check if the second provided merged cell is "farther" in the provided direction.
   *
   * @param {MergedCellCoords} mergedCell The merged cell to check.
   * @param {string} direction Drag direction.
   * @returns {boolean|null} `true` if the second provided merged cell is "farther".
   */
  isFarther(mergedCell, direction) {
    if (!mergedCell) {
      return true;
    }
    if (direction === "down") {
      return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;
    } else if (direction === "up") {
      return mergedCell.row > this.row;
    } else if (direction === "right") {
      return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;
    } else if (direction === "left") {
      return mergedCell.col > this.col;
    }
    return null;
  }
  /**
   * Get the bottom row index of the merged cell.
   *
   * @returns {number}
   */
  getLastRow() {
    return this.row + this.rowspan - 1;
  }
  /**
   * Get the rightmost column index of the merged cell.
   *
   * @returns {number}
   */
  getLastColumn() {
    return this.col + this.colspan - 1;
  }
  /**
   * Get the range coordinates of the merged cell.
   *
   * @returns {CellRange}
   */
  getRange() {
    return this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn()));
  }
};
var cellCoords_default = MergedCellCoords;

// node_modules/handsontable/plugins/mergeCells/utils.mjs
function applySpanProperties(TD, mergedCellInfo, row, col) {
  if (mergedCellInfo) {
    if (mergedCellInfo.row === row && mergedCellInfo.col === col) {
      TD.setAttribute("rowspan", mergedCellInfo.rowspan.toString());
      TD.setAttribute("colspan", mergedCellInfo.colspan.toString());
    } else {
      TD.removeAttribute("rowspan");
      TD.removeAttribute("colspan");
      TD.style.display = "none";
    }
  } else {
    TD.removeAttribute("rowspan");
    TD.removeAttribute("colspan");
    TD.style.display = "";
  }
}

// node_modules/handsontable/plugins/mergeCells/cellsCollection.mjs
var MergedCellsCollection = class _MergedCellsCollection {
  constructor(plugin) {
    this.plugin = plugin;
    this.mergedCells = [];
    this.hot = plugin.hot;
  }
  /**
   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static IS_OVERLAPPING_WARNING(newMergedCell) {
    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}], overlaps\x20
      with the other declared merged cell. The overlapping merged cell was not added to the table, please\x20
      fix your setup.`;
  }
  /**
   * Get a merged cell from the container, based on the provided arguments. You can provide either the "starting coordinates"
   * of a merged cell, or any coordinates from the body of the merged cell.
   *
   * @param {number} row Row index.
   * @param {number} column Column index.
   * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.
   */
  get(row, column) {
    const mergedCells = this.mergedCells;
    let result = false;
    arrayEach(mergedCells, (mergedCell) => {
      if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {
        result = mergedCell;
        return false;
      }
      return true;
    });
    return result;
  }
  /**
   * Get a merged cell containing the provided range.
   *
   * @param {CellRange|object} range The range to search merged cells for.
   * @returns {MergedCellCoords|boolean}
   */
  getByRange(range) {
    const mergedCells = this.mergedCells;
    let result = false;
    arrayEach(mergedCells, (mergedCell) => {
      if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {
        result = mergedCell;
        return result;
      }
      return true;
    });
    return result;
  }
  /**
   * Get a merged cell contained in the provided range.
   *
   * @param {CellRange|object} range The range to search merged cells in.
   * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.
   * @returns {Array|boolean} Array of found merged cells of `false` if none were found.
   */
  getWithinRange(range) {
    let countPartials = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const mergedCells = this.mergedCells;
    const foundMergedCells = [];
    let testedRange = range;
    if (!testedRange.includesRange) {
      const from2 = this.hot._createCellCoords(testedRange.from.row, testedRange.from.col);
      const to2 = this.hot._createCellCoords(testedRange.to.row, testedRange.to.col);
      testedRange = this.hot._createCellRange(from2, from2, to2);
    }
    arrayEach(mergedCells, (mergedCell) => {
      const mergedCellTopLeft = this.hot._createCellCoords(mergedCell.row, mergedCell.col);
      const mergedCellBottomRight = this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);
      const mergedCellRange = this.hot._createCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
      if (countPartials) {
        if (testedRange.overlaps(mergedCellRange)) {
          foundMergedCells.push(mergedCell);
        }
      } else if (testedRange.includesRange(mergedCellRange)) {
        foundMergedCells.push(mergedCell);
      }
    });
    return foundMergedCells.length ? foundMergedCells : false;
  }
  /**
   * Add a merged cell to the container.
   *
   * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.
   * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.
   */
  add(mergedCellInfo) {
    const mergedCells = this.mergedCells;
    const row = mergedCellInfo.row;
    const column = mergedCellInfo.col;
    const rowspan = mergedCellInfo.rowspan;
    const colspan = mergedCellInfo.colspan;
    const newMergedCell = new cellCoords_default(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);
    const alreadyExists = this.get(row, column);
    const isOverlapping = this.isOverlapping(newMergedCell);
    if (!alreadyExists && !isOverlapping) {
      if (this.hot) {
        newMergedCell.normalize(this.hot);
      }
      mergedCells.push(newMergedCell);
      return newMergedCell;
    }
    warn2(_MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));
    return false;
  }
  /**
   * Remove a merged cell from the container. You can provide either the "starting coordinates"
   * of a merged cell, or any coordinates from the body of the merged cell.
   *
   * @param {number} row Row index.
   * @param {number} column Column index.
   * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.
   */
  remove(row, column) {
    const mergedCells = this.mergedCells;
    const wantedCollection = this.get(row, column);
    const wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : -1;
    if (wantedCollection && wantedCollectionIndex !== -1) {
      mergedCells.splice(wantedCollectionIndex, 1);
      return wantedCollection;
    }
    return false;
  }
  /**
   * Clear all the merged cells.
   */
  clear() {
    const mergedCells = this.mergedCells;
    const mergedCellParentsToClear = [];
    const hiddenCollectionElements = [];
    arrayEach(mergedCells, (mergedCell) => {
      const TD = this.hot.getCell(mergedCell.row, mergedCell.col);
      if (TD) {
        mergedCellParentsToClear.push([TD, this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);
      }
    });
    this.mergedCells.length = 0;
    arrayEach(mergedCellParentsToClear, (mergedCell, i) => {
      rangeEach(0, mergedCell.rowspan - 1, (j) => {
        rangeEach(0, mergedCell.colspan - 1, (k) => {
          if (k !== 0 || j !== 0) {
            const TD = this.hot.getCell(mergedCell.row + j, mergedCell.col + k);
            if (TD) {
              hiddenCollectionElements.push([TD, null, null, null]);
            }
          }
        });
      });
      mergedCellParentsToClear[i][1] = null;
    });
    arrayEach(mergedCellParentsToClear, (mergedCellParents) => {
      applySpanProperties(...mergedCellParents);
    });
    arrayEach(hiddenCollectionElements, (hiddenCollectionElement) => {
      applySpanProperties(...hiddenCollectionElement);
    });
  }
  /**
   * Check if the provided merged cell overlaps with the others in the container.
   *
   * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.
   * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.
   */
  isOverlapping(mergedCell) {
    const mergedCellRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(mergedCell.row, mergedCell.col), this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));
    let result = false;
    arrayEach(this.mergedCells, (col) => {
      const currentRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(col.row, col.col), this.hot._createCellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));
      if (currentRange.overlaps(mergedCellRange)) {
        result = true;
        return false;
      }
      return true;
    });
    return result;
  }
  /**
   * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  isFirstRenderableMergedCell(row, column) {
    const mergeParent = this.get(row, column);
    return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;
  }
  /**
   * Get the first renderable coords of the merged cell at the provided coordinates.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the
   *                        merged cell.
   */
  getFirstRenderableCoords(row, column) {
    const mergeParent = this.get(row, column);
    if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {
      return this.hot._createCellCoords(row, column);
    }
    const firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);
    const firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);
    return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);
  }
  /**
   * Shift the merged cell in the direction and by an offset defined in the arguments.
   *
   * @param {string} direction `right`, `left`, `up` or `down`.
   * @param {number} index Index where the change, which caused the shifting took place.
   * @param {number} count Number of rows/columns added/removed in the preceding action.
   */
  shiftCollections(direction, index2, count) {
    const shiftVector = [0, 0];
    switch (direction) {
      case "right":
        shiftVector[0] += count;
        break;
      case "left":
        shiftVector[0] -= count;
        break;
      case "down":
        shiftVector[1] += count;
        break;
      case "up":
        shiftVector[1] -= count;
        break;
      default:
    }
    arrayEach(this.mergedCells, (currentMerge) => {
      currentMerge.shift(shiftVector, index2);
    });
    rangeEachReverse(this.mergedCells.length - 1, 0, (i) => {
      const currentMerge = this.mergedCells[i];
      if (currentMerge && currentMerge.removed) {
        this.mergedCells.splice(this.mergedCells.indexOf(currentMerge), 1);
      }
    });
  }
};
var cellsCollection_default = MergedCellsCollection;

// node_modules/handsontable/plugins/mergeCells/calculations/autofill.mjs
var AutofillCalculations = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.mergedCellsCollection = this.plugin.mergedCellsCollection;
    this.currentFillData = null;
  }
  /**
   * Correct the provided selection area, so it's not selecting only a part of a merged cell.
   *
   * @param {Array} selectionArea The selection to correct.
   */
  correctSelectionAreaSize(selectionArea) {
    if (selectionArea[0] === selectionArea[2] && selectionArea[1] === selectionArea[3]) {
      const mergedCell = this.mergedCellsCollection.get(selectionArea[0], selectionArea[1]);
      if (mergedCell) {
        selectionArea[2] = selectionArea[0] + mergedCell.rowspan - 1;
        selectionArea[3] = selectionArea[1] + mergedCell.colspan - 1;
      }
    }
  }
  /**
   * Get the direction of the autofill process.
   *
   * @param {Array} selectionArea The selection area.
   * @param {Array} finalArea The final area (base + drag).
   * @returns {string} `up`, `down`, `left` or `right`.
   */
  getDirection(selectionArea, finalArea) {
    let direction = null;
    if (finalArea[0] === selectionArea[0] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
      direction = "down";
    } else if (finalArea[2] === selectionArea[2] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
      direction = "up";
    } else if (finalArea[1] === selectionArea[1] && finalArea[2] === selectionArea[2]) {
      direction = "right";
    } else {
      direction = "left";
    }
    return direction;
  }
  /**
   * Snap the drag area to the farthest merged cell, so it won't clip any of the merged cells.
   *
   * @param {Array} baseArea The base selected area.
   * @param {Array} dragArea The drag area.
   * @param {string} dragDirection The autofill drag direction.
   * @param {Array} foundMergedCells MergeCellCoords found in the base selection area.
   * @returns {Array} The new drag area.
   */
  snapDragArea(baseArea, dragArea, dragDirection, foundMergedCells) {
    const newDragArea = dragArea.slice(0);
    const fillSize = this.getAutofillSize(baseArea, dragArea, dragDirection);
    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;
    const verticalDirection = ["up", "down"].indexOf(dragDirection) > -1;
    const fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
    const fulls = Math.floor(fillSize / fullCycle) * fullCycle;
    const partials = fillSize - fulls;
    const farthestCollection = this.getFarthestCollection(baseArea, dragArea, dragDirection, foundMergedCells);
    if (farthestCollection) {
      if (dragDirection === "down") {
        const fill = farthestCollection.row + farthestCollection.rowspan - baseAreaStartRow - partials;
        const newLimit = newDragArea[2] + fill;
        if (newLimit >= this.plugin.hot.countRows()) {
          newDragArea[2] -= partials;
        } else {
          newDragArea[2] += partials ? fill : 0;
        }
      } else if (dragDirection === "right") {
        const fill = farthestCollection.col + farthestCollection.colspan - baseAreaStartColumn - partials;
        const newLimit = newDragArea[3] + fill;
        if (newLimit >= this.plugin.hot.countCols()) {
          newDragArea[3] -= partials;
        } else {
          newDragArea[3] += partials ? fill : 0;
        }
      } else if (dragDirection === "up") {
        const fill = baseAreaEndRow - partials - farthestCollection.row + 1;
        const newLimit = newDragArea[0] + fill;
        if (newLimit < 0) {
          newDragArea[0] += partials;
        } else {
          newDragArea[0] -= partials ? fill : 0;
        }
      } else if (dragDirection === "left") {
        const fill = baseAreaEndColumn - partials - farthestCollection.col + 1;
        const newLimit = newDragArea[1] + fill;
        if (newLimit < 0) {
          newDragArea[1] += partials;
        } else {
          newDragArea[1] -= partials ? fill : 0;
        }
      }
    }
    this.updateCurrentFillCache({
      baseArea,
      dragDirection,
      foundMergedCells,
      fillSize,
      dragArea: newDragArea,
      cycleLength: fullCycle
    });
    return newDragArea;
  }
  /**
   * Update the current fill cache with the provided object.
   *
   * @private
   * @param {object} updateObject The current filled object cache.
   */
  updateCurrentFillCache(updateObject) {
    if (!this.currentFillData) {
      this.currentFillData = {};
    }
    extend2(this.currentFillData, updateObject);
  }
  /**
   * Get the "length" of the drag area.
   *
   * @private
   * @param {Array} baseArea The base selection area.
   * @param {Array} dragArea The drag area (containing the base area).
   * @param {string} direction The drag direction.
   * @returns {number|null} The "length" (height or width, depending on the direction) of the drag.
   */
  getAutofillSize(baseArea, dragArea, direction) {
    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;
    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;
    switch (direction) {
      case "up":
        return baseAreaStartRow - dragAreaStartRow;
      case "down":
        return dragAreaEndRow - baseAreaEndRow;
      case "left":
        return baseAreaStartColumn - dragAreaStartColumn;
      case "right":
        return dragAreaEndColumn - baseAreaEndColumn;
      default:
        return null;
    }
  }
  /**
   * Trim the default drag area (containing the selection area) to the drag-only area.
   *
   * @private
   * @param {Array} baseArea The base selection area.
   * @param {Array} dragArea The base selection area extended by the drag area.
   * @param {string} direction Drag direction.
   * @returns {Array|null} Array representing the drag area coordinates.
   */
  getDragArea(baseArea, dragArea, direction) {
    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;
    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;
    switch (direction) {
      case "up":
        return [dragAreaStartRow, dragAreaStartColumn, baseAreaStartRow - 1, baseAreaEndColumn];
      case "down":
        return [baseAreaEndRow + 1, baseAreaStartColumn, dragAreaEndRow, baseAreaEndColumn];
      case "left":
        return [dragAreaStartRow, dragAreaStartColumn, baseAreaEndRow, baseAreaStartColumn - 1];
      case "right":
        return [baseAreaStartRow, baseAreaEndColumn + 1, dragAreaEndRow, dragAreaEndColumn];
      default:
        return null;
    }
  }
  /**
   * Get the to-be-farthest merged cell in the newly filled area.
   *
   * @private
   * @param {Array} baseArea The base selection area.
   * @param {Array} dragArea The drag area (containing the base area).
   * @param {string} direction The drag direction.
   * @param {Array} mergedCellArray Array of the merged cells found in the base area.
   * @returns {MergedCellCoords|null}
   */
  getFarthestCollection(baseArea, dragArea, direction, mergedCellArray) {
    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;
    const verticalDirection = ["up", "down"].indexOf(direction) > -1;
    const baseEnd = verticalDirection ? baseAreaEndRow : baseAreaEndColumn;
    const baseStart = verticalDirection ? baseAreaStartRow : baseAreaStartColumn;
    const fillSize = this.getAutofillSize(baseArea, dragArea, direction);
    const fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
    const fulls = Math.floor(fillSize / fullCycle) * fullCycle;
    const partials = fillSize - fulls;
    let inclusionFunctionName = null;
    let farthestCollection = null;
    let endOfDragRecreationIndex = null;
    switch (direction) {
      case "up":
        inclusionFunctionName = "includesVertically";
        endOfDragRecreationIndex = baseEnd - partials + 1;
        break;
      case "left":
        inclusionFunctionName = "includesHorizontally";
        endOfDragRecreationIndex = baseEnd - partials + 1;
        break;
      case "down":
        inclusionFunctionName = "includesVertically";
        endOfDragRecreationIndex = baseStart + partials - 1;
        break;
      case "right":
        inclusionFunctionName = "includesHorizontally";
        endOfDragRecreationIndex = baseStart + partials - 1;
        break;
      default:
    }
    arrayEach(mergedCellArray, (currentCollection) => {
      if (currentCollection[inclusionFunctionName](endOfDragRecreationIndex) && currentCollection.isFarther(farthestCollection, direction)) {
        farthestCollection = currentCollection;
      }
    });
    return farthestCollection;
  }
  /**
   * Recreate the merged cells after the autofill process.
   *
   * @param {Array} changes Changes made.
   */
  recreateAfterDataPopulation(changes) {
    if (!this.currentFillData) {
      return;
    }
    const fillRange = this.getRangeFromChanges(changes);
    const foundMergedCells = this.currentFillData.foundMergedCells;
    const dragDirection = this.currentFillData.dragDirection;
    const inBounds = (current2, offset3) => {
      switch (dragDirection) {
        case "up":
          return current2.row - offset3 >= fillRange.from.row;
        case "down":
          return current2.row + current2.rowspan - 1 + offset3 <= fillRange.to.row;
        case "left":
          return current2.col - offset3 >= fillRange.from.column;
        case "right":
          return current2.col + current2.colspan - 1 + offset3 <= fillRange.to.column;
        default:
          return null;
      }
    };
    let fillOffset = 0;
    let current = null;
    let multiplier = 1;
    do {
      for (let j = 0; j < foundMergedCells.length; j += 1) {
        current = foundMergedCells[j];
        fillOffset = multiplier * this.currentFillData.cycleLength;
        if (inBounds(current, fillOffset)) {
          switch (dragDirection) {
            case "up":
              this.plugin.mergedCellsCollection.add({
                row: current.row - fillOffset,
                rowspan: current.rowspan,
                col: current.col,
                colspan: current.colspan
              });
              break;
            case "down":
              this.plugin.mergedCellsCollection.add({
                row: current.row + fillOffset,
                rowspan: current.rowspan,
                col: current.col,
                colspan: current.colspan
              });
              break;
            case "left":
              this.plugin.mergedCellsCollection.add({
                row: current.row,
                rowspan: current.rowspan,
                col: current.col - fillOffset,
                colspan: current.colspan
              });
              break;
            case "right":
              this.plugin.mergedCellsCollection.add({
                row: current.row,
                rowspan: current.rowspan,
                col: current.col + fillOffset,
                colspan: current.colspan
              });
              break;
            default:
          }
        }
        if (j === foundMergedCells.length - 1) {
          multiplier += 1;
        }
      }
    } while (inBounds(current, fillOffset));
    this.currentFillData = null;
    this.plugin.hot.render();
    if (foundMergedCells.length > 0) {
      this.plugin.ifChromeForceRepaint();
    }
  }
  /**
   * Get the drag range from the changes made.
   *
   * @private
   * @param {Array} changes The changes made.
   * @returns {object} Object with `from` and `to` properties, both containing `row` and `column` keys.
   */
  getRangeFromChanges(changes) {
    const rows = {
      min: null,
      max: null
    };
    const columns = {
      min: null,
      max: null
    };
    arrayEach(changes, (change) => {
      const rowIndex = change[0];
      const columnIndex = this.plugin.hot.propToCol(change[1]);
      if (rows.min === null || rowIndex < rows.min) {
        rows.min = rowIndex;
      }
      if (rows.max === null || rowIndex > rows.max) {
        rows.max = rowIndex;
      }
      if (columns.min === null || columnIndex < columns.min) {
        columns.min = columnIndex;
      }
      if (columns.max === null || columnIndex > columns.max) {
        columns.max = columnIndex;
      }
    });
    return {
      from: {
        row: rows.min,
        column: columns.min
      },
      to: {
        row: rows.max,
        column: columns.max
      }
    };
  }
  /**
   * Check if the drag area contains any merged cells.
   *
   * @param {Array} baseArea The base selection area.
   * @param {Array} fullArea The base area extended by the drag area.
   * @param {string} direction Drag direction.
   * @returns {boolean}
   */
  dragAreaOverlapsCollections(baseArea, fullArea, direction) {
    const dragArea = this.getDragArea(baseArea, fullArea, direction);
    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;
    const topLeft = this.plugin.hot._createCellCoords(dragAreaStartRow, dragAreaStartColumn);
    const bottomRight = this.plugin.hot._createCellCoords(dragAreaEndRow, dragAreaEndColumn);
    const dragRange = this.plugin.hot._createCellRange(topLeft, topLeft, bottomRight);
    return !!this.mergedCellsCollection.getWithinRange(dragRange, true);
  }
};
var autofill_default = AutofillCalculations;

// node_modules/handsontable/plugins/mergeCells/calculations/selection.mjs
var SelectionCalculations = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.hot = plugin.hot;
    this.fullySelectedMergedCellClassName = "fullySelectedMergedCell";
  }
  /**
   * "Snap" the delta value according to defined merged cells. (In other words, compensate the rowspan -
   * e.g. Going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.).
   *
   * @param {object} delta The delta object containing `row` and `col` properties.
   * @param {CellRange} selectionRange The selection range.
   * @param {object} mergedCell A merged cell object.
   */
  snapDelta(delta, selectionRange, mergedCell) {
    const cellCoords = selectionRange.to;
    const newRow = cellCoords.row + delta.row;
    const newColumn = cellCoords.col + delta.col;
    if (delta.row) {
      this.jumpOverMergedCell(delta, mergedCell, newRow);
    } else if (delta.col) {
      this.jumpOverMergedCell(delta, mergedCell, newColumn);
    }
  }
  /**
   * "Jump" over the merged cell (compensate for the indexes within the merged cell to get past it).
   *
   * @private
   * @param {object} delta The delta object.
   * @param {MergedCellCoords} mergedCell The merge cell object.
   * @param {number} newIndex New row/column index, created with the delta.
   */
  jumpOverMergedCell(delta, mergedCell, newIndex) {
    let flatDelta = delta.row || delta.col;
    let includesIndex = null;
    let firstIndex = null;
    let lastIndex = null;
    if (delta.row) {
      includesIndex = mergedCell.includesVertically(newIndex);
      firstIndex = mergedCell.row;
      lastIndex = mergedCell.getLastRow();
    } else if (delta.col) {
      includesIndex = mergedCell.includesHorizontally(newIndex);
      firstIndex = mergedCell.col;
      lastIndex = mergedCell.getLastColumn();
    }
    if (flatDelta === 0) {
      return;
    } else if (flatDelta > 0) {
      if (includesIndex && newIndex !== firstIndex) {
        flatDelta += lastIndex - newIndex + 1;
      }
    } else if (includesIndex && newIndex !== lastIndex) {
      flatDelta -= newIndex - firstIndex + 1;
    }
    if (delta.row) {
      delta.row = flatDelta;
    } else if (delta.col) {
      delta.col = flatDelta;
    }
  }
  /**
   * Get a selection range with `to` property incremented by the provided delta.
   *
   * @param {CellRange} oldSelectionRange The base selection range.
   * @param {object} delta The delta object with `row` and `col` properties.
   * @returns {CellRange} A new `CellRange` object.
   */
  getUpdatedSelectionRange(oldSelectionRange, delta) {
    return this.hot._createCellRange(oldSelectionRange.highlight, oldSelectionRange.from, this.hot._createCellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));
  }
  /**
   * Generate an additional class name for the entirely-selected merged cells.
   *
   * @param {number} currentRow Visual row index of the currently processed cell.
   * @param {number} currentColumn Visual column index of the currently cell.
   * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
   * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.
   * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.
   */
  getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {
    const startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);
    const startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);
    const endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);
    const endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);
    if (layerLevel === void 0) {
      return;
    }
    const isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn);
    if (!isFirstRenderableMergedCell) {
      return;
    }
    const mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);
    if (!mergedCell) {
      return;
    }
    const mergeRowEnd = mergedCell.getLastRow();
    const mergeColumnEnd = mergedCell.getLastColumn();
    const fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;
    if (fullMergeAreaWithinSelection) {
      return `${this.fullySelectedMergedCellClassName}-${layerLevel}`;
    } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {
      return `${this.fullySelectedMergedCellClassName}-multiple`;
    }
  }
  /**
   * Check if the provided merged cell is fully selected (by one or many layers of selection).
   *
   * @param {MergedCellCoords} mergedCell The merged cell to be processed.
   * @param {CellRange[]} selectionRangesArray Array of selection ranges.
   * @returns {boolean}
   */
  isMergeCellFullySelected(mergedCell, selectionRangesArray) {
    const mergedCellIndividualCoords = [];
    if (!selectionRangesArray || !mergedCell) {
      return false;
    }
    for (let r = 0; r < mergedCell.rowspan; r += 1) {
      for (let c = 0; c < mergedCell.colspan; c += 1) {
        mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + r, mergedCell.col + c));
      }
    }
    for (let i = 0; i < mergedCellIndividualCoords.length; i += 1) {
      const insideSelections = [];
      for (let s = 0; s < selectionRangesArray.length; s += 1) {
        insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);
      }
      if (!insideSelections.includes(true)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Generate an array of the entirely-selected merged cells' class names.
   *
   * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
   */
  getSelectedMergedCellClassNameToRemove() {
    const classNames = [];
    for (let i = 0; i <= 7; i += 1) {
      classNames.push(`${this.fullySelectedMergedCellClassName}-${i}`);
    }
    classNames.push(`${this.fullySelectedMergedCellClassName}-multiple`);
    return classNames;
  }
};
var selection_default3 = SelectionCalculations;

// node_modules/handsontable/plugins/mergeCells/contextMenuItem/toggleMerge.mjs
function toggleMergeItem(plugin) {
  return {
    key: "mergeCells",
    name() {
      const sel = this.getSelectedLast();
      if (sel) {
        const info = plugin.mergedCellsCollection.get(sel[0], sel[1]);
        if (info.row === sel[0] && info.col === sel[1] && info.row + info.rowspan - 1 === sel[2] && info.col + info.colspan - 1 === sel[3]) {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNMERGE_CELLS);
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_MERGE_CELLS);
    },
    callback() {
      plugin.toggleMergeOnSelection();
    },
    disabled() {
      const sel = this.getSelectedLast();
      if (!sel) {
        return true;
      }
      const isSingleCell = cellCoords_default.isSingleCell({
        row: sel[0],
        col: sel[1],
        rowspan: sel[2] - sel[0] + 1,
        colspan: sel[3] - sel[1] + 1
      });
      return isSingleCell || this.selection.isSelectedByCorner();
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/mergeCells/mergeCells.mjs
pluginHooks_default.getSingleton().register("beforeMergeCells");
pluginHooks_default.getSingleton().register("afterMergeCells");
pluginHooks_default.getSingleton().register("beforeUnmergeCells");
pluginHooks_default.getSingleton().register("afterUnmergeCells");
var PLUGIN_KEY25 = "mergeCells";
var PLUGIN_PRIORITY24 = 150;
var privatePool19 = /* @__PURE__ */ new WeakMap();
var SHORTCUTS_GROUP8 = PLUGIN_KEY25;
var MergeCells = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY25;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY24;
  }
  constructor(hotInstance) {
    super(hotInstance);
    privatePool19.set(this, {
      lastDesiredCoords: null
    });
    this.mergedCellsCollection = null;
    this.autofillCalculations = null;
    this.selectionCalculations = null;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link MergeCells#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY25];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.mergedCellsCollection = new cellsCollection_default(this);
    this.autofillCalculations = new autofill_default(this);
    this.selectionCalculations = new selection_default3(this);
    this.addHook("afterInit", function() {
      return _this.onAfterInit(...arguments);
    });
    this.addHook("modifyTransformStart", function() {
      return _this.onModifyTransformStart(...arguments);
    });
    this.addHook("afterModifyTransformStart", function() {
      return _this.onAfterModifyTransformStart(...arguments);
    });
    this.addHook("modifyTransformEnd", function() {
      return _this.onModifyTransformEnd(...arguments);
    });
    this.addHook("modifyGetCellCoords", function() {
      return _this.onModifyGetCellCoords(...arguments);
    });
    this.addHook("beforeSetRangeStart", function() {
      return _this.onBeforeSetRangeStart(...arguments);
    });
    this.addHook("beforeSetRangeStartOnly", function() {
      return _this.onBeforeSetRangeStart(...arguments);
    });
    this.addHook("beforeSetRangeEnd", function() {
      return _this.onBeforeSetRangeEnd(...arguments);
    });
    this.addHook("afterIsMultipleSelection", function() {
      return _this.onAfterIsMultipleSelection(...arguments);
    });
    this.addHook("afterRenderer", function() {
      return _this.onAfterRenderer(...arguments);
    });
    this.addHook("afterContextMenuDefaultOptions", function() {
      return _this.addMergeActionsToContextMenu(...arguments);
    });
    this.addHook("afterGetCellMeta", function() {
      return _this.onAfterGetCellMeta(...arguments);
    });
    this.addHook("afterViewportRowCalculatorOverride", function() {
      return _this.onAfterViewportRowCalculatorOverride(...arguments);
    });
    this.addHook("afterViewportColumnCalculatorOverride", function() {
      return _this.onAfterViewportColumnCalculatorOverride(...arguments);
    });
    this.addHook("modifyAutofillRange", function() {
      return _this.onModifyAutofillRange(...arguments);
    });
    this.addHook("afterCreateCol", function() {
      return _this.onAfterCreateCol(...arguments);
    });
    this.addHook("afterRemoveCol", function() {
      return _this.onAfterRemoveCol(...arguments);
    });
    this.addHook("afterCreateRow", function() {
      return _this.onAfterCreateRow(...arguments);
    });
    this.addHook("afterRemoveRow", function() {
      return _this.onAfterRemoveRow(...arguments);
    });
    this.addHook("afterChange", function() {
      return _this.onAfterChange(...arguments);
    });
    this.addHook("beforeDrawBorders", function() {
      return _this.onBeforeDrawAreaBorders(...arguments);
    });
    this.addHook("afterDrawSelection", function() {
      return _this.onAfterDrawSelection(...arguments);
    });
    this.addHook("beforeRemoveCellClassNames", function() {
      return _this.onBeforeRemoveCellClassNames(...arguments);
    });
    this.addHook("beforeUndoStackChange", (action, source) => {
      if (source === "MergeCells") {
        return false;
      }
    });
    this.registerShortcuts();
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.clearCollections();
    this.unregisterShortcuts();
    this.hot.render();
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the
   * following configuration options:
   *  - [`mergeCells`](@/api/options.md#mergecells)
   */
  updatePlugin() {
    const settings = this.hot.getSettings()[PLUGIN_KEY25];
    this.disablePlugin();
    this.enablePlugin();
    this.generateFromSettings(settings);
    super.updatePlugin();
  }
  /**
   * If the browser is recognized as Chrome, force an additional repaint to prevent showing the effects of a Chrome bug.
   *
   * Issue described in https://github.com/handsontable/dev-handsontable/issues/521.
   *
   * @private
   */
  ifChromeForceRepaint() {
    if (!isChrome()) {
      return;
    }
    const rowsToRefresh = [];
    let rowIndexesToRefresh = [];
    this.mergedCellsCollection.mergedCells.forEach((mergedCell) => {
      const {
        row,
        rowspan
      } = mergedCell;
      for (let r = row + 1; r < row + rowspan; r++) {
        rowIndexesToRefresh.push(r);
      }
    });
    rowIndexesToRefresh = [...new Set(rowIndexesToRefresh)];
    rowIndexesToRefresh.forEach((rowIndex) => {
      const renderableRowIndex = this.hot.rowIndexMapper.getRenderableFromVisualIndex(rowIndex);
      this.hot.view._wt.wtOverlays.getOverlays(true).map((overlay) => (overlay === null || overlay === void 0 ? void 0 : overlay.name) === "master" ? overlay : overlay.clone.wtTable).forEach((wtTableRef) => {
        const rowToRefresh = wtTableRef.getRow(renderableRowIndex);
        if (rowToRefresh) {
          rowToRefresh.style.background = getStyle(rowToRefresh, "backgroundColor").replace(")", ", 0.99)");
          rowsToRefresh.push(rowToRefresh);
        }
      });
    });
    this.hot._registerTimeout(() => {
      rowsToRefresh.forEach((rowElement) => {
        rowElement.style.background = getStyle(rowElement, "backgroundColor").replace(", 0.99)", ")");
      });
    }, 1);
  }
  /**
   * Validates a single setting object, represented by a single merged cell information object.
   *
   * @private
   * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.
   * @returns {boolean}
   */
  validateSetting(setting) {
    let valid = true;
    if (!setting) {
      return false;
    }
    if (cellCoords_default.containsNegativeValues(setting)) {
      warn2(cellCoords_default.NEGATIVE_VALUES_WARNING(setting));
      valid = false;
    } else if (cellCoords_default.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {
      warn2(cellCoords_default.IS_OUT_OF_BOUNDS_WARNING(setting));
      valid = false;
    } else if (cellCoords_default.isSingleCell(setting)) {
      warn2(cellCoords_default.IS_SINGLE_CELL(setting));
      valid = false;
    } else if (cellCoords_default.containsZeroSpan(setting)) {
      warn2(cellCoords_default.ZERO_SPAN_WARNING(setting));
      valid = false;
    }
    return valid;
  }
  /**
   * Generates the merged cells from the settings provided to the plugin.
   *
   * @private
   * @param {Array|boolean} settings The settings provided to the plugin.
   */
  generateFromSettings(settings) {
    if (Array.isArray(settings)) {
      const populatedNulls = [];
      arrayEach(settings, (setting) => {
        if (!this.validateSetting(setting)) {
          return;
        }
        const highlight = this.hot._createCellCoords(setting.row, setting.col);
        const rangeEnd = this.hot._createCellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);
        const mergeRange = this.hot._createCellRange(highlight, highlight, rangeEnd);
        this.mergeRange(mergeRange, true, true);
        rangeEach(setting.row, setting.row + setting.rowspan - 1, (rowIndex) => {
          rangeEach(setting.col, setting.col + setting.colspan - 1, (columnIndex) => {
            if ((rowIndex === setting.row && columnIndex === setting.col) === false) {
              populatedNulls.push([rowIndex, columnIndex, null]);
            }
          });
        });
      });
      if (populatedNulls.length === 0) {
        return;
      }
      this.hot.setDataAtCell(populatedNulls);
    }
  }
  /**
   * Clears the merged cells from the merged cell container.
   */
  clearCollections() {
    this.mergedCellsCollection.clear();
  }
  /**
   * Returns `true` if a range is mergeable.
   *
   * @private
   * @param {object} newMergedCellInfo Merged cell information object to test.
   * @param {boolean} [auto=false] `true` if triggered at initialization.
   * @returns {boolean}
   */
  canMergeRange(newMergedCellInfo) {
    let auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return auto ? true : this.validateSetting(newMergedCellInfo);
  }
  /**
   * Merge or unmerge, based on last selected range.
   *
   * @private
   */
  toggleMergeOnSelection() {
    const currentRange = this.hot.getSelectedRangeLast();
    if (!currentRange) {
      return;
    }
    currentRange.setDirection(this.hot.isRtl() ? "NE-SW" : "NW-SE");
    const {
      from: from2,
      to: to2
    } = currentRange;
    this.toggleMerge(currentRange);
    this.hot.selectCell(from2.row, from2.col, to2.row, to2.col, false);
  }
  /**
   * Merges the selection provided as a cell range.
   *
   * @param {CellRange} [cellRange] Selection cell range.
   */
  mergeSelection() {
    let cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
    if (!cellRange) {
      return;
    }
    cellRange.setDirection(this.hot.isRtl() ? "NE-SW" : "NW-SE");
    const {
      from: from2,
      to: to2
    } = cellRange;
    this.unmergeRange(cellRange, true);
    this.mergeRange(cellRange);
    this.hot.selectCell(from2.row, from2.col, to2.row, to2.col, false);
  }
  /**
   * Unmerges the selection provided as a cell range.
   *
   * @param {CellRange} [cellRange] Selection cell range.
   */
  unmergeSelection() {
    let cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
    if (!cellRange) {
      return;
    }
    const {
      from: from2,
      to: to2
    } = cellRange;
    this.unmergeRange(cellRange, true);
    this.hot.selectCell(from2.row, from2.col, to2.row, to2.col, false);
  }
  /**
   * Merges cells in the provided cell range.
   *
   * @private
   * @param {CellRange} cellRange Cell range to merge.
   * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.
   * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end,
   *   but rather return its arguments.
   * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to
   *   true. If the the merging process went successful, it returns `true`, otherwise - `false`.
   * @fires Hooks#beforeMergeCells
   * @fires Hooks#afterMergeCells
   */
  mergeRange(cellRange) {
    let auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let preventPopulation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const topStart = cellRange.getTopStartCorner();
    const bottomEnd = cellRange.getBottomEndCorner();
    const mergeParent = {
      row: topStart.row,
      col: topStart.col,
      rowspan: bottomEnd.row - topStart.row + 1,
      colspan: bottomEnd.col - topStart.col + 1
    };
    const clearedData = [];
    let populationInfo = null;
    if (!this.canMergeRange(mergeParent, auto)) {
      return false;
    }
    this.hot.runHooks("beforeMergeCells", cellRange, auto);
    rangeEach(0, mergeParent.rowspan - 1, (i) => {
      rangeEach(0, mergeParent.colspan - 1, (j) => {
        let clearedValue = null;
        if (!clearedData[i]) {
          clearedData[i] = [];
        }
        if (i === 0 && j === 0) {
          clearedValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(mergeParent.row), this.hot.toPhysicalColumn(mergeParent.col));
        } else {
          this.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, "hidden", true);
        }
        clearedData[i][j] = clearedValue;
      });
    });
    this.hot.setCellMeta(mergeParent.row, mergeParent.col, "spanned", true);
    const mergedCellAdded = this.mergedCellsCollection.add(mergeParent);
    if (mergedCellAdded) {
      if (preventPopulation) {
        populationInfo = [mergeParent.row, mergeParent.col, clearedData];
      } else {
        this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);
      }
      if (!auto) {
        this.ifChromeForceRepaint();
      }
      this.hot.runHooks("afterMergeCells", cellRange, mergeParent, auto);
      return populationInfo;
    }
    return true;
  }
  /**
   * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.
   *
   * @private
   * @param {CellRange} cellRange Selection cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   *
   * @fires Hooks#beforeUnmergeCells
   * @fires Hooks#afterUnmergeCells
   */
  unmergeRange(cellRange) {
    let auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);
    if (!mergedCells) {
      return;
    }
    this.hot.runHooks("beforeUnmergeCells", cellRange, auto);
    arrayEach(mergedCells, (currentCollection) => {
      this.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);
      rangeEach(0, currentCollection.rowspan - 1, (i) => {
        rangeEach(0, currentCollection.colspan - 1, (j) => {
          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, "hidden");
          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, "copyable");
        });
      });
      this.hot.removeCellMeta(currentCollection.row, currentCollection.col, "spanned");
    });
    this.hot.runHooks("afterUnmergeCells", cellRange, auto);
    this.hot.render();
  }
  /**
   * Merges or unmerges, based on the cell range provided as `cellRange`.
   *
   * @private
   * @param {CellRange} cellRange The cell range to merge or unmerged.
   */
  toggleMerge(cellRange) {
    const mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);
    const mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;
    if (mergedCellCoversWholeRange) {
      this.unmergeRange(cellRange);
    } else {
      this.mergeSelection(cellRange);
    }
  }
  /**
   * Merges the specified range.
   *
   * @param {number} startRow Start row of the merged cell.
   * @param {number} startColumn Start column of the merged cell.
   * @param {number} endRow End row of the merged cell.
   * @param {number} endColumn End column of the merged cell.
   * @fires Hooks#beforeMergeCells
   * @fires Hooks#afterMergeCells
   */
  merge(startRow, startColumn, endRow, endColumn) {
    const start = this.hot._createCellCoords(startRow, startColumn);
    const end = this.hot._createCellCoords(endRow, endColumn);
    this.mergeRange(this.hot._createCellRange(start, start, end));
  }
  /**
   * Unmerges the merged cell in the provided range.
   *
   * @param {number} startRow Start row of the merged cell.
   * @param {number} startColumn Start column of the merged cell.
   * @param {number} endRow End row of the merged cell.
   * @param {number} endColumn End column of the merged cell.
   * @fires Hooks#beforeUnmergeCells
   * @fires Hooks#afterUnmergeCells
   */
  unmerge(startRow, startColumn, endRow, endColumn) {
    const start = this.hot._createCellCoords(startRow, startColumn);
    const end = this.hot._createCellCoords(endRow, endColumn);
    this.unmergeRange(this.hot._createCellRange(start, start, end));
  }
  /**
   * `afterInit` hook callback.
   *
   * @private
   */
  onAfterInit() {
    this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY25]);
    this.hot.render();
  }
  /**
   * Register shortcuts responsible for toggling a merge.
   *
   * @private
   */
  registerShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const gridContext = shortcutManager.getContext("grid");
    gridContext.addShortcut({
      keys: [["Control", "m"]],
      callback: () => {
        this.toggleMerge(this.hot.getSelectedRangeLast());
        this.hot.render();
      },
      runOnlyIf: (event2) => !event2.altKey,
      // right ALT in some systems triggers ALT+CTRL
      group: SHORTCUTS_GROUP8
    });
  }
  /**
   * Unregister shortcuts responsible for toggling a merge.
   *
   * @private
   */
  unregisterShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const gridContext = shortcutManager.getContext("grid");
    gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP8);
  }
  /**
   * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection`
   * hook callback.
   *
   * @private
   * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.
   * @returns {boolean}
   */
  onAfterIsMultipleSelection(isMultiple) {
    if (isMultiple) {
      const mergedCells = this.mergedCellsCollection.mergedCells;
      const selectionRange = this.hot.getSelectedRangeLast();
      for (let group = 0; group < mergedCells.length; group += 1) {
        if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {
          return false;
        }
      }
    }
    return isMultiple;
  }
  /**
   * `modifyTransformStart` hook callback.
   *
   * @private
   * @param {object} delta The transformation delta.
   */
  onModifyTransformStart(delta) {
    const priv = privatePool19.get(this);
    const currentlySelectedRange = this.hot.getSelectedRangeLast();
    let newDelta = {
      row: delta.row,
      col: delta.col
    };
    let nextPosition = null;
    const currentPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);
    const mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);
    if (!priv.lastDesiredCoords) {
      priv.lastDesiredCoords = this.hot._createCellCoords(null, null);
    }
    if (mergedParent) {
      const mergeTopLeft = this.hot._createCellCoords(mergedParent.row, mergedParent.col);
      const mergeBottomRight = this.hot._createCellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);
      const mergeRange = this.hot._createCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);
      if (!mergeRange.includes(priv.lastDesiredCoords)) {
        priv.lastDesiredCoords = this.hot._createCellCoords(null, null);
      }
      newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;
      newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;
      if (delta.row > 0) {
        newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;
      } else if (delta.row < 0) {
        newDelta.row = currentPosition.row - mergedParent.row + delta.row;
      }
      if (delta.col > 0) {
        newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;
      } else if (delta.col < 0) {
        newDelta.col = currentPosition.col - mergedParent.col + delta.col;
      }
    }
    nextPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);
    const nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);
    if (nextPositionMergedCell) {
      const firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);
      priv.lastDesiredCoords = nextPosition;
      newDelta = {
        row: firstRenderableCoords.row - currentPosition.row,
        col: firstRenderableCoords.col - currentPosition.col
      };
    }
    if (newDelta.row !== 0) {
      delta.row = newDelta.row;
    }
    if (newDelta.col !== 0) {
      delta.col = newDelta.col;
    }
  }
  /**
   * `modifyTransformEnd` hook callback. Needed to handle "jumping over" merged merged cells, while selecting.
   *
   * @private
   * @param {object} delta The transformation delta.
   */
  onModifyTransformEnd(delta) {
    const currentSelectionRange = this.hot.getSelectedRangeLast();
    const newDelta = clone3(delta);
    const newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);
    let tempDelta = clone3(newDelta);
    const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);
    do {
      tempDelta = clone3(newDelta);
      this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);
      arrayEach(mergedCellsWithinRange, (mergedCell) => {
        this.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);
      });
    } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);
    delta.row = newDelta.row;
    delta.col = newDelta.col;
  }
  /**
   * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.
   *
   * @private
   * @param {number} row Row index.
   * @param {number} column Visual column index.
   * @returns {Array|undefined} Visual coordinates of the merge.
   */
  onModifyGetCellCoords(row, column) {
    if (row < 0 || column < 0) {
      return;
    }
    const mergeParent = this.mergedCellsCollection.get(row, column);
    if (!mergeParent) {
      return;
    }
    const {
      row: mergeRow,
      col: mergeColumn,
      colspan,
      rowspan
    } = mergeParent;
    return [
      // Most top-left merged cell coords.
      mergeRow,
      mergeColumn,
      // Most bottom-right merged cell coords.
      mergeRow + rowspan - 1,
      mergeColumn + colspan - 1
    ];
  }
  /**
   * `afterContextMenuDefaultOptions` hook callback.
   *
   * @private
   * @param {object} defaultOptions The default context menu options.
   */
  addMergeActionsToContextMenu(defaultOptions) {
    defaultOptions.items.push({
      name: "---------"
    }, toggleMergeItem(this));
  }
  /**
   * `afterRenderer` hook callback.
   *
   * @private
   * @param {HTMLElement} TD The cell to be modified.
   * @param {number} row Row index.
   * @param {number} col Visual column index.
   */
  onAfterRenderer(TD, row, col) {
    const mergedCell = this.mergedCellsCollection.get(row, col);
    const mergedCellCopy = isObject2(mergedCell) ? clone3(mergedCell) : void 0;
    if (isObject2(mergedCellCopy)) {
      const {
        rowIndexMapper: rowMapper,
        columnIndexMapper: columnMapper
      } = this.hot;
      const {
        row: mergeRow,
        col: mergeColumn,
        colspan,
        rowspan
      } = mergedCellCopy;
      const [lastMergedRowIndex, lastMergedColumnIndex] = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan);
      const renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);
      const renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);
      const maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1;
      const maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1;
      mergedCellCopy.row = rowMapper.getNearestNotHiddenIndex(mergedCellCopy.row, 1);
      mergedCellCopy.col = columnMapper.getNearestNotHiddenIndex(mergedCellCopy.col, 1);
      mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan);
      mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);
    }
    applySpanProperties(TD, mergedCellCopy, row, col);
  }
  /**
   * `beforeSetRangeStart` and `beforeSetRangeStartOnly` hook callback.
   * A selection within merge area should be rewritten to the start of merge area.
   *
   * @private
   * @param {object} coords Cell coords.
   */
  onBeforeSetRangeStart(coords) {
    if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {
      const mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);
      [coords.row, coords.col] = [mergeParent.row, mergeParent.col];
    }
  }
  /**
   * `beforeSetRangeEnd` hook callback.
   * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the
   * merged cell.
   *
   * Note: Please keep in mind that callback may modify both start and end range coordinates by the reference.
   *
   * @private
   * @param {object} coords Cell coords.
   */
  onBeforeSetRangeEnd(coords) {
    const selRange = this.hot.getSelectedRangeLast();
    selRange.highlight = this.hot._createCellCoords(selRange.highlight.row, selRange.highlight.col);
    selRange.to = coords;
    let rangeExpanded = false;
    if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {
      return;
    }
    do {
      rangeExpanded = false;
      for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {
        const cellInfo = this.mergedCellsCollection.mergedCells[i];
        const mergedCellRange = cellInfo.getRange();
        if (selRange.expandByRange(mergedCellRange)) {
          coords.row = selRange.to.row;
          coords.col = selRange.to.col;
          rangeExpanded = true;
        }
      }
    } while (rangeExpanded);
  }
  /**
   * The `afterGetCellMeta` hook callback.
   *
   * @private
   * @param {number} row Row index.
   * @param {number} col Column index.
   * @param {object} cellProperties The cell properties object.
   */
  onAfterGetCellMeta(row, col, cellProperties) {
    const mergeParent = this.mergedCellsCollection.get(row, col);
    if (mergeParent) {
      if (mergeParent.row !== row || mergeParent.col !== col) {
        cellProperties.copyable = false;
      } else {
        cellProperties.rowspan = mergeParent.rowspan;
        cellProperties.colspan = mergeParent.colspan;
      }
    }
  }
  /**
   * `afterViewportRowCalculatorOverride` hook callback.
   *
   * @private
   * @param {object} calc The row calculator object.
   */
  onAfterViewportRowCalculatorOverride(calc) {
    const nrOfColumns = this.hot.countCols();
    this.modifyViewportRowStart(calc, nrOfColumns);
    this.modifyViewportRowEnd(calc, nrOfColumns);
  }
  /**
   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.
   *
   * @private
   * @param {object} calc The row calculator object.
   * @param {number} nrOfColumns Number of visual columns.
   */
  modifyViewportRowStart(calc, nrOfColumns) {
    const rowMapper = this.hot.rowIndexMapper;
    const visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);
    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {
      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);
      if (isObject2(mergeParentForViewportStart)) {
        const renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.row, 1));
        if (renderableIndexAtMergeStart < calc.startRow) {
          calc.startRow = renderableIndexAtMergeStart;
          this.modifyViewportRowStart(calc, nrOfColumns);
          return;
        }
      }
    }
  }
  /**
   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.
   *
   * @private
   * @param {object} calc The row calculator object.
   * @param {number} nrOfColumns Number of visual columns.
   */
  modifyViewportRowEnd(calc, nrOfColumns) {
    const rowMapper = this.hot.rowIndexMapper;
    const visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);
    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {
      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);
      if (isObject2(mergeParentForViewportEnd)) {
        const mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;
        const renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeEnd, -1));
        if (renderableIndexAtMergeEnd > calc.endRow) {
          calc.endRow = renderableIndexAtMergeEnd;
          this.modifyViewportRowEnd(calc, nrOfColumns);
          return;
        }
      }
    }
  }
  /**
   * `afterViewportColumnCalculatorOverride` hook callback.
   *
   * @private
   * @param {object} calc The column calculator object.
   */
  onAfterViewportColumnCalculatorOverride(calc) {
    const nrOfRows = this.hot.countRows();
    this.modifyViewportColumnStart(calc, nrOfRows);
    this.modifyViewportColumnEnd(calc, nrOfRows);
  }
  /**
   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.
   *
   * @private
   * @param {object} calc The column calculator object.
   * @param {number} nrOfRows Number of visual rows.
   */
  modifyViewportColumnStart(calc, nrOfRows) {
    const columnMapper = this.hot.columnIndexMapper;
    const visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);
    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {
      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);
      if (isObject2(mergeParentForViewportStart)) {
        const renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.col, 1));
        if (renderableIndexAtMergeStart < calc.startColumn) {
          calc.startColumn = renderableIndexAtMergeStart;
          this.modifyViewportColumnStart(calc, nrOfRows);
          return;
        }
      }
    }
  }
  /**
   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.
   *
   * @private
   * @param {object} calc The column calculator object.
   * @param {number} nrOfRows Number of visual rows.
   */
  modifyViewportColumnEnd(calc, nrOfRows) {
    const columnMapper = this.hot.columnIndexMapper;
    const visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);
    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {
      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);
      if (isObject2(mergeParentForViewportEnd)) {
        const mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;
        const renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeEnd, -1));
        if (renderableIndexAtMergeEnd > calc.endColumn) {
          calc.endColumn = renderableIndexAtMergeEnd;
          this.modifyViewportColumnEnd(calc, nrOfRows);
          return;
        }
      }
    }
  }
  /**
   * Translates merged cell coordinates to renderable indexes.
   *
   * @private
   * @param {number} parentRow Visual row index.
   * @param {number} rowspan Rowspan which describes shift which will be applied to parent row
   *                         to calculate renderable index which points to the most bottom
   *                         index position. Pass rowspan as `0` to calculate the most top
   *                         index position.
   * @param {number} parentColumn Visual column index.
   * @param {number} colspan Colspan which describes shift which will be applied to parent column
   *                         to calculate renderable index which points to the most right
   *                         index position. Pass colspan as `0` to calculate the most left
   *                         index position.
   * @returns {number[]}
   */
  translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {
    const {
      rowIndexMapper: rowMapper,
      columnIndexMapper: columnMapper
    } = this.hot;
    let firstNonHiddenRow;
    let firstNonHiddenColumn;
    if (rowspan === 0) {
      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow, 1);
    } else {
      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow + rowspan - 1, -1);
    }
    if (colspan === 0) {
      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn, 1);
    } else {
      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn + colspan - 1, -1);
    }
    const renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;
    const renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;
    return [renderableRow, renderableColumn];
  }
  /**
   * The `modifyAutofillRange` hook callback.
   *
   * @private
   * @param {Array} drag The drag area coordinates.
   * @param {Array} select The selection information.
   * @returns {Array} The new drag area.
   */
  onModifyAutofillRange(drag, select) {
    this.autofillCalculations.correctSelectionAreaSize(select);
    const dragDirection = this.autofillCalculations.getDirection(select, drag);
    let dragArea = drag;
    if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {
      dragArea = select;
      return dragArea;
    }
    const mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({
      from: {
        row: select[0],
        col: select[1]
      },
      to: {
        row: select[2],
        col: select[3]
      }
    });
    if (!mergedCellsWithinSelectionArea) {
      return dragArea;
    }
    dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);
    return dragArea;
  }
  /**
   * `afterCreateCol` hook callback.
   *
   * @private
   * @param {number} column Column index.
   * @param {number} count Number of created columns.
   */
  onAfterCreateCol(column, count) {
    this.mergedCellsCollection.shiftCollections("right", column, count);
  }
  /**
   * `afterRemoveCol` hook callback.
   *
   * @private
   * @param {number} column Column index.
   * @param {number} count Number of removed columns.
   */
  onAfterRemoveCol(column, count) {
    this.mergedCellsCollection.shiftCollections("left", column, count);
  }
  /**
   * `afterCreateRow` hook callback.
   *
   * @private
   * @param {number} row Row index.
   * @param {number} count Number of created rows.
   * @param {string} source Source of change.
   */
  onAfterCreateRow(row, count, source) {
    if (source === "auto") {
      return;
    }
    this.mergedCellsCollection.shiftCollections("down", row, count);
  }
  /**
   * `afterRemoveRow` hook callback.
   *
   * @private
   * @param {number} row Row index.
   * @param {number} count Number of removed rows.
   */
  onAfterRemoveRow(row, count) {
    this.mergedCellsCollection.shiftCollections("up", row, count);
  }
  /**
   * `afterChange` hook callback. Used to propagate merged cells after using Autofill.
   *
   * @private
   * @param {Array} changes The changes array.
   * @param {string} source Determines the source of the change.
   */
  onAfterChange(changes, source) {
    if (source !== "Autofill.fill") {
      return;
    }
    this.autofillCalculations.recreateAfterDataPopulation(changes);
  }
  /**
   * `beforeDrawAreaBorders` hook callback.
   *
   * @private
   * @param {Array} corners Visual coordinates of the area corners.
   * @param {string} className Class name for the area.
   */
  onBeforeDrawAreaBorders(corners, className) {
    if (className && className === "area") {
      const selectedRange = this.hot.getSelectedRangeLast();
      const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);
      arrayEach(mergedCellsWithinRange, (mergedCell) => {
        if (selectedRange.getBottomEndCorner().row === mergedCell.getLastRow() && selectedRange.getBottomEndCorner().col === mergedCell.getLastColumn()) {
          corners[2] = mergedCell.row;
          corners[3] = mergedCell.col;
        }
      });
    }
  }
  /**
   * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of
   * the table with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.
   *
   * @private
   * @param {CellCoords} coords Coordinates of the to-be-selected cell.
   * @param {number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value =
   *   down).
   * @param {number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value =
   *   down).
   */
  onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {
    if (!this.enabled) {
      return;
    }
    const mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);
    if (!mergedCellAtCoords) {
      return;
    }
    const goingDown = rowTransformDir > 0;
    const goingUp = rowTransformDir < 0;
    const goingLeft = colTransformDir < 0;
    const goingRight = colTransformDir > 0;
    const mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;
    const mergedCellOnTopEdge = mergedCellAtCoords.row === 0;
    const mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;
    const mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;
    if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {
      coords.row = mergedCellAtCoords.row;
      coords.col = mergedCellAtCoords.col;
    }
  }
  /**
   * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.
   *
   * @private
   * @param {number} currentRow Visual row index of the currently processed cell.
   * @param {number} currentColumn Visual column index of the currently cell.
   * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow,
   *   endColumn]`.
   * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.
   * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently
   *   processed cell.
   */
  onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {
    if (!cornersOfSelection) {
      return;
    }
    return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);
  }
  /**
   * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.
   *
   * @private
   * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from
   *   all the cells in the table.
   */
  onBeforeRemoveCellClassNames() {
    return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();
  }
};

// node_modules/handsontable/plugins/multiColumnSorting/rootComparator.mjs
function rootComparator2(sortingOrders, columnMetas) {
  return function(rowIndexWithValues, nextRowIndexWithValues) {
    const [, ...values] = rowIndexWithValues;
    const [, ...nextValues] = nextRowIndexWithValues;
    return function getCompareResult(column) {
      const sortingOrder = sortingOrders[column];
      const columnMeta = columnMetas[column];
      const value = values[column];
      const nextValue = nextValues[column];
      const pluginSettings = columnMeta.multiColumnSorting;
      const compareFunctionFactory5 = pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory : getCompareFunctionFactory(columnMeta.type);
      const compareResult = compareFunctionFactory5(sortingOrder, columnMeta, pluginSettings)(value, nextValue);
      if (compareResult === DO_NOT_SWAP) {
        const nextSortedColumn = column + 1;
        if (typeof columnMetas[nextSortedColumn] !== "undefined") {
          return getCompareResult(nextSortedColumn);
        }
      }
      return compareResult;
    }(0);
  };
}

// node_modules/handsontable/plugins/multiColumnSorting/utils.mjs
function warnAboutPluginsConflict() {
  warn2(toSingleLine`Plugins \`columnSorting\` and \`multiColumnSorting\` should not be enabled simultaneously. 
    Only \`multiColumnSorting\` will work.`);
}

// node_modules/handsontable/plugins/multiColumnSorting/domHelpers.mjs
var COLUMN_ORDER_PREFIX = "sort";
function getClassesToAdd2(columnStatesManager, column, showSortIndicator) {
  const cssClasses = [];
  if (showSortIndicator === false) {
    return cssClasses;
  }
  if (columnStatesManager.isColumnSorted(column) && columnStatesManager.getNumberOfSortedColumns() > 1) {
    cssClasses.push(`${COLUMN_ORDER_PREFIX}-${columnStatesManager.getIndexOfColumnInSortQueue(column) + 1}`);
  }
  return cssClasses;
}
function getClassesToRemove2(htmlElement) {
  const cssClasses = htmlElement.className.split(" ");
  const sortSequenceRegExp = new RegExp(`^${COLUMN_ORDER_PREFIX}-[0-9]{1,2}$`);
  return cssClasses.filter((cssClass) => sortSequenceRegExp.test(cssClass));
}

// node_modules/handsontable/plugins/multiColumnSorting/multiColumnSorting.mjs
var PLUGIN_KEY26 = "multiColumnSorting";
var PLUGIN_PRIORITY25 = 170;
var APPEND_COLUMN_CONFIG_STRATEGY2 = "append";
var CONFLICTED_PLUGIN_KEY = "columnSorting";
registerRootComparator(PLUGIN_KEY26, rootComparator2);
var MultiColumnSorting = class extends ColumnSorting {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY26;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY25;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.pluginKey = PLUGIN_KEY26;
  }
  /**
   * Checks if the plugin is enabled in the Handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link MultiColumnSorting#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return super.isEnabled();
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (!this.enabled && this.hot.getSettings()[this.pluginKey] && this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {
      warnAboutPluginsConflict();
    }
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    super.disablePlugin();
  }
  /**
   * Sorts the table by chosen columns and orders.
   *
   * @param {undefined|object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   *
   * **Note**: Please keep in mind that every call of `sort` function set an entirely new sort order. Previous sort configs aren't preserved.
   *
   * @example
   * ```js
   * // sort ascending first visual column
   * hot.getPlugin('multiColumnSorting').sort({ column: 0, sortOrder: 'asc' });
   *
   * // sort first two visual column in the defined sequence
   * hot.getPlugin('multiColumnSorting').sort([{
   *   column: 1, sortOrder: 'asc'
   * }, {
   *   column: 0, sortOrder: 'desc'
   * }]);
   * ```
   *
   * @fires Hooks#beforeColumnSort
   * @fires Hooks#afterColumnSort
   */
  sort(sortConfig) {
    super.sort(sortConfig);
  }
  /**
   * Clear the sort performed on the table.
   */
  clearSort() {
    super.clearSort();
  }
  /**
   * Checks if the table is sorted (any column have to be sorted).
   *
   * @returns {boolean}
   */
  isSorted() {
    return super.isSorted();
  }
  /**
   * Get sort configuration for particular column or for all sorted columns. Objects contain `column` and `sortOrder` properties.
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key. They are handled by the `sort` function.
   *
   * @param {number} [column] Visual column index.
   * @returns {undefined|object|Array}
   */
  getSortConfig(column) {
    return super.getSortConfig(column);
  }
  /**
   * @description
   * Warn: Useful mainly for providing server side sort implementation (see in the example below). It doesn't sort the data set. It just sets sort configuration for all sorted columns.
   * Note: Please keep in mind that this method doesn't re-render the table.
   *
   * @example
   * ```js
   * beforeColumnSort: function(currentSortConfig, destinationSortConfigs) {
   *   const columnSortPlugin = this.getPlugin('multiColumnSorting');
   *
   *   columnSortPlugin.setSortConfig(destinationSortConfigs);
   *
   *   // const newData = ... // Calculated data set, ie. from an AJAX call.
   *
   *   this.loadData(newData); // Load new data set and re-render the table.
   *
   *   return false; // The blockade for the default sort action.
   * }
   * ```
   *
   * @param {undefined|object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   */
  setSortConfig(sortConfig) {
    super.setSortConfig(sortConfig);
  }
  /**
   * Get normalized sort configs.
   *
   * @private
   * @param {object|Array} [sortConfig=[]] Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   * @returns {Array}
   */
  getNormalizedSortConfigs() {
    let sortConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (Array.isArray(sortConfig)) {
      return sortConfig;
    }
    return [sortConfig];
  }
  /**
   * Update header classes.
   *
   * @private
   * @param {HTMLElement} headerSpanElement Header span element.
   * @param {...*} args Extra arguments for helpers.
   */
  updateHeaderClasses(headerSpanElement) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    super.updateHeaderClasses(headerSpanElement, ...args);
    removeClass(headerSpanElement, getClassesToRemove2(headerSpanElement));
    if (this.enabled !== false) {
      addClass(headerSpanElement, getClassesToAdd2(...args));
    }
  }
  /**
   * Overwriting base plugin's `onUpdateSettings` method. Please keep in mind that `onAfterUpdateSettings` isn't called
   * for `updateSettings` in specific situations.
   *
   * @private
   * @param {object} newSettings New settings object.
   */
  onUpdateSettings(newSettings) {
    if (this.hot.getSettings()[this.pluginKey] && this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {
      warnAboutPluginsConflict();
    }
    super.onUpdateSettings(newSettings);
  }
  /**
   * Callback for the `onAfterOnCellMouseDown` hook.
   *
   * @private
   * @param {Event} event Event which are provided by hook.
   * @param {CellCoords} coords Visual coords of the selected cell.
   */
  onAfterOnCellMouseDown(event2, coords) {
    if (wasHeaderClickedProperly(coords.row, coords.col, event2) === false) {
      return;
    }
    if (this.wasClickableHeaderClicked(event2, coords.col)) {
      if (this.hot.getShortcutManager().isCtrlPressed()) {
        this.hot.deselectCell();
        this.hot.selectColumns(coords.col);
        this.sort(this.getNextSortConfig(coords.col, APPEND_COLUMN_CONFIG_STRATEGY2));
      } else {
        this.sort(this.getColumnNextConfig(coords.col));
      }
    }
  }
};

// node_modules/handsontable/plugins/multipleSelectionHandles/multipleSelectionHandles.mjs
var PLUGIN_KEY27 = "multipleSelectionHandles";
var PLUGIN_PRIORITY26 = 160;
var MultipleSelectionHandles = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY27;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY26;
  }
  /**
   * @param {object} hotInstance The handsontable instance.
   */
  constructor(hotInstance) {
    super(hotInstance);
    this.dragged = [];
    this.eventManager = null;
    this.lastSetCell = null;
  }
  /**
   * Check if the plugin is enabled in the handsontable settings.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return isMobileBrowser();
  }
  /**
   * Enable plugin for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    if (!this.eventManager) {
      this.eventManager = new eventManager_default(this);
    }
    this.registerListeners();
    super.enablePlugin();
  }
  /**
   * Bind the touch events.
   *
   * @private
   */
  registerListeners() {
    const _this = this;
    const {
      rootElement
    } = this.hot;
    function removeFromDragged(query) {
      if (_this.dragged.length === 1) {
        _this.dragged.splice(0, _this.dragged.length);
        return true;
      }
      const entryPosition = _this.dragged.indexOf(query);
      if (entryPosition === -1) {
        return false;
      } else if (entryPosition === 0) {
        _this.dragged = _this.dragged.slice(0, 1);
      } else if (entryPosition === 1) {
        _this.dragged = _this.dragged.slice(-1);
      }
    }
    this.eventManager.addEventListener(rootElement, "touchstart", (event2) => {
      let selectedRange;
      if (hasClass(event2.target, "topSelectionHandle-HitArea")) {
        selectedRange = _this.hot.getSelectedRangeLast();
        _this.dragged.push("top");
        _this.touchStartRange = {
          width: selectedRange.getWidth(),
          height: selectedRange.getHeight(),
          direction: selectedRange.getDirection()
        };
        event2.preventDefault();
        return false;
      } else if (hasClass(event2.target, "bottomSelectionHandle-HitArea")) {
        selectedRange = _this.hot.getSelectedRangeLast();
        _this.dragged.push("bottom");
        _this.touchStartRange = {
          width: selectedRange.getWidth(),
          height: selectedRange.getHeight(),
          direction: selectedRange.getDirection()
        };
        event2.preventDefault();
        return false;
      }
    });
    this.eventManager.addEventListener(rootElement, "touchend", (event2) => {
      if (hasClass(event2.target, "topSelectionHandle-HitArea")) {
        removeFromDragged.call(_this, "top");
        _this.touchStartRange = void 0;
        event2.preventDefault();
        return false;
      } else if (hasClass(event2.target, "bottomSelectionHandle-HitArea")) {
        removeFromDragged.call(_this, "bottom");
        _this.touchStartRange = void 0;
        event2.preventDefault();
        return false;
      }
    });
    this.eventManager.addEventListener(rootElement, "touchmove", (event2) => {
      const {
        rootDocument
      } = this.hot;
      let targetCoords;
      let selectedRange;
      let rangeWidth;
      let rangeHeight;
      let rangeDirection;
      let newRangeCoords;
      if (_this.dragged.length === 0) {
        return;
      }
      const endTarget = rootDocument.elementFromPoint(event2.touches[0].clientX, event2.touches[0].clientY);
      if (!endTarget || endTarget === _this.lastSetCell) {
        return;
      }
      if (endTarget.nodeName === "TD" || endTarget.nodeName === "TH") {
        targetCoords = _this.hot.getCoords(endTarget);
        if (targetCoords.col === -1) {
          targetCoords.col = 0;
        }
        selectedRange = _this.hot.getSelectedRangeLast();
        rangeWidth = selectedRange.getWidth();
        rangeHeight = selectedRange.getHeight();
        rangeDirection = selectedRange.getDirection();
        if (rangeWidth === 1 && rangeHeight === 1) {
          _this.hot.selection.setRangeEnd(targetCoords);
        }
        newRangeCoords = _this.getCurrentRangeCoords(selectedRange, targetCoords, _this.touchStartRange.direction, rangeDirection, _this.dragged[0]);
        if (newRangeCoords.start !== null) {
          _this.hot.selection.setRangeStart(newRangeCoords.start);
        }
        _this.hot.selection.setRangeEnd(newRangeCoords.end);
        _this.lastSetCell = endTarget;
      }
      event2.preventDefault();
    });
  }
  getCurrentRangeCoords(selectedRange, currentTouch, touchStartDirection, currentDirection, draggedHandle) {
    const topStartCorner = selectedRange.getTopStartCorner();
    const bottomEndCorner = selectedRange.getBottomEndCorner();
    const bottomStartCorner = selectedRange.getBottomStartCorner();
    const topEndCorner = selectedRange.getTopEndCorner();
    let newCoords = {
      start: null,
      end: null
    };
    switch (touchStartDirection) {
      case "NE-SW":
        switch (currentDirection) {
          case "NE-SW":
          case "NW-SE":
            if (draggedHandle === "top") {
              newCoords = {
                start: this.hot._createCellCoords(currentTouch.row, selectedRange.highlight.col),
                end: this.hot._createCellCoords(bottomStartCorner.row, currentTouch.col)
              };
            } else {
              newCoords = {
                start: this.hot._createCellCoords(selectedRange.highlight.row, currentTouch.col),
                end: this.hot._createCellCoords(currentTouch.row, topStartCorner.col)
              };
            }
            break;
          case "SE-NW":
            if (draggedHandle === "bottom") {
              newCoords = {
                start: this.hot._createCellCoords(bottomEndCorner.row, currentTouch.col),
                end: this.hot._createCellCoords(currentTouch.row, topStartCorner.col)
              };
            }
            break;
          default:
            break;
        }
        break;
      case "NW-SE":
        switch (currentDirection) {
          case "NE-SW":
            if (draggedHandle === "top") {
              newCoords = {
                start: currentTouch,
                end: bottomStartCorner
              };
            } else {
              newCoords.end = currentTouch;
            }
            break;
          case "NW-SE":
            if (draggedHandle === "top") {
              newCoords = {
                start: currentTouch,
                end: bottomEndCorner
              };
            } else {
              newCoords.end = currentTouch;
            }
            break;
          case "SE-NW":
            if (draggedHandle === "top") {
              newCoords = {
                start: currentTouch,
                end: topStartCorner
              };
            } else {
              newCoords.end = currentTouch;
            }
            break;
          case "SW-NE":
            if (draggedHandle === "top") {
              newCoords = {
                start: currentTouch,
                end: topEndCorner
              };
            } else {
              newCoords.end = currentTouch;
            }
            break;
          default:
            break;
        }
        break;
      case "SW-NE":
        switch (currentDirection) {
          case "NW-SE":
            if (draggedHandle === "bottom") {
              newCoords = {
                start: this.hot._createCellCoords(currentTouch.row, topStartCorner.col),
                end: this.hot._createCellCoords(bottomStartCorner.row, currentTouch.col)
              };
            } else {
              newCoords = {
                start: this.hot._createCellCoords(topStartCorner.row, currentTouch.col),
                end: this.hot._createCellCoords(currentTouch.row, bottomEndCorner.col)
              };
            }
            break;
          case "SW-NE":
            if (draggedHandle === "top") {
              newCoords = {
                start: this.hot._createCellCoords(selectedRange.highlight.row, currentTouch.col),
                end: this.hot._createCellCoords(currentTouch.row, bottomEndCorner.col)
              };
            } else {
              newCoords = {
                start: this.hot._createCellCoords(currentTouch.row, topStartCorner.col),
                end: this.hot._createCellCoords(topStartCorner.row, currentTouch.col)
              };
            }
            break;
          case "SE-NW":
            if (draggedHandle === "bottom") {
              newCoords = {
                start: this.hot._createCellCoords(currentTouch.row, topEndCorner.col),
                end: this.hot._createCellCoords(topStartCorner.row, currentTouch.col)
              };
            } else if (draggedHandle === "top") {
              newCoords = {
                start: bottomStartCorner,
                end: currentTouch
              };
            }
            break;
          default:
            break;
        }
        break;
      case "SE-NW":
        switch (currentDirection) {
          case "NW-SE":
          case "NE-SW":
          case "SW-NE":
            if (draggedHandle === "top") {
              newCoords.end = currentTouch;
            }
            break;
          case "SE-NW":
            if (draggedHandle === "top") {
              newCoords.end = currentTouch;
            } else {
              newCoords = {
                start: currentTouch,
                end: topStartCorner
              };
            }
            break;
          default:
            break;
        }
        break;
      default:
        break;
    }
    return newCoords;
  }
  /**
   * Check if user is currently dragging the handle.
   *
   * @returns {boolean} Dragging state.
   */
  isDragged() {
    return this.dragged.length > 0;
  }
};

// node_modules/handsontable/plugins/nestedHeaders/stateManager/utils.mjs
function createDefaultHeaderSettings() {
  let {
    label = "",
    colspan = 1,
    origColspan = 1,
    collapsible = false,
    crossHiddenColumns = [],
    isCollapsed = false,
    isHidden = false,
    isRoot = false,
    isPlaceholder = false
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return {
    label,
    colspan,
    origColspan,
    collapsible,
    isCollapsed,
    crossHiddenColumns,
    isHidden,
    isRoot,
    isPlaceholder
  };
}
function createPlaceholderHeaderSettings() {
  return {
    label: "",
    isPlaceholder: true
  };
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/settingsNormalizer.mjs
function normalizeSettings(sourceSettings) {
  let columnsLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
  const normalizedSettings = [];
  if (columnsLimit === 0) {
    return normalizedSettings;
  }
  arrayEach(sourceSettings, (headersSettings) => {
    const columns = [];
    let columnIndex = 0;
    normalizedSettings.push(columns);
    arrayEach(headersSettings, (sourceHeaderSettings) => {
      const headerSettings = createDefaultHeaderSettings();
      if (isObject2(sourceHeaderSettings)) {
        const {
          label,
          colspan
        } = sourceHeaderSettings;
        headerSettings.label = stringify(label);
        if (typeof colspan === "number" && colspan > 1) {
          headerSettings.colspan = colspan;
          headerSettings.origColspan = colspan;
        }
      } else {
        headerSettings.label = stringify(sourceHeaderSettings);
      }
      columnIndex += headerSettings.origColspan;
      let cancelProcessing = false;
      if (columnIndex >= columnsLimit) {
        headerSettings.colspan = headerSettings.origColspan - (columnIndex - columnsLimit);
        headerSettings.origColspan = headerSettings.colspan;
        cancelProcessing = true;
      }
      columns.push(headerSettings);
      if (headerSettings.colspan > 1) {
        for (let i = 0; i < headerSettings.colspan - 1; i++) {
          columns.push(createPlaceholderHeaderSettings());
        }
      }
      return !cancelProcessing;
    });
  });
  const columnsLength = Math.max(...arrayMap(normalizedSettings, (headersSettings) => headersSettings.length));
  arrayEach(normalizedSettings, (headersSettings) => {
    if (headersSettings.length < columnsLength) {
      const defaultSettings = arrayMap(new Array(columnsLength - headersSettings.length), () => createDefaultHeaderSettings());
      headersSettings.splice(headersSettings.length, 0, ...defaultSettings);
    }
  });
  return normalizedSettings;
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/sourceSettings.mjs
function _classPrivateFieldInitSpec14(obj, privateMap, value) {
  _checkPrivateRedeclaration15(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration15(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet14(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor14(receiver, privateMap, "get");
  return _classApplyDescriptorGet14(receiver, descriptor);
}
function _classApplyDescriptorGet14(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet14(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor14(receiver, privateMap, "set");
  _classApplyDescriptorSet14(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor14(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet14(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var HEADER_CONFIGURABLE_PROPS = ["label", "collapsible"];
var _data = /* @__PURE__ */ new WeakMap();
var _dataLength = /* @__PURE__ */ new WeakMap();
var _columnsLimit2 = /* @__PURE__ */ new WeakMap();
var SourceSettings = class {
  constructor() {
    _classPrivateFieldInitSpec14(this, _data, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec14(this, _dataLength, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec14(this, _columnsLimit2, {
      writable: true,
      value: Infinity
    });
  }
  /**
   * Sets columns limit to the source settings will be trimmed. All headers which
   * overlap the column limit will be reduced to keep the structure solid.
   *
   * @param {number} columnsCount The number of columns to limit to.
   */
  setColumnsLimit(columnsCount) {
    _classPrivateFieldSet14(this, _columnsLimit2, columnsCount);
  }
  /**
   * Sets a new nested header configuration.
   *
   * @param {Array[]} [nestedHeadersSettings=[]] The user-defined nested headers settings.
   */
  setData() {
    let nestedHeadersSettings = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classPrivateFieldSet14(this, _data, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet14(this, _columnsLimit2)));
    _classPrivateFieldSet14(this, _dataLength, _classPrivateFieldGet14(this, _data).length);
  }
  /**
   * Gets normalized source settings.
   *
   * @returns {Array[]}
   */
  getData() {
    return _classPrivateFieldGet14(this, _data);
  }
  /**
   * Merges settings with current source settings.
   *
   * @param {object[]} additionalSettings An array of objects with `row`, `col` and additional
   *                                      properties to merge with current source settings.
   */
  mergeWith(additionalSettings) {
    arrayEach(additionalSettings, (_ref2) => {
      let {
        row,
        col,
        ...rest
      } = _ref2;
      const headerSettings = this.getHeaderSettings(row, col);
      if (headerSettings !== null) {
        extend2(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);
      }
    });
  }
  /**
   * Maps the current state with a callback. For each source settings the callback function
   * is called. If the function returns value that value is merged with the source settings.
   *
   * @param {Function} callback A function that is called for every header settings.
   *                            Each time the callback is called, the returned value extends
   *                            header settings.
   */
  map(callback) {
    arrayEach(_classPrivateFieldGet14(this, _data), (header) => {
      arrayEach(header, (headerSettings) => {
        const propsToExtend = callback({
          ...headerSettings
        });
        if (isObject2(propsToExtend)) {
          extend2(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);
        }
      });
    });
  }
  /**
   * Gets source column header settings for a specified header. The returned
   * object contains information about the header label, its colspan length,
   * or if it is hidden in the header renderers.
   *
   * @param {number} headerLevel Header level (0 = most distant to the table).
   * @param {number} columnIndex A visual column index.
   * @returns {object|null}
   */
  getHeaderSettings(headerLevel, columnIndex) {
    var _headersSettings$colu;
    if (headerLevel >= _classPrivateFieldGet14(this, _dataLength) || headerLevel < 0) {
      return null;
    }
    const headersSettings = _classPrivateFieldGet14(this, _data)[headerLevel];
    if (columnIndex >= headersSettings.length) {
      return null;
    }
    return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;
  }
  /**
   * Gets source of column headers settings for specified headers. If the retrieved column
   * settings overlap the range "box" determined by "columnIndex" and "columnsLength"
   * the exception will be thrown.
   *
   * @param {number} headerLevel Header level (0 = most distant to the table).
   * @param {number} columnIndex A visual column index from which the settings will be extracted.
   * @param {number} [columnsLength=1] The number of columns involved in the extraction of settings.
   * @returns {object}
   */
  getHeadersSettings(headerLevel, columnIndex) {
    let columnsLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const headersSettingsChunks = [];
    if (headerLevel >= _classPrivateFieldGet14(this, _dataLength) || headerLevel < 0) {
      return headersSettingsChunks;
    }
    const headersSettings = _classPrivateFieldGet14(this, _data)[headerLevel];
    let currentLength = 0;
    for (let i = columnIndex; i < headersSettings.length; i++) {
      const headerSettings = headersSettings[i];
      if (headerSettings.isPlaceholder) {
        throw new Error("The first column settings cannot overlap the other header layers");
      }
      currentLength += headerSettings.colspan;
      headersSettingsChunks.push(headerSettings);
      if (headerSettings.colspan > 1) {
        i += headerSettings.colspan - 1;
      }
      if (currentLength === columnsLength) {
        break;
      }
      if (currentLength > columnsLength) {
        throw new Error("The last column settings cannot overlap the other header layers");
      }
    }
    return headersSettingsChunks;
  }
  /**
   * Gets a total number of headers levels.
   *
   * @returns {number}
   */
  getLayersCount() {
    return _classPrivateFieldGet14(this, _dataLength);
  }
  /**
   * Gets a total number of columns count.
   *
   * @returns {number}
   */
  getColumnsCount() {
    return _classPrivateFieldGet14(this, _dataLength) > 0 ? _classPrivateFieldGet14(this, _data)[0].length : 0;
  }
  /**
   * Clears the data.
   */
  clear() {
    _classPrivateFieldSet14(this, _data, []);
    _classPrivateFieldSet14(this, _dataLength, 0);
  }
};

// node_modules/handsontable/utils/dataStructures/tree.mjs
function _defineProperty21(obj, key, value) {
  key = _toPropertyKey21(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey21(arg) {
  var key = _toPrimitive21(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive21(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var TRAVERSAL_DF_PRE = "DF-pre-order";
function depthFirstPreOrder(callback, context) {
  let continueTraverse = callback.call(context, this);
  for (let i = 0; i < this.childs.length; i++) {
    if (continueTraverse === false) {
      return false;
    }
    continueTraverse = depthFirstPreOrder.call(this.childs[i], callback, context);
  }
  return continueTraverse;
}
var TRAVERSAL_DF_POST = "DF-post-order";
function depthFirstPostOrder(callback, context) {
  for (let i = 0; i < this.childs.length; i++) {
    const continueTraverse = depthFirstPostOrder.call(this.childs[i], callback, context);
    if (continueTraverse === false) {
      return false;
    }
  }
  return callback.call(context, this);
}
var TRAVERSAL_BF = "BF";
function breadthFirst(callback, context) {
  const queue = [this];
  function process2() {
    if (queue.length === 0) {
      return;
    }
    const node = queue.shift();
    queue.push(...node.childs);
    if (callback.call(context, node) !== false) {
      process2();
    }
  }
  process2();
}
var DEFAULT_TRAVERSAL_STRATEGY = TRAVERSAL_BF;
var TRAVERSAL_STRATEGIES = /* @__PURE__ */ new Map([[TRAVERSAL_DF_PRE, depthFirstPreOrder], [TRAVERSAL_DF_POST, depthFirstPostOrder], [TRAVERSAL_BF, breadthFirst]]);
var TreeNode = class _TreeNode {
  constructor(data) {
    _defineProperty21(this, "data", {});
    _defineProperty21(this, "parent", null);
    _defineProperty21(this, "childs", []);
    this.data = data;
  }
  /**
   * Adds a node to tree leaves. Added node is linked with the parent node through "parent" property.
   *
   * @param {TreeNode} node A TreeNode to add.
   */
  addChild(node) {
    node.parent = this;
    this.childs.push(node);
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @memberof TreeNode#
   * @function cloneTree
   *
   * Clones a tree structure deeply.
   *
   * For example, for giving a tree structure:
   *      .--(B1)--.
   *   .-(C1)   .-(C2)-.----.
   *  (D1)     (D2)   (D3) (D4)
   *
   * Cloning a tree starting from C2 node creates a mirrored tree structure.
   *     .-(C2')-.-----.
   *    (D2')   (D3') (D4')
   *
   * The cloned tree can be safely modified without affecting the original structure.
   * After modification, the clone can be merged with a tree using the "replaceTreeWith" method.
   *
   * @param {TreeNode} [nodeTree=this] A TreeNode to clone.
   * @returns {TreeNode}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  cloneTree() {
    let nodeTree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
    const clonedNode = new _TreeNode({
      ...nodeTree.data
    });
    for (let i = 0; i < nodeTree.childs.length; i++) {
      clonedNode.addChild(this.cloneTree(nodeTree.childs[i]));
    }
    return clonedNode;
  }
  /**
   * Replaces the current node with a passed tree structure.
   *
   * @param {TreeNode} nodeTree A TreeNode to replace with.
   */
  replaceTreeWith(nodeTree) {
    this.data = {
      ...nodeTree.data
    };
    this.childs = [];
    for (let i = 0; i < nodeTree.childs.length; i++) {
      this.addChild(nodeTree.childs[i]);
    }
  }
  /**
   * Traverses the tree structure through node childs. The walk down traversing supports
   * a three different strategies.
   *  - Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR));
   *  - Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR));
   *  - Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).
   *
   * @param {Function} callback The callback function which will be called for each node.
   * @param {string} [traversalStrategy=DEFAULT_TRAVERSAL_STRATEGY] Traversing strategy.
   */
  walkDown(callback) {
    let traversalStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_TRAVERSAL_STRATEGY;
    if (!TRAVERSAL_STRATEGIES.has(traversalStrategy)) {
      throw new Error(`Traversal strategy "${traversalStrategy}" does not exist`);
    }
    TRAVERSAL_STRATEGIES.get(traversalStrategy).call(this, callback, this);
  }
  /**
   * Traverses the tree structure through node parents.
   *
   * @param {Function} callback The callback function which will be called for each node.
   */
  walkUp(callback) {
    const context = this;
    const process2 = (node) => {
      const continueTraverse = callback.call(context, node);
      if (continueTraverse !== false && node.parent !== null) {
        process2(node.parent);
      }
    };
    process2(this);
  }
};

// node_modules/handsontable/plugins/nestedHeaders/stateManager/headersTree.mjs
function _classPrivateFieldInitSpec15(obj, privateMap, value) {
  _checkPrivateRedeclaration16(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration16(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet15(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor15(receiver, privateMap, "get");
  return _classApplyDescriptorGet15(receiver, descriptor);
}
function _classApplyDescriptorGet15(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet15(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor15(receiver, privateMap, "set");
  _classApplyDescriptorSet15(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor15(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet15(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _rootNodes = /* @__PURE__ */ new WeakMap();
var _rootsIndex = /* @__PURE__ */ new WeakMap();
var _sourceSettings = /* @__PURE__ */ new WeakMap();
var HeadersTree = class {
  constructor(sourceSettings) {
    _classPrivateFieldInitSpec15(this, _rootNodes, {
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    _classPrivateFieldInitSpec15(this, _rootsIndex, {
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    _classPrivateFieldInitSpec15(this, _sourceSettings, {
      writable: true,
      value: null
    });
    _classPrivateFieldSet15(this, _sourceSettings, sourceSettings);
  }
  /**
   * Gets an array of the all root nodes.
   *
   * @returns {TreeNode[]}
   */
  getRoots() {
    return Array.from(_classPrivateFieldGet15(this, _rootNodes).values());
  }
  /**
   * Gets a root node by specified visual column index.
   *
   * @param {number} columnIndex A visual column index.
   * @returns {TreeNode|undefined}
   */
  getRootByColumn(columnIndex) {
    let node;
    if (_classPrivateFieldGet15(this, _rootsIndex).has(columnIndex)) {
      node = _classPrivateFieldGet15(this, _rootNodes).get(_classPrivateFieldGet15(this, _rootsIndex).get(columnIndex));
    }
    return node;
  }
  /**
   * Gets a tree node by its position in the grid settings.
   *
   * @param {number} headerLevel Header level index (there is support only for positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {TreeNode|undefined}
   */
  getNode(headerLevel, columnIndex) {
    const rootNode = this.getRootByColumn(columnIndex);
    if (!rootNode) {
      return;
    }
    const normColumnIndex = columnIndex - _classPrivateFieldGet15(this, _rootsIndex).get(columnIndex);
    let columnCursor = 0;
    let treeNode;
    rootNode.walkDown((node) => {
      const {
        data: {
          origColspan,
          headerLevel: nodeHeaderLevel
        }
      } = node;
      if (headerLevel === nodeHeaderLevel) {
        if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {
          treeNode = node;
          treeNode.data.isRoot = columnIndex === treeNode.data.columnIndex;
          return false;
        }
        columnCursor += origColspan;
      }
    });
    return treeNode;
  }
  /**
   * Builds (or rebuilds if called again) root nodes indexes.
   */
  rebuildTreeIndex() {
    let columnIndex = 0;
    _classPrivateFieldGet15(this, _rootsIndex).clear();
    arrayEach(_classPrivateFieldGet15(this, _rootNodes), (_ref2) => {
      let [, {
        data: {
          colspan
        }
      }] = _ref2;
      for (let i = columnIndex; i < columnIndex + colspan; i++) {
        _classPrivateFieldGet15(this, _rootsIndex).set(i, columnIndex);
      }
      columnIndex += colspan;
    });
  }
  /**
   * Builds trees based on SourceSettings class. Calling a method causes clearing the tree state built
   * from the previous call.
   */
  buildTree() {
    this.clear();
    const columnsCount = _classPrivateFieldGet15(this, _sourceSettings).getColumnsCount();
    let columnIndex = 0;
    while (columnIndex < columnsCount) {
      const columnSettings = _classPrivateFieldGet15(this, _sourceSettings).getHeaderSettings(0, columnIndex);
      const rootNode = new TreeNode();
      _classPrivateFieldGet15(this, _rootNodes).set(columnIndex, rootNode);
      this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);
      columnIndex += columnSettings.origColspan;
    }
    this.rebuildTreeIndex();
  }
  /**
   * Builds leaves for specified tree node.
   *
   * @param {TreeNode} parentNode A node to which the leaves applies.
   * @param {number} columnIndex A visual column index.
   * @param {number} headerLevel Currently processed header level.
   * @param {number} [extractionLength=1] Determines column extraction length for node children.
   */
  buildLeaves(parentNode, columnIndex, headerLevel) {
    let extractionLength = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    const columnsSettings = _classPrivateFieldGet15(this, _sourceSettings).getHeadersSettings(headerLevel, columnIndex, extractionLength);
    headerLevel += 1;
    arrayEach(columnsSettings, (columnSettings) => {
      const nodeData = {
        ...columnSettings,
        /**
         * The header level (tree node depth level).
         *
         * @type {number}
         */
        headerLevel: headerLevel - 1,
        /**
         * A visual column index.
         *
         * @type {number}
         */
        columnIndex
      };
      let node;
      if (headerLevel === 1) {
        parentNode.data = nodeData;
        node = parentNode;
      } else {
        node = new TreeNode(nodeData);
        parentNode.addChild(node);
      }
      if (headerLevel < _classPrivateFieldGet15(this, _sourceSettings).getLayersCount()) {
        this.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);
      }
      columnIndex += columnSettings.origColspan;
    });
  }
  /**
   * Clears the tree to the initial state.
   */
  clear() {
    _classPrivateFieldGet15(this, _rootNodes).clear();
    _classPrivateFieldGet15(this, _rootsIndex).clear();
  }
};

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/utils/tree.mjs
function traverseHiddenNodeColumnIndexes(node, callback) {
  node.walkDown((_ref2) => {
    let {
      data,
      childs
    } = _ref2;
    if (!data.isHidden) {
      callback(data.columnIndex);
      if (childs.length === 0) {
        for (let i = 1; i < data.colspan; i++) {
          callback(data.columnIndex + i);
        }
      }
    }
  });
}
function getFirstChildProperty(_ref2, propertyName) {
  let {
    childs
  } = _ref2;
  if (childs.length === 0) {
    return;
  }
  return childs[0].data[propertyName];
}
function isNodeReflectsFirstChildColspan(node) {
  return getFirstChildProperty(node, "origColspan") === node.data.origColspan;
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/expand.mjs
function expandNode(nodeToProcess) {
  const {
    data: nodeData,
    childs: nodeChilds
  } = nodeToProcess;
  if (!nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {
    return {
      rollbackModification: () => {
      },
      affectedColumns: [],
      colspanCompensation: 0
    };
  }
  const isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);
  if (isNodeReflected) {
    return expandNode(nodeChilds[0]);
  }
  nodeData.isCollapsed = false;
  const allLeavesExceptMostLeft = nodeChilds.slice(1);
  const affectedColumns = /* @__PURE__ */ new Set();
  let colspanCompensation = 0;
  if (allLeavesExceptMostLeft.length > 0) {
    arrayEach(allLeavesExceptMostLeft, (node) => {
      node.replaceTreeWith(node.data.clonedTree);
      node.data.clonedTree = null;
      const leafData = node.data;
      colspanCompensation += leafData.colspan;
      traverseHiddenNodeColumnIndexes(node, (gridColumnIndex) => {
        affectedColumns.add(gridColumnIndex);
      });
    });
  } else {
    const {
      colspan,
      origColspan,
      columnIndex
    } = nodeData;
    colspanCompensation = origColspan - colspan;
    for (let i = 1; i < origColspan; i++) {
      affectedColumns.add(columnIndex + i);
    }
  }
  nodeToProcess.walkUp((node) => {
    const {
      data
    } = node;
    data.colspan += colspanCompensation;
    if (data.colspan >= data.origColspan) {
      data.colspan = data.origColspan;
      data.isCollapsed = false;
    } else if (isNodeReflectsFirstChildColspan(node)) {
      data.isCollapsed = getFirstChildProperty(node, "isCollapsed");
    }
  });
  return {
    rollbackModification: () => collapseNode(nodeToProcess),
    affectedColumns: Array.from(affectedColumns),
    colspanCompensation
  };
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/collapse.mjs
function collapseNode(nodeToProcess) {
  var _getFirstChildPropert;
  const {
    data: nodeData,
    childs: nodeChilds
  } = nodeToProcess;
  if (nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {
    return {
      rollbackModification: () => {
      },
      affectedColumns: [],
      colspanCompensation: 0
    };
  }
  const isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);
  if (isNodeReflected) {
    return collapseNode(nodeChilds[0]);
  }
  nodeData.isCollapsed = true;
  const allLeavesExceptMostLeft = nodeChilds.slice(1);
  const affectedColumns = /* @__PURE__ */ new Set();
  if (allLeavesExceptMostLeft.length > 0) {
    arrayEach(allLeavesExceptMostLeft, (node) => {
      traverseHiddenNodeColumnIndexes(node, (gridColumnIndex) => {
        affectedColumns.add(gridColumnIndex);
      });
      node.data.clonedTree = node.cloneTree();
      node.walkDown((_ref2) => {
        let {
          data
        } = _ref2;
        data.isHidden = true;
      });
    });
  } else {
    const {
      origColspan,
      columnIndex
    } = nodeData;
    for (let i = 1; i < origColspan; i++) {
      const gridColumnIndex = columnIndex + i;
      affectedColumns.add(gridColumnIndex);
    }
  }
  const colspanCompensation = nodeData.colspan - ((_getFirstChildPropert = getFirstChildProperty(nodeToProcess, "colspan")) !== null && _getFirstChildPropert !== void 0 ? _getFirstChildPropert : 1);
  nodeToProcess.walkUp((node) => {
    const {
      data
    } = node;
    data.colspan -= colspanCompensation;
    if (data.colspan <= 1) {
      data.colspan = 1;
      data.isCollapsed = true;
    } else if (isNodeReflectsFirstChildColspan(node)) {
      data.isCollapsed = getFirstChildProperty(node, "isCollapsed");
    }
  });
  return {
    rollbackModification: () => expandNode(nodeToProcess),
    affectedColumns: Array.from(affectedColumns),
    colspanCompensation
  };
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/hideColumn.mjs
function hideColumn(nodeToProcess, gridColumnIndex) {
  if (!Number.isInteger(gridColumnIndex)) {
    throw new Error("The passed gridColumnIndex argument has invalid type.");
  }
  if (nodeToProcess.childs.length > 0) {
    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\x20
the last node, the hide column modification can be applied.`);
  }
  const {
    crossHiddenColumns
  } = nodeToProcess.data;
  if (crossHiddenColumns.includes(gridColumnIndex)) {
    return;
  }
  let isCollapsibleNode = false;
  nodeToProcess.walkUp((node) => {
    const {
      data: {
        collapsible
      }
    } = node;
    if (collapsible) {
      isCollapsibleNode = true;
      return false;
    }
  });
  if (isCollapsibleNode) {
    return;
  }
  nodeToProcess.walkUp((node) => {
    const {
      data
    } = node;
    data.crossHiddenColumns.push(gridColumnIndex);
    if (data.colspan > 1) {
      data.colspan -= 1;
    } else {
      data.isHidden = true;
    }
  });
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/showColumn.mjs
function showColumn(nodeToProcess, gridColumnIndex) {
  if (!Number.isInteger(gridColumnIndex)) {
    throw new Error("The passed gridColumnIndex argument has invalid type.");
  }
  if (nodeToProcess.childs.length > 0) {
    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\x20
the last node, the show column modification can be applied.`);
  }
  const {
    crossHiddenColumns
  } = nodeToProcess.data;
  if (!crossHiddenColumns.includes(gridColumnIndex)) {
    return;
  }
  let isCollapsibleNode = false;
  nodeToProcess.walkUp((node) => {
    const {
      data: {
        collapsible
      }
    } = node;
    if (collapsible) {
      isCollapsibleNode = true;
      return false;
    }
  });
  if (isCollapsibleNode) {
    return;
  }
  nodeToProcess.walkUp((node) => {
    const {
      data
    } = node;
    data.crossHiddenColumns.splice(data.crossHiddenColumns.indexOf(gridColumnIndex), 1);
    if (!data.isHidden && data.colspan < data.origColspan) {
      data.colspan += 1;
    }
    data.isHidden = false;
  });
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/index.mjs
var availableModifiers = /* @__PURE__ */ new Map([["collapse", collapseNode], ["expand", expandNode], ["hide-column", hideColumn], ["show-column", showColumn]]);
function triggerNodeModification(actionName, nodeToProcess, gridColumnIndex) {
  if (!availableModifiers.has(actionName)) {
    throw new Error(`The node modifier action ("${actionName}") does not exist.`);
  }
  return availableModifiers.get(actionName)(nodeToProcess, gridColumnIndex);
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/matrixGenerator.mjs
function generateMatrix(headerRoots) {
  const matrix = [];
  arrayEach(headerRoots, (rootNode) => {
    rootNode.walkDown((node) => {
      const nodeData = node.data;
      const {
        origColspan,
        columnIndex,
        headerLevel,
        crossHiddenColumns
      } = nodeData;
      const colspanHeaderLayer = createNestedArrayIfNecessary(matrix, headerLevel);
      let isRootSettingsFound = false;
      for (let i = columnIndex; i < columnIndex + origColspan; i++) {
        const isColumnHidden = crossHiddenColumns.includes(i);
        if (isColumnHidden || isRootSettingsFound) {
          colspanHeaderLayer.push(createPlaceholderHeaderSettings(nodeData));
        } else {
          const headerRootSettings = createHeaderSettings(nodeData);
          headerRootSettings.isRoot = true;
          colspanHeaderLayer.push(headerRootSettings);
          isRootSettingsFound = true;
        }
      }
    });
  });
  return matrix;
}
function createHeaderSettings(nodeData) {
  const {
    crossHiddenColumns,
    ...headerRootSettings
  } = createDefaultHeaderSettings(nodeData);
  return headerRootSettings;
}
function createNestedArrayIfNecessary(array, index2) {
  let subArray;
  if (Array.isArray(array[index2])) {
    subArray = array[index2];
  } else {
    subArray = [];
    array[index2] = subArray;
  }
  return subArray;
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/index.mjs
function _classPrivateFieldInitSpec16(obj, privateMap, value) {
  _checkPrivateRedeclaration17(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration17(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet16(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor16(receiver, privateMap, "set");
  _classApplyDescriptorSet16(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet16(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet16(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor16(receiver, privateMap, "get");
  return _classApplyDescriptorGet16(receiver, descriptor);
}
function _classExtractFieldDescriptor16(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet16(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var _sourceSettings2 = /* @__PURE__ */ new WeakMap();
var _headersTree = /* @__PURE__ */ new WeakMap();
var _stateMatrix = /* @__PURE__ */ new WeakMap();
var StateManager = class {
  constructor() {
    _classPrivateFieldInitSpec16(this, _sourceSettings2, {
      writable: true,
      value: new SourceSettings()
    });
    _classPrivateFieldInitSpec16(this, _headersTree, {
      writable: true,
      value: new HeadersTree(_classPrivateFieldGet16(this, _sourceSettings2))
    });
    _classPrivateFieldInitSpec16(this, _stateMatrix, {
      writable: true,
      value: [[]]
    });
  }
  /**
   * Sets a new state for the nested headers plugin based on settings passed
   * directly to the plugin.
   *
   * @param {Array[]} nestedHeadersSettings The user-defined settings.
   * @returns {boolean} Returns `true` if the settings are processed correctly, `false` otherwise.
   */
  setState(nestedHeadersSettings) {
    _classPrivateFieldGet16(this, _sourceSettings2).setData(nestedHeadersSettings);
    let hasError = false;
    try {
      _classPrivateFieldGet16(this, _headersTree).buildTree();
    } catch (ex) {
      _classPrivateFieldGet16(this, _headersTree).clear();
      _classPrivateFieldGet16(this, _sourceSettings2).clear();
      hasError = true;
    }
    _classPrivateFieldSet16(this, _stateMatrix, generateMatrix(_classPrivateFieldGet16(this, _headersTree).getRoots()));
    return hasError;
  }
  /**
   * Sets columns limit to the state will be trimmed. All headers (colspans) which
   * overlap the column limit will be reduced to keep the structure solid.
   *
   * @param {number} columnsCount The number of columns to limit to.
   */
  setColumnsLimit(columnsCount) {
    _classPrivateFieldGet16(this, _sourceSettings2).setColumnsLimit(columnsCount);
  }
  /**
   * Merges settings with current plugin state.
   *
   * By default only foreign keys are merged with source state and passed to the tree. But only
   * known keys are exported to matrix.
   *
   * @param {object[]} settings An array of objects to merge with the current source settings.
   *                            It is a requirement that every object has `row` and `col` properties
   *                            which points to the specific header settings object.
   */
  mergeStateWith(settings) {
    const transformedSettings = arrayMap(settings, (_ref2) => {
      let {
        row,
        ...rest
      } = _ref2;
      return {
        row: row < 0 ? this.rowCoordsToLevel(row) : row,
        ...rest
      };
    });
    _classPrivateFieldGet16(this, _sourceSettings2).mergeWith(transformedSettings);
    _classPrivateFieldGet16(this, _headersTree).buildTree();
    _classPrivateFieldSet16(this, _stateMatrix, generateMatrix(_classPrivateFieldGet16(this, _headersTree).getRoots()));
  }
  /**
   * Maps the current state with a callback. For each header settings the callback function
   * is called. If the function returns value that value is merged with the state.
   *
   * By default only foreign keys are merged with source state and passed to the tree. But only
   * known keys are exported to matrix.
   *
   * @param {Function} callback A function that is called for every header source settings.
   *                            Each time the callback is called, the returned value extends
   *                            header settings.
   */
  mapState(callback) {
    _classPrivateFieldGet16(this, _sourceSettings2).map(callback);
    _classPrivateFieldGet16(this, _headersTree).buildTree();
    _classPrivateFieldSet16(this, _stateMatrix, generateMatrix(_classPrivateFieldGet16(this, _headersTree).getRoots()));
  }
  /**
   * Maps the current tree nodes with a callback. For each node the callback function
   * is called. If the function returns value that value is added to returned array.
   *
   * @param {Function} callback A function that is called for every tree node.
   *                            Each time the callback is called, the returned value is
   *                            added to returned array.
   * @returns {Array}
   */
  mapNodes(callback) {
    return arrayReduce(_classPrivateFieldGet16(this, _headersTree).getRoots(), (acc, rootNode) => {
      rootNode.walkDown((node) => {
        const result = callback(node.data);
        if (result !== void 0) {
          acc.push(result);
        }
      });
      return acc;
    }, []);
  }
  /**
   * Triggers an action (e.g. "collapse") from the NodeModifiers module. The module
   * modifies a tree structure in such a way as to obtain the correct structure consistent with the
   * called action.
   *
   * @param {string} action An action name to trigger.
   * @param {number} headerLevel Header level index (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {object|undefined}
   */
  triggerNodeModification(action, headerLevel, columnIndex) {
    if (headerLevel < 0) {
      headerLevel = this.rowCoordsToLevel(headerLevel);
    }
    const nodeToProcess = _classPrivateFieldGet16(this, _headersTree).getNode(headerLevel, columnIndex);
    let actionResult;
    if (nodeToProcess) {
      actionResult = triggerNodeModification(action, nodeToProcess, columnIndex);
      _classPrivateFieldSet16(this, _stateMatrix, generateMatrix(_classPrivateFieldGet16(this, _headersTree).getRoots()));
    }
    return actionResult;
  }
  /**
   * Triggers an action (e.g. "hide-column") from the NodeModifiers module. The action is
   * triggered starting from the lowest header. The module modifies a tree structure in
   * such a way as to obtain the correct structure consistent with the called action.
   *
   * @param {string} action An action name to trigger.
   * @param {number} columnIndex A visual column index.
   * @returns {object|undefined}
   */
  triggerColumnModification(action, columnIndex) {
    return this.triggerNodeModification(action, -1, columnIndex);
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @memberof StateManager#
   * @function rowCoordsToLevel
   *
   * Translates row coordinates into header level. The row coordinates counts from -1 to -N
   * and describes headers counting from most closest to most distant from the table.
   * The header levels are counted from 0 to N where 0 describes most distant header
   * from the table.
   *
   *  Row coords             Header level
   *           +--------------+
   *       -3  │ A1 │ A1      │  0
   *           +--------------+
   *       -2  │ B1 │ B2 │ B3 │  1
   *           +--------------+
   *       -1  │ C1 │ C2 │ C3 │  2
   *           +==============+
   *           │    │    │    │
   *           +--------------+
   *           │    │    │    │
   *
   * @param {number} rowIndex A visual row index.
   * @returns {number|null} Returns unsigned number.
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  rowCoordsToLevel(rowIndex) {
    if (rowIndex >= 0) {
      return null;
    }
    const headerLevel = rowIndex + Math.max(this.getLayersCount(), 1);
    if (headerLevel < 0) {
      return null;
    }
    return headerLevel;
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @memberof StateManager#
   * @function levelToRowCoords
   *
   * Translates header level into row coordinates. The row coordinates counts from -1 to -N
   * and describes headers counting from most closest to most distant from the table.
   * The header levels are counted from 0 to N where 0 describes most distant header
   * from the table.
   *
   *  Header level            Row coords
   *           +--------------+
   *        0  │ A1 │ A1      │  -3
   *           +--------------+
   *        1  │ B1 │ B2 │ B3 │  -2
   *           +--------------+
   *        2  │ C1 │ C2 │ C3 │  -1
   *           +==============+
   *           │    │    │    │
   *           +--------------+
   *           │    │    │    │
   *
   * @param {number} headerLevel Header level index.
   * @returns {number} Returns negative number.
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  levelToRowCoords(headerLevel) {
    if (headerLevel < 0) {
      return null;
    }
    const rowIndex = headerLevel - Math.max(this.getLayersCount(), 1);
    if (rowIndex >= 0) {
      return null;
    }
    return rowIndex;
  }
  /**
   * Gets column header settings for a specified column and header index. The returned object contains
   * all information necessary for header renderers. It contains header label, colspan length, or hidden
   * flag.
   *
   * @param {number} headerLevel Header level (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {object|null}
   */
  getHeaderSettings(headerLevel, columnIndex) {
    var _classPrivateFieldGet22, _classPrivateFieldGet32;
    if (headerLevel < 0) {
      headerLevel = this.rowCoordsToLevel(headerLevel);
    }
    if (headerLevel === null || headerLevel >= this.getLayersCount()) {
      return null;
    }
    return (_classPrivateFieldGet22 = (_classPrivateFieldGet32 = _classPrivateFieldGet16(this, _stateMatrix)[headerLevel]) === null || _classPrivateFieldGet32 === void 0 ? void 0 : _classPrivateFieldGet32[columnIndex]) !== null && _classPrivateFieldGet22 !== void 0 ? _classPrivateFieldGet22 : null;
  }
  /**
   * Gets tree data that is connected to the column header. The returned object contains all information
   * necessary for modifying tree structure (column collapsing, hiding, etc.). It contains a header
   * label, colspan length, or visual column index that indicates which column index the node is rendered from.
   *
   * @param {number} headerLevel Header level (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {object|null}
   */
  getHeaderTreeNodeData(headerLevel, columnIndex) {
    if (headerLevel < 0) {
      headerLevel = this.rowCoordsToLevel(headerLevel);
    }
    if (headerLevel === null || headerLevel >= this.getLayersCount()) {
      return null;
    }
    const node = _classPrivateFieldGet16(this, _headersTree).getNode(headerLevel, columnIndex);
    if (!node) {
      return null;
    }
    return {
      ...node.data
    };
  }
  /**
   * The method is helpful in cases where the column index targets in-between currently
   * collapsed column. In that case, the method returns the left-most column index
   * where the nested header begins.
   *
   * @param {number} headerLevel Header level (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {number}
   */
  findLeftMostColumnIndex(headerLevel, columnIndex) {
    var _this$getHeaderSettin;
    const {
      isRoot
    } = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {
      isRoot: true
    };
    if (isRoot) {
      return columnIndex;
    }
    let stepBackColumn = columnIndex - 1;
    while (stepBackColumn >= 0) {
      var _this$getHeaderSettin2;
      const {
        isRoot: isRootNode
      } = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {
        isRoot: true
      };
      if (isRootNode) {
        break;
      }
      stepBackColumn -= 1;
    }
    return stepBackColumn;
  }
  /**
   * Gets a total number of headers levels.
   *
   * @returns {number}
   */
  getLayersCount() {
    return _classPrivateFieldGet16(this, _sourceSettings2).getLayersCount();
  }
  /**
   * Gets a total number of columns count.
   *
   * @returns {number}
   */
  getColumnsCount() {
    return _classPrivateFieldGet16(this, _sourceSettings2).getColumnsCount();
  }
  /**
   * Clears the column state manager to the initial state.
   */
  clear() {
    _classPrivateFieldSet16(this, _stateMatrix, []);
    _classPrivateFieldGet16(this, _sourceSettings2).clear();
    _classPrivateFieldGet16(this, _headersTree).clear();
  }
};

// node_modules/handsontable/plugins/nestedHeaders/utils/ghostTable.mjs
function _defineProperty22(obj, key, value) {
  key = _toPropertyKey22(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey22(arg) {
  var key = _toPrimitive22(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive22(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var GhostTable2 = class {
  constructor(hot, nestedHeaderSettingsGetter) {
    _defineProperty22(this, "hot", void 0);
    _defineProperty22(this, "nestedHeaderSettingsGetter", void 0);
    _defineProperty22(this, "layersCount", 0);
    _defineProperty22(this, "container", void 0);
    _defineProperty22(this, "widthsMap", void 0);
    this.hot = hot;
    this.nestedHeaderSettingsGetter = nestedHeaderSettingsGetter;
    this.widthsMap = this.hot.columnIndexMapper.createAndRegisterIndexMap("nestedHeaders.widthsMap", "physicalIndexToValue");
  }
  /**
   * Sets the number of nested headers layers count.
   *
   * @param {number} layersCount Total number of headers levels.
   * @returns {GhostTable}
   */
  setLayersCount(layersCount) {
    this.layersCount = layersCount;
    return this;
  }
  /**
   * Gets the column width based on the visual column index.
   *
   * @param {number} visualColumn Visual column index.
   * @returns {number|null}
   */
  getWidth(visualColumn) {
    return this.widthsMap.getValueAtIndex(this.hot.toPhysicalColumn(visualColumn));
  }
  /**
   * Build cache of the headers widths.
   */
  buildWidthsMap() {
    this.container = this.hot.rootDocument.createElement("div");
    this.container.classList.add("handsontable", "htGhostTable", "htAutoSize");
    this._buildGhostTable(this.container);
    this.hot.rootDocument.body.appendChild(this.container);
    const columns = this.container.querySelectorAll("tr:last-of-type th");
    const maxColumns = columns.length;
    this.widthsMap.clear();
    for (let column = 0; column < maxColumns; column++) {
      const visualColumnsIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(column);
      const physicalColumnIndex = this.hot.toPhysicalColumn(visualColumnsIndex);
      this.widthsMap.setValueAtIndex(physicalColumnIndex, columns[column].offsetWidth);
    }
    this.container.parentNode.removeChild(this.container);
    this.container = null;
  }
  /**
   * Build temporary table for getting minimal columns widths.
   *
   * @private
   * @param {HTMLElement} container The element where the DOM nodes are injected.
   */
  _buildGhostTable(container) {
    const {
      rootDocument,
      columnIndexMapper
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    const table = rootDocument.createElement("table");
    const isDropdownEnabled = !!this.hot.getSettings().dropdownMenu;
    const maxRenderedCols = columnIndexMapper.getRenderableIndexesLength();
    for (let row = 0; row < this.layersCount; row++) {
      const tr = rootDocument.createElement("tr");
      for (let col = 0; col < maxRenderedCols; col++) {
        let visualColumnsIndex = columnIndexMapper.getVisualFromRenderableIndex(col);
        if (visualColumnsIndex === null) {
          visualColumnsIndex = col;
        }
        const th = rootDocument.createElement("th");
        const headerSettings = this.nestedHeaderSettingsGetter(row, visualColumnsIndex);
        if (headerSettings && (!headerSettings.isPlaceholder || headerSettings.isHidden)) {
          let label = headerSettings.label;
          if (isDropdownEnabled) {
            label += '<button class="changeType"></button>';
          }
          fastInnerHTML(th, label);
          th.colSpan = headerSettings.colspan;
          tr.appendChild(th);
        }
      }
      table.appendChild(tr);
    }
    fragment.appendChild(table);
    container.appendChild(fragment);
  }
  /**
   * Clear the widths cache.
   */
  clear() {
    this.widthsMap.clear();
    this.container = null;
  }
};
var ghostTable_default2 = GhostTable2;

// node_modules/handsontable/plugins/nestedHeaders/nestedHeaders.mjs
function _defineProperty23(obj, key, value) {
  key = _toPropertyKey23(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey23(arg) {
  var key = _toPrimitive23(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive23(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldInitSpec17(obj, privateMap, value) {
  _checkPrivateRedeclaration18(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration18(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet17(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor17(receiver, privateMap, "set");
  _classApplyDescriptorSet17(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet17(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet17(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor17(receiver, privateMap, "get");
  return _classApplyDescriptorGet17(receiver, descriptor);
}
function _classExtractFieldDescriptor17(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet17(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var PLUGIN_KEY28 = "nestedHeaders";
var PLUGIN_PRIORITY27 = 280;
var _stateManager = /* @__PURE__ */ new WeakMap();
var _hidingIndexMapObserver = /* @__PURE__ */ new WeakMap();
var NestedHeaders = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateFieldInitSpec17(this, _stateManager, {
      writable: true,
      value: new StateManager()
    });
    _classPrivateFieldInitSpec17(this, _hidingIndexMapObserver, {
      writable: true,
      value: null
    });
    _defineProperty23(this, "ghostTable", new ghostTable_default2(this.hot, (row, column) => this.getHeaderSettings(row, column)));
    _defineProperty23(this, "detectedOverlappedHeaders", false);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY28;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY27;
  }
  /**
   * Check if plugin is enabled.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY28];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const {
      nestedHeaders
    } = this.hot.getSettings();
    if (!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {
      warn2(toSingleLine`Your Nested Headers plugin configuration is invalid. The settings has to be\x20
                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]`);
    }
    this.addHook("init", () => this.onInit());
    this.addHook("afterLoadData", function() {
      return _this.onAfterLoadData(...arguments);
    });
    this.addHook("beforeOnCellMouseDown", function() {
      return _this.onBeforeOnCellMouseDown(...arguments);
    });
    this.addHook("afterOnCellMouseDown", function() {
      return _this.onAfterOnCellMouseDown(...arguments);
    });
    this.addHook("beforeOnCellMouseOver", function() {
      return _this.onBeforeOnCellMouseOver(...arguments);
    });
    this.addHook("afterGetColumnHeaderRenderers", (array) => this.onAfterGetColumnHeaderRenderers(array));
    this.addHook("modifyColWidth", function() {
      return _this.onModifyColWidth(...arguments);
    });
    this.addHook("modifyColumnHeaderValue", function() {
      return _this.onModifyColumnHeaderValue(...arguments);
    });
    this.addHook("beforeHighlightingColumnHeader", function() {
      return _this.onBeforeHighlightingColumnHeader(...arguments);
    });
    this.addHook("beforeCopy", function() {
      return _this.onBeforeCopy(...arguments);
    });
    this.addHook("afterViewportColumnCalculatorOverride", function() {
      return _this.onAfterViewportColumnCalculatorOverride(...arguments);
    });
    super.enablePlugin();
    this.updatePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`nestedHeaders`](@/api/options.md#nestedheaders)
   */
  updatePlugin() {
    if (!this.hot.view) {
      return;
    }
    const {
      nestedHeaders
    } = this.hot.getSettings();
    _classPrivateFieldGet17(this, _stateManager).setColumnsLimit(this.hot.countCols());
    if (Array.isArray(nestedHeaders)) {
      this.detectedOverlappedHeaders = _classPrivateFieldGet17(this, _stateManager).setState(nestedHeaders);
    }
    if (this.detectedOverlappedHeaders) {
      warn2(toSingleLine`Your Nested Headers plugin setup contains overlapping headers. This kind of configuration\x20
                        is currently not supported.`);
    }
    if (this.enabled) {
      this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach((isColumnHidden, physicalColumnIndex) => {
        const actionName = isColumnHidden === true ? "hide-column" : "show-column";
        _classPrivateFieldGet17(this, _stateManager).triggerColumnModification(actionName, physicalColumnIndex);
      });
    }
    if (!_classPrivateFieldGet17(this, _hidingIndexMapObserver) && this.enabled) {
      _classPrivateFieldSet17(this, _hidingIndexMapObserver, this.hot.columnIndexMapper.createChangesObserver("hiding").subscribe((changes) => {
        changes.forEach((_ref2) => {
          let {
            op,
            index: columnIndex,
            newValue
          } = _ref2;
          if (op === "replace") {
            const actionName = newValue === true ? "hide-column" : "show-column";
            _classPrivateFieldGet17(this, _stateManager).triggerColumnModification(actionName, columnIndex);
          }
        });
        this.ghostTable.buildWidthsMap();
      }));
    }
    this.ghostTable.setLayersCount(this.getLayersCount()).buildWidthsMap();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.clearColspans();
    _classPrivateFieldGet17(this, _stateManager).clear();
    _classPrivateFieldGet17(this, _hidingIndexMapObserver).unsubscribe();
    _classPrivateFieldSet17(this, _hidingIndexMapObserver, null);
    this.ghostTable.clear();
    super.disablePlugin();
  }
  /**
   * Returns an instance of the internal state manager of the plugin.
   *
   * @private
   * @returns {StateManager}
   */
  getStateManager() {
    return _classPrivateFieldGet17(this, _stateManager);
  }
  /**
   * Gets a total number of headers levels.
   *
   * @private
   * @returns {number}
   */
  getLayersCount() {
    return _classPrivateFieldGet17(this, _stateManager).getLayersCount();
  }
  /**
   * Gets column settings for a specified header. The returned object contains
   * information about the header label, its colspan length, or if it is hidden
   * in the header renderers.
   *
   * @private
   * @param {number} headerLevel Header level (0 = most distant to the table).
   * @param {number} columnIndex A visual column index.
   * @returns {object}
   */
  getHeaderSettings(headerLevel, columnIndex) {
    return _classPrivateFieldGet17(this, _stateManager).getHeaderSettings(headerLevel, columnIndex);
  }
  /**
   * Clear the colspans remaining after plugin usage.
   *
   * @private
   */
  clearColspans() {
    if (!this.hot.view) {
      return;
    }
    const {
      _wt: wt
    } = this.hot.view;
    const headerLevels = wt.getSetting("columnHeaders").length;
    const mainHeaders = wt.wtTable.THEAD;
    const topHeaders = wt.wtOverlays.topOverlay.clone.wtTable.THEAD;
    const topLeftCornerHeaders = wt.wtOverlays.topInlineStartCornerOverlay ? wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;
    for (let i = 0; i < headerLevels; i++) {
      const masterLevel = mainHeaders.childNodes[i];
      if (!masterLevel) {
        break;
      }
      const topLevel = topHeaders.childNodes[i];
      const topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;
      for (let j = 0, masterNodes = masterLevel.childNodes.length; j < masterNodes; j++) {
        masterLevel.childNodes[j].removeAttribute("colspan");
        removeClass(masterLevel.childNodes[j], "hiddenHeader");
        if (topLevel && topLevel.childNodes[j]) {
          topLevel.childNodes[j].removeAttribute("colspan");
          removeClass(topLevel.childNodes[j], "hiddenHeader");
        }
        if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {
          topLeftCornerLevel.childNodes[j].removeAttribute("colspan");
          removeClass(topLeftCornerLevel.childNodes[j], "hiddenHeader");
        }
      }
    }
  }
  /**
   * Generates the appropriate header renderer for a header row.
   *
   * @private
   * @param {number} headerLevel The index of header level counting from the top (positive
   *                             values counting from 0 to N).
   * @returns {Function}
   * @fires Hooks#afterGetColHeader
   */
  headerRendererFactory(headerLevel) {
    var _this2 = this;
    const fixedColumnsStart = this.hot.view._wt.getSetting("fixedColumnsStart");
    return (renderedColumnIndex, TH) => {
      var _classPrivateFieldGet22;
      const {
        columnIndexMapper,
        view
      } = this.hot;
      let visualColumnIndex = columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
      if (visualColumnIndex === null) {
        visualColumnIndex = renderedColumnIndex;
      }
      TH.removeAttribute("colspan");
      removeClass(TH, "hiddenHeader");
      const {
        colspan,
        isHidden,
        isPlaceholder
      } = (_classPrivateFieldGet22 = _classPrivateFieldGet17(this, _stateManager).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet22 !== void 0 ? _classPrivateFieldGet22 : {
        label: ""
      };
      if (isPlaceholder || isHidden) {
        addClass(TH, "hiddenHeader");
      } else if (colspan > 1) {
        var _wtOverlays$topInline, _wtOverlays$inlineSta;
        const {
          wtOverlays
        } = view._wt;
        const isTopInlineStartOverlay = (_wtOverlays$topInline = wtOverlays.topInlineStartCornerOverlay) === null || _wtOverlays$topInline === void 0 ? void 0 : _wtOverlays$topInline.clone.wtTable.THEAD.contains(TH);
        const isInlineStartOverlay = (_wtOverlays$inlineSta = wtOverlays.inlineStartOverlay) === null || _wtOverlays$inlineSta === void 0 ? void 0 : _wtOverlays$inlineSta.clone.wtTable.THEAD.contains(TH);
        const correctedColspan = isTopInlineStartOverlay || isInlineStartOverlay ? Math.min(colspan, fixedColumnsStart - renderedColumnIndex) : colspan;
        if (correctedColspan > 1) {
          TH.setAttribute("colspan", correctedColspan);
        }
      }
      this.hot.view.appendColHeader(visualColumnIndex, TH, function() {
        return _this2.getColumnHeaderValue(...arguments);
      }, headerLevel);
    };
  }
  /**
   * Returns the column header value for specified column and header level index.
   *
   * @private
   * @param {number} visualColumnIndex Visual column index.
   * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)
   *                             and negative (-1 to -N) values. For positive values, 0 points to the
   *                             top most header, and for negative direction, -1 points to the most bottom
   *                             header (the header closest to the cells).
   * @returns {string} Returns the column header value to update.
   */
  getColumnHeaderValue(visualColumnIndex, headerLevel) {
    var _classPrivateFieldGet32;
    const {
      isHidden,
      isPlaceholder
    } = (_classPrivateFieldGet32 = _classPrivateFieldGet17(this, _stateManager).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet32 !== void 0 ? _classPrivateFieldGet32 : {};
    if (isPlaceholder || isHidden) {
      return "";
    }
    return this.hot.getColHeader(visualColumnIndex, headerLevel);
  }
  /**
   * Allows to control which header DOM element will be used to highlight.
   *
   * @private
   * @param {number} visualColumn A visual column index of the highlighted row header.
   * @param {number} headerLevel A row header level that is currently highlighted.
   * @param {object} highlightMeta An object with meta data that describes the highlight state.
   * @returns {number}
   */
  onBeforeHighlightingColumnHeader(visualColumn, headerLevel, highlightMeta) {
    const headerNodeData = _classPrivateFieldGet17(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumn);
    if (!headerNodeData) {
      return visualColumn;
    }
    const {
      classNames,
      columnCursor,
      selectionType,
      selectionWidth
    } = highlightMeta;
    const {
      isRoot,
      colspan
    } = _classPrivateFieldGet17(this, _stateManager).getHeaderSettings(headerLevel, visualColumn);
    if (selectionType === HEADER_TYPE) {
      if (!isRoot) {
        return headerNodeData.columnIndex;
      }
    } else if (selectionType === ACTIVE_HEADER_TYPE) {
      if (colspan > selectionWidth - columnCursor || !isRoot) {
        classNames.length = 0;
      }
    }
    return visualColumn;
  }
  /**
   * Listens the `beforeCopy` hook that allows processing the copied column headers so that the
   * merged column headers do not propagate the value for each column but only once at the beginning
   * of the column.
   *
   * @private
   * @param {Array[]} data An array of arrays which contains data to copied.
   * @param {object[]} copyableRanges An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
   *                                  which will copied.
   * @param {{ columnHeadersCount: number }} copiedHeadersCount An object with keys that holds information with
   *                                                            the number of copied headers.
   */
  onBeforeCopy(data, copyableRanges, _ref2) {
    let {
      columnHeadersCount
    } = _ref2;
    if (columnHeadersCount === 0) {
      return;
    }
    for (let rangeIndex = 0; rangeIndex < copyableRanges.length; rangeIndex++) {
      const {
        startRow,
        startCol,
        endRow,
        endCol
      } = copyableRanges[rangeIndex];
      const rowsCount = endRow - startRow + 1;
      const columnsCount = startCol - endCol + 1;
      if (startRow >= 0 || columnsCount === 1) {
        break;
      }
      for (let column = startCol; column <= endCol; column++) {
        for (let row = startRow; row <= endRow; row++) {
          var _classPrivateFieldGet42;
          const zeroBasedColumnHeaderLevel = rowsCount + row;
          const zeroBasedColumnIndex = column - startCol;
          if (zeroBasedColumnIndex === 0) {
            continue;
          }
          const isRoot = (_classPrivateFieldGet42 = _classPrivateFieldGet17(this, _stateManager).getHeaderTreeNodeData(row, column)) === null || _classPrivateFieldGet42 === void 0 ? void 0 : _classPrivateFieldGet42.isRoot;
          if (isRoot === false) {
            data[zeroBasedColumnHeaderLevel][zeroBasedColumnIndex] = "";
          }
        }
      }
    }
  }
  /**
   * Allows blocking the column selection that is controlled by the core Selection module.
   *
   * @private
   * @param {MouseEvent} event Mouse event.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {CellCoords} TD The table cell or header element.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  onBeforeOnCellMouseDown(event2, coords, TD, controller) {
    const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
    if (headerNodeData) {
      controller.column = true;
    }
  }
  /**
   * Allows to control how the column selection based on the coordinates and the nested headers is made.
   *
   * @private
   * @param {MouseEvent} event Mouse event.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   */
  onAfterOnCellMouseDown(event2, coords) {
    const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
    if (!headerNodeData) {
      return;
    }
    const {
      selection
    } = this.hot;
    const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;
    const columnsToSelect = [];
    const {
      columnIndex,
      origColspan
    } = headerNodeData;
    const allowRightClickSelection = !selection.inInSelection(coords);
    if (event2.shiftKey && currentSelection) {
      if (coords.col < currentSelection.from.col) {
        columnsToSelect.push(currentSelection.getTopEndCorner().col, columnIndex, coords.row);
      } else if (coords.col > currentSelection.from.col) {
        columnsToSelect.push(currentSelection.getTopStartCorner().col, columnIndex + origColspan - 1, coords.row);
      } else {
        columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);
      }
    } else if (isLeftClick(event2) || isRightClick(event2) && allowRightClickSelection) {
      columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);
    }
    selection.selectColumns(...columnsToSelect);
  }
  /**
   * Makes the header-selection properly select the nested headers.
   *
   * @private
   * @param {MouseEvent} event Mouse event.
   * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
   * @param {HTMLElement} TD The cell element.
   * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
   *                            a boolean value that allows or disallows changing the selection for that particular area.
   */
  onBeforeOnCellMouseOver(event2, coords, TD, controller) {
    if (!this.hot.view.isMouseDown()) {
      return;
    }
    const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
    if (!headerNodeData) {
      return;
    }
    const {
      columnIndex,
      origColspan
    } = headerNodeData;
    const selectedRange = this.hot.getSelectedRangeLast();
    const topStartCoords = selectedRange.getTopStartCorner();
    const bottomEndCoords = selectedRange.getBottomEndCorner();
    const {
      from: from2
    } = selectedRange;
    controller.column = true;
    controller.cell = true;
    const columnsToSelect = [];
    if (coords.col < from2.col) {
      columnsToSelect.push(bottomEndCoords.col, columnIndex);
    } else if (coords.col > from2.col) {
      columnsToSelect.push(topStartCoords.col, columnIndex + origColspan - 1);
    } else {
      columnsToSelect.push(columnIndex, columnIndex + origColspan - 1);
    }
    this.hot.selectColumns(...columnsToSelect);
  }
  /**
   * `afterGetColumnHeader` hook callback - prepares the header structure.
   *
   * @private
   * @param {Array} renderersArray Array of renderers.
   */
  onAfterGetColumnHeaderRenderers(renderersArray) {
    renderersArray.length = 0;
    for (let headerLayer = 0; headerLayer < _classPrivateFieldGet17(this, _stateManager).getLayersCount(); headerLayer++) {
      renderersArray.push(this.headerRendererFactory(headerLayer));
    }
  }
  /**
   * Make the renderer render the first nested column in its entirety.
   *
   * @private
   * @param {object} calc Viewport column calculator.
   */
  onAfterViewportColumnCalculatorOverride(calc) {
    const headerLayersCount = _classPrivateFieldGet17(this, _stateManager).getLayersCount();
    let newStartColumn = calc.startColumn;
    let nonRenderable = !!headerLayersCount;
    for (let headerLayer = 0; headerLayer < headerLayersCount; headerLayer++) {
      const startColumn = _classPrivateFieldGet17(this, _stateManager).findLeftMostColumnIndex(headerLayer, calc.startColumn);
      const renderedStartColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);
      if (startColumn >= 0) {
        nonRenderable = false;
      }
      if (isNumeric(renderedStartColumn) && renderedStartColumn < calc.startColumn) {
        newStartColumn = renderedStartColumn;
        break;
      }
    }
    calc.startColumn = nonRenderable ? _classPrivateFieldGet17(this, _stateManager).getHeaderTreeNodeData(0, newStartColumn).columnIndex : newStartColumn;
  }
  /**
   * `modifyColWidth` hook callback - returns width from cache, when is greater than incoming from hook.
   *
   * @private
   * @param {number} width Width from hook.
   * @param {number} column Visual index of an column.
   * @returns {number}
   */
  onModifyColWidth(width, column) {
    const cachedWidth = this.ghostTable.getWidth(column);
    return width > cachedWidth ? width : cachedWidth;
  }
  /**
   * Listens the `modifyColumnHeaderValue` hook that overwrites the column headers values based on
   * the internal state and settings of the plugin.
   *
   * @private
   * @param {string} value The column header value.
   * @param {number} visualColumnIndex The visual column index.
   * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)
   *                             and negative (-1 to -N) values. For positive values, 0 points to the
   *                             top most header, and for negative direction, -1 points to the most bottom
   *                             header (the header closest to the cells).
   * @returns {string} Returns the column header value to update.
   */
  onModifyColumnHeaderValue(value, visualColumnIndex, headerLevel) {
    var _classPrivateFieldGet52;
    const {
      label
    } = (_classPrivateFieldGet52 = _classPrivateFieldGet17(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet52 !== void 0 ? _classPrivateFieldGet52 : {
      label: ""
    };
    return label;
  }
  /**
   * Updates the plugin state after HoT initialization.
   *
   * @private
   */
  onInit() {
    this.updatePlugin();
  }
  /**
   * Updates the plugin state after new dataset load.
   *
   * @private
   * @param {Array[]} sourceData Array of arrays or array of objects containing data.
   * @param {boolean} initialLoad Flag that determines whether the data has been loaded
   *                              during the initialization.
   */
  onAfterLoadData(sourceData, initialLoad) {
    if (!initialLoad) {
      this.updatePlugin();
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldSet17(this, _stateManager, null);
    if (_classPrivateFieldGet17(this, _hidingIndexMapObserver) !== null) {
      _classPrivateFieldGet17(this, _hidingIndexMapObserver).unsubscribe();
      _classPrivateFieldSet17(this, _hidingIndexMapObserver, null);
    }
    super.destroy();
  }
  /**
   * Gets the tree data that belongs to the column headers pointed by the passed coordinates.
   *
   * @private
   * @param {CellCoords} coords The CellCoords instance.
   * @returns {object|undefined}
   */
  _getHeaderTreeNodeDataByCoords(coords) {
    if (coords.row >= 0 || coords.col < 0) {
      return;
    }
    return _classPrivateFieldGet17(this, _stateManager).getHeaderTreeNodeData(coords.row, coords.col);
  }
};

// node_modules/handsontable/plugins/nestedRows/data/dataManager.mjs
var DataManager = class {
  constructor(nestedRowsPlugin, hotInstance) {
    this.hot = hotInstance;
    this.data = null;
    this.plugin = nestedRowsPlugin;
    this.parentReference = /* @__PURE__ */ new WeakMap();
    this.cache = {
      levels: [],
      levelCount: 0,
      rows: [],
      nodeInfo: /* @__PURE__ */ new WeakMap()
    };
  }
  /**
   * Set the data for the manager.
   *
   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.
   */
  setData(data) {
    this.data = data;
  }
  /**
   * Get the data cached in the manager.
   *
   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}
   */
  getData() {
    return this.data;
  }
  /**
   * Load the "raw" source data, without NestedRows' modifications.
   *
   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}
   */
  getRawSourceData() {
    let rawSourceData = null;
    this.plugin.disableCoreAPIModifiers();
    rawSourceData = this.hot.getSourceData();
    this.plugin.enableCoreAPIModifiers();
    return rawSourceData;
  }
  /**
   * Update the Data Manager with new data and refresh cache.
   *
   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.
   */
  updateWithData(data) {
    this.setData(data);
    this.rewriteCache();
  }
  /**
   * Rewrite the nested structure cache.
   *
   * @private
   */
  rewriteCache() {
    this.cache = {
      levels: [],
      levelCount: 0,
      rows: [],
      nodeInfo: /* @__PURE__ */ new WeakMap()
    };
    rangeEach(0, this.data.length - 1, (i) => {
      this.cacheNode(this.data[i], 0, null);
    });
  }
  /**
   * Cache a data node.
   *
   * @private
   * @param {object} node Node to cache.
   * @param {number} level Level of the node.
   * @param {object} parent Parent of the node.
   */
  cacheNode(node, level, parent) {
    if (!this.cache.levels[level]) {
      this.cache.levels[level] = [];
      this.cache.levelCount += 1;
    }
    this.cache.levels[level].push(node);
    this.cache.rows.push(node);
    this.cache.nodeInfo.set(node, {
      parent,
      row: this.cache.rows.length - 1,
      level
    });
    if (this.hasChildren(node)) {
      arrayEach(node.__children, (elem) => {
        this.cacheNode(elem, level + 1, node);
      });
    }
  }
  /**
   * Get the date for the provided visual row number.
   *
   * @param {number} row Row index.
   * @returns {object}
   */
  getDataObject(row) {
    return row === null || row === void 0 ? null : this.cache.rows[row];
  }
  /**
   * Read the row tree in search for a specific row index or row object.
   *
   * @private
   * @param {object} parent The initial parent object.
   * @param {number} readCount Number of read nodes.
   * @param {number} neededIndex The row index we search for.
   * @param {object} neededObject The row object we search for.
   * @returns {number|object}
   */
  readTreeNodes(parent, readCount, neededIndex, neededObject) {
    let rootLevel = false;
    let readNodesCount = readCount;
    if (isNaN(readNodesCount) && readNodesCount.end) {
      return readNodesCount;
    }
    let parentObj = parent;
    if (!parentObj) {
      parentObj = {
        __children: this.data
      };
      rootLevel = true;
      readNodesCount -= 1;
    }
    if (neededIndex !== null && neededIndex !== void 0 && readNodesCount === neededIndex) {
      return {
        result: parentObj,
        end: true
      };
    }
    if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {
      return {
        result: readNodesCount,
        end: true
      };
    }
    readNodesCount += 1;
    if (parentObj.__children) {
      arrayEach(parentObj.__children, (val) => {
        this.parentReference.set(val, rootLevel ? null : parentObj);
        readNodesCount = this.readTreeNodes(val, readNodesCount, neededIndex, neededObject);
        if (isNaN(readNodesCount) && readNodesCount.end) {
          return false;
        }
      });
    }
    return readNodesCount;
  }
  /**
   * Mock a parent node.
   *
   * @private
   * @returns {*}
   */
  mockParent() {
    const fakeParent = this.mockNode();
    fakeParent.__children = this.data;
    return fakeParent;
  }
  /**
   * Mock a data node.
   *
   * @private
   * @returns {{}}
   */
  mockNode() {
    const fakeNode = {};
    objectEach(this.data[0], (val, key) => {
      fakeNode[key] = null;
    });
    return fakeNode;
  }
  /**
   * Get the row index for the provided row object.
   *
   * @param {object} rowObj The row object.
   * @returns {number} Row index.
   */
  getRowIndex(rowObj) {
    return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;
  }
  /**
   * Get the index of the provided row index/row object within its parent.
   *
   * @param {number|object} row Row index / row object.
   * @returns {number}
   */
  getRowIndexWithinParent(row) {
    let rowObj = null;
    if (isNaN(row)) {
      rowObj = row;
    } else {
      rowObj = this.getDataObject(row);
    }
    const parent = this.getRowParent(row);
    if (parent === null || parent === void 0) {
      return this.data.indexOf(rowObj);
    }
    return parent.__children.indexOf(rowObj);
  }
  /**
   * Count all rows (including all parents and children).
   *
   * @returns {number}
   */
  countAllRows() {
    const rootNodeMock = {
      __children: this.data
    };
    return this.countChildren(rootNodeMock);
  }
  /**
   * Count children of the provided parent.
   *
   * @param {object|number} parent Parent node.
   * @returns {number} Children count.
   */
  countChildren(parent) {
    let rowCount = 0;
    let parentNode = parent;
    if (!isNaN(parentNode)) {
      parentNode = this.getDataObject(parentNode);
    }
    if (!parentNode || !parentNode.__children) {
      return 0;
    }
    arrayEach(parentNode.__children, (elem) => {
      rowCount += 1;
      if (elem.__children) {
        rowCount += this.countChildren(elem);
      }
    });
    return rowCount;
  }
  /**
   * Get the parent of the row at the provided index.
   *
   * @param {number|object} row Physical row index.
   * @returns {object}
   */
  getRowParent(row) {
    let rowObject;
    if (isNaN(row)) {
      rowObject = row;
    } else {
      rowObject = this.getDataObject(row);
    }
    return this.getRowObjectParent(rowObject);
  }
  /**
   * Get the parent of the provided row object.
   *
   * @private
   * @param {object} rowObject The row object (tree node).
   * @returns {object|null}
   */
  getRowObjectParent(rowObject) {
    if (!rowObject || typeof rowObject !== "object") {
      return null;
    }
    return this.cache.nodeInfo.get(rowObject).parent;
  }
  /**
   * Get the nesting level for the row with the provided row index.
   *
   * @param {number} row Row index.
   * @returns {number|null} Row level or null, when row doesn't exist.
   */
  getRowLevel(row) {
    let rowObject = null;
    if (isNaN(row)) {
      rowObject = row;
    } else {
      rowObject = this.getDataObject(row);
    }
    return rowObject ? this.getRowObjectLevel(rowObject) : null;
  }
  /**
   * Get the nesting level for the row with the provided row index.
   *
   * @private
   * @param {object} rowObject Row object.
   * @returns {number} Row level.
   */
  getRowObjectLevel(rowObject) {
    return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;
  }
  /**
   * Check if the provided row/row element has children.
   *
   * @param {number|object} row Row number or row element.
   * @returns {boolean}
   */
  hasChildren(row) {
    let rowObj = row;
    if (!isNaN(rowObj)) {
      rowObj = this.getDataObject(rowObj);
    }
    return !!(rowObj.__children && rowObj.__children.length);
  }
  /**
   * Returns `true` if the row at the provided index has a parent.
   *
   * @param {number} index Row index.
   * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.
   */
  isChild(index2) {
    return this.getRowParent(index2) !== null;
  }
  /**
   * Get child at a provided index from the parent element.
   *
   * @param {object} parent The parent row object.
   * @param {number} index Index of the child element to be retrieved.
   * @returns {object|null} The child element or `null` if the child doesn't exist.
   */
  getChild(parent, index2) {
    var _parent$__children;
    return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index2]) || null;
  }
  /**
   * Return `true` of the row at the provided index is located at the topmost level.
   *
   * @param {number} index Row index.
   * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.
   */
  isRowHighestLevel(index2) {
    return !this.isChild(index2);
  }
  /**
   * Return `true` if the provided row index / row object represents a parent in the nested structure.
   *
   * @param {number|object} row Row index / row object.
   * @returns {boolean} `true` if the row is a parent, `false` otherwise.
   */
  isParent(row) {
    var _rowObj$__children;
    let rowObj = row;
    if (!isNaN(rowObj)) {
      rowObj = this.getDataObject(rowObj);
    }
    return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;
  }
  /**
   * Add a child to the provided parent. It's optional to add a row object as the "element".
   *
   * @param {object} parent The parent row object.
   * @param {object} [element] The element to add as a child.
   */
  addChild(parent, element) {
    let childElement = element;
    this.hot.runHooks("beforeAddChild", parent, childElement);
    let parentIndex = null;
    if (parent) {
      parentIndex = this.getRowIndex(parent);
    }
    this.hot.runHooks("beforeCreateRow", parentIndex + this.countChildren(parent) + 1, 1);
    let functionalParent = parent;
    if (!parent) {
      functionalParent = this.mockParent();
    }
    if (!functionalParent.__children) {
      functionalParent.__children = [];
    }
    if (!childElement) {
      childElement = this.mockNode();
    }
    functionalParent.__children.push(childElement);
    this.rewriteCache();
    const newRowIndex = this.getRowIndex(childElement);
    this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);
    this.hot.runHooks("afterCreateRow", newRowIndex, 1);
    this.hot.runHooks("afterAddChild", parent, childElement);
  }
  /**
   * Add a child node to the provided parent at a specified index.
   *
   * @param {object} parent Parent node.
   * @param {number} index Index to insert the child element at.
   * @param {object} [element] Element (node) to insert.
   */
  addChildAtIndex(parent, index2, element) {
    let childElement = element;
    let flattenedIndex;
    if (!childElement) {
      childElement = this.mockNode();
    }
    this.hot.runHooks("beforeAddChild", parent, childElement, index2);
    if (parent) {
      const parentIndex = this.getRowIndex(parent);
      const finalChildIndex = parentIndex + index2 + 1;
      this.hot.runHooks("beforeCreateRow", finalChildIndex, 1);
      parent.__children.splice(index2, null, childElement);
      this.rewriteCache();
      this.plugin.disableCoreAPIModifiers();
      this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), "__children", parent.__children, "NestedRows.addChildAtIndex");
      this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);
      this.plugin.enableCoreAPIModifiers();
      this.hot.runHooks("afterCreateRow", finalChildIndex, 1);
      flattenedIndex = finalChildIndex;
    } else {
      this.plugin.disableCoreAPIModifiers();
      this.hot.alter("insert_row_above", index2, 1, "NestedRows.addChildAtIndex");
      this.plugin.enableCoreAPIModifiers();
      flattenedIndex = this.getRowIndex(this.data[index2]);
    }
    childElement = this.getDataObject(flattenedIndex);
    this.hot.runHooks("afterAddChild", parent, childElement, index2);
  }
  /**
   * Add a sibling element at the specified index.
   *
   * @param {number} index New element sibling's index.
   * @param {('above'|'below')} where Direction in which the sibling is to be created.
   */
  addSibling(index2) {
    let where = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "below";
    const translatedIndex = this.translateTrimmedRow(index2);
    const parent = this.getRowParent(translatedIndex);
    const indexWithinParent = this.getRowIndexWithinParent(translatedIndex);
    switch (where) {
      case "below":
        this.addChildAtIndex(parent, indexWithinParent + 1, null);
        break;
      case "above":
        this.addChildAtIndex(parent, indexWithinParent, null);
        break;
      default:
        break;
    }
  }
  /**
   * Detach the provided element from its parent and add it right after it.
   *
   * @param {object|Array} elements Row object or an array of selected coordinates.
   * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.
   */
  detachFromParent(elements) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let element = null;
    const rowObjects = [];
    if (Array.isArray(elements)) {
      rangeEach(elements[0], elements[2], (i) => {
        const translatedIndex = this.translateTrimmedRow(i);
        rowObjects.push(this.getDataObject(translatedIndex));
      });
      rangeEach(0, rowObjects.length - 2, (i) => {
        this.detachFromParent(rowObjects[i], false);
      });
      element = rowObjects[rowObjects.length - 1];
    } else {
      element = elements;
    }
    const childRowIndex = this.getRowIndex(element);
    const childCount = this.countChildren(element);
    const indexWithinParent = this.getRowIndexWithinParent(element);
    const parent = this.getRowParent(element);
    const grandparent = this.getRowParent(parent);
    const grandparentRowIndex = this.getRowIndex(grandparent);
    let movedElementRowIndex = null;
    this.hot.runHooks("beforeDetachChild", parent, element);
    if (indexWithinParent !== null && indexWithinParent !== void 0) {
      const removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));
      this.hot.runHooks("beforeRemoveRow", childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);
      parent.__children.splice(indexWithinParent, 1);
      this.rewriteCache();
      this.hot.runHooks("afterRemoveRow", childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);
      if (grandparent) {
        movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);
        const lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);
        const lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);
        this.hot.runHooks("beforeCreateRow", lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);
        grandparent.__children.push(element);
      } else {
        movedElementRowIndex = this.hot.countRows() + 1;
        this.hot.runHooks("beforeCreateRow", movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);
        this.data.push(element);
      }
    }
    this.rewriteCache();
    this.hot.runHooks("afterCreateRow", movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);
    this.hot.runHooks("afterDetachChild", parent, element, this.getRowIndex(element));
    if (forceRender) {
      this.hot.render();
    }
  }
  /**
   * Filter the data by the `logicRows` array.
   *
   * @private
   * @param {number} index Index of the first row to remove.
   * @param {number} amount Number of elements to remove.
   * @param {Array} logicRows Array of indexes to remove.
   */
  filterData(index2, amount, logicRows) {
    const elementsToRemove = [];
    arrayEach(logicRows, (elem) => {
      elementsToRemove.push(this.getDataObject(elem));
    });
    arrayEach(elementsToRemove, (elem) => {
      const indexWithinParent = this.getRowIndexWithinParent(elem);
      const tempParent = this.getRowParent(elem);
      if (tempParent === null) {
        this.data.splice(indexWithinParent, 1);
      } else {
        tempParent.__children.splice(indexWithinParent, 1);
      }
    });
    this.rewriteCache();
  }
  /**
   * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the
   * default script.
   *
   * @private
   * @param {number} index Physical index of the element at the splice beginning.
   * @param {number} amount Number of elements to be removed.
   * @param {object[]} elements Array of row objects to add.
   */
  spliceData(index2, amount, elements) {
    const previousElement = this.getDataObject(index2 - 1);
    let newRowParent = null;
    let indexWithinParent = index2;
    if (previousElement && previousElement.__children && previousElement.__children.length === 0) {
      newRowParent = previousElement;
      indexWithinParent = 0;
    } else if (index2 < this.countAllRows()) {
      newRowParent = this.getRowParent(index2);
      indexWithinParent = this.getRowIndexWithinParent(index2);
    }
    if (newRowParent) {
      if (elements) {
        newRowParent.__children.splice(indexWithinParent, amount, ...elements);
      } else {
        newRowParent.__children.splice(indexWithinParent, amount);
      }
    } else if (elements) {
      this.data.splice(indexWithinParent, amount, ...elements);
    } else {
      this.data.splice(indexWithinParent, amount);
    }
    this.rewriteCache();
  }
  /**
   * Update the `__children` key of the upmost parent of the provided row object.
   *
   * @private
   * @param {object} rowElement Row object.
   */
  syncRowWithRawSource(rowElement) {
    let upmostParent = rowElement;
    let tempParent = null;
    do {
      tempParent = this.getRowParent(tempParent);
      if (tempParent !== null) {
        upmostParent = tempParent;
      }
    } while (tempParent !== null);
    this.plugin.disableCoreAPIModifiers();
    this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), "__children", upmostParent.__children, "NestedRows.syncRowWithRawSource");
    this.plugin.enableCoreAPIModifiers();
  }
  /* eslint-disable jsdoc/require-param */
  /**
   * Move a single row.
   *
   * @param {number} fromIndex Index of the row to be moved.
   * @param {number} toIndex Index of the destination.
   * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.
   * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.
   */
  /* eslint-enable jsdoc/require-param */
  moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {
    const moveToLastRow = toIndex === this.hot.countRows();
    const fromParent = this.getRowParent(fromIndex);
    const indexInFromParent = this.getRowIndexWithinParent(fromIndex);
    const elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);
    const movingUp = fromIndex > toIndex;
    let toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);
    if (toParent === null || toParent === void 0) {
      toParent = this.getRowParent(toIndex - 1);
    }
    if (toParent === null || toParent === void 0) {
      toParent = this.getDataObject(toIndex - 1);
    }
    if (!toParent) {
      toParent = this.getDataObject(toIndex);
      toParent.__children = [];
    } else if (!toParent.__children) {
      toParent.__children = [];
    }
    const indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);
    const sameParent = fromParent === toParent;
    toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);
    fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);
    this.syncRowWithRawSource(fromParent);
    if (!sameParent) {
      this.syncRowWithRawSource(toParent);
    }
  }
  /**
   * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.
   *
   * @private
   * @param {number} row Row index.
   * @returns {number}
   */
  translateTrimmedRow(row) {
    if (this.plugin.collapsingUI) {
      return this.plugin.collapsingUI.translateTrimmedRow(row);
    }
    return row;
  }
  /**
   * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.
   *
   * @private
   * @param {number} row Row index.
   * @returns {number}
   */
  untranslateTrimmedRow(row) {
    if (this.plugin.collapsingUI) {
      return this.plugin.collapsingUI.untranslateTrimmedRow(row);
    }
    return row;
  }
};
var dataManager_default = DataManager;

// node_modules/handsontable/plugins/nestedRows/ui/_base.mjs
var BaseUI4 = class {
  constructor(pluginInstance, hotInstance) {
    this.hot = hotInstance;
    this.plugin = pluginInstance;
  }
};
var base_default7 = BaseUI4;

// node_modules/handsontable/plugins/nestedRows/ui/headers.mjs
var HeadersUI = class _HeadersUI extends base_default7 {
  /**
   * CSS classes used in the row headers.
   *
   * @type {object}
   */
  static get CSS_CLASSES() {
    return {
      indicatorContainer: "ht_nestingLevels",
      parent: "ht_nestingParent",
      indicator: "ht_nestingLevel",
      emptyIndicator: "ht_nestingLevel_empty",
      button: "ht_nestingButton",
      expandButton: "ht_nestingExpand",
      collapseButton: "ht_nestingCollapse"
    };
  }
  constructor(nestedRowsPlugin, hotInstance) {
    super(nestedRowsPlugin, hotInstance);
    this.dataManager = this.plugin.dataManager;
    this.collapsingUI = this.plugin.collapsingUI;
    this.rowHeaderWidthCache = null;
  }
  /**
   * Append nesting indicators and buttons to the row headers.
   *
   * @private
   * @param {number} row Row index.
   * @param {HTMLElement} TH TH 3element.
   */
  appendLevelIndicators(row, TH) {
    const rowIndex = this.hot.toPhysicalRow(row);
    const rowLevel = this.dataManager.getRowLevel(rowIndex);
    const rowObject = this.dataManager.getDataObject(rowIndex);
    const innerDiv = TH.getElementsByTagName("DIV")[0];
    const innerSpan = innerDiv.querySelector("span.rowHeader");
    const previousIndicators = innerDiv.querySelectorAll('[class^="ht_nesting"]');
    arrayEach(previousIndicators, (elem) => {
      if (elem) {
        innerDiv.removeChild(elem);
      }
    });
    addClass(TH, _HeadersUI.CSS_CLASSES.indicatorContainer);
    if (rowLevel) {
      const {
        rootDocument
      } = this.hot;
      const initialContent = innerSpan.cloneNode(true);
      innerDiv.innerHTML = "";
      rangeEach(0, rowLevel - 1, () => {
        const levelIndicator = rootDocument.createElement("SPAN");
        addClass(levelIndicator, _HeadersUI.CSS_CLASSES.emptyIndicator);
        innerDiv.appendChild(levelIndicator);
      });
      innerDiv.appendChild(initialContent);
    }
    if (this.dataManager.hasChildren(rowObject)) {
      const buttonsContainer = this.hot.rootDocument.createElement("DIV");
      addClass(TH, _HeadersUI.CSS_CLASSES.parent);
      if (this.collapsingUI.areChildrenCollapsed(rowIndex)) {
        addClass(buttonsContainer, `${_HeadersUI.CSS_CLASSES.button} ${_HeadersUI.CSS_CLASSES.expandButton}`);
      } else {
        addClass(buttonsContainer, `${_HeadersUI.CSS_CLASSES.button} ${_HeadersUI.CSS_CLASSES.collapseButton}`);
      }
      innerDiv.appendChild(buttonsContainer);
    }
  }
  /**
   * Update the row header width according to number of levels in the dataset.
   *
   * @private
   * @param {number} deepestLevel Cached deepest level of nesting.
   */
  updateRowHeaderWidth(deepestLevel) {
    let deepestLevelIndex = deepestLevel;
    if (!deepestLevelIndex) {
      deepestLevelIndex = this.dataManager.cache.levelCount;
    }
    this.rowHeaderWidthCache = Math.max(50, 11 + 10 * deepestLevelIndex + 25);
    this.hot.render();
  }
};
var headers_default = HeadersUI;

// node_modules/handsontable/plugins/nestedRows/ui/collapsing.mjs
var CollapsingUI = class extends base_default7 {
  constructor(nestedRowsPlugin, hotInstance) {
    var _this;
    super(nestedRowsPlugin, hotInstance);
    _this = this;
    this.dataManager = this.plugin.dataManager;
    this.collapsedRows = [];
    this.collapsedRowsStash = {
      stash: function() {
        let forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        _this.lastCollapsedRows = _this.collapsedRows.slice(0);
        _this.expandMultipleChildren(_this.lastCollapsedRows, forceRender);
      },
      shiftStash: function(baseIndex, targetIndex) {
        let delta = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        if (targetIndex === null || targetIndex === void 0) {
          targetIndex = Infinity;
        }
        arrayEach(_this.lastCollapsedRows, (elem, i) => {
          if (elem >= baseIndex && elem < targetIndex) {
            _this.lastCollapsedRows[i] = elem + delta;
          }
        });
      },
      applyStash: function() {
        let forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        _this.collapseMultipleChildren(_this.lastCollapsedRows, forceRender);
        _this.lastCollapsedRows = void 0;
      },
      trimStash: (realElementIndex, amount) => {
        rangeEach(realElementIndex, realElementIndex + amount - 1, (i) => {
          const indexOfElement = this.lastCollapsedRows.indexOf(i);
          if (indexOfElement > -1) {
            this.lastCollapsedRows.splice(indexOfElement, 1);
          }
        });
      }
    };
  }
  /**
   * Collapse the children of the row passed as an argument.
   *
   * @param {number|object} row The parent row.
   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   * @returns {Array}
   */
  collapseChildren(row) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const rowsToCollapse = [];
    let rowObject = null;
    let rowIndex = null;
    let rowsToTrim = null;
    if (isNaN(row)) {
      rowObject = row;
      rowIndex = this.dataManager.getRowIndex(rowObject);
    } else {
      rowObject = this.dataManager.getDataObject(row);
      rowIndex = row;
    }
    if (this.dataManager.hasChildren(rowObject)) {
      arrayEach(rowObject.__children, (elem) => {
        rowsToCollapse.push(this.dataManager.getRowIndex(elem));
      });
    }
    rowsToTrim = this.collapseRows(rowsToCollapse, true, false);
    if (doTrimming) {
      this.trimRows(rowsToTrim);
    }
    if (forceRender) {
      this.renderAndAdjust();
    }
    if (this.collapsedRows.indexOf(rowIndex) === -1) {
      this.collapsedRows.push(rowIndex);
    }
    return rowsToTrim;
  }
  /**
   * Collapse multiple children.
   *
   * @param {Array} rows Rows to collapse (including their children).
   * @param {boolean} [forceRender=true] `true` if the table should be rendered after finishing the function.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   */
  collapseMultipleChildren(rows) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const rowsToTrim = [];
    arrayEach(rows, (elem) => {
      rowsToTrim.push(...this.collapseChildren(elem, false, false));
    });
    if (doTrimming) {
      this.trimRows(rowsToTrim);
    }
    if (forceRender) {
      this.renderAndAdjust();
    }
  }
  /**
   * Collapse a single row.
   *
   * @param {number} rowIndex Index of the row to collapse.
   * @param {boolean} [recursive=true] `true` if it should collapse the row's children.
   */
  collapseRow(rowIndex) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    this.collapseRows([rowIndex], recursive);
  }
  /**
   * Collapse multiple rows.
   *
   * @param {Array} rowIndexes Array of row indexes to collapse.
   * @param {boolean} [recursive=true] `true` if it should collapse the rows' children.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   * @returns {Array} Rows prepared for trimming (or trimmed, if doTrimming == true).
   */
  collapseRows(rowIndexes) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const rowsToTrim = [];
    arrayEach(rowIndexes, (elem) => {
      rowsToTrim.push(elem);
      if (recursive) {
        this.collapseChildRows(elem, rowsToTrim);
      }
    });
    if (doTrimming) {
      this.trimRows(rowsToTrim);
    }
    return rowsToTrim;
  }
  /**
   * Collapse child rows of the row at the provided index.
   *
   * @param {number} parentIndex Index of the parent node.
   * @param {Array} [rowsToTrim=[]] Array of rows to trim. Defaults to an empty array.
   * @param {boolean} [recursive] `true` if the collapsing process should be recursive.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   */
  collapseChildRows(parentIndex) {
    let rowsToTrim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let recursive = arguments.length > 2 ? arguments[2] : void 0;
    let doTrimming = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (this.dataManager.hasChildren(parentIndex)) {
      const parentObject = this.dataManager.getDataObject(parentIndex);
      arrayEach(parentObject.__children, (elem) => {
        const elemIndex = this.dataManager.getRowIndex(elem);
        rowsToTrim.push(elemIndex);
        this.collapseChildRows(elemIndex, rowsToTrim);
      });
    }
    if (doTrimming) {
      this.trimRows(rowsToTrim);
    }
  }
  /**
   * Expand a single row.
   *
   * @param {number} rowIndex Index of the row to expand.
   * @param {boolean} [recursive=true] `true` if it should expand the row's children recursively.
   */
  expandRow(rowIndex) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    this.expandRows([rowIndex], recursive);
  }
  /**
   * Expand multiple rows.
   *
   * @param {Array} rowIndexes Array of indexes of the rows to expand.
   * @param {boolean} [recursive=true] `true` if it should expand the rows' children recursively.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   * @returns {Array} Array of row indexes to be untrimmed.
   */
  expandRows(rowIndexes) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const rowsToUntrim = [];
    arrayEach(rowIndexes, (elem) => {
      rowsToUntrim.push(elem);
      if (recursive) {
        this.expandChildRows(elem, rowsToUntrim);
      }
    });
    if (doTrimming) {
      this.untrimRows(rowsToUntrim);
    }
    return rowsToUntrim;
  }
  /**
   * Expand child rows of the provided index.
   *
   * @param {number} parentIndex Index of the parent row.
   * @param {Array} [rowsToUntrim=[]] Array of the rows to be untrimmed.
   * @param {boolean} [recursive] `true` if it should expand the rows' children recursively.
   * @param {boolean} [doTrimming=false] I determine whether collapsing should envolve trimming rows.
   */
  expandChildRows(parentIndex) {
    let rowsToUntrim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let recursive = arguments.length > 2 ? arguments[2] : void 0;
    let doTrimming = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (this.dataManager.hasChildren(parentIndex)) {
      const parentObject = this.dataManager.getDataObject(parentIndex);
      arrayEach(parentObject.__children, (elem) => {
        if (!this.isAnyParentCollapsed(elem)) {
          const elemIndex = this.dataManager.getRowIndex(elem);
          rowsToUntrim.push(elemIndex);
          this.expandChildRows(elemIndex, rowsToUntrim);
        }
      });
    }
    if (doTrimming) {
      this.untrimRows(rowsToUntrim);
    }
  }
  /**
   * Expand the children of the row passed as an argument.
   *
   * @param {number|object} row Parent row.
   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.
   * @param {boolean} [doTrimming=true] If set to `true`, the trimming will be applied when the function finishes.
   * @returns {number[]}
   */
  expandChildren(row) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const rowsToExpand = [];
    let rowObject = null;
    let rowIndex = null;
    let rowsToUntrim = null;
    if (isNaN(row)) {
      rowObject = row;
      rowIndex = this.dataManager.getRowIndex(row);
    } else {
      rowObject = this.dataManager.getDataObject(row);
      rowIndex = row;
    }
    this.collapsedRows.splice(this.collapsedRows.indexOf(rowIndex), 1);
    if (this.dataManager.hasChildren(rowObject)) {
      arrayEach(rowObject.__children, (elem) => {
        const childIndex = this.dataManager.getRowIndex(elem);
        rowsToExpand.push(childIndex);
      });
    }
    rowsToUntrim = this.expandRows(rowsToExpand, true, false);
    if (doTrimming) {
      this.untrimRows(rowsToUntrim);
    }
    if (forceRender) {
      this.renderAndAdjust();
    }
    return rowsToUntrim;
  }
  /**
   * Expand multiple rows' children.
   *
   * @param {Array} rows Array of rows which children are about to be expanded.
   * @param {boolean} [forceRender=true] `true` if the table should render after finishing the function.
   * @param {boolean} [doTrimming=true] `true` if the rows should be untrimmed after finishing the function.
   */
  expandMultipleChildren(rows) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const rowsToUntrim = [];
    arrayEach(rows, (elem) => {
      rowsToUntrim.push(...this.expandChildren(elem, false, false));
    });
    if (doTrimming) {
      this.untrimRows(rowsToUntrim);
    }
    if (forceRender) {
      this.renderAndAdjust();
    }
  }
  /**
   * Collapse all collapsable rows.
   */
  collapseAll() {
    const data = this.dataManager.getData();
    const parentsToCollapse = [];
    arrayEach(data, (elem) => {
      if (this.dataManager.hasChildren(elem)) {
        parentsToCollapse.push(elem);
      }
    });
    this.collapseMultipleChildren(parentsToCollapse);
    this.renderAndAdjust();
  }
  /**
   * Expand all collapsable rows.
   */
  expandAll() {
    const data = this.dataManager.getData();
    const parentsToExpand = [];
    arrayEach(data, (elem) => {
      if (this.dataManager.hasChildren(elem)) {
        parentsToExpand.push(elem);
      }
    });
    this.expandMultipleChildren(parentsToExpand);
    this.renderAndAdjust();
  }
  /**
   * Trim rows.
   *
   * @param {Array} rows Physical row indexes.
   */
  trimRows(rows) {
    this.hot.batchExecution(() => {
      arrayEach(rows, (physicalRow) => {
        this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, true);
      });
    }, true);
  }
  /**
   * Untrim rows.
   *
   * @param {Array} rows Physical row indexes.
   */
  untrimRows(rows) {
    this.hot.batchExecution(() => {
      arrayEach(rows, (physicalRow) => {
        this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, false);
      });
    }, true);
  }
  /**
   * Check if all child rows are collapsed.
   *
   * @private
   * @param {number|object|null} row The parent row. `null` for the top level.
   * @returns {boolean}
   */
  areChildrenCollapsed(row) {
    let rowObj = isNaN(row) ? row : this.dataManager.getDataObject(row);
    let allCollapsed = true;
    if (rowObj === null) {
      rowObj = {
        __children: this.dataManager.data
      };
    }
    if (this.dataManager.hasChildren(rowObj)) {
      arrayEach(rowObj.__children, (elem) => {
        const rowIndex = this.dataManager.getRowIndex(elem);
        if (!this.plugin.collapsedRowsMap.getValueAtIndex(rowIndex)) {
          allCollapsed = false;
          return false;
        }
      });
    }
    return allCollapsed;
  }
  /**
   * Check if any of the row object parents are collapsed.
   *
   * @private
   * @param {object} rowObj Row object.
   * @returns {boolean}
   */
  isAnyParentCollapsed(rowObj) {
    let parent = rowObj;
    while (parent !== null) {
      parent = this.dataManager.getRowParent(parent);
      const parentIndex = this.dataManager.getRowIndex(parent);
      if (this.collapsedRows.indexOf(parentIndex) > -1) {
        return true;
      }
    }
    return false;
  }
  /**
   * Toggle collapsed state. Callback for the `beforeOnCellMousedown` hook.
   *
   * @private
   * @param {MouseEvent} event `mousedown` event.
   * @param {object} coords Coordinates of the clicked cell/header.
   */
  toggleState(event2, coords) {
    if (coords.col >= 0) {
      return;
    }
    const row = this.translateTrimmedRow(coords.row);
    if (hasClass(event2.target, headers_default.CSS_CLASSES.button)) {
      if (this.areChildrenCollapsed(row)) {
        this.expandChildren(row);
      } else {
        this.collapseChildren(row);
      }
      stopImmediatePropagation(event2);
    }
  }
  /**
   * Translate visual row after trimming to physical base row index.
   *
   * @private
   * @param {number} row Row index.
   * @returns {number} Base row index.
   */
  translateTrimmedRow(row) {
    return this.hot.toPhysicalRow(row);
  }
  /**
   * Translate physical row after trimming to visual base row index.
   *
   * @private
   * @param {number} row Row index.
   * @returns {number} Base row index.
   */
  untranslateTrimmedRow(row) {
    return this.hot.toVisualRow(row);
  }
  /**
   * Helper function to render the table and call the `adjustElementsSize` method.
   *
   * @private
   */
  renderAndAdjust() {
    this.hot.render();
    this.hot.view.adjustElementsSize();
  }
};
var collapsing_default = CollapsingUI;

// node_modules/handsontable/plugins/nestedRows/ui/contextMenu.mjs
var privatePool20 = /* @__PURE__ */ new WeakMap();
var ContextMenuUI = class extends base_default7 {
  constructor(nestedRowsPlugin, hotInstance) {
    super(nestedRowsPlugin, hotInstance);
    privatePool20.set(this, {
      row_above: (key, selection) => {
        const lastSelection = selection[selection.length - 1];
        this.dataManager.addSibling(lastSelection.start.row, "above");
      },
      row_below: (key, selection) => {
        const lastSelection = selection[selection.length - 1];
        this.dataManager.addSibling(lastSelection.start.row, "below");
      }
    });
    this.dataManager = this.plugin.dataManager;
  }
  /**
   * Append options to the context menu. (Propagated from the `afterContextMenuDefaultOptions` hook callback)
   * f.
   *
   * @private
   * @param {object} defaultOptions Default context menu options.
   * @returns {*}
   */
  appendOptions(defaultOptions) {
    const newEntries = [{
      key: "add_child",
      name() {
        return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD);
      },
      callback: () => {
        const translatedRowIndex = this.dataManager.translateTrimmedRow(this.hot.getSelectedLast()[0]);
        const parent = this.dataManager.getDataObject(translatedRowIndex);
        this.dataManager.addChild(parent);
      },
      disabled: () => {
        const selected = this.hot.getSelectedLast();
        return !selected || selected[0] < 0 || this.hot.selection.isSelectedByColumnHeader() || this.hot.countRows() >= this.hot.getSettings().maxRows;
      }
    }, {
      key: "detach_from_parent",
      name() {
        return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD);
      },
      callback: () => {
        this.dataManager.detachFromParent(this.hot.getSelectedLast());
      },
      disabled: () => {
        const selected = this.hot.getSelectedLast();
        const translatedRowIndex = this.dataManager.translateTrimmedRow(selected[0]);
        const parent = this.dataManager.getRowParent(translatedRowIndex);
        return !parent || !selected || selected[0] < 0 || this.hot.selection.isSelectedByColumnHeader() || this.hot.countRows() >= this.hot.getSettings().maxRows;
      }
    }, {
      name: "---------"
    }];
    rangeEach(0, defaultOptions.items.length - 1, (i) => {
      if (i === 0) {
        arrayEach(newEntries, (val, j) => {
          defaultOptions.items.splice(i + j, 0, val);
        });
        return false;
      }
    });
    return this.modifyRowInsertingOptions(defaultOptions);
  }
  /**
   * Modify how the row inserting options work.
   *
   * @private
   * @param {object} defaultOptions Default context menu items.
   * @returns {*}
   */
  modifyRowInsertingOptions(defaultOptions) {
    const priv = privatePool20.get(this);
    rangeEach(0, defaultOptions.items.length - 1, (i) => {
      const option = priv[defaultOptions.items[i].key];
      if (option !== null && option !== void 0) {
        defaultOptions.items[i].callback = option;
      }
    });
    return defaultOptions;
  }
};
var contextMenu_default = ContextMenuUI;

// node_modules/handsontable/plugins/nestedRows/utils/rowMoveController.mjs
var RowMoveController = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.hot = plugin.hot;
    this.dataManager = plugin.dataManager;
    this.collapsingUI = plugin.collapsingUI;
  }
  /**
   * `beforeRowMove` hook callback.
   *
   * @param {Array} rows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements
   *   will be placed after the moving action. To check the visualization of the final index, please take a look at
   *   [documentation](@/guides/rows/row-moving.md).
   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we
   *   are going to drop the moved elements. To check visualization of drop index please take a look at
   *   [documentation](@/guides/rows/row-moving.md).
   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {
    const improperUsage = this.displayAPICompatibilityWarning({
      rows,
      finalIndex,
      dropIndex,
      movePossible
    });
    if (improperUsage) {
      return false;
    }
    this.movedToCollapsed = false;
    const dropToLastRow = dropIndex === this.hot.countRows();
    const physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);
    let allowMove = true;
    const physicalStartIndexes = rows.map((rowIndex) => {
      if (!allowMove) {
        return false;
      }
      const physicalRowIndex = this.dataManager.translateTrimmedRow(rowIndex);
      allowMove = this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);
      return physicalRowIndex;
    });
    const willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;
    if (!allowMove || !willDataChange) {
      return false;
    }
    const baseParent = this.getBaseParent(physicalStartIndexes);
    const targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);
    const sameParent = baseParent === targetParent;
    this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent);
    this.collapsingUI.collapsedRowsStash.stash();
    this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);
    this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);
    this.dataManager.rewriteCache();
    this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);
    this.collapsingUI.collapsedRowsStash.applyStash(false);
    this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));
    this.hot.render();
    this.selectCells(rows, dropIndex);
    return false;
  }
  /**
   * Display a `dragRows`/`moveRows` method compatibility warning if needed.
   *
   * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.
   * @returns {boolean} `true` if is a result of an improper usage of the moving API.
   */
  displayAPICompatibilityWarning(beforeMoveRowHookArgs) {
    const {
      rows,
      finalIndex,
      dropIndex,
      movePossible
    } = beforeMoveRowHookArgs;
    let shouldTerminate = false;
    if (isUndefined2(dropIndex)) {
      warn2(toSingleLine`Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\x20
      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.`);
      this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, false);
      shouldTerminate = true;
    }
    return shouldTerminate;
  }
  /**
   * Check if the moving action should be allowed.
   *
   * @param {number} physicalRowIndex Physical start row index.
   * @param {number} physicalDropIndex Physical drop index.
   * @returns {boolean} `true` if it should continue with the moving action.
   */
  shouldAllowMoving(physicalRowIndex, physicalDropIndex) {
    return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);
  }
  /**
   * Get the base row parent.
   *
   * @param {number} physicalStartIndexes Physical start row index.
   * @returns {object|null} The base row parent.
   */
  getBaseParent(physicalStartIndexes) {
    return this.dataManager.getRowParent(physicalStartIndexes[0]);
  }
  /**
   * Get the target row parent.
   *
   * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.
   * @param {number} physicalDropIndex Physical drop row index.
   * @returns {object|null} The target row parent.
   */
  getTargetParent(dropToLastRow, physicalDropIndex) {
    let targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex);
    if (targetParent === null || targetParent === void 0) {
      targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);
    }
    return targetParent;
  }
  /**
   * Shift the cached collapsible rows position according to the move action.
   *
   * @param {number[]} physicalStartIndexes Physical start row indexes.
   * @param {number} physicalDropIndex Physical drop index.
   * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.
   */
  shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {
    if (!sameParent) {
      if (Math.max(...physicalStartIndexes) <= physicalDropIndex) {
        this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);
      } else {
        this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);
      }
    }
  }
  /**
   * Move the rows at the provided coordinates.
   *
   * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.
   * @param {number} physicalDropIndex Physical drop index.
   * @param {object} targetParent Parent of the destination row.
   */
  moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {
    const moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;
    this.hot.batchRender(() => {
      physicalStartIndexes.forEach((physicalStartIndex) => {
        this.dataManager.moveRow(physicalStartIndex, physicalDropIndex, this.movedToCollapsed, moveToLastChild);
      });
    });
  }
  /**
   * Move the cell meta for multiple rows.
   *
   * @param {number[]} baseIndexes Array of indexes for the rows being moved.
   * @param {number} targetIndex Index of the destination of the move.
   */
  moveCellsMeta(baseIndexes, targetIndex) {
    const rowsOfMeta = [];
    const movingDown = Math.max(...baseIndexes) < targetIndex;
    baseIndexes.forEach((baseIndex) => {
      rowsOfMeta.push(this.hot.getCellMetaAtRow(baseIndex));
    });
    this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);
    this.hot.spliceCellsMeta(targetIndex - (movingDown ? rowsOfMeta.length : 0), 0, ...rowsOfMeta);
  }
  /**
   * Select cells after the move.
   *
   * @param {Array} rows Array of visual row indexes to be moved.
   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we
   *   are going to drop the moved elements. To check visualization of drop index please take a look at
   *   [documentation](@/guides/rows/row-moving.md).
   */
  selectCells(rows, dropIndex) {
    const rowsLen = rows.length;
    let startRow = 0;
    let endRow = 0;
    let selection = null;
    let lastColIndex = null;
    if (this.movedToCollapsed) {
      let physicalDropIndex = null;
      if (rows[rowsLen - 1] < dropIndex) {
        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);
      } else {
        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);
      }
      const parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);
      const parentIndex = this.dataManager.getRowIndex(parentObject);
      startRow = this.dataManager.untranslateTrimmedRow(parentIndex);
      endRow = startRow;
    } else if (rows[rowsLen - 1] < dropIndex) {
      endRow = dropIndex - 1;
      startRow = endRow - rowsLen + 1;
    } else {
      startRow = dropIndex;
      endRow = startRow + rowsLen - 1;
    }
    selection = this.hot.selection;
    lastColIndex = this.hot.countCols() - 1;
    selection.setRangeStart(this.hot._createCellCoords(startRow, 0));
    selection.setRangeEnd(this.hot._createCellCoords(endRow, lastColIndex), true);
  }
  // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.
  /**
   * Indicates if order of rows was changed.
   *
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements
   *   will be placed after the moving action. To check the visualization of the final index, please take a look at
   *   [documentation](@/guides/rows/row-moving.md).
   * @returns {boolean}
   */
  isRowOrderChanged(movedRows, finalIndex) {
    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);
  }
};

// node_modules/handsontable/plugins/nestedRows/nestedRows.mjs
var PLUGIN_KEY29 = "nestedRows";
var PLUGIN_PRIORITY28 = 300;
var privatePool21 = /* @__PURE__ */ new WeakMap();
var WRONG_DATA_TYPE_ERROR = "The Nested Rows plugin requires an Array of Objects as a dataset to be provided. The plugin has been disabled.";
var NestedRows = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY29;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY28;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.dataManager = null;
    this.headersUI = null;
    this.collapsedRowsMap = null;
    privatePool21.set(this, {
      movedToCollapsed: false,
      skipRender: null,
      skipCoreAPIModifiers: false
    });
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link NestedRows#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY29];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.collapsedRowsMap = this.hot.rowIndexMapper.registerMap("nestedRows", new TrimmingMap());
    this.dataManager = new dataManager_default(this, this.hot);
    this.collapsingUI = new collapsing_default(this, this.hot);
    this.headersUI = new headers_default(this, this.hot);
    this.contextMenuUI = new contextMenu_default(this, this.hot);
    this.rowMoveController = new RowMoveController(this);
    this.addHook("afterInit", function() {
      return _this.onAfterInit(...arguments);
    });
    this.addHook("beforeViewRender", function() {
      return _this.onBeforeViewRender(...arguments);
    });
    this.addHook("modifyRowData", function() {
      return _this.onModifyRowData(...arguments);
    });
    this.addHook("modifySourceLength", function() {
      return _this.onModifySourceLength(...arguments);
    });
    this.addHook("beforeDataSplice", function() {
      return _this.onBeforeDataSplice(...arguments);
    });
    this.addHook("filterData", function() {
      return _this.onFilterData(...arguments);
    });
    this.addHook("afterContextMenuDefaultOptions", function() {
      return _this.onAfterContextMenuDefaultOptions(...arguments);
    });
    this.addHook("afterGetRowHeader", function() {
      return _this.onAfterGetRowHeader(...arguments);
    });
    this.addHook("beforeOnCellMouseDown", function() {
      return _this.onBeforeOnCellMouseDown(...arguments);
    });
    this.addHook("beforeRemoveRow", function() {
      return _this.onBeforeRemoveRow(...arguments);
    });
    this.addHook("afterRemoveRow", function() {
      return _this.onAfterRemoveRow(...arguments);
    });
    this.addHook("beforeAddChild", function() {
      return _this.onBeforeAddChild(...arguments);
    });
    this.addHook("afterAddChild", function() {
      return _this.onAfterAddChild(...arguments);
    });
    this.addHook("beforeDetachChild", function() {
      return _this.onBeforeDetachChild(...arguments);
    });
    this.addHook("afterDetachChild", function() {
      return _this.onAfterDetachChild(...arguments);
    });
    this.addHook("modifyRowHeaderWidth", function() {
      return _this.onModifyRowHeaderWidth(...arguments);
    });
    this.addHook("afterCreateRow", function() {
      return _this.onAfterCreateRow(...arguments);
    });
    this.addHook("beforeRowMove", function() {
      return _this.onBeforeRowMove(...arguments);
    });
    this.addHook("beforeLoadData", (data) => this.onBeforeLoadData(data));
    this.addHook("beforeUpdateData", (data) => this.onBeforeLoadData(data));
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.rowIndexMapper.unregisterMap("nestedRows");
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`nestedRows`](@/api/options.md#nestedrows)
   */
  updatePlugin() {
    this.disablePlugin();
    const currentSourceData = this.dataManager.getData();
    this.enablePlugin();
    this.dataManager.updateWithData(currentSourceData);
    super.updatePlugin();
  }
  /**
   * `beforeRowMove` hook callback.
   *
   * @private
   * @param {Array} rows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements
   *   will be placed after the moving action. To check the visualization of the final index, please take a look at
   *   [documentation](@/guides/rows/row-summary.md).
   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we
   *   are going to drop the moved elements. To check visualization of drop index please take a look at
   *   [documentation](@/guides/rows/row-summary.md).
   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {
    return this.rowMoveController.onBeforeRowMove(rows, finalIndex, dropIndex, movePossible);
  }
  /**
   * Enable the modify hook skipping flag - allows retrieving the data from Handsontable without this plugin's
   * modifications.
   */
  disableCoreAPIModifiers() {
    const priv = privatePool21.get(this);
    priv.skipCoreAPIModifiers = true;
  }
  /**
   * Disable the modify hook skipping flag.
   */
  enableCoreAPIModifiers() {
    const priv = privatePool21.get(this);
    priv.skipCoreAPIModifiers = false;
  }
  /**
   * `beforeOnCellMousedown` hook callback.
   *
   * @private
   * @param {MouseEvent} event Mousedown event.
   * @param {object} coords Cell coords.
   * @param {HTMLElement} TD Clicked cell.
   */
  onBeforeOnCellMouseDown(event2, coords, TD) {
    this.collapsingUI.toggleState(event2, coords, TD);
  }
  /**
   * The modifyRowData hook callback.
   *
   * @private
   * @param {number} row Visual row index.
   * @returns {boolean}
   */
  onModifyRowData(row) {
    const priv = privatePool21.get(this);
    if (priv.skipCoreAPIModifiers) {
      return;
    }
    return this.dataManager.getDataObject(row);
  }
  /**
   * Modify the source data length to match the length of the nested structure.
   *
   * @private
   * @returns {number}
   */
  onModifySourceLength() {
    const priv = privatePool21.get(this);
    if (priv.skipCoreAPIModifiers) {
      return;
    }
    return this.dataManager.countAllRows();
  }
  /**
   * @private
   * @param {number} index The index where the data was spliced.
   * @param {number} amount An amount of items to remove.
   * @param {object} element An element to add.
   * @returns {boolean}
   */
  onBeforeDataSplice(index2, amount, element) {
    const priv = privatePool21.get(this);
    if (priv.skipCoreAPIModifiers || this.dataManager.isRowHighestLevel(index2)) {
      return true;
    }
    this.dataManager.spliceData(index2, amount, element);
    return false;
  }
  /**
   * Provide custom source data filtering. It's handled by core method and replaces the native filtering.
   *
   * @private
   * @param {number} index The index where the data filtering starts.
   * @param {number} amount An amount of rows which filtering applies to.
   * @param {number} physicalRows Physical row indexes.
   * @returns {Array}
   */
  onFilterData(index2, amount, physicalRows) {
    const priv = privatePool21.get(this);
    this.collapsingUI.collapsedRowsStash.stash();
    this.collapsingUI.collapsedRowsStash.trimStash(physicalRows[0], amount);
    this.collapsingUI.collapsedRowsStash.shiftStash(physicalRows[0], null, -1 * amount);
    this.dataManager.filterData(index2, amount, physicalRows);
    priv.skipRender = true;
    return this.dataManager.getData().slice();
  }
  /**
   * `afterContextMenuDefaultOptions` hook callback.
   *
   * @private
   * @param {object} defaultOptions The default context menu items order.
   * @returns {boolean}
   */
  onAfterContextMenuDefaultOptions(defaultOptions) {
    return this.contextMenuUI.appendOptions(defaultOptions);
  }
  /**
   * `afterGetRowHeader` hook callback.
   *
   * @private
   * @param {number} row Row index.
   * @param {HTMLElement} TH Row header element.
   */
  onAfterGetRowHeader(row, TH) {
    this.headersUI.appendLevelIndicators(row, TH);
  }
  /**
   * `modifyRowHeaderWidth` hook callback.
   *
   * @private
   * @param {number} rowHeaderWidth The initial row header width(s).
   * @returns {number}
   */
  onModifyRowHeaderWidth(rowHeaderWidth) {
    return this.headersUI.rowHeaderWidthCache || rowHeaderWidth;
  }
  /**
   * `onAfterRemoveRow` hook callback.
   *
   * @private
   * @param {number} index Removed row.
   * @param {number} amount Amount of removed rows.
   * @param {Array} logicRows An array of the removed physical rows.
   * @param {string} source Source of action.
   */
  onAfterRemoveRow(index2, amount, logicRows, source) {
    if (source === this.pluginName) {
      return;
    }
    const priv = privatePool21.get(this);
    setTimeout(() => {
      priv.skipRender = null;
      this.headersUI.updateRowHeaderWidth();
      this.collapsingUI.collapsedRowsStash.applyStash();
    }, 0);
  }
  /**
   * Callback for the `beforeRemoveRow` change list of removed physical indexes by reference. Removing parent node
   * has effect in removing children nodes.
   *
   * @private
   * @param {number} index Visual index of starter row.
   * @param {number} amount Amount of rows to be removed.
   * @param {Array} physicalRows List of physical indexes.
   */
  onBeforeRemoveRow(index2, amount, physicalRows) {
    const modifiedPhysicalRows = Array.from(physicalRows.reduce((removedRows, physicalIndex) => {
      if (this.dataManager.isParent(physicalIndex)) {
        const children = this.dataManager.getDataObject(physicalIndex).__children;
        removedRows.add(physicalIndex);
        if (Array.isArray(children)) {
          children.forEach((child) => removedRows.add(this.dataManager.getRowIndex(child)));
        }
        return removedRows;
      }
      return removedRows.add(physicalIndex);
    }, /* @__PURE__ */ new Set()));
    physicalRows.length = 0;
    physicalRows.push(...modifiedPhysicalRows);
  }
  /**
   * `beforeAddChild` hook callback.
   *
   * @private
   */
  onBeforeAddChild() {
    this.collapsingUI.collapsedRowsStash.stash();
  }
  /**
   * `afterAddChild` hook callback.
   *
   * @private
   * @param {object} parent Parent element.
   * @param {object} element New child element.
   */
  onAfterAddChild(parent, element) {
    this.collapsingUI.collapsedRowsStash.shiftStash(this.dataManager.getRowIndex(element));
    this.collapsingUI.collapsedRowsStash.applyStash();
    this.headersUI.updateRowHeaderWidth();
  }
  /**
   * `beforeDetachChild` hook callback.
   *
   * @private
   */
  onBeforeDetachChild() {
    this.collapsingUI.collapsedRowsStash.stash();
  }
  /**
   * `afterDetachChild` hook callback.
   *
   * @private
   * @param {object} parent Parent element.
   * @param {object} element New child element.
   * @param {number} finalElementRowIndex The final row index of the detached element.
   */
  onAfterDetachChild(parent, element, finalElementRowIndex) {
    this.collapsingUI.collapsedRowsStash.shiftStash(finalElementRowIndex, null, -1);
    this.collapsingUI.collapsedRowsStash.applyStash();
    this.headersUI.updateRowHeaderWidth();
  }
  /**
   * `afterCreateRow` hook callback.
   *
   * @private
   */
  onAfterCreateRow() {
    this.dataManager.rewriteCache();
  }
  /**
   * `afterInit` hook callback.
   *
   * @private
   */
  onAfterInit() {
    const deepestLevel = Math.max(...this.dataManager.cache.levels);
    if (deepestLevel > 0) {
      this.headersUI.updateRowHeaderWidth(deepestLevel);
    }
  }
  /**
   * `beforeViewRender` hook callback.
   *
   * @param {boolean} force Indicates if the render call was trigered by a change of settings or data.
   * @param {object} skipRender An object, holder for skipRender functionality.
   * @private
   */
  onBeforeViewRender(force, skipRender) {
    const priv = privatePool21.get(this);
    if (priv.skipRender) {
      skipRender.skipRender = true;
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
  /**
   * `beforeLoadData` hook callback.
   *
   * @param {Array} data The source data.
   * @private
   */
  onBeforeLoadData(data) {
    if (!isArrayOfObjects(data)) {
      error(WRONG_DATA_TYPE_ERROR);
      this.hot.getSettings()[PLUGIN_KEY29] = false;
      this.disablePlugin();
      return;
    }
    this.dataManager.setData(data);
    this.dataManager.rewriteCache();
  }
};

// node_modules/handsontable/plugins/persistentState/storage.mjs
var Storage = class {
  // eslint-disable-next-line no-restricted-globals
  constructor(prefix) {
    let rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
    this.rootWindow = rootWindow;
    this.prefix = prefix;
    this.savedKeys = [];
    this.loadSavedKeys();
  }
  /**
   * Save data to localStorage.
   *
   * @param {string} key Key string.
   * @param {Mixed} value Value to save.
   */
  saveValue(key, value) {
    this.rootWindow.localStorage.setItem(`${this.prefix}_${key}`, JSON.stringify(value));
    if (this.savedKeys.indexOf(key) === -1) {
      this.savedKeys.push(key);
      this.saveSavedKeys();
    }
  }
  /**
   * Load data from localStorage.
   *
   * @param {string} key Key string.
   * @param {object} defaultValue Object containing the loaded data.
   *
   * @returns {object|undefined}
   */
  loadValue(key, defaultValue) {
    const itemKey = typeof key === "undefined" ? defaultValue : key;
    const value = this.rootWindow.localStorage.getItem(`${this.prefix}_${itemKey}`);
    return value === null ? void 0 : JSON.parse(value);
  }
  /**
   * Reset given data from localStorage.
   *
   * @param {string} key Key string.
   */
  reset(key) {
    this.rootWindow.localStorage.removeItem(`${this.prefix}_${key}`);
  }
  /**
   * Reset all data from localStorage.
   *
   */
  resetAll() {
    arrayEach(this.savedKeys, (value, index2) => {
      this.rootWindow.localStorage.removeItem(`${this.prefix}_${this.savedKeys[index2]}`);
    });
    this.clearSavedKeys();
  }
  /**
   * Load and save all keys from localStorage.
   *
   * @private
   */
  loadSavedKeys() {
    const keysJSON = this.rootWindow.localStorage.getItem(`${this.prefix}__persistentStateKeys`);
    const keys2 = typeof keysJSON === "string" ? JSON.parse(keysJSON) : void 0;
    this.savedKeys = keys2 || [];
  }
  /**
   * Save saved key in localStorage.
   *
   * @private
   */
  saveSavedKeys() {
    this.rootWindow.localStorage.setItem(`${this.prefix}__persistentStateKeys`, JSON.stringify(this.savedKeys));
  }
  /**
   * Clear saved key from localStorage.
   *
   * @private
   */
  clearSavedKeys() {
    this.savedKeys.length = 0;
    this.saveSavedKeys();
  }
};
var storage_default = Storage;

// node_modules/handsontable/plugins/persistentState/persistentState.mjs
pluginHooks_default.getSingleton().register("persistentStateSave");
pluginHooks_default.getSingleton().register("persistentStateLoad");
pluginHooks_default.getSingleton().register("persistentStateReset");
var PLUGIN_KEY30 = "persistentState";
var PLUGIN_PRIORITY29 = 0;
var PersistentState = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY30;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY29;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.storage = void 0;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link PersistentState#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY30];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    if (!this.storage) {
      this.storage = new storage_default(this.hot.rootElement.id, this.hot.rootWindow);
    }
    this.addHook("persistentStateSave", (key, value) => this.saveValue(key, value));
    this.addHook("persistentStateLoad", (key, saveTo) => this.loadValue(key, saveTo));
    this.addHook("persistentStateReset", () => this.resetValue());
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.storage = void 0;
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`persistentState`](@/api/options.md#persistentstate)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Loads the value from local storage.
   *
   * @param {string} key Storage key.
   * @param {object} saveTo Saved value from local storage.
   */
  loadValue(key, saveTo) {
    saveTo.value = this.storage.loadValue(key);
  }
  /**
   * Saves the data to local storage.
   *
   * @param {string} key Storage key.
   * @param {Mixed} value Value to save.
   */
  saveValue(key, value) {
    this.storage.saveValue(key, value);
  }
  /**
   * Resets the data or all data from local storage.
   *
   * @param {string} key [optional] Storage key.
   */
  resetValue(key) {
    if (typeof key === "undefined") {
      this.storage.resetAll();
    } else {
      this.storage.reset(key);
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/search/search.mjs
var PLUGIN_KEY31 = "search";
var PLUGIN_PRIORITY30 = 190;
var DEFAULT_SEARCH_RESULT_CLASS = "htSearchResult";
var DEFAULT_CALLBACK = function(instance, row, col, data, testResult) {
  instance.getCellMeta(row, col).isSearchResult = testResult;
};
var DEFAULT_QUERY_METHOD = function(query, value, cellProperties) {
  if (isUndefined2(query) || query === null || !query.toLocaleLowerCase || query.length === 0) {
    return false;
  }
  if (isUndefined2(value) || value === null) {
    return false;
  }
  return value.toString().toLocaleLowerCase(cellProperties.locale).indexOf(query.toLocaleLowerCase(cellProperties.locale)) !== -1;
};
var Search = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY31;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY30;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.callback = DEFAULT_CALLBACK;
    this.queryMethod = DEFAULT_QUERY_METHOD;
    this.searchResultClass = DEFAULT_SEARCH_RESULT_CLASS;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY31];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const searchSettings = this.hot.getSettings()[PLUGIN_KEY31];
    this.updatePluginSettings(searchSettings);
    this.addHook("beforeRenderer", function() {
      return _this.onBeforeRenderer(...arguments);
    });
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    var _this2 = this;
    const beforeRendererCallback = function() {
      return _this2.onBeforeRenderer(...arguments);
    };
    this.hot.addHook("beforeRenderer", beforeRendererCallback);
    this.hot.addHookOnce("afterViewRender", () => {
      this.hot.removeHook("beforeRenderer", beforeRendererCallback);
    });
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`search`](@/api/options.md#search)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Makes the query.
   *
   * @param {string} queryStr Value to be search.
   * @param {Function} [callback] Callback function performed on cells with values which matches to the searched query.
   * @param {Function} [queryMethod] Query function responsible for determining whether a query matches the value stored in a cell.
   * @returns {object[]} Return an array of objects with `row`, `col`, `data` properties or empty array.
   */
  query(queryStr) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getCallback();
    let queryMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getQueryMethod();
    const rowCount = this.hot.countRows();
    const colCount = this.hot.countCols();
    const queryResult = [];
    const instance = this.hot;
    rangeEach(0, rowCount - 1, (rowIndex) => {
      rangeEach(0, colCount - 1, (colIndex) => {
        const cellData = this.hot.getDataAtCell(rowIndex, colIndex);
        const cellProperties = this.hot.getCellMeta(rowIndex, colIndex);
        const cellCallback = cellProperties.search.callback || callback;
        const cellQueryMethod = cellProperties.search.queryMethod || queryMethod;
        const testResult = cellQueryMethod(queryStr, cellData, cellProperties);
        if (testResult) {
          const singleResult = {
            row: rowIndex,
            col: colIndex,
            data: cellData
          };
          queryResult.push(singleResult);
        }
        if (cellCallback) {
          cellCallback(instance, rowIndex, colIndex, cellData, testResult);
        }
      });
    });
    return queryResult;
  }
  /**
   * Gets the callback function.
   *
   * @returns {Function} Return the callback function.
   */
  getCallback() {
    return this.callback;
  }
  /**
   * Sets the callback function. This function will be called during querying for each cell.
   *
   * @param {Function} newCallback A callback function.
   */
  setCallback(newCallback) {
    this.callback = newCallback;
  }
  /**
   * Gets the query method function.
   *
   * @returns {Function} Return the query method.
   */
  getQueryMethod() {
    return this.queryMethod;
  }
  /**
   * Sets the query method function. The function is responsible for determining whether a query matches the value stored in a cell.
   *
   * @param {Function} newQueryMethod A function with specific match logic.
   */
  setQueryMethod(newQueryMethod) {
    this.queryMethod = newQueryMethod;
  }
  /**
   * Gets search result cells class name.
   *
   * @returns {string} Return the cell class name.
   */
  getSearchResultClass() {
    return this.searchResultClass;
  }
  /**
   * Sets search result cells class name. This class name will be added to each cell that belongs to the searched query.
   *
   * @param {string} newElementClass CSS class name.
   */
  setSearchResultClass(newElementClass) {
    this.searchResultClass = newElementClass;
  }
  /**
   * Updates the settings of the plugin.
   *
   * @param {object} searchSettings The plugin settings, taken from Handsontable configuration.
   * @private
   */
  updatePluginSettings(searchSettings) {
    if (isObject2(searchSettings)) {
      if (searchSettings.searchResultClass) {
        this.setSearchResultClass(searchSettings.searchResultClass);
      }
      if (searchSettings.queryMethod) {
        this.setQueryMethod(searchSettings.queryMethod);
      }
      if (searchSettings.callback) {
        this.setCallback(searchSettings.callback);
      }
    }
  }
  /**
   * The `beforeRenderer` hook callback.
   *
   * @private
   * @param {HTMLTableCellElement} TD The rendered `TD` element.
   * @param {number} row Visual row index.
   * @param {number} col Visual column index.
   * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.
   * @param {string} value Value of the rendered cell.
   * @param {object} cellProperties Object containing the cell's properties.
   */
  onBeforeRenderer(TD, row, col, prop, value, cellProperties) {
    const className = cellProperties.className || [];
    let classArray = [];
    if (typeof className === "string") {
      classArray = className.split(" ");
    } else {
      classArray.push(...className);
    }
    if (this.isEnabled() && cellProperties.isSearchResult) {
      if (!classArray.includes(this.searchResultClass)) {
        classArray.push(`${this.searchResultClass}`);
      }
    } else if (classArray.includes(this.searchResultClass)) {
      classArray.splice(classArray.indexOf(this.searchResultClass), 1);
    }
    cellProperties.className = classArray.join(" ");
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/touchScroll/touchScroll.mjs
var PLUGIN_KEY32 = "touchScroll";
var PLUGIN_PRIORITY31 = 200;
var TouchScroll = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY32;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY31;
  }
  static get SETTING_KEYS() {
    return true;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.scrollbars = [];
    this.clones = [];
    this.lockedCollection = false;
    this.freezeOverlays = false;
  }
  /**
   * Check if plugin is enabled.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return isTouchSupported();
  }
  /**
   * Enable the plugin.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.addHook("afterViewRender", () => this.onAfterViewRender());
    this.registerEvents();
    super.enablePlugin();
  }
  /**
   * Updates the plugin to use the latest options you have specified.
   */
  updatePlugin() {
    this.lockedCollection = false;
    super.updatePlugin();
  }
  /**
   * Disable plugin for this Handsontable instance.
   */
  disablePlugin() {
    super.disablePlugin();
  }
  /**
   * Register all necessary events.
   *
   * @private
   */
  registerEvents() {
    this.addHook("beforeTouchScroll", () => this.onBeforeTouchScroll());
    this.addHook("afterMomentumScroll", () => this.onAfterMomentumScroll());
  }
  /**
   * After view render listener.
   *
   * @private
   */
  onAfterViewRender() {
    if (this.lockedCollection) {
      return;
    }
    const {
      topOverlay,
      bottomOverlay,
      inlineStartOverlay,
      topInlineStartCornerOverlay,
      bottomInlineStartCornerOverlay
    } = this.hot.view._wt.wtOverlays;
    this.lockedCollection = true;
    this.scrollbars.length = 0;
    this.scrollbars.push(topOverlay);
    if (bottomOverlay.clone) {
      this.scrollbars.push(bottomOverlay);
    }
    this.scrollbars.push(inlineStartOverlay);
    if (topInlineStartCornerOverlay) {
      this.scrollbars.push(topInlineStartCornerOverlay);
    }
    if (bottomInlineStartCornerOverlay && bottomInlineStartCornerOverlay.clone) {
      this.scrollbars.push(bottomInlineStartCornerOverlay);
    }
    this.clones = [];
    if (topOverlay.needFullRender) {
      this.clones.push(topOverlay.clone.wtTable.holder.parentNode);
    }
    if (bottomOverlay.needFullRender) {
      this.clones.push(bottomOverlay.clone.wtTable.holder.parentNode);
    }
    if (inlineStartOverlay.needFullRender) {
      this.clones.push(inlineStartOverlay.clone.wtTable.holder.parentNode);
    }
    if (topInlineStartCornerOverlay) {
      this.clones.push(topInlineStartCornerOverlay.clone.wtTable.holder.parentNode);
    }
    if (bottomInlineStartCornerOverlay && bottomInlineStartCornerOverlay.clone) {
      this.clones.push(bottomInlineStartCornerOverlay.clone.wtTable.holder.parentNode);
    }
  }
  /**
   * Touch scroll listener.
   *
   * @private
   */
  onBeforeTouchScroll() {
    this.freezeOverlays = true;
    arrayEach(this.clones, (clone4) => {
      addClass(clone4, "hide-tween");
    });
  }
  /**
   * After momentum scroll listener.
   *
   * @private
   */
  onAfterMomentumScroll() {
    this.freezeOverlays = false;
    arrayEach(this.clones, (clone4) => {
      removeClass(clone4, "hide-tween");
      addClass(clone4, "show-tween");
    });
    this.hot._registerTimeout(() => {
      arrayEach(this.clones, (clone4) => {
        removeClass(clone4, "show-tween");
      });
    }, 400);
    arrayEach(this.scrollbars, (scrollbar) => {
      scrollbar.refresh();
      scrollbar.resetFixedPosition();
    });
    this.hot.view._wt.wtOverlays.syncScrollWithMaster();
  }
};

// node_modules/handsontable/plugins/trimRows/trimRows.mjs
var PLUGIN_KEY33 = "trimRows";
var PLUGIN_PRIORITY32 = 330;
var TrimRows = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY33;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY32;
  }
  constructor(hotInstance) {
    super(hotInstance);
    this.trimmedRowsMap = null;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY33];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.trimmedRowsMap = this.hot.rowIndexMapper.registerMap("trimRows", new TrimmingMap());
    this.trimmedRowsMap.addLocalHook("init", () => this.onMapInit());
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`trimRows`](@/api/options.md#trimrows)
   */
  updatePlugin() {
    const trimmedRows = this.hot.getSettings()[PLUGIN_KEY33];
    if (Array.isArray(trimmedRows)) {
      this.hot.batchExecution(() => {
        this.trimmedRowsMap.clear();
        arrayEach(trimmedRows, (physicalRow) => {
          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);
        });
      }, true);
    }
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.rowIndexMapper.unregisterMap("trimRows");
    super.disablePlugin();
  }
  /**
   * Get list of trimmed rows.
   *
   * @returns {Array} Physical rows.
   */
  getTrimmedRows() {
    return this.trimmedRowsMap.getTrimmedIndexes();
  }
  /**
   * Trims the rows provided in the array.
   *
   * @param {number[]} rows Array of physical row indexes.
   * @fires Hooks#beforeTrimRow
   * @fires Hooks#afterTrimRow
   */
  trimRows(rows) {
    const currentTrimConfig = this.getTrimmedRows();
    const isValidConfig = this.isValidConfig(rows);
    let destinationTrimConfig = currentTrimConfig;
    if (isValidConfig) {
      destinationTrimConfig = Array.from(new Set(currentTrimConfig.concat(rows)));
    }
    const allowTrimRow = this.hot.runHooks("beforeTrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig);
    if (allowTrimRow === false) {
      return;
    }
    if (isValidConfig) {
      this.hot.batchExecution(() => {
        arrayEach(rows, (physicalRow) => {
          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);
        });
      }, true);
    }
    this.hot.runHooks("afterTrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig, isValidConfig && destinationTrimConfig.length > currentTrimConfig.length);
  }
  /**
   * Trims the row provided as a physical row index (counting from 0).
   *
   * @param {...number} row Physical row index.
   */
  trimRow() {
    for (var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {
      row[_key] = arguments[_key];
    }
    this.trimRows(row);
  }
  /**
   * Untrims the rows provided in the array.
   *
   * @param {number[]} rows Array of physical row indexes.
   * @fires Hooks#beforeUntrimRow
   * @fires Hooks#afterUntrimRow
   */
  untrimRows(rows) {
    const currentTrimConfig = this.getTrimmedRows();
    const isValidConfig = this.isValidConfig(rows);
    let destinationTrimConfig = currentTrimConfig;
    const trimmingMapValues = this.trimmedRowsMap.getValues().slice();
    const isAnyRowUntrimmed = rows.length > 0;
    if (isValidConfig && isAnyRowUntrimmed) {
      arrayEach(rows, (physicalRow) => {
        trimmingMapValues[physicalRow] = false;
      });
      destinationTrimConfig = arrayReduce(trimmingMapValues, (trimmedIndexes, isTrimmed, physicalIndex) => {
        if (isTrimmed) {
          trimmedIndexes.push(physicalIndex);
        }
        return trimmedIndexes;
      }, []);
    }
    const allowUntrimRow = this.hot.runHooks("beforeUntrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed);
    if (allowUntrimRow === false) {
      return;
    }
    if (isValidConfig && isAnyRowUntrimmed) {
      this.trimmedRowsMap.setValues(trimmingMapValues);
    }
    this.hot.runHooks("afterUntrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed, isValidConfig && destinationTrimConfig.length < currentTrimConfig.length);
  }
  /**
   * Untrims the row provided as a physical row index (counting from 0).
   *
   * @param {...number} row Physical row index.
   */
  untrimRow() {
    for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      row[_key2] = arguments[_key2];
    }
    this.untrimRows(row);
  }
  /**
   * Checks if given row is hidden.
   *
   * @param {number} physicalRow Physical row index.
   * @returns {boolean}
   */
  isTrimmed(physicalRow) {
    return this.trimmedRowsMap.getValueAtIndex(physicalRow) || false;
  }
  /**
   * Untrims all trimmed rows.
   */
  untrimAll() {
    this.untrimRows(this.getTrimmedRows());
  }
  /**
   * Get if trim config is valid. Check whether all of the provided physical row indexes are within source data.
   *
   * @param {Array} trimmedRows List of physical row indexes.
   * @returns {boolean}
   */
  isValidConfig(trimmedRows) {
    const sourceRows = this.hot.countSourceRows();
    return trimmedRows.every((trimmedRow) => Number.isInteger(trimmedRow) && trimmedRow >= 0 && trimmedRow < sourceRows);
  }
  /**
   * On map initialized hook callback.
   *
   * @private
   */
  onMapInit() {
    const trimmedRows = this.hot.getSettings()[PLUGIN_KEY33];
    if (Array.isArray(trimmedRows)) {
      this.hot.batchExecution(() => {
        arrayEach(trimmedRows, (physicalRow) => {
          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);
        });
      }, true);
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/undoRedo/undoRedo.mjs
var SHORTCUTS_GROUP9 = "undoRedo";
var PLUGIN_KEY34 = "undoRedo";
function UndoRedo(instance) {
  const plugin = this;
  this.instance = instance;
  this.doneActions = [];
  this.undoneActions = [];
  this.ignoreNewActions = false;
  this.enabled = false;
  instance.addHook("afterChange", function(changes, source) {
    const changesLen = changes && changes.length;
    if (!changesLen) {
      return;
    }
    const hasDifferences = changes.find((change) => {
      const [, , oldValue, newValue] = change;
      return oldValue !== newValue;
    });
    if (!hasDifferences) {
      return;
    }
    const wrappedAction = () => {
      const clonedChanges = changes.reduce((arr, change) => {
        arr.push([...change]);
        return arr;
      }, []);
      arrayEach(clonedChanges, (change) => {
        change[1] = instance.propToCol(change[1]);
      });
      const selected = changesLen > 1 ? this.getSelected() : [[clonedChanges[0][0], clonedChanges[0][1]]];
      return new UndoRedo.ChangeAction(clonedChanges, selected);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("afterCreateRow", (index2, amount, source) => {
    plugin.done(() => new UndoRedo.CreateRowAction(index2, amount), source);
  });
  instance.addHook("beforeRemoveRow", (index2, amount, logicRows, source) => {
    const wrappedAction = () => {
      const physicalRowIndex = instance.toPhysicalRow(index2);
      const removedData = deepClone(plugin.instance.getSourceData(physicalRowIndex, 0, physicalRowIndex + amount - 1, plugin.instance.countSourceCols() - 1));
      return new UndoRedo.RemoveRowAction(physicalRowIndex, removedData, instance.getSettings().fixedRowsBottom, instance.getSettings().fixedRowsTop, instance.rowIndexMapper.getIndexesSequence());
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("afterCreateCol", (index2, amount, source) => {
    plugin.done(() => new UndoRedo.CreateColumnAction(index2, amount), source);
  });
  instance.addHook("beforeRemoveCol", (index2, amount, logicColumns, source) => {
    const wrappedAction = () => {
      const originalData = plugin.instance.getSourceDataArray();
      const columnIndex = (plugin.instance.countCols() + index2) % plugin.instance.countCols();
      const removedData = [];
      const headers = [];
      const indexes = [];
      rangeEach(originalData.length - 1, (i) => {
        const column = [];
        const origRow = originalData[i];
        rangeEach(columnIndex, columnIndex + (amount - 1), (j) => {
          column.push(origRow[instance.toPhysicalColumn(j)]);
        });
        removedData.push(column);
      });
      rangeEach(amount - 1, (i) => {
        indexes.push(instance.toPhysicalColumn(columnIndex + i));
      });
      if (Array.isArray(instance.getSettings().colHeaders)) {
        rangeEach(amount - 1, (i) => {
          headers.push(instance.getSettings().colHeaders[instance.toPhysicalColumn(columnIndex + i)] || null);
        });
      }
      const columnsMap = instance.columnIndexMapper.getIndexesSequence();
      const rowsMap = instance.rowIndexMapper.getIndexesSequence();
      return new UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, columnsMap, rowsMap, instance.getSettings().fixedColumnsStart);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("beforeCellAlignment", (stateBefore, range, type, alignment) => {
    plugin.done(() => new UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment));
  });
  instance.addHook("beforeFilter", (conditionsStack) => {
    plugin.done(() => new UndoRedo.FiltersAction(conditionsStack));
  });
  instance.addHook("beforeRowMove", (rows, finalIndex) => {
    if (rows === false) {
      return;
    }
    plugin.done(() => new UndoRedo.RowMoveAction(rows, finalIndex));
  });
  instance.addHook("beforeMergeCells", (cellRange, auto) => {
    if (auto) {
      return;
    }
    plugin.done(() => new UndoRedo.MergeCellsAction(instance, cellRange));
  });
  instance.addHook("afterUnmergeCells", (cellRange, auto) => {
    if (auto) {
      return;
    }
    plugin.done(() => new UndoRedo.UnmergeCellsAction(instance, cellRange));
  });
  instance.addHook("afterInit", () => {
    plugin.init();
  });
}
UndoRedo.prototype.done = function(wrappedAction, source) {
  if (this.ignoreNewActions) {
    return;
  }
  const isBlockedByDefault = source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto";
  if (isBlockedByDefault) {
    return;
  }
  const doneActionsCopy = this.doneActions.slice();
  const continueAction = this.instance.runHooks("beforeUndoStackChange", doneActionsCopy, source);
  if (continueAction === false) {
    return;
  }
  const newAction = wrappedAction();
  const undoneActionsCopy = this.undoneActions.slice();
  this.doneActions.push(newAction);
  this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
  this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
  this.undoneActions.length = 0;
  this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
};
UndoRedo.prototype.undo = function() {
  if (this.isUndoAvailable()) {
    const doneActionsCopy = this.doneActions.slice();
    this.instance.runHooks("beforeUndoStackChange", doneActionsCopy);
    const action = this.doneActions.pop();
    this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
    const actionClone = deepClone(action);
    const continueAction = this.instance.runHooks("beforeUndo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    const that = this;
    const undoneActionsCopy = this.undoneActions.slice();
    this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
    action.undo(this.instance, () => {
      that.ignoreNewActions = false;
      that.undoneActions.push(action);
    });
    this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
    this.instance.runHooks("afterUndo", actionClone);
  }
};
UndoRedo.prototype.redo = function() {
  if (this.isRedoAvailable()) {
    const undoneActionsCopy = this.undoneActions.slice();
    this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
    const action = this.undoneActions.pop();
    this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
    const actionClone = deepClone(action);
    const continueAction = this.instance.runHooks("beforeRedo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    const that = this;
    const doneActionsCopy = this.doneActions.slice();
    this.instance.runHooks("beforeUndoStackChange", doneActionsCopy);
    action.redo(this.instance, () => {
      that.ignoreNewActions = false;
      that.doneActions.push(action);
    });
    this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
    this.instance.runHooks("afterRedo", actionClone);
  }
};
UndoRedo.prototype.isUndoAvailable = function() {
  return this.doneActions.length > 0;
};
UndoRedo.prototype.isRedoAvailable = function() {
  return this.undoneActions.length > 0;
};
UndoRedo.prototype.clear = function() {
  this.doneActions.length = 0;
  this.undoneActions.length = 0;
};
UndoRedo.prototype.isEnabled = function() {
  return this.enabled;
};
UndoRedo.prototype.enable = function() {
  if (this.isEnabled()) {
    return;
  }
  const hot = this.instance;
  this.enabled = true;
  exposeUndoRedoMethods(hot);
  this.registerShortcuts();
  hot.addHook("afterChange", onAfterChange);
};
UndoRedo.prototype.disable = function() {
  if (!this.isEnabled()) {
    return;
  }
  const hot = this.instance;
  this.enabled = false;
  removeExposedUndoRedoMethods(hot);
  this.unregisterShortcuts();
  hot.removeHook("afterChange", onAfterChange);
};
UndoRedo.prototype.destroy = function() {
  this.clear();
  this.instance = null;
  this.doneActions = null;
  this.undoneActions = null;
};
UndoRedo.Action = function() {
};
UndoRedo.Action.prototype.undo = function() {
};
UndoRedo.Action.prototype.redo = function() {
};
UndoRedo.ChangeAction = function(changes, selected) {
  this.changes = changes;
  this.selected = selected;
  this.actionType = "change";
};
inherit(UndoRedo.ChangeAction, UndoRedo.Action);
UndoRedo.ChangeAction.prototype.undo = function(instance, undoneCallback) {
  const data = deepClone(this.changes);
  const emptyRowsAtTheEnd = instance.countEmptyRows(true);
  const emptyColsAtTheEnd = instance.countEmptyCols(true);
  for (let i = 0, len = data.length; i < len; i++) {
    data[i].splice(3, 1);
  }
  instance.addHookOnce("afterChange", undoneCallback);
  instance.setDataAtCell(data, null, null, "UndoRedo.undo");
  for (let i = 0, len = data.length; i < len; i++) {
    const [row, column] = data[i];
    if (instance.getSettings().minSpareRows && row + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {
      instance.alter("remove_row", parseInt(row + 1, 10), instance.getSettings().minSpareRows);
      instance.undoRedo.doneActions.pop();
    }
    if (instance.getSettings().minSpareCols && column + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd === instance.getSettings().minSpareCols) {
      instance.alter("remove_col", parseInt(column + 1, 10), instance.getSettings().minSpareCols);
      instance.undoRedo.doneActions.pop();
    }
  }
  instance.selectCells(this.selected, false, false);
};
UndoRedo.ChangeAction.prototype.redo = function(instance, onFinishCallback) {
  const data = deepClone(this.changes);
  for (let i = 0, len = data.length; i < len; i++) {
    data[i].splice(2, 1);
  }
  instance.addHookOnce("afterChange", onFinishCallback);
  instance.setDataAtCell(data, null, null, "UndoRedo.redo");
  if (this.selected) {
    instance.selectCells(this.selected, false, false);
  }
};
UndoRedo.CreateRowAction = function(index2, amount) {
  this.index = index2;
  this.amount = amount;
  this.actionType = "insert_row";
};
inherit(UndoRedo.CreateRowAction, UndoRedo.Action);
UndoRedo.CreateRowAction.prototype.undo = function(instance, undoneCallback) {
  const rowCount = instance.countRows();
  const minSpareRows = instance.getSettings().minSpareRows;
  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {
    this.index -= minSpareRows;
  }
  instance.addHookOnce("afterRemoveRow", undoneCallback);
  instance.alter("remove_row", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateRow", redoneCallback);
  instance.alter("insert_row_above", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveRowAction = function(index2, data, fixedRowsBottom, fixedRowsTop, rowIndexesSequence) {
  this.index = index2;
  this.data = data;
  this.actionType = "remove_row";
  this.fixedRowsBottom = fixedRowsBottom;
  this.fixedRowsTop = fixedRowsTop;
  this.rowIndexesSequence = rowIndexesSequence;
};
inherit(UndoRedo.RemoveRowAction, UndoRedo.Action);
UndoRedo.RemoveRowAction.prototype.undo = function(instance, undoneCallback) {
  const settings = instance.getSettings();
  const changes = [];
  settings.fixedRowsBottom = this.fixedRowsBottom;
  settings.fixedRowsTop = this.fixedRowsTop;
  this.data.forEach((dataRow, rowIndexDelta) => {
    Object.keys(dataRow).forEach((columnProp) => {
      const columnIndex = parseInt(columnProp, 10);
      changes.push([this.index + rowIndexDelta, isNaN(columnIndex) ? columnProp : columnIndex, dataRow[columnProp]]);
    });
  });
  instance.alter("insert_row_above", this.index, this.data.length, "UndoRedo.undo");
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.setSourceDataAtCell(changes, null, null, "UndoRedo.undo");
  instance.rowIndexMapper.setIndexesSequence(this.rowIndexesSequence);
};
UndoRedo.RemoveRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveRow", redoneCallback);
  instance.alter("remove_row", this.index, this.data.length, "UndoRedo.redo");
};
UndoRedo.CreateColumnAction = function(index2, amount) {
  this.index = index2;
  this.amount = amount;
  this.actionType = "insert_col";
};
inherit(UndoRedo.CreateColumnAction, UndoRedo.Action);
UndoRedo.CreateColumnAction.prototype.undo = function(instance, undoneCallback) {
  instance.addHookOnce("afterRemoveCol", undoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateCol", redoneCallback);
  instance.alter("insert_col_start", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveColumnAction = function(index2, indexes, data, headers, columnPositions, rowPositions, fixedColumnsStart) {
  this.index = index2;
  this.indexes = indexes;
  this.data = data;
  this.amount = this.data[0].length;
  this.headers = headers;
  this.columnPositions = columnPositions.slice(0);
  this.rowPositions = rowPositions.slice(0);
  this.actionType = "remove_col";
  this.fixedColumnsStart = fixedColumnsStart;
};
inherit(UndoRedo.RemoveColumnAction, UndoRedo.Action);
UndoRedo.RemoveColumnAction.prototype.undo = function(instance, undoneCallback) {
  const settings = instance.getSettings();
  settings.fixedColumnsStart = this.fixedColumnsStart;
  const ascendingIndexes = this.indexes.slice(0).sort();
  const sortByIndexes = (elem, j, arr) => arr[this.indexes.indexOf(ascendingIndexes[j])];
  const removedDataLength = this.data.length;
  const sortedData = [];
  for (let rowIndex = 0; rowIndex < removedDataLength; rowIndex++) {
    sortedData.push(arrayMap(this.data[rowIndex], sortByIndexes));
  }
  const sortedHeaders = arrayMap(this.headers, sortByIndexes);
  const changes = [];
  instance.alter("insert_col_start", this.indexes[0], this.indexes.length, "UndoRedo.undo");
  arrayEach(instance.getSourceDataArray(), (rowData, rowIndex) => {
    arrayEach(ascendingIndexes, (changedIndex, contiquesIndex) => {
      rowData[changedIndex] = sortedData[rowIndex][contiquesIndex];
      changes.push([rowIndex, changedIndex, rowData[changedIndex]]);
    });
  });
  instance.setSourceDataAtCell(changes, void 0, void 0, "UndoRedo.undo");
  if (typeof this.headers !== "undefined") {
    arrayEach(sortedHeaders, (headerData, columnIndex) => {
      instance.getSettings().colHeaders[ascendingIndexes[columnIndex]] = headerData;
    });
  }
  instance.batchExecution(() => {
    instance.rowIndexMapper.setIndexesSequence(this.rowPositions);
    instance.columnIndexMapper.setIndexesSequence(this.columnPositions);
  }, true);
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.render();
};
UndoRedo.RemoveColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveCol", redoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.CellAlignmentAction = function(stateBefore, range, type, alignment) {
  this.stateBefore = stateBefore;
  this.range = range;
  this.type = type;
  this.alignment = alignment;
};
UndoRedo.CellAlignmentAction.prototype.undo = function(instance, undoneCallback) {
  arrayEach(this.range, (range) => {
    range.forAll((row, col) => {
      if (row >= 0 && col >= 0) {
        instance.setCellMeta(row, col, "className", this.stateBefore[row][col] || " htLeft");
      }
    });
  });
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.render();
};
UndoRedo.CellAlignmentAction.prototype.redo = function(instance, undoneCallback) {
  align(this.range, this.type, this.alignment, (row, col) => instance.getCellMeta(row, col), (row, col, key, value) => instance.setCellMeta(row, col, key, value));
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.render();
};
UndoRedo.FiltersAction = function(conditionsStack) {
  this.conditionsStack = conditionsStack;
  this.actionType = "filter";
};
inherit(UndoRedo.FiltersAction, UndoRedo.Action);
UndoRedo.FiltersAction.prototype.undo = function(instance, undoneCallback) {
  const filters = instance.getPlugin("filters");
  instance.addHookOnce("afterViewRender", undoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, this.conditionsStack.length - 1));
  filters.filter();
};
UndoRedo.FiltersAction.prototype.redo = function(instance, redoneCallback) {
  const filters = instance.getPlugin("filters");
  instance.addHookOnce("afterViewRender", redoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack);
  filters.filter();
};
var MergeCellsAction = class extends UndoRedo.Action {
  constructor(instance, cellRange) {
    super();
    this.cellRange = cellRange;
    const topStartCorner = this.cellRange.getTopStartCorner();
    const bottomEndCorner = this.cellRange.getBottomEndCorner();
    this.rangeData = instance.getData(topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col);
  }
  undo(instance, undoneCallback) {
    const mergeCellsPlugin = instance.getPlugin("mergeCells");
    instance.addHookOnce("afterViewRender", undoneCallback);
    mergeCellsPlugin.unmergeRange(this.cellRange, true);
    const topStartCorner = this.cellRange.getTopStartCorner();
    instance.populateFromArray(topStartCorner.row, topStartCorner.col, this.rangeData, void 0, void 0, "MergeCells");
  }
  redo(instance, redoneCallback) {
    const mergeCellsPlugin = instance.getPlugin("mergeCells");
    instance.addHookOnce("afterViewRender", redoneCallback);
    mergeCellsPlugin.mergeRange(this.cellRange);
  }
};
UndoRedo.MergeCellsAction = MergeCellsAction;
var UnmergeCellsAction = class extends UndoRedo.Action {
  constructor(instance, cellRange) {
    super();
    this.cellRange = cellRange;
  }
  undo(instance, undoneCallback) {
    const mergeCellsPlugin = instance.getPlugin("mergeCells");
    instance.addHookOnce("afterViewRender", undoneCallback);
    mergeCellsPlugin.mergeRange(this.cellRange, true);
  }
  redo(instance, redoneCallback) {
    const mergeCellsPlugin = instance.getPlugin("mergeCells");
    instance.addHookOnce("afterViewRender", redoneCallback);
    mergeCellsPlugin.unmergeRange(this.cellRange, true);
    instance.render();
  }
};
UndoRedo.UnmergeCellsAction = UnmergeCellsAction;
UndoRedo.RowMoveAction = function(rows, finalIndex) {
  this.rows = rows.slice();
  this.finalIndex = finalIndex;
  this.actionType = "row_move";
};
inherit(UndoRedo.RowMoveAction, UndoRedo.Action);
UndoRedo.RowMoveAction.prototype.undo = function(instance, undoneCallback) {
  const manualRowMove = instance.getPlugin("manualRowMove");
  const copyOfRows = [].concat(this.rows);
  const rowsMovedUp = copyOfRows.filter((a) => a > this.finalIndex);
  const rowsMovedDown = copyOfRows.filter((a) => a <= this.finalIndex);
  const allMovedRows = rowsMovedUp.sort((a, b) => b - a).concat(rowsMovedDown.sort((a, b) => a - b));
  instance.addHookOnce("afterViewRender", undoneCallback);
  for (let i = 0; i < allMovedRows.length; i += 1) {
    const newPhysicalRow = instance.toVisualRow(allMovedRows[i]);
    manualRowMove.moveRow(newPhysicalRow, allMovedRows[i]);
  }
  instance.render();
  instance.deselectCell();
  instance.selectRows(this.rows[0], this.rows[0] + this.rows.length - 1);
};
UndoRedo.RowMoveAction.prototype.redo = function(instance, redoneCallback) {
  const manualRowMove = instance.getPlugin("manualRowMove");
  instance.addHookOnce("afterViewRender", redoneCallback);
  manualRowMove.moveRows(this.rows.slice(), this.finalIndex);
  instance.render();
  instance.deselectCell();
  instance.selectRows(this.finalIndex, this.finalIndex + this.rows.length - 1);
};
UndoRedo.prototype.init = function() {
  const settings = this.instance.getSettings().undo;
  const pluginEnabled = typeof settings === "undefined" || settings;
  if (!this.instance.undoRedo) {
    this.instance.undoRedo = this;
  }
  if (pluginEnabled) {
    this.instance.undoRedo.enable();
  } else {
    this.instance.undoRedo.disable();
  }
};
UndoRedo.prototype.registerShortcuts = function() {
  const shortcutManager = this.instance.getShortcutManager();
  const gridContext = shortcutManager.getContext("grid");
  const runOnlyIf = (event2) => {
    return !event2.altKey;
  };
  const config = {
    runOnlyIf,
    group: SHORTCUTS_GROUP9
  };
  gridContext.addShortcuts([{
    keys: [["Control/Meta", "z"]],
    callback: () => {
      this.undo();
    }
  }, {
    keys: [["Control/Meta", "y"], ["Control/Meta", "Shift", "z"]],
    callback: () => {
      this.redo();
    }
  }], config);
};
UndoRedo.prototype.unregisterShortcuts = function() {
  const shortcutManager = this.instance.getShortcutManager();
  const gridContext = shortcutManager.getContext("grid");
  gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP9);
};
function onAfterChange(changes, source) {
  const instance = this;
  if (source === "loadData") {
    return instance.undoRedo.clear();
  }
}
function exposeUndoRedoMethods(instance) {
  instance.undo = function() {
    return instance.undoRedo.undo();
  };
  instance.redo = function() {
    return instance.undoRedo.redo();
  };
  instance.isUndoAvailable = function() {
    return instance.undoRedo.isUndoAvailable();
  };
  instance.isRedoAvailable = function() {
    return instance.undoRedo.isRedoAvailable();
  };
  instance.clearUndo = function() {
    return instance.undoRedo.clear();
  };
}
function removeExposedUndoRedoMethods(instance) {
  delete instance.undo;
  delete instance.redo;
  delete instance.isUndoAvailable;
  delete instance.isRedoAvailable;
  delete instance.clearUndo;
}
var hook = pluginHooks_default.getSingleton();
hook.add("afterUpdateSettings", function() {
  var _this$getPlugin;
  (_this$getPlugin = this.getPlugin("undoRedo")) === null || _this$getPlugin === void 0 || _this$getPlugin.init();
});
hook.register("beforeUndo");
hook.register("afterUndo");
hook.register("beforeRedo");
hook.register("afterRedo");
UndoRedo.PLUGIN_KEY = PLUGIN_KEY34;
UndoRedo.SETTING_KEYS = true;
var undoRedo_default = UndoRedo;

// node_modules/handsontable/plugins/index.mjs
function registerAllPlugins() {
  registerPlugin(AutoColumnSize);
  registerPlugin(Autofill);
  registerPlugin(AutoRowSize);
  registerPlugin(BindRowsWithHeaders);
  registerPlugin(CollapsibleColumns);
  registerPlugin(ColumnSorting);
  registerPlugin(ColumnSummary);
  registerPlugin(Comments);
  registerPlugin(ContextMenu);
  registerPlugin(CopyPaste);
  registerPlugin(CustomBorders);
  registerPlugin(DragToScroll);
  registerPlugin(DropdownMenu);
  registerPlugin(ExportFile);
  registerPlugin(Filters);
  registerPlugin(Formulas);
  registerPlugin(HiddenColumns);
  registerPlugin(HiddenRows);
  registerPlugin(ManualColumnFreeze);
  registerPlugin(ManualColumnMove);
  registerPlugin(ManualColumnResize);
  registerPlugin(ManualRowMove);
  registerPlugin(ManualRowResize);
  registerPlugin(MergeCells);
  registerPlugin(MultiColumnSorting);
  registerPlugin(MultipleSelectionHandles);
  registerPlugin(NestedHeaders);
  registerPlugin(NestedRows);
  registerPlugin(PersistentState);
  registerPlugin(Search);
  registerPlugin(TouchScroll);
  registerPlugin(TrimRows);
  registerPlugin(undoRedo_default);
}

// node_modules/handsontable/registry.mjs
function registerAllModules() {
  registerAllEditors();
  registerAllRenderers();
  registerAllValidators();
  registerAllCellTypes();
  registerAllPlugins();
}

// node_modules/handsontable/helpers/wrappers/jquery.mjs
function jQueryWrapper(Handsontable2) {
  const jQuery = typeof window === "undefined" ? false : window.jQuery;
  if (!jQuery) {
    return;
  }
  jQuery.fn.handsontable = function(action) {
    const $this = this.first();
    let instance = $this.data("handsontable");
    if (typeof action !== "string") {
      const userSettings = action || {};
      if (instance) {
        instance.updateSettings(userSettings);
      } else {
        instance = new Handsontable2.Core($this[0], userSettings);
        $this.data("handsontable", instance);
        instance.init();
      }
      return $this;
    }
    let output;
    if (instance) {
      if (typeof instance[action] !== "undefined") {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        output = instance[action].call(instance, ...args);
        if (action === "destroy") {
          $this.removeData();
        }
      } else {
        throw new Error(`Handsontable do not provide action: ${action}`);
      }
    }
    return output;
  };
}

// node_modules/handsontable/index.mjs
var _Handsontable$cellTyp;
var _Handsontable$editors;
var _Handsontable$rendere;
var _Handsontable$validat;
var _Handsontable$plugins;
registerAllModules();
jQueryWrapper(base_default);
base_default.__GhostTable = ghostTable_default;
base_default._getListenersCounter = getListenersCounter;
base_default._getRegisteredMapsCounter = getRegisteredMapsCounter;
base_default.EventManager = eventManager_default;
var HELPERS = [array_exports, browser_exports, data_exports, date_exports, feature_exports, function_exports, mixed_exports, number_exports, object_exports, string_exports, unicode_exports, parseTable_exports];
var DOM = [element_exports, event_exports];
base_default.helper = {};
base_default.dom = {};
arrayEach(HELPERS, (helper) => {
  arrayEach(Object.getOwnPropertyNames(helper), (key) => {
    if (key.charAt(0) !== "_") {
      base_default.helper[key] = helper[key];
    }
  });
});
arrayEach(DOM, (helper) => {
  arrayEach(Object.getOwnPropertyNames(helper), (key) => {
    if (key.charAt(0) !== "_") {
      base_default.dom[key] = helper[key];
    }
  });
});
base_default.cellTypes = (_Handsontable$cellTyp = base_default.cellTypes) !== null && _Handsontable$cellTyp !== void 0 ? _Handsontable$cellTyp : {};
arrayEach(getNames4(), (cellTypeName) => {
  base_default.cellTypes[cellTypeName] = _getItem4(cellTypeName);
});
base_default.cellTypes.registerCellType = _register4;
base_default.cellTypes.getCellType = _getItem4;
base_default.editors = (_Handsontable$editors = base_default.editors) !== null && _Handsontable$editors !== void 0 ? _Handsontable$editors : {};
arrayEach(getNames(), (editorName) => {
  base_default.editors[`${toUpperCaseFirst(editorName)}Editor`] = _getItem(editorName);
});
base_default.editors.registerEditor = _register;
base_default.editors.getEditor = _getItem;
base_default.renderers = (_Handsontable$rendere = base_default.renderers) !== null && _Handsontable$rendere !== void 0 ? _Handsontable$rendere : {};
arrayEach(getNames2(), (rendererName) => {
  const renderer = _getItem2(rendererName);
  if (rendererName === "base") {
    base_default.renderers.cellDecorator = renderer;
  }
  base_default.renderers[`${toUpperCaseFirst(rendererName)}Renderer`] = renderer;
});
base_default.renderers.registerRenderer = _register2;
base_default.renderers.getRenderer = _getItem2;
base_default.validators = (_Handsontable$validat = base_default.validators) !== null && _Handsontable$validat !== void 0 ? _Handsontable$validat : {};
arrayEach(getNames3(), (validatorName) => {
  base_default.validators[`${toUpperCaseFirst(validatorName)}Validator`] = _getItem3(validatorName);
});
base_default.validators.registerValidator = _register3;
base_default.validators.getValidator = _getItem3;
base_default.plugins = (_Handsontable$plugins = base_default.plugins) !== null && _Handsontable$plugins !== void 0 ? _Handsontable$plugins : {};
arrayEach(getPluginsNames(), (pluginName) => {
  base_default.plugins[pluginName] = getPlugin(pluginName);
});
base_default.plugins[`${toUpperCaseFirst(BasePlugin.PLUGIN_KEY)}Plugin`] = BasePlugin;
base_default.plugins.registerPlugin = registerPlugin;
base_default.plugins.getPlugin = getPlugin;
var handsontable_default = base_default;
export {
  coords_default as CellCoords,
  range_default as CellRange,
  handsontable_default as default
};
/*! Bundled license information:

moment/dist/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

pikaday/pikaday.js:
  (*!
   * Pikaday
   *
   * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/Pikaday/Pikaday
   *)

dompurify/dist/purify.es.js:
  (*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE *)

handsontable/i18n/languages/en-US.mjs:
  (**
   * @preserve
   * Authors: Handsoncode
   * Last updated: Nov 15, 2017
   *
   * Description: Definition file for English - United States language-country.
   *)
*/
//# sourceMappingURL=handsontable.js.map
